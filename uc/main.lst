   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	watchdog_sms_disarm:
  13               	.LFB34:
  14               		.file 1 "main.c"
   1:main.c        **** 
   2:main.c        **** #ifndef INCLUDE
   3:main.c        **** #include "narzedzia.h"
   4:main.c        **** #include <avr/eeprom.h>
   5:main.c        **** #include <avr/interrupt.h>
   6:main.c        **** #include <avr/io.h>
   7:main.c        **** #include <avr/pgmspace.h>
   8:main.c        **** #include <avr/sleep.h>
   9:main.c        **** #include <avr/wdt.h>
  10:main.c        **** #include <ctype.h>
  11:main.c        **** #include <stdio.h>
  12:main.c        **** #include <stdlib.h>
  13:main.c        **** #include <string.h>
  14:main.c        **** #include <util/crc16.h>
  15:main.c        **** #include <util/delay.h>
  16:main.c        **** 
  17:main.c        **** #ifndef TEST_ATMEGA128
  18:main.c        **** #include "pin_ATmega328.h"
  19:main.c        **** #else
  20:main.c        **** #include "pin_ATmega128.h"
  21:main.c        **** #endif
  22:main.c        **** #include "bufpomoc.h"
  23:main.c        **** #include "data_sim900.h"
  24:main.c        **** #include "interpretacjaSMS.h"
  25:main.c        **** #include "komendy.h"
  26:main.c        **** #include "konfiguracja.h"
  27:main.c        **** #include "pdu.h"
  28:main.c        **** #include "sim900.h"
  29:main.c        **** #include "wewy.h"
  30:main.c        **** #include "zapiseeprom.h"
  31:main.c        **** 
  32:main.c        **** #include "test_pcb.h"
  33:main.c        **** 
  34:main.c        **** #endif
  35:main.c        **** 
  36:main.c        **** // static const char nazwa_urzadzenia[12 + 1] PROGMEM = "BRAMA";
  37:main.c        **** 
  38:main.c        **** uchar skryba_wlaczona = FALSE;
  39:main.c        **** uint skryba_limit = 795; // Domyslny limit uzytkownikow dla Skryby (795 max,
  40:main.c        ****                          // pozycje 796-800 dla Super Userow)
  41:main.c        **** uchar tryb_clip = TRUE;
  42:main.c        **** uint licznik_timeout_rozmowy_100ms = 0;
  43:main.c        **** 
  44:main.c        **** volatile uint32_t g_czas_systemowy_100ms = 0;
  45:main.c        **** 
  46:main.c        **** #define INFORMACJA_W_RAPORCIE "www.sonfy.pl"
  47:main.c        **** 
  48:main.c        **** uchar licznik_100ms_dioda_led;
  49:main.c        **** uchar liczba_blyskow_led = 0;
  50:main.c        **** uchar stan_cyklu_blysku =
  51:main.c        ****     0; // 0-5: 0-1=ON (200ms), 2-5=OFF (400ms), 1 blysk=600ms
  52:main.c        **** 
  53:main.c        **** #define zapal_diode_led(czas_100ms) (licznik_100ms_dioda_led = (czas_100ms) + 1)
  54:main.c        **** #define zapal_diode_led_blyski(liczba)                                         \
  55:main.c        ****   (liczba_blyskow_led = (liczba), stan_cyklu_blysku = 0)
  56:main.c        **** // #define zapal_diode_led(czas_100ms)
  57:main.c        **** 
  58:main.c        **** volatile uchar wykonaj_zdarzenie_timer = FALSE;
  59:main.c        **** #define CZY_WYKONAC_ZDARZENIE_TIMER() wykonaj_zdarzenie_timer
  60:main.c        **** 
  61:main.c        **** #define WYKONAJ_WATKI_BRAK 0
  62:main.c        **** #define WYKONAJ_WATKI_10MS BIT(0)
  63:main.c        **** #define WYKONAJ_WATKI_100MS BIT(1)
  64:main.c        **** volatile uchar wykonac_watki_10MS = FALSE;
  65:main.c        **** uchar wykonac_watki = WYKONAJ_WATKI_BRAK;
  66:main.c        **** #define CZY_WYKONAC_WATKI_10MS() (wykonac_watki & WYKONAJ_WATKI_10MS)
  67:main.c        **** #define CZY_WYKONAC_WATKI_100MS() (wykonac_watki & WYKONAJ_WATKI_100MS)
  68:main.c        **** #define RESETUJ_WYKONANIE_WATKOW() (wykonac_watki = 0)
  69:main.c        **** 
  70:main.c        **** volatile uchar licznik_wybudz_watki_10MS = 0;
  71:main.c        **** #define OPOZNIENIE_TIMERA_0 18
  72:main.c        **** #define czy_pozostal_czas(procent)                                             \
  73:main.c        ****   (licznik_wybudz_watki_10MS < (100 - (procent)) * OPOZNIENIE_TIMERA_0 / 100)
  74:main.c        **** 
  75:main.c        **** przerwanie_timer() {
  76:main.c        ****   if (++licznik_wybudz_watki_10MS >= OPOZNIENIE_TIMERA_0) {
  77:main.c        ****     licznik_wybudz_watki_10MS = 0;
  78:main.c        ****     wykonac_watki_10MS = TRUE;
  79:main.c        ****   }
  80:main.c        **** 
  81:main.c        ****   if (STATUS_WLACZONY_SIM900()) {
  82:main.c        ****     if (!CZY_ODBIERANIE_DANYCH_SIM900() && czy_jest_bezczynny_SIM900()) {
  83:main.c        ****       ustaw_odbior_SIM900();
  84:main.c        ****     }
  85:main.c        ****     if (CZY_HANDSHAKING_CTS_ZEZWALA_NA_TRANSMISJE_SIM900()) {
  86:main.c        ****       cli();
  87:main.c        ****       if (CZY_WYSYLANIE_DANYCH_SIM900()) {
  88:main.c        ****         WYLACZ_PRZERWANIE_WYSYLANIA_DANYCH_SIM900();
  89:main.c        ****         sei();
  90:main.c        ****         uchar p = sprawdzaj_wejscie_CTS_SIM900;
  91:main.c        ****         if (p && (podlaczony_modul_gsm_SIM900 ||
  92:main.c        ****                   aktualnie_wysylane_polecenie_SIM900 ==
  93:main.c        ****                       KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT)) {
  94:main.c        ****           p = FALSE;
  95:main.c        ****           sprawdzaj_wejscie_CTS_SIM900 = p;
  96:main.c        ****           WSTAW_ZNAK_DO_BUFORA_SIM900();
  97:main.c        ****         }
  98:main.c        ****         cli();
  99:main.c        ****         WLACZ_PRZERWANIE_WYSYLANIA_DANYCH_SIM900();
 100:main.c        ****       }
 101:main.c        ****       sei();
 102:main.c        ****     }
 103:main.c        ****   } else {
 104:main.c        ****     zakoncz_przesylanie_SIM900();
 105:main.c        ****   }
 106:main.c        **** 
 107:main.c        ****   wykonaj_zdarzenie_timer =
 108:main.c        ****       TRUE; // uruchamia zdarzenie_timer, ktra korzysta z pozostaych zmiennych
 109:main.c        **** }
 110:main.c        **** 
 111:main.c        **** uchar modul_zalogowany_w_sieci = FALSE;
 112:main.c        **** 
 113:main.c        **** uchar licznik_reset_modulu_SIM900 = 0;
 114:main.c        **** #define START_LICZNIK_RESET_MODULU_SIM900 30
 115:main.c        **** 
 116:main.c        **** uchar licznik_reset_urzadzenia = 0;
 117:main.c        **** #define LICZNIK_RESET_URZADZENIA_RESET_SIM900 200
 118:main.c        **** #define START_LICZNIK_RESET_URZADZENIA 220
 119:main.c        **** 
 120:main.c        **** uint opoznienie_wysylania_clipow_100MS = 0;
 121:main.c        **** 
 122:main.c        **** void generuj_raport_sieci(uchar **buf_sms) {
 123:main.c        ****   static const char tekst_gsm[] PROGMEM = "AC800-DTM-TS";
 124:main.c        ****   uchar *ptr = *buf_sms;
 125:main.c        **** 
 126:main.c        ****   memcpy_R(ptr, tekst_gsm);
 127:main.c        ****   ptr += sizeof tekst_gsm - 1;
 128:main.c        ****   *ptr++ = '\n';
 129:main.c        **** 
 130:main.c        ****   strcpy_P((char *)ptr, PSTR("Czas: "));
 131:main.c        ****   ptr += strlen((char *)ptr);
 132:main.c        ****   strcat((char *)ptr, rtc_czas);
 133:main.c        ****   ptr += strlen((char *)ptr);
 134:main.c        ****   *ptr++ = '\n';
 135:main.c        **** 
 136:main.c        ****   static const char text_sygnal[] PROGMEM = "Sygnal GSM ";
 137:main.c        ****   memcpy_R(ptr, text_sygnal);
 138:main.c        ****   ptr += sizeof text_sygnal - 1;
 139:main.c        **** 
 140:main.c        ****   if (poziom_sieci_gsm <= 31 && modul_zalogowany_w_sieci) {
 141:main.c        ****     utoa(poziom_sieci_gsm * 100 / 31, ptr, 10);
 142:main.c        ****     ptr += strlen(ptr);
 143:main.c        ****     *ptr++ = '%';
 144:main.c        ****   } else {
 145:main.c        ****     *ptr++ = '-';
 146:main.c        ****     *ptr++ = '-';
 147:main.c        ****     *ptr++ = '-';
 148:main.c        ****   }
 149:main.c        ****   *ptr = 0;
 150:main.c        ****   *buf_sms = ptr;
 151:main.c        **** }
 152:main.c        **** 
 153:main.c        **** void generuj_raport_uzytkownikow_1(uchar **buf_sms) {
 154:main.c        ****   static const char tekst_gsm[] PROGMEM = "Uzytkownicy ";
 155:main.c        ****   uchar *ptr = *buf_sms;
 156:main.c        **** 
 157:main.c        ****   memcpy_R(ptr, tekst_gsm);
 158:main.c        ****   ptr += sizeof tekst_gsm - 1;
 159:main.c        ****   uint aktywne_numery = 0;
 160:main.c        ****   uint wolne_numery = 0;
 161:main.c        ****   // for (uchar nr_uzyt_clip = 0; nr_uzyt_clip <
 162:main.c        ****   // MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip)
 163:main.c        ****   for (uint nr_uzyt_clip = 0; nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 164:main.c        ****        ++nr_uzyt_clip) {
 165:main.c        ****     if (czy_aktywny_numer_telefonu_brama(nr_uzyt_clip))
 166:main.c        ****       ++aktywne_numery;
 167:main.c        ****     else
 168:main.c        ****       ++wolne_numery;
 169:main.c        ****   }
 170:main.c        **** 
 171:main.c        ****   utoa(aktywne_numery, ptr, 10);
 172:main.c        ****   ptr += strlen(ptr);
 173:main.c        ****   *ptr++ = '/';
 174:main.c        ****   utoa(wolne_numery, ptr, 10);
 175:main.c        ****   ptr += strlen(ptr);
 176:main.c        ****   *buf_sms = ptr;
 177:main.c        **** }
 178:main.c        **** 
 179:main.c        **** void generuj_raport_uzytkownikow(uchar **buf_sms) {
 180:main.c        ****   static const char tekst_gsm[] PROGMEM = "Uzytkownicy ";
 181:main.c        ****   uchar *ptr = *buf_sms;
 182:main.c        **** 
 183:main.c        ****   memcpy_R(ptr, tekst_gsm);
 184:main.c        ****   ptr += sizeof tekst_gsm - 1;
 185:main.c        ****   uchar aktywne_numery = 0;
 186:main.c        ****   uchar wolne_numery = 0;
 187:main.c        ****   for (uint nr_uzyt_clip = 0; nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 188:main.c        ****        ++nr_uzyt_clip) {
 189:main.c        ****     if (czy_aktywny_numer_telefonu_brama(nr_uzyt_clip))
 190:main.c        ****       ++aktywne_numery;
 191:main.c        ****     else
 192:main.c        ****       ++wolne_numery;
 193:main.c        ****   }
 194:main.c        ****   utoa(aktywne_numery, ptr, 10);
 195:main.c        ****   ptr += strlen(ptr);
 196:main.c        ****   *ptr++ = '/';
 197:main.c        ****   utoa(wolne_numery, ptr, 10);
 198:main.c        ****   ptr += strlen(ptr);
 199:main.c        ****   *buf_sms = ptr;
 200:main.c        **** }
 201:main.c        **** 
 202:main.c        **** uchar blokada_systemu = FALSE; // Nowa zmienna globalna
 203:main.c        **** uchar tryb_pracy = 1;          // 0=Prywatny, 1=Publiczny (domyślnie Publiczny)
 204:main.c        **** 
 205:main.c        **** void generuj_raport_stanu_urzadzenia(void) {
 206:main.c        ****   uchar *sms = (char *)tekst_wysylanego_smsa;
 207:main.c        ****   *sms++ = '*';
 208:main.c        ****   *sms++ = '\n';
 209:main.c        ****   generuj_raport_sieci(&sms);
 210:main.c        ****   *sms++ = '\n';
 211:main.c        ****   generuj_raport_uzytkownikow_1(&sms);
 212:main.c        ****   *sms++ = '\n';
 213:main.c        **** 
 214:main.c        ****   // Status sterownika (START/STOP)
 215:main.c        ****   if (blokada_systemu) {
 216:main.c        ****     strcpy_P((char *)sms, PSTR("Status: Zablokowany"));
 217:main.c        ****   } else {
 218:main.c        ****     strcpy_P((char *)sms, PSTR("Status: Aktywny"));
 219:main.c        ****   }
 220:main.c        ****   sms += strlen((char *)sms);
 221:main.c        ****   *sms++ = '\n';
 222:main.c        **** 
 223:main.c        ****   // Tryb pracy (OPEN/CLOSE)
 224:main.c        ****   if (tryb_pracy == 0) {
 225:main.c        ****     strcpy_P((char *)sms, PSTR("Tryb: Prywatny"));
 226:main.c        ****   } else {
 227:main.c        ****     strcpy_P((char *)sms, PSTR("Tryb: Publiczny"));
 228:main.c        ****   }
 229:main.c        ****   sms += strlen((char *)sms);
 230:main.c        **** 
 231:main.c        ****   if (tryb_clip) {
 232:main.c        ****     strcpy_P((char *)sms, PSTR(" CLIP"));
 233:main.c        ****   } else {
 234:main.c        ****     strcpy_P((char *)sms, PSTR(" DTMF"));
 235:main.c        ****   }
 236:main.c        ****   sms += strlen((char *)sms);
 237:main.c        ****   *sms++ = '\n';
 238:main.c        **** 
 239:main.c        ****   if (czas_start_h == 0xFF) {
 240:main.c        ****     strcpy_P((char *)sms, PSTR("Harmonogram: Wylaczony"));
 241:main.c        ****   } else {
 242:main.c        ****     sprintf((char *)sms, "Harmonogram: %02d:%02d %02d:%02d", (int)czas_start_h,
 243:main.c        ****             (int)czas_start_m, (int)czas_stop_h, (int)czas_stop_m);
 244:main.c        ****   }
 245:main.c        ****   sms += strlen((char *)sms);
 246:main.c        ****   *sms++ = '\n';
 247:main.c        **** 
 248:main.c        ****   // Skryba status (ON/OFF) - bez wyświetlania limitu
 249:main.c        ****   if (skryba_wlaczona) {
 250:main.c        ****     strcpy_P((char *)sms, PSTR("Skryba: Wlaczona"));
 251:main.c        ****   } else {
 252:main.c        ****     strcpy_P((char *)sms, PSTR("Skryba: Wylaczona"));
 253:main.c        ****   }
 254:main.c        ****   sms += strlen((char *)sms);
 255:main.c        ****   *sms++ = '\n';
 256:main.c        **** 
 257:main.c        ****   static const char tekst_demo[] PROGMEM = INFORMACJA_W_RAPORCIE;
 258:main.c        ****   strcpy_P((char *)sms, tekst_demo);
 259:main.c        **** }
 260:main.c        **** 
 261:main.c        **** // Helper function: sprawdz czy numer jest Super Userem (pozycje 795-800)
 262:main.c        **** uchar czy_numer_jest_super_userem(const uchar *numer_telefonu) {
 263:main.c        ****   // Konwertuj numer do formatu EEPROM
 264:main.c        ****   uchar temp_buf[LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM];
 265:main.c        ****   konwertuj_telefon_na_blok_eeprom(
 266:main.c        ****       (uchar *)numer_telefonu,
 267:main.c        ****       (uchar *)numer_telefonu + strlen((char *)numer_telefonu), temp_buf);
 268:main.c        **** 
 269:main.c        ****   // Sprawdz pozycje 794-799 (user-facing 795-800)
 270:main.c        ****   for (uint nr_uzyt = 794; nr_uzyt < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 271:main.c        ****        ++nr_uzyt) {
 272:main.c        ****     if (porownaj_numer_telefonu_blok(
 273:main.c        ****             temp_buf, (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt))) {
 274:main.c        ****       return TRUE; // Znaleziono w pozycjach super userow
 275:main.c        ****     }
 276:main.c        ****   }
 277:main.c        ****   return FALSE;
 278:main.c        **** }
 279:main.c        **** 
 280:main.c        **** void ustaw_wyjscie_clip(void) {
 281:main.c        ****   stan_wyjscie[0] = TRUE;
 282:main.c        ****   licznik_przelacznik_wyjscia[0] = 2 * 10ul; // 2 sekundy
 283:main.c        **** }
 284:main.c        **** 
 285:main.c        **** uchar kod_modulu[LICZBA_BAJTOW_KODU_DOSTEPU];
 286:main.c        **** 
 287:main.c        **** uchar nie_wysylaj_echa_z_powodu_nietypowego_smsa;
 288:main.c        **** 
 289:main.c        **** uchar numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama;
 290:main.c        **** uchar numer_telefonu_skryba[20];
 291:main.c        **** 
 292:main.c        **** // Blokada komend REPORT/USER - maksymalnie 8 w ciągu 30 sekund
 293:main.c        **** static uchar licznik_report_user = 0;
 294:main.c        **** static uint timer_report_user_100ms = 0;
 295:main.c        **** #define MAX_LICZBA_KOMEND_REPORT_USER_W_OKNIE 8
 296:main.c        **** #define OKNO_CZASOWE_REPORT_USER_100MS (30 * 10) // 30 sekund
 297:main.c        **** 
 298:main.c        **** // Mechanizm wykrywania zablokowanej kolejki i czyszczenia
 299:main.c        **** static komenda_typ ostatnia_pierwsza_komenda = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 300:main.c        **** static uint licznik_kolejka_stoi_100ms = 0;
 301:main.c        **** #define MAX_CZAS_KOLEJKA_STOI_100MS                                            \
 302:main.c        ****   (15 * 10) // 15 sekund - jesli kolejka stoi tyle czasu, wyczysc
 303:main.c        **** 
 304:main.c        **** static uint licznik_usunietych_sms_przez_limit = 0;
 305:main.c        **** static uint licznik_awaryjnych_resetow_kolejki = 0;
 306:main.c        **** 
 307:main.c        **** #define WATCHDOG_WYSYLANIA_SMS_100MS (30 * 10) // 30 sekund
 308:main.c        **** static uint licznik_watchdog_wysylanie_smsa_100ms = 0;
 309:main.c        **** static uchar liczba_kolejnych_watchdogow_wysylania = 0;
 310:main.c        **** #define WATCHDOG_SMS_TIMEOUT_100MS (10 * 10) // 10 sekund
 311:main.c        **** #define WATCHDOG_SMS_SAFE_MODE_100MS                                           \
 312:main.c        ****   (5 * 10) // 5 sekund po resecie - nie przyjmuj SMS
 313:main.c        **** 
 314:main.c        **** static inline void watchdog_sms_arm(void) {
 315:main.c        ****   watchdog_sms_aktywny = TRUE;
 316:main.c        ****   watchdog_sms_licznik_100ms = 0;
 317:main.c        **** }
 318:main.c        **** 
 319:main.c        **** static inline void watchdog_sms_disarm(void) {
  15               		.loc 1 319 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 320:main.c        ****   watchdog_sms_aktywny = FALSE;
  21               		.loc 1 320 0
  22 0000 1092 0000 		sts watchdog_sms_aktywny,__zero_reg__
 321:main.c        ****   watchdog_sms_licznik_100ms = 0;
  23               		.loc 1 321 0
  24 0004 1092 0000 		sts watchdog_sms_licznik_100ms+1,__zero_reg__
  25 0008 1092 0000 		sts watchdog_sms_licznik_100ms,__zero_reg__
  26               	/* epilogue start */
 322:main.c        **** }
  27               		.loc 1 322 0
  28 000c 0895      		ret
  29               		.cfi_endproc
  30               	.LFE34:
  33               	czy_numer_istnieje:
  34               	.LFB58:
 323:main.c        **** 
 324:main.c        **** static inline void sygnalizuj_pelny_system(void) {
 325:main.c        ****   // 10 szybkich blyskow informuje, ze kolejka/limit SMS jest zapelniony
 326:main.c        ****   zapal_diode_led_blyski(10);
 327:main.c        **** }
 328:main.c        **** 
 329:main.c        **** // Funkcja usuwania zablokowanego SMS z modulu SIM900
 330:main.c        **** static void usun_zablokowany_sms(void) {
 331:main.c        ****   // Usun SMS z modulu SIM900 (numer jest w aktualnie_wysylane_polecenie_SIM900)
 332:main.c        ****   // Sprawdzamy czy to byla komenda odczytu SMS
 333:main.c        ****   if (aktualnie_wysylane_polecenie_SIM900 >= KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 334:main.c        ****       aktualnie_wysylane_polecenie_SIM900 <= KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 335:main.c        ****     const uchar nr_smsa =
 336:main.c        ****         aktualnie_wysylane_polecenie_SIM900 - KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1;
 337:main.c        ****     // Uzywamy filtruj_i_dodaj_komende zamiast dodaj_komende
 338:main.c        ****     filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_USUN_SMSA_1 + nr_smsa);
 339:main.c        ****   } else {
 340:main.c        ****     // Fallback: Usun wszystkie
 341:main.c        ****     filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 342:main.c        ****   }
 343:main.c        **** }
 344:main.c        **** 
 345:main.c        **** static void zareaguj_na_usuniety_sms_z_powodu_limitu(void) {
 346:main.c        ****   if (licznik_usunietych_sms_przez_limit < 0xFFFF)
 347:main.c        ****     ++licznik_usunietych_sms_przez_limit;
 348:main.c        ****   sygnalizuj_pelny_system();
 349:main.c        ****   watchdog_sms_disarm();
 350:main.c        ****   // Uzywamy filtruj_i_dodaj
 351:main.c        ****   filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 352:main.c        **** }
 353:main.c        **** 
 354:main.c        **** // Funkcja zapisu znacznikow debugowania do EEPROM
 355:main.c        **** static void zapisz_debug_do_eeprom(uchar komenda, uchar akcja) {
 356:main.c        ****   if (!czy_wolny_eeprom())
 357:main.c        ****     return;
 358:main.c        **** 
 359:main.c        ****   uchar buf[8];
 360:main.c        ****   buf[0] = licznik_report_user;
 361:main.c        ****   buf[1] = (uchar)(timer_report_user_100ms & 0xFF);
 362:main.c        ****   buf[2] = (uchar)((timer_report_user_100ms >> 8) & 0xFF);
 363:main.c        ****   buf[3] = (uchar)flaga_wysylanie_smsa;
 364:main.c        **** 
 365:main.c        ****   uchar liczba_sms_w_kolejce = 0;
 366:main.c        ****   for (uchar i = 0; i < LICZBA_KOMEND; ++i) {
 367:main.c        ****     if (komendy_kolejka[i] >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
 368:main.c        ****         komendy_kolejka[i] <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
 369:main.c        ****       ++liczba_sms_w_kolejce;
 370:main.c        ****   }
 371:main.c        ****   buf[4] = liczba_sms_w_kolejce;
 372:main.c        ****   buf[5] = komenda;
 373:main.c        ****   buf[6] = akcja;
 374:main.c        **** 
 375:main.c        ****   zapisz_znaki_w_eeprom(buf, EEPROM_DEBUG_START, 7);
 376:main.c        **** }
 377:main.c        **** 
 378:main.c        **** void wykonanie_polecenia_sms(void) {
 379:main.c        ****   tekst_odebranego_smsa[MAX_LICZBA_ZNAKOW_SMS] = 0; // (1) dla pewnoci
 380:main.c        ****   watchdog_sms_arm();
 381:main.c        ****   const uchar komenda = interpretuj_wiadomosc_sms(tekst_odebranego_smsa);
 382:main.c        **** 
 383:main.c        ****   // Aktualizacja czasu z timestampu SMS (PRZED wykonaniem komendy!)
 384:main.c        ****   // KAŻDY SMS (nawet bez kodu ABCD) synchronizuje RTC, z wyłączeniem SET
 385:main.c        ****   extern uchar sms_timestamp_godzina;
 386:main.c        ****   extern uchar sms_timestamp_minuta;
 387:main.c        ****   extern uchar sms_timestamp_sekunda;
 388:main.c        ****   extern uchar sms_pomijaj_aktualizacje_czasu;
 389:main.c        **** 
 390:main.c        ****   if (!sms_pomijaj_aktualizacje_czasu) {
 391:main.c        ****     // Aktualizuj rtc_czas z timestampu SMS (z sekundami z PDU)
 392:main.c        ****     sprintf(rtc_czas, "%02d:%02d:%02d", sms_timestamp_godzina,
 393:main.c        ****             sms_timestamp_minuta, sms_timestamp_sekunda);
 394:main.c        **** 
 395:main.c        ****     // Zaktualizuj RTC w SIM900 (hardware)
 396:main.c        ****     extern char bufor_ustaw_czas[32];
 397:main.c        ****     sprintf(bufor_ustaw_czas, "+CCLK=\"24/01/01,%02d:%02d:%02d+04\"",
 398:main.c        ****             sms_timestamp_godzina, sms_timestamp_minuta, sms_timestamp_sekunda);
 399:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_USTAW_ZEGAR_SIM900);
 400:main.c        **** 
 401:main.c        ****     // Aktualizuj blokadę czasową
 402:main.c        ****     if (czas_start_h != 0xFF) {
 403:main.c        ****       int curr_time = sms_timestamp_godzina * 60 + sms_timestamp_minuta;
 404:main.c        ****       int start_time = czas_start_h * 60 + czas_start_m;
 405:main.c        ****       int stop_time = czas_stop_h * 60 + czas_stop_m;
 406:main.c        **** 
 407:main.c        ****       if (start_time <= stop_time) {
 408:main.c        ****         // Normalny przedział (np. 08:00 - 16:00)
 409:main.c        ****         blokada_sterowania_czasowa =
 410:main.c        ****             !(curr_time >= start_time && curr_time <= stop_time);
 411:main.c        ****       } else {
 412:main.c        ****         // Przejście przez północ (np. 22:00 - 06:00)
 413:main.c        ****         blokada_sterowania_czasowa =
 414:main.c        ****             !(curr_time >= start_time || curr_time <= stop_time);
 415:main.c        ****       }
 416:main.c        ****     } else {
 417:main.c        ****       blokada_sterowania_czasowa = FALSE;
 418:main.c        ****     }
 419:main.c        ****   }
 420:main.c        **** 
 421:main.c        ****   // Resetuj flagę pomijania dla następnego SMS
 422:main.c        ****   sms_pomijaj_aktualizacje_czasu = FALSE;
 423:main.c        **** 
 424:main.c        ****   // --- BLOKADA SYSTEMU (START/STOP) ---
 425:main.c        ****   if (blokada_systemu) {
 426:main.c        ****     // Gdy zablokowany, akceptuj tylko START i REPORT
 427:main.c        ****     if (komenda != INTERPRETACJA_SMS_POPRAWNY && // START/STOP zwracaja POPRAWNY
 428:main.c        ****         komenda != INTERPRETACJA_SMS_RAPORT) {
 429:main.c        ****       // Sprawdz czy to byla komenda START (ktora wlasnie odblokowala system)
 430:main.c        ****       // Jesli system nadal jest zablokowany (czyli to nie byl START), to
 431:main.c        ****       // ignoruj
 432:main.c        ****       if (eeprom_read_byte((const uint8_t *)ADRES_EEPROM_BLOKADA_SYSTEMU) ==
 433:main.c        ****           1) {
 434:main.c        ****         zapisz_debug_do_eeprom(1, 2); // Debug: Odrzucono przez blokade
 435:main.c        ****         usun_zablokowany_sms();
 436:main.c        ****         return;
 437:main.c        ****       }
 438:main.c        ****     }
 439:main.c        ****   }
 440:main.c        **** 
 441:main.c        ****   // --- WARSTWA 1: Limit czasowy (Rate Limiting) - V7 style ---
 442:main.c        ****   if (komenda == INTERPRETACJA_SMS_RAPORT ||
 443:main.c        ****       komenda == INTERPRETACJA_SMS_USER) {
 444:main.c        ****     if (licznik_report_user >= MAX_LICZBA_KOMEND_REPORT_USER_W_OKNIE) {
 445:main.c        ****       zapisz_debug_do_eeprom(1, 1);
 446:main.c        ****       usun_zablokowany_sms();
 447:main.c        ****       zareaguj_na_usuniety_sms_z_powodu_limitu();
 448:main.c        ****       watchdog_sms_disarm();
 449:main.c        ****       return;
 450:main.c        ****     }
 451:main.c        ****   }
 452:main.c        **** 
 453:main.c        ****   // --- WARSTWA 2: Sprawdzenie zajętości modemu (Busy Check) ---
 454:main.c        ****   if (flaga_wysylanie_smsa) {
 455:main.c        ****     // Same number check
 456:main.c        ****     if (strcmp((char *)numer_telefonu_odebranego_smsa,
 457:main.c        ****                (char *)numer_telefonu_wysylanego_smsa) == 0) {
 458:main.c        ****       zapisz_debug_do_eeprom(1, 1);
 459:main.c        ****       usun_zablokowany_sms();
 460:main.c        ****       zareaguj_na_usuniety_sms_z_powodu_limitu();
 461:main.c        ****       watchdog_sms_disarm();
 462:main.c        ****       return;
 463:main.c        ****     }
 464:main.c        ****     // Different number but busy
 465:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 466:main.c        ****     usun_zablokowany_sms();
 467:main.c        ****     zareaguj_na_usuniety_sms_z_powodu_limitu();
 468:main.c        ****     watchdog_sms_disarm();
 469:main.c        ****     return;
 470:main.c        ****   }
 471:main.c        **** 
 472:main.c        ****   // --- WARSTWA 3 i 4: Ochrona kolejki ---
 473:main.c        ****   uchar liczba_sms_w_kolejce = 0;
 474:main.c        ****   uchar liczba_wszystkich_komend = 0;
 475:main.c        ****   for (uchar i = 0; i < LICZBA_KOMEND; ++i) {
 476:main.c        ****     if (komendy_kolejka[i] != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 477:main.c        ****       ++liczba_wszystkich_komend;
 478:main.c        ****       if (komendy_kolejka[i] >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
 479:main.c        ****           komendy_kolejka[i] <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
 480:main.c        ****         ++liczba_sms_w_kolejce;
 481:main.c        ****     }
 482:main.c        ****   }
 483:main.c        **** 
 484:main.c        ****   if (liczba_wszystkich_komend >= 35) {
 485:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 486:main.c        ****     usun_zablokowany_sms();
 487:main.c        ****     zareaguj_na_usuniety_sms_z_powodu_limitu();
 488:main.c        ****     watchdog_sms_disarm();
 489:main.c        ****     return;
 490:main.c        ****   }
 491:main.c        **** 
 492:main.c        ****   if (liczba_sms_w_kolejce >= 6) {
 493:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 494:main.c        ****     usun_zablokowany_sms();
 495:main.c        ****     zareaguj_na_usuniety_sms_z_powodu_limitu();
 496:main.c        ****     watchdog_sms_disarm();
 497:main.c        ****     return;
 498:main.c        ****   }
 499:main.c        **** 
 500:main.c        ****   switch (komenda) {
 501:main.c        ****   case INTERPRETACJA_SMS_POPRAWNY:
 502:main.c        ****     zapal_diode_led_blyski(2); // Odbior poprawnej komendy - 2 blyski
 503:main.c        ****     break;
 504:main.c        ****   case INTERPRETACJA_SMS_BRAK_KODU: {
 505:main.c        ****     zapal_diode_led_blyski(1); // Odbior zwyklego SMS (bez kodu) - 1 blysk
 506:main.c        ****     zapisz_debug_do_eeprom(0, 3);
 507:main.c        ****     break;
 508:main.c        ****   }
 509:main.c        ****   case INTERPRETACJA_SMS_RAPORT: {
 510:main.c        ****     ++licznik_report_user;
 511:main.c        ****     timer_report_user_100ms = OKNO_CZASOWE_REPORT_USER_100MS;
 512:main.c        **** 
 513:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 514:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 515:main.c        ****     generuj_raport_stanu_urzadzenia();
 516:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 517:main.c        ****     zapal_diode_led_blyski(2); // Komenda REPORT - 2 blyski
 518:main.c        ****     zapisz_debug_do_eeprom(1, 0);
 519:main.c        ****     break;
 520:main.c        ****   }
 521:main.c        ****   case INTERPRETACJA_SMS_DEBUG: {
 522:main.c        ****     // DEBUG - wyślij flagi debug dla SKRYBA i USER
 523:main.c        ****     strcpy_P((char *)tekst_wysylanego_smsa, PSTR("DEBUG\n"));
 524:main.c        ****     uchar *sms = tekst_wysylanego_smsa + strlen((char *)tekst_wysylanego_smsa);
 525:main.c        **** 
 526:main.c        ****     // SKRYBA DEBUG
 527:main.c        ****     strcpy_P((char *)sms, PSTR("SKRYBA:"));
 528:main.c        ****     sms += strlen((char *)sms);
 529:main.c        ****     *sms++ =
 530:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_2);
 531:main.c        ****     *sms++ =
 532:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_3);
 533:main.c        ****     *sms++ =
 534:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_4);
 535:main.c        ****     *sms++ =
 536:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_5);
 537:main.c        ****     *sms++ = '\n';
 538:main.c        **** 
 539:main.c        ****     // USER DEBUG - wyświetl jako liczby dziesiętne
 540:main.c        ****     strcpy_P((char *)sms, PSTR("U1="));
 541:main.c        ****     sms += strlen((char *)sms);
 542:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_1), sms, 10);
 543:main.c        ****     sms += strlen((char *)sms);
 544:main.c        **** 
 545:main.c        ****     strcpy_P((char *)sms, PSTR(" U2="));
 546:main.c        ****     sms += strlen((char *)sms);
 547:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_2), sms, 10);
 548:main.c        ****     sms += strlen((char *)sms);
 549:main.c        **** 
 550:main.c        ****     strcpy_P((char *)sms, PSTR(" U3="));
 551:main.c        ****     sms += strlen((char *)sms);
 552:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_3), sms, 10);
 553:main.c        ****     sms += strlen((char *)sms);
 554:main.c        ****     *sms++ = '\n';
 555:main.c        **** 
 556:main.c        ****     strcpy_P((char *)sms, PSTR("U4="));
 557:main.c        ****     sms += strlen((char *)sms);
 558:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_4), sms, 10);
 559:main.c        ****     sms += strlen((char *)sms);
 560:main.c        **** 
 561:main.c        ****     strcpy_P((char *)sms, PSTR(" U5="));
 562:main.c        ****     sms += strlen((char *)sms);
 563:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_5), sms, 10);
 564:main.c        ****     sms += strlen((char *)sms);
 565:main.c        **** 
 566:main.c        ****     strcpy_P((char *)sms, PSTR(" U6="));
 567:main.c        ****     sms += strlen((char *)sms);
 568:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_6), sms, 10);
 569:main.c        ****     sms += strlen((char *)sms);
 570:main.c        **** 
 571:main.c        ****     strcpy_P((char *)sms, PSTR(" U7="));
 572:main.c        ****     sms += strlen((char *)sms);
 573:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_7), sms, 10);
 574:main.c        ****     sms += strlen((char *)sms);
 575:main.c        ****     *sms++ = '\n';
 576:main.c        **** 
 577:main.c        ****     strcpy_P((char *)sms, PSTR("1=RCV 2=BSY 3=CNT 4=QSM 5=QAL 6=FND 7=ADD"));
 578:main.c        **** 
 579:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 580:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 581:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 582:main.c        ****     zapal_diode_led_blyski(2);
 583:main.c        ****     break;
 584:main.c        ****   }
 585:main.c        ****   case INTERPRETACJA_SMS_USER: {
 586:main.c        ****     ++licznik_report_user;
 587:main.c        ****     timer_report_user_100ms = OKNO_CZASOWE_REPORT_USER_100MS;
 588:main.c        **** 
 589:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 590:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 591:main.c        **** 
 592:main.c        ****     // Uzyj lokalnego bufora aby uniknac konfliktow z EEPROM
 593:main.c        ****     uchar temp_buf[10];
 594:main.c        **** 
 595:main.c        ****     // Konwertuj numer na format EEPROM
 596:main.c        ****     konwertuj_telefon_na_blok_eeprom(
 597:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
 598:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[strlen(
 599:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
 600:main.c        ****         temp_buf);
 601:main.c        **** 
 602:main.c        ****     // Sprawdz czy numer jest na liscie
 603:main.c        ****     uchar znaleziono = FALSE;
 604:main.c        ****     for (uint nr_uzyt_clip = 0;
 605:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 606:main.c        ****       if (porownaj_numer_telefonu_blok(
 607:main.c        ****               temp_buf, (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
 608:main.c        ****         znaleziono = TRUE;
 609:main.c        ****         break;
 610:main.c        ****       }
 611:main.c        ****     }
 612:main.c        **** 
 613:main.c        ****     // Przygotuj odpowiedz z numerem telefonu i statusem
 614:main.c        ****     strcpy((char *)tekst_wysylanego_smsa,
 615:main.c        ****            (char *)numer_telefonu_do_ktorego_dzwonic);
 616:main.c        ****     strcat((char *)tekst_wysylanego_smsa, ": ");
 617:main.c        ****     if (znaleziono) {
 618:main.c        ****       strcat((char *)tekst_wysylanego_smsa, "OK");
 619:main.c        ****     } else {
 620:main.c        ****       strcat((char *)tekst_wysylanego_smsa, "Brak takiego numeru w systemie");
 621:main.c        ****     }
 622:main.c        **** 
 623:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 624:main.c        **** 
 625:main.c        ****     zapal_diode_led_blyski(2); // Komenda USER - 2 blyski
 626:main.c        **** 
 627:main.c        ****     // Zapisz debug tylko na koncu (bezpiecznie)
 628:main.c        ****     // U1=1 (USER), U6=znaleziono
 629:main.c        ****     if (czy_wolny_eeprom()) {
 630:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 631:main.c        ****       // Ale poniewaz zapisz_znak_w_eeprom uzywa przerwan, nie mozemy wolac go
 632:main.c        ****       // od razu drugi raz Mozemy zapisac skondensowana informacje lub uzyc
 633:main.c        ****       // bufora Dla bezpieczenstwa zapiszmy tylko jeden bajt statusu Bit 0:
 634:main.c        ****       // znaleziono, Bit 1: USER wykonany zapisz_znak_w_eeprom(znaleziono |
 635:main.c        ****       // 0x02, ADRES_EEPROM_DEBUG_USER_6);
 636:main.c        ****     }
 637:main.c        ****     zapisz_debug_do_eeprom(2, znaleziono); // 2 = USER
 638:main.c        ****     break;
 639:main.c        ****   }
 640:main.c        ****   case INTERPRETACJA_SMS_USER_BEZ_NUMERU: {
 641:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 642:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 643:main.c        ****     strcpy((char *)tekst_wysylanego_smsa,
 644:main.c        ****            "Wpisz numer jaki sprawdzasz, np: USER 793557357");
 645:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 646:main.c        ****     zapal_diode_led_blyski(2);
 647:main.c        ****     break;
 648:main.c        ****   }
 649:main.c        ****   case INTERPRETACJA_SMS_USER_LIST: {
 650:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 651:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 652:main.c        ****     numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama = 0;
 653:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW);
 654:main.c        ****     zapal_diode_led_blyski(2);
 655:main.c        ****     break;
 656:main.c        ****   }
 657:main.c        ****   case INTERPRETACJA_SMS_RESET_WSZYSTKICH_USTAWIEN: {
 658:main.c        ****     if (not czy_sa_komendy_z_przedzialu(
 659:main.c        ****             KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 660:main.c        ****             KOMENDA_KOLEJKI_RESET_USTAWIEN_INICJALIZACJA)) {
 661:main.c        ****       zapal_diode_led_blyski(25);
 662:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
 663:main.c        ****     }
 664:main.c        ****     break;
 665:main.c        ****   }
 666:main.c        ****   default:
 667:main.c        ****     break;
 668:main.c        ****   }
 669:main.c        **** 
 670:main.c        ****   watchdog_sms_disarm();
 671:main.c        **** }
 672:main.c        **** 
 673:main.c        **** void steruj_wejsciem_reset_100ms(void) {
 674:main.c        ****   static uchar licznik_reset;
 675:main.c        ****   if (CZY_AKTUALNY_STAN_LOGICZNY_ON(0)) {
 676:main.c        ****     if (licznik_reset < 20 * 10)
 677:main.c        ****       ++licznik_reset;
 678:main.c        ****   } else {
 679:main.c        ****     if (licznik_reset >= 20 * 10) {
 680:main.c        ****       if (not czy_sa_komendy_z_przedzialu(
 681:main.c        ****               KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 682:main.c        ****               KOMENDA_KOLEJKI_RESET_USTAWIEN_INICJALIZACJA))
 683:main.c        ****         dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
 684:main.c        ****     } else if (licznik_reset >= 5 * 10) {
 685:main.c        ****       if (not czy_sa_komendy_z_przedzialu(
 686:main.c        ****               KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 687:main.c        ****               KOMENDA_KOLEJKI_RESET_USTAWIEN_INICJALIZACJA))
 688:main.c        ****         dodaj_komende(KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU);
 689:main.c        ****     }
 690:main.c        ****     licznik_reset = 0;
 691:main.c        ****   }
 692:main.c        **** }
 693:main.c        **** 
 694:main.c        **** uchar sprawdz_przychodzaca_rozmowe(void) // wysya TRUE, gdy naley odebra
 695:main.c        **** {
 696:main.c        ****   // Super User: pozycje 795-800 omijaja wszystkie blokady
 697:main.c        ****   uchar jest_super_user =
 698:main.c        ****       czy_numer_jest_super_userem(numer_telefonu_ktory_dzwoni);
 699:main.c        **** 
 700:main.c        ****   if (blokada_systemu && !jest_super_user) {
 701:main.c        ****     return FALSE; // Ignoruj rozmowy gdy system zablokowany (chyba ze super
 702:main.c        ****                   // user)
 703:main.c        ****   }
 704:main.c        **** 
 705:main.c        ****   if (blokada_sterowania_czasowa && !jest_super_user) {
 706:main.c        ****     return FALSE; // Ignoruj rozmowy gdy blokada czasowa (chyba ze super user)
 707:main.c        ****   }
 708:main.c        **** 
 709:main.c        ****   // W trybie DTMF:
 710:main.c        ****   if (!tryb_clip) {
 711:main.c        ****     if (numer_telefonu_ktory_dzwoni[0] != 0)
 712:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA);
 713:main.c        **** 
 714:main.c        ****     // Publiczny: odbierz wszystkie
 715:main.c        ****     if (tryb_pracy == 1)
 716:main.c        ****       return TRUE;
 717:main.c        **** 
 718:main.c        ****     // Prywatny: sprawdź autoryzację SYNCHRONICZNIE
 719:main.c        ****     // Konwertuj numer na format EEPROM
 720:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_ktory_dzwoni[0],
 721:main.c        ****                                      &numer_telefonu_ktory_dzwoni[strlen(
 722:main.c        ****                                          (char *)numer_telefonu_ktory_dzwoni)],
 723:main.c        ****                                      &bufor_eeprom[0]);
 724:main.c        **** 
 725:main.c        ****     // Sprawdź listę autoryzowanych numerów
 726:main.c        ****     for (uint nr_uzyt = 0; nr_uzyt < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 727:main.c        ****          ++nr_uzyt) {
 728:main.c        ****       if (porownaj_numer_telefonu_blok(
 729:main.c        ****               &bufor_eeprom[0], (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt))) {
 730:main.c        ****         return TRUE; // Numer autoryzowany - odbierz
 731:main.c        ****       }
 732:main.c        ****     }
 733:main.c        ****     return FALSE; // Numer nieautoryzowany - odrzuć
 734:main.c        ****   }
 735:main.c        **** 
 736:main.c        ****   // W trybie CLIP:
 737:main.c        ****   if (numer_telefonu_ktory_dzwoni[0] != 0)
 738:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA);
 739:main.c        **** 
 740:main.c        ****   // Publiczny: włącz wyjście dla wszystkich
 741:main.c        ****   if (tryb_pracy == 1)
 742:main.c        ****     return TRUE;
 743:main.c        **** 
 744:main.c        ****   // Prywatny: sprawdź autoryzację
 745:main.c        ****   return FALSE; // Autoryzacja przez SPRAWDZ_UZYTKOWNIKOW_BRAMA
 746:main.c        **** }
 747:main.c        **** 
 748:main.c        **** uchar wysylanie_echa_przez_pdu = FALSE;
 749:main.c        **** 
 750:main.c        **** uchar *ptr_start_pdu_z_wiadomoscia; // pierwszy znak
 751:main.c        **** 
 752:main.c        **** #define WYSYLANIE_SMSA_CLIPA_BRAK 0
 753:main.c        **** #define WYSYLANIE_SMSA_WYSYLANIE 1
 754:main.c        **** #define WYSYLANIE_SMSA_POWTARZANIE 2
 755:main.c        **** #define WYSYLANIE_CLIPA_WYSYLANIE 4
 756:main.c        **** #define WYSYLANIE_CLIPA_KONCZENIE 5
 757:main.c        **** 
 758:main.c        **** uchar wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
 759:main.c        **** 
 760:main.c        **** enum PowodZakonczeniaRozmowyTelefonicznej {
 761:main.c        ****   powod_zakonczenia_rozmowy_odrzucenie,
 762:main.c        ****   powod_zakonczenia_rozmowy_zakonczenie,
 763:main.c        ****   powod_zakonczenia_rozmowy_przekroczony_czas,
 764:main.c        ****   powod_zakonczenia_rozmowy_otrzymana_wiadomosc
 765:main.c        **** };
 766:main.c        **** 
 767:main.c        **** void zakonczono_rozmowe_telefoniczna(
 768:main.c        ****     const enum PowodZakonczeniaRozmowyTelefonicznej powod) {
 769:main.c        ****   POMOC_DODAJ2('#', 'a');
 770:main.c        ****   opoznienie_SIM900_100MS = 60; // byo 60
 771:main.c        ****   licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 772:main.c        ****   ustaw_maksymalny_czas_dzwonienia = 0;
 773:main.c        ****   maksymalny_czas_dzwonienia = 0;
 774:main.c        ****   blokada_clip = FALSE;
 775:main.c        **** }
 776:main.c        **** 
 777:main.c        **** enum PowodZakonczeniaWysylaniaSMS {
 778:main.c        ****   zakonczenie_wysylania_sms_ok,
 779:main.c        ****   zakonczenie_wysylania_sms_blad_powtarzanie,
 780:main.c        ****   zakonczenie_wysylania_sms_blad_zakonczenie,
 781:main.c        ****   zakonczenie_wysylania_sms_blad_powtorz_sms,
 782:main.c        **** };
 783:main.c        **** 
 784:main.c        **** void zakonczono_wysylanie_smsa(const enum PowodZakonczeniaWysylaniaSMS powod) {
 785:main.c        ****   POMOC_DODAJ2('#', 'A');
 786:main.c        ****   opoznienie_SIM900_100MS = 60;
 787:main.c        **** 
 788:main.c        ****   wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
 789:main.c        **** }
 790:main.c        **** 
 791:main.c        **** void problem_z_wyslaniem_powiadomienia(void) {
 792:main.c        ****   wykonywanie_rozmowy_telefonicznej = FALSE;
 793:main.c        ****   licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 794:main.c        ****   wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 795:main.c        ****   czekanie_na_odebranie_zachety = FALSE;
 796:main.c        ****   opoznienie_SIM900_100MS = 60;
 797:main.c        ****   flaga_wysylanie_smsa = 0;
 798:main.c        **** }
 799:main.c        **** 
 800:main.c        **** #define JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ()                             \
 801:main.c        ****   if (!czy_mozna_wysylac_dane_do_SIM900) {                                     \
 802:main.c        ****     dodaj_komende(wykonywana_komenda);                                         \
 803:main.c        ****     break;                                                                     \
 804:main.c        ****   }                                                                            \
 805:main.c        ****   wysylane_polecenie_SIM900 = wykonywana_komenda;
 806:main.c        **** 
 807:main.c        **** #define POWTORZ_JESLI(WAR)                                                     \
 808:main.c        ****   {                                                                            \
 809:main.c        ****     if (WAR) {                                                                 \
 810:main.c        ****       dodaj_komende(wykonywana_komenda);                                       \
 811:main.c        ****       break;                                                                   \
 812:main.c        ****     }                                                                          \
 813:main.c        ****   }
 814:main.c        **** 
 815:main.c        **** #define JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ() POWTORZ_JESLI(!czy_wolny_eeprom())
 816:main.c        **** 
 817:main.c        **** #define JESLI_SIM900_ZAJETY_WYKONAJ_POZNIEJ() POWTORZ_JESLI(czy_gsm_zajety)
 818:main.c        **** 
 819:main.c        **** #include "main_sim900.h"
 820:main.c        **** 
 821:main.c        **** #define aktualnie_wykonywana_komenda wykonywana_komenda
 822:main.c        **** 
 823:main.c        **** void inicjalizuj_parametry_modulu(void);
 824:main.c        **** 
 825:main.c        **** #define MAX_LICZBA_KOMEND_DLA_ALARMOW (LICZBA_KOMEND / 4)
 826:main.c        **** 
 827:main.c        **** // Funkcja pomocnicza: Wyciąga ostatnie N cyfr z numeru telefonu
 828:main.c        **** // max_digits: maksimum cyfr (9)
 829:main.c        **** static void wyciagnij_ostatnie_cyfry(const uchar *numer_pelny,
 830:main.c        ****                                      uchar *numer_skrocony, uchar max_digits) {
 831:main.c        ****   uchar len = strlen((char *)numer_pelny);
 832:main.c        **** 
 833:main.c        ****   if (len > max_digits) {
 834:main.c        ****     // Take last max_digits
 835:main.c        ****     strcpy((char *)numer_skrocony, (char *)numer_pelny + (len - max_digits));
 836:main.c        ****   } else {
 837:main.c        ****     // Take all
 838:main.c        ****     strcpy((char *)numer_skrocony, (char *)numer_pelny);
 839:main.c        ****   }
 840:main.c        **** }
 841:main.c        **** 
 842:main.c        **** // Helper function to check if a number exists in EEPROM
 843:main.c        **** // Uses bufor_eeprom as temporary storage for comparison
 844:main.c        **** static uchar czy_numer_istnieje(const uchar *numer_telefonu) {
  35               		.loc 1 844 0
  36               		.cfi_startproc
  37               	.LVL0:
  38 000e CF93      		push r28
  39               	.LCFI0:
  40               		.cfi_def_cfa_offset 3
  41               		.cfi_offset 28, -2
  42 0010 DF93      		push r29
  43               	.LCFI1:
  44               		.cfi_def_cfa_offset 4
  45               		.cfi_offset 29, -3
  46               	/* prologue: function */
  47               	/* frame size = 0 */
  48               	/* stack size = 2 */
  49               	.L__stack_usage = 2
 845:main.c        ****   // Convert number to EEPROM block format
 846:main.c        ****   // We use a local buffer to avoid corrupting global buffers if possible,
 847:main.c        ****   // but porownaj_numer_telefonu_blok expects a block.
 848:main.c        ****   // Let's use bufor_eeprom as it is standard for this operation in this
 849:main.c        ****   // codebase.
 850:main.c        ****   konwertuj_telefon_na_blok_eeprom(
 851:main.c        ****       numer_telefonu, numer_telefonu + strlen((char *)numer_telefonu),
  50               		.loc 1 851 0
  51 0012 FC01      		movw r30,r24
  52               		0:
  53 0014 0190      		ld __tmp_reg__,Z+
  54 0016 0020      		tst __tmp_reg__
  55 0018 01F4      		brne 0b
  56 001a BF01      		movw r22,r30
 850:main.c        ****       numer_telefonu, numer_telefonu + strlen((char *)numer_telefonu),
  57               		.loc 1 850 0
  58 001c 6150      		subi r22,1
  59 001e 7109      		sbc r23,__zero_reg__
  60 0020 40E0      		ldi r20,lo8(bufor_eeprom)
  61 0022 50E0      		ldi r21,hi8(bufor_eeprom)
  62 0024 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
  63               	.LVL1:
  64 0028 C8E0      		ldi r28,lo8(8)
  65 002a D0E0      		ldi r29,0
  66               	.LVL2:
  67               	.L4:
  68               	.LBB357:
 852:main.c        ****       bufor_eeprom);
 853:main.c        **** 
 854:main.c        ****   for (uint nr_uzyt_clip = 0; nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 855:main.c        ****        ++nr_uzyt_clip) {
 856:main.c        ****     if (porownaj_numer_telefonu_blok(
  69               		.loc 1 856 0
  70 002c BE01      		movw r22,r28
  71 002e 80E0      		ldi r24,lo8(bufor_eeprom)
  72 0030 90E0      		ldi r25,hi8(bufor_eeprom)
  73 0032 0E94 0000 		call porownaj_numer_telefonu_blok
  74               	.LVL3:
  75 0036 8111      		cpse r24,__zero_reg__
  76 0038 00C0      		rjmp .L5
  77 003a 2596      		adiw r28,5
 854:main.c        ****        ++nr_uzyt_clip) {
  78               		.loc 1 854 0
  79 003c C83A      		cpi r28,-88
  80 003e FFE0      		ldi r31,15
  81 0040 DF07      		cpc r29,r31
  82 0042 01F4      		brne .L4
  83               	.L2:
  84               	/* epilogue start */
  85               	.LBE357:
 857:main.c        ****             bufor_eeprom, (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
 858:main.c        ****       return TRUE;
 859:main.c        ****     }
 860:main.c        ****   }
 861:main.c        ****   return FALSE;
 862:main.c        **** }
  86               		.loc 1 862 0
  87 0044 DF91      		pop r29
  88 0046 CF91      		pop r28
  89 0048 0895      		ret
  90               	.L5:
  91               	.LBB358:
 858:main.c        ****     }
  92               		.loc 1 858 0
  93 004a 8FEF      		ldi r24,lo8(-1)
  94 004c 00C0      		rjmp .L2
  95               	.LBE358:
  96               		.cfi_endproc
  97               	.LFE58:
 100               	usun_zablokowany_sms:
 101               	.LFB36:
 330:main.c        ****   // Usun SMS z modulu SIM900 (numer jest w aktualnie_wysylane_polecenie_SIM900)
 102               		.loc 1 330 0
 103               		.cfi_startproc
 104               	/* prologue: function */
 105               	/* frame size = 0 */
 106               	/* stack size = 0 */
 107               	.L__stack_usage = 0
 333:main.c        ****       aktualnie_wysylane_polecenie_SIM900 <= KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 108               		.loc 1 333 0
 109 004e 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 110 0052 96E5      		ldi r25,lo8(86)
 111 0054 980F      		add r25,r24
 112               	.LBB359:
 338:main.c        ****   } else {
 113               		.loc 1 338 0
 114 0056 8C5E      		subi r24,lo8(-(20))
 115               	.LBE359:
 333:main.c        ****       aktualnie_wysylane_polecenie_SIM900 <= KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 116               		.loc 1 333 0
 117 0058 9431      		cpi r25,lo8(20)
 118 005a 00F0      		brlo .L9
 341:main.c        ****   }
 119               		.loc 1 341 0
 120 005c 82E9      		ldi r24,lo8(-110)
 121               	.L9:
 122 005e 0C94 0000 		jmp filtruj_i_dodaj_komende
 123               	.LVL4:
 124               		.cfi_endproc
 125               	.LFE36:
 128               	zareaguj_na_usuniety_sms_z_powodu_limitu:
 129               	.LFB37:
 345:main.c        ****   if (licznik_usunietych_sms_przez_limit < 0xFFFF)
 130               		.loc 1 345 0
 131               		.cfi_startproc
 132               	/* prologue: function */
 133               	/* frame size = 0 */
 134               	/* stack size = 0 */
 135               	.L__stack_usage = 0
 346:main.c        ****     ++licznik_usunietych_sms_przez_limit;
 136               		.loc 1 346 0
 137 0062 8091 0000 		lds r24,licznik_usunietych_sms_przez_limit
 138 0066 9091 0000 		lds r25,licznik_usunietych_sms_przez_limit+1
 139 006a 8F3F      		cpi r24,-1
 140 006c 9807      		cpc r25,r24
 141 006e 01F0      		breq .L11
 347:main.c        ****   sygnalizuj_pelny_system();
 142               		.loc 1 347 0
 143 0070 0196      		adiw r24,1
 144 0072 9093 0000 		sts licznik_usunietych_sms_przez_limit+1,r25
 145 0076 8093 0000 		sts licznik_usunietych_sms_przez_limit,r24
 146               	.L11:
 147               	.LBB362:
 148               	.LBB363:
 326:main.c        **** }
 149               		.loc 1 326 0
 150 007a 8AE0      		ldi r24,lo8(10)
 151 007c 8093 0000 		sts liczba_blyskow_led,r24
 152 0080 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 153               	.LBE363:
 154               	.LBE362:
 349:main.c        ****   // Uzywamy filtruj_i_dodaj
 155               		.loc 1 349 0
 156 0084 0E94 0000 		call watchdog_sms_disarm
 157               	.LVL5:
 351:main.c        **** }
 158               		.loc 1 351 0
 159 0088 82E9      		ldi r24,lo8(-110)
 160 008a 0C94 0000 		jmp filtruj_i_dodaj_komende
 161               	.LVL6:
 162               		.cfi_endproc
 163               	.LFE37:
 166               	polozenie_polecenia_SIM900:
 167               	.LFB48:
 168               		.file 2 "main_sim900.h"
   1:main_sim900.h **** 
   2:main_sim900.h **** #ifdef MAIN_SIM900_H
   3:main_sim900.h **** #error Dwa razy wlaczany plik
   4:main_sim900.h **** #endif
   5:main_sim900.h **** 
   6:main_sim900.h **** void wyzerowanie_danych_SIM900(void) {
   7:main_sim900.h ****   POMOC_DODAJ2('*', 't');
   8:main_sim900.h ****   problem_z_wyslaniem_powiadomienia();
   9:main_sim900.h ****   licznik_wysylane_polecenie_SIM900 = 0;
  10:main_sim900.h ****   aktualnie_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
  11:main_sim900.h ****   liczba_komend_w_kolejce_SIM900 = 0;
  12:main_sim900.h ****   licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow = 0;
  13:main_sim900.h ****   czekanie_na_odebranie_zachety = FALSE;
  14:main_sim900.h ****   flaga_odebrany_znak_zachety = FALSE;
  15:main_sim900.h ****   trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
  16:main_sim900.h ****   wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
  17:main_sim900.h ****   flaga_odczytywanie_smsa = FALSE;
  18:main_sim900.h **** }
  19:main_sim900.h **** 
  20:main_sim900.h **** void reset_modulu_SIM900(void) {
  21:main_sim900.h ****   wyzerowanie_danych_SIM900();
  22:main_sim900.h ****   POMOC_DODAJ2('*', 'm');
  23:main_sim900.h ****   HARDRESET_SIM900();
  24:main_sim900.h ****   podlaczony_modul_gsm_SIM900 = FALSE;
  25:main_sim900.h ****   podlaczona_karta_SIM_SIM900 = FALSE;
  26:main_sim900.h ****   licznik_blad_stanu_karty_SIM = 0;
  27:main_sim900.h ****   licznik_blad_zalogowania_u_operatora = 0;
  28:main_sim900.h ****   nazwa_operatora[0] = '\0';
  29:main_sim900.h ****   licznik_ogolny_blad_zalogowania = 0;
  30:main_sim900.h ****   blokada_clip = FALSE;
  31:main_sim900.h ****   nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
  32:main_sim900.h ****   poziom_sieci_gsm = POZIOM_SIECI_BLAD;
  33:main_sim900.h ****   filtruj_komendy_z_przedzialu(KOMENDA_KOLEJKI_USUN_SMSA_1,
  34:main_sim900.h ****                                KOMENDA_KOLEJKI_USUN_SMSA_20);
  35:main_sim900.h ****   filtruj_komendy_z_przedzialu(
  36:main_sim900.h ****       KOMENDA_KOLEJKI_KOMENDA_SIM900,
  37:main_sim900.h ****       KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE);
  38:main_sim900.h ****   filtruj_komendy_z_przedzialu(
  39:main_sim900.h ****       KOMENDA_KOLEJKI_SPRAWDZ_PIN,
  40:main_sim900.h ****       KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ);
  41:main_sim900.h ****   filtruj_komendy_z_przedzialu(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT,
  42:main_sim900.h ****                                KOMENDA_KOLEJKI_WYSLIJ_PDU);
  43:main_sim900.h ****   modul_zalogowany_w_sieci = FALSE;
  44:main_sim900.h **** }
  45:main_sim900.h **** 
  46:main_sim900.h **** static uchar czy_polecenie_SIM900(PGM_P polecenie, const uchar liczba_znakow) {
  47:main_sim900.h ****   return strncmp_P(odebrany_blok_SIM900 + 2, polecenie, liczba_znakow) == 0;
  48:main_sim900.h **** }
  49:main_sim900.h **** 
  50:main_sim900.h **** static uchar *polozenie_polecenia_SIM900(PGM_P polecenie) {
 169               		.loc 2 50 0
 170               		.cfi_startproc
 171               	.LVL7:
 172               	/* prologue: function */
 173               	/* frame size = 0 */
 174               	/* stack size = 0 */
 175               	.L__stack_usage = 0
  51:main_sim900.h ****   return strstr_P(odebrany_blok_SIM900, polecenie);
 176               		.loc 2 51 0
 177 008e BC01      		movw r22,r24
 178 0090 80E0      		ldi r24,lo8(odebrany_blok_SIM900)
 179 0092 90E0      		ldi r25,hi8(odebrany_blok_SIM900)
 180               	.LVL8:
 181 0094 0C94 0000 		jmp strstr_P
 182               	.LVL9:
 183               		.cfi_endproc
 184               	.LFE48:
 187               	opoznienie_startowe:
 188               	.LFB70:
 863:main.c        **** 
 864:main.c        **** uchar wykonanie_komend_ukladow(void) {
 865:main.c        ****   const komenda_typ aktualnie_wykonywana_komenda = komendy_kolejka[0];
 866:main.c        **** 
 867:main.c        ****   switch (aktualnie_wykonywana_komenda) {
 868:main.c        ****   case KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU: {
 869:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 870:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 871:main.c        ****     kod_modulu[1] = bufor_eeprom[1] = 'B';
 872:main.c        ****     kod_modulu[2] = bufor_eeprom[2] = 'C';
 873:main.c        ****     kod_modulu[3] = bufor_eeprom[3] = 'D';
 874:main.c        ****     zapisz_znaki_w_eeprom_bez_kopiowania(ADRES_EEPROM_KOD_DOSTEPU,
 875:main.c        ****                                          LICZBA_BAJTOW_KODU_DOSTEPU);
 876:main.c        ****     zapal_diode_led(50);
 877:main.c        ****     break;
 878:main.c        ****   }
 879:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_0:
 880:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_1:
 881:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_2:
 882:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_3:
 883:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_4:
 884:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_5:
 885:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_6:
 886:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_7:
 887:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_8:
 888:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_9:
 889:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_10:
 890:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_11:
 891:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_12:
 892:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_13:
 893:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_14:
 894:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_15:
 895:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_16:
 896:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_17:
 897:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_18:
 898:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_19:
 899:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_20:
 900:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_21:
 901:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_22:
 902:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_23:
 903:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_24:
 904:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_25:
 905:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_26:
 906:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_27:
 907:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_28:
 908:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_29:
 909:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_30:
 910:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_31:
 911:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_32:
 912:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_33:
 913:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_34:
 914:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_35:
 915:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_36:
 916:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_37:
 917:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_38:
 918:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_39:
 919:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_40:
 920:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_41:
 921:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_42:
 922:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_43:
 923:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_44:
 924:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_45:
 925:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_46:
 926:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_47:
 927:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_48:
 928:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_49:
 929:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_50:
 930:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_51:
 931:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_52:
 932:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_53:
 933:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_54:
 934:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_55:
 935:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_56:
 936:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_57:
 937:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_58:
 938:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_59:
 939:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_60:
 940:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_61:
 941:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_62:
 942:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_63:
 943:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_64:
 944:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_65:
 945:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_66:
 946:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_67:
 947:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_68:
 948:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_69:
 949:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_70:
 950:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_71:
 951:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_72:
 952:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_73:
 953:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_74:
 954:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_75:
 955:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_76:
 956:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_77:
 957:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_78:
 958:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_79:
 959:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_80:
 960:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_81:
 961:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_82:
 962:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_83:
 963:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_84:
 964:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_85:
 965:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_86:
 966:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_87:
 967:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_88:
 968:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_89:
 969:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_90:
 970:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_91:
 971:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_92:
 972:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_93:
 973:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_94:
 974:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_95:
 975:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_96:
 976:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_97:
 977:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_98:
 978:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_99:
 979:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_100:
 980:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_101:
 981:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_102:
 982:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_103:
 983:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_104:
 984:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_105:
 985:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_106:
 986:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_107:
 987:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_108:
 988:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_109:
 989:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_110:
 990:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_111:
 991:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_112:
 992:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_113:
 993:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_114:
 994:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_115:
 995:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_116:
 996:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_117:
 997:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_118:
 998:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_119:
 999:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_120:
1000:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_121:
1001:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_122:
1002:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_123:
1003:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_124:
1004:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_125:
1005:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_126:
1006:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_127: {
1007:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1008:main.c        ****     const uchar nr_bloku =
1009:main.c        ****         aktualnie_wykonywana_komenda - KOMENDA_KOLEJKI_RESET_USTAWIEN_0;
1010:main.c        **** #define LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE 32
1011:main.c        ****     memset(bufor_eeprom, 0xff, LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE);
1012:main.c        ****     if (nr_bloku == 0) {
1013:main.c        ****       kod_modulu[0] = bufor_eeprom[1] = 'A';
1014:main.c        ****       kod_modulu[1] = bufor_eeprom[2] = 'B';
1015:main.c        ****       kod_modulu[2] = bufor_eeprom[3] = 'C';
1016:main.c        ****       kod_modulu[3] = bufor_eeprom[4] = 'D';
1017:main.c        ****       bufor_eeprom[5] = 0;
1018:main.c        ****       stan_wyjscie[0] = 0;
1019:main.c        ****       licznik_przelacznik_wyjscia[0] = 0;
1020:main.c        ****     }
1021:main.c        ****     zapisz_znaki_w_eeprom_bez_kopiowania(
1022:main.c        ****         nr_bloku * LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE,
1023:main.c        ****         LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE);
1024:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0 + nr_bloku + 1);
1025:main.c        ****     zapal_diode_led(50);
1026:main.c        ****     break;
1027:main.c        ****   }
1028:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_INICJALIZACJA: {
1029:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1030:main.c        ****     uchar bledny_zapis = FALSE;
1031:main.c        ****     static const uchar tab_eeprom_fabryczny[6] PROGMEM = {
1032:main.c        ****         0xff, 'A', 'B', 'C', 'D', 0x00,
1033:main.c        ****     };
1034:main.c        ****     for (uint i = 0; i < 6; ++i) {
1035:main.c        ****       if (eeprom_read_byte((void *)i) !=
1036:main.c        ****           pgm_read_byte(tab_eeprom_fabryczny + i))
1037:main.c        ****         bledny_zapis = TRUE;
1038:main.c        ****     }
1039:main.c        ****     for (uint i = EEPROM_NUMER_TELEFONU_BRAMA_0;
1040:main.c        ****          i < EEPROM_NUMER_TELEFONU_BRAMA_0 +
1041:main.c        ****                  MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA *
1042:main.c        ****                      LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM;
1043:main.c        ****          ++i) {
1044:main.c        ****       if (eeprom_read_byte((void *)i) != 0xff) {
1045:main.c        ****         bledny_zapis = TRUE;
1046:main.c        ****         break;
1047:main.c        ****       }
1048:main.c        ****     }
1049:main.c        ****     if (bledny_zapis) {
1050:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
1051:main.c        ****       break;
1052:main.c        ****     }
1053:main.c        ****     inicjalizuj_parametry_modulu();
1054:main.c        ****     ustaw_stan_led(FALSE); // Wylacz diode po zakonczeniu resetu
1055:main.c        ****     break;
1056:main.c        ****   }
1057:main.c        ****   case KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA: {
1058:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1059:main.c        **** 
1060:main.c        ****     if (blokada_sterowania_czasowa) {
1061:main.c        ****       // Poza dozwolonym czasem - ignoruj
1062:main.c        ****       break;
1063:main.c        ****     }
1064:main.c        **** 
1065:main.c        ****     // Make a local copy of the phone number to prevent corruption
1066:main.c        ****     // if the global buffer changes during processing (e.g. new CLIP)
1067:main.c        ****     uchar numer_lokalny[MAX_LICZBA_ZNAKOW_TELEFON + 1];
1068:main.c        ****     strcpy((char *)numer_lokalny, (char *)numer_telefonu_ktory_dzwoni);
1069:main.c        **** 
1070:main.c        ****     // Konwertuj numer dla późniejszego użycia
1071:main.c        ****     konwertuj_telefon_na_blok_eeprom(
1072:main.c        ****         &numer_lokalny[0], &numer_lokalny[strlen((char *)numer_lokalny)],
1073:main.c        ****         &bufor_eeprom[0]);
1074:main.c        **** 
1075:main.c        ****     // Sprawdź czy numer jest na liście (PEŁNY NUMER)
1076:main.c        ****     uchar znaleziono = FALSE;
1077:main.c        ****     if (tryb_pracy != 1) {
1078:main.c        ****       // Tylko w trybie prywatnym sprawdzamy listę
1079:main.c        ****       for (uint nr_uzyt_clip = 0;
1080:main.c        ****            nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
1081:main.c        ****         if (porownaj_numer_telefonu_blok(
1082:main.c        ****                 &bufor_eeprom[0],
1083:main.c        ****                 (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
1084:main.c        ****           znaleziono = TRUE;
1085:main.c        ****           break;
1086:main.c        ****         }
1087:main.c        ****       }
1088:main.c        ****     }
1089:main.c        **** 
1090:main.c        ****     // SKRYBA: Jeśli nie znaleziono pełnego, sprawdź skrócony (ostatnie 9 cyfr)
1091:main.c        ****     uchar numer_skrocony[20]; // Increased buffer size
1092:main.c        ****     if (skryba_wlaczona && !znaleziono) {
1093:main.c        ****       wyciagnij_ostatnie_cyfry(numer_lokalny, numer_skrocony, 9);
1094:main.c        **** 
1095:main.c        ****       // Konwertuj skrócony numer do bufor_eeprom dla porównania
1096:main.c        ****       konwertuj_telefon_na_blok_eeprom(
1097:main.c        ****           &numer_skrocony[0], &numer_skrocony[strlen((char *)numer_skrocony)],
1098:main.c        ****           &bufor_eeprom[0]);
1099:main.c        **** 
1100:main.c        ****       if (tryb_pracy != 1) {
1101:main.c        ****         for (uint nr_uzyt_clip = 0;
1102:main.c        ****              nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
1103:main.c        ****              ++nr_uzyt_clip) {
1104:main.c        ****           if (porownaj_numer_telefonu_blok(
1105:main.c        ****                   &bufor_eeprom[0],
1106:main.c        ****                   (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
1107:main.c        ****             znaleziono = TRUE;
1108:main.c        ****             break;
1109:main.c        ****           }
1110:main.c        ****         }
1111:main.c        ****       }
1112:main.c        ****     }
1113:main.c        **** 
1114:main.c        ****     // SKRYBA: Auto-save numer jesli wlaczona i nie znaleziono
1115:main.c        ****     zapisz_znak_w_eeprom(skryba_wlaczona ? 1 : 0,
1116:main.c        ****                          ADRES_EEPROM_DEBUG_SKRYBA_2); // DEBUG
1117:main.c        ****     zapisz_znak_w_eeprom(znaleziono ? 0 : 1,
1118:main.c        ****                          ADRES_EEPROM_DEBUG_SKRYBA_3); // DEBUG
1119:main.c        **** 
1120:main.c        ****     if (skryba_wlaczona && !znaleziono) {
1121:main.c        ****       uchar len_full = strlen((char *)numer_lokalny);
1122:main.c        **** 
1123:main.c        ****       // DEBUG: Zapisz dlugosc numeru
1124:main.c        ****       zapisz_znak_w_eeprom(len_full, ADRES_EEPROM_DEBUG_SKRYBA_5);
1125:main.c        **** 
1126:main.c        ****       if (len_full >= 3) {
1127:main.c        ****         // Skopiuj skrócony numer do numer_telefonu_skryba
1128:main.c        ****         strcpy((char *)numer_telefonu_skryba, (char *)numer_skrocony);
1129:main.c        **** 
1130:main.c        ****         // Extra check: ensure extracted number is also >= 3 chars
1131:main.c        ****         if (strlen((char *)numer_telefonu_skryba) >= 3) {
1132:main.c        ****           zapisz_znak_w_eeprom(
1133:main.c        ****               1, ADRES_EEPROM_DEBUG_SKRYBA_4); // DEBUG: komenda dodana
1134:main.c        **** 
1135:main.c        ****           // Dodaj komende dodania uzytkownika Skryba
1136:main.c        ****           dodaj_komende(KOMENDA_KOLEJKI_DODAJ_UZYTKOWNIKA_SKRYBA);
1137:main.c        ****         }
1138:main.c        ****       }
1139:main.c        ****     }
1140:main.c        **** 
1141:main.c        ****     // Teraz sprawdź tryb i otwórz bramę (TYLKO W TRYBIE CLIP!)
1142:main.c        ****     if (tryb_clip) {
1143:main.c        ****       if (tryb_pracy == 1) {
1144:main.c        ****         // Tryb publiczny - otwórz dla każdego
1145:main.c        ****         ustaw_wyjscie_clip();
1146:main.c        ****       } else if (znaleziono) {
1147:main.c        ****         // Tryb prywatny - otwórz tylko dla znalezionych
1148:main.c        ****         ustaw_wyjscie_clip();
1149:main.c        ****       }
1150:main.c        ****     }
1151:main.c        ****     // W trybie DTMF NIE włączamy wyjścia - czekamy na klawisz '1'
1152:main.c        **** 
1153:main.c        ****     break;
1154:main.c        ****   }
1155:main.c        ****   case KOMENDA_KOLEJKI_DODAJ_UZYTKOWNIKA_BRAMA: {
1156:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1157:main.c        **** 
1158:main.c        ****     // Check for duplicates using the helper function
1159:main.c        ****     if (czy_numer_istnieje(numer_telefonu_do_ktorego_dzwonic)) {
1160:main.c        ****       return TRUE; // Duplicate found, abort
1161:main.c        ****     }
1162:main.c        **** 
1163:main.c        ****     // Re-convert because czy_numer_istnieje uses bufor_eeprom which might be
1164:main.c        ****     // modified (though in this implementation it sets it correctly for writing
1165:main.c        ****     // too) But to be safe and consistent with original logic:
1166:main.c        ****     konwertuj_telefon_na_blok_eeprom(
1167:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
1168:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[strlen(
1169:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
1170:main.c        ****         &bufor_eeprom[0]);
1171:main.c        **** 
1172:main.c        ****     uchar dodano = FALSE;
1173:main.c        ****     // Skryba: dodawaj tylko do pozycji 0-794 (user-facing 1-795)
1174:main.c        ****     // Pozycje 795-800 (indeksy 794-799) sa zarezerwowane dla Super Userow
1175:main.c        ****     uint max_pozycja = (skryba_limit < 795) ? skryba_limit : 795;
1176:main.c        ****     for (uint nr_uzyt_clip = 0; nr_uzyt_clip < max_pozycja; ++nr_uzyt_clip) {
1177:main.c        ****       if (not czy_aktywny_numer_telefonu_brama(nr_uzyt_clip)) {
1178:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
1179:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
1180:main.c        ****             LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1181:main.c        ****         dodano = TRUE;
1182:main.c        ****         break;
1183:main.c        ****       }
1184:main.c        ****     }
1185:main.c        **** 
1186:main.c        ****     // Jesli dodano numer i Skryba jest wlaczona, sprawdz czy osiagnieto limit
1187:main.c        ****     if (dodano && skryba_wlaczona) {
1188:main.c        ****       // Policz aktywnych uzytkownikow
1189:main.c        ****       uint aktywne_numery = 0;
1190:main.c        ****       for (uint i = 0; i < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++i) {
1191:main.c        ****         if (czy_aktywny_numer_telefonu_brama(i)) {
1192:main.c        ****           ++aktywne_numery;
1193:main.c        ****         }
1194:main.c        ****       }
1195:main.c        **** 
1196:main.c        ****       // Jesli osiagnieto limit, wylacz Skrybe
1197:main.c        ****       if (aktywne_numery >= skryba_limit) {
1198:main.c        ****         skryba_wlaczona = FALSE;
1199:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_SKRYBA);
1200:main.c        **** 
1201:main.c        ****         tryb_pracy = 0; // Prywatny
1202:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_TRYB_PRACY);
1203:main.c        ****       }
1204:main.c        ****     }
1205:main.c        ****     break;
1206:main.c        ****   }
1207:main.c        ****   case KOMENDA_KOLEJKI_DODAJ_UZYTKOWNIKA_SKRYBA: {
1208:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1209:main.c        **** 
1210:main.c        ****     // Use a LOCAL buffer for Skryba to avoid corruption by czy_numer_istnieje
1211:main.c        ****     uchar bufor_skryba[LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM];
1212:main.c        **** 
1213:main.c        ****     // Convert Skryba number to EEPROM format FIRST, before duplicate check
1214:main.c        ****     konwertuj_telefon_na_blok_eeprom(
1215:main.c        ****         &numer_telefonu_skryba[0],
1216:main.c        ****         &numer_telefonu_skryba[strlen((char *)numer_telefonu_skryba)],
1217:main.c        ****         bufor_skryba);
1218:main.c        **** 
1219:main.c        ****     // Check for duplicates using the helper function
1220:main.c        ****     // (This will use bufor_eeprom internally, but we have our number safe in
1221:main.c        ****     // bufor_skryba)
1222:main.c        ****     if (czy_numer_istnieje(numer_telefonu_skryba)) {
1223:main.c        ****       return TRUE; // Duplicate found, abort
1224:main.c        ****     }
1225:main.c        **** 
1226:main.c        ****     // Copy our safe buffer to bufor_eeprom for writing
1227:main.c        ****     memcpy(bufor_eeprom, bufor_skryba, LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1228:main.c        **** 
1229:main.c        ****     uchar dodano = FALSE;
1230:main.c        ****     for (uint nr_uzyt_clip = 0;
1231:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
1232:main.c        ****       if (not czy_aktywny_numer_telefonu_brama(nr_uzyt_clip)) {
1233:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
1234:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
1235:main.c        ****             LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1236:main.c        **** 
1237:main.c        ****         dodano = TRUE;
1238:main.c        ****         break;
1239:main.c        ****       }
1240:main.c        ****     }
1241:main.c        **** 
1242:main.c        ****     // Jesli dodano numer i Skryba jest wlaczona, sprawdz czy osiagnieto limit
1243:main.c        ****     if (dodano && skryba_wlaczona) {
1244:main.c        ****       // Policz aktywnych uzytkownikow
1245:main.c        ****       uint aktywne_numery = 0;
1246:main.c        ****       for (uint i = 0; i < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++i) {
1247:main.c        ****         if (czy_aktywny_numer_telefonu_brama(i)) {
1248:main.c        ****           ++aktywne_numery;
1249:main.c        ****         }
1250:main.c        ****       }
1251:main.c        **** 
1252:main.c        ****       // Jesli osiagnieto limit, wylacz Skrybe
1253:main.c        ****       if (aktywne_numery >= skryba_limit) {
1254:main.c        ****         skryba_wlaczona = FALSE;
1255:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_SKRYBA);
1256:main.c        **** 
1257:main.c        ****         tryb_pracy = 0; // Prywatny
1258:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_TRYB_PRACY);
1259:main.c        ****       }
1260:main.c        ****     }
1261:main.c        ****     break;
1262:main.c        ****   }
1263:main.c        ****   case KOMENDA_KOLEJKI_DODAJ_SUPER_USERA: {
1264:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1265:main.c        **** 
1266:main.c        ****     // Use a LOCAL buffer to avoid corruption by czy_numer_istnieje
1267:main.c        ****     uchar bufor_super[LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM];
1268:main.c        **** 
1269:main.c        ****     // Convert number to EEPROM format FIRST, before duplicate check
1270:main.c        ****     konwertuj_telefon_na_blok_eeprom(
1271:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
1272:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[strlen(
1273:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
1274:main.c        ****         bufor_super);
1275:main.c        **** 
1276:main.c        ****     // Check for duplicates using the helper function
1277:main.c        ****     // (This will use bufor_eeprom internally, but we have our number safe in
1278:main.c        ****     // bufor_super)
1279:main.c        ****     if (czy_numer_istnieje(numer_telefonu_do_ktorego_dzwonic)) {
1280:main.c        ****       // Numer juz istnieje - wyslij komunikat
1281:main.c        ****       strcpy((char *)numer_telefonu_wysylanego_smsa,
1282:main.c        ****              (char *)numer_telefonu_odebranego_smsa);
1283:main.c        ****       strcpy_P((char *)tekst_wysylanego_smsa,
1284:main.c        ****                PSTR("Numer juz istnieje w systemie"));
1285:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
1286:main.c        ****       return TRUE;
1287:main.c        ****     }
1288:main.c        **** 
1289:main.c        ****     // Copy our safe buffer to bufor_eeprom for writing
1290:main.c        ****     memcpy(bufor_eeprom, bufor_super, LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1291:main.c        **** 
1292:main.c        ****     // Szukaj pierwszej wolnej pozycji w zakresie 794-799 (user-facing 795-800)
1293:main.c        ****     uchar dodano = FALSE;
1294:main.c        ****     uint pozycja_dodana = 0;
1295:main.c        ****     for (uint nr_uzyt = 794; nr_uzyt < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
1296:main.c        ****          ++nr_uzyt) {
1297:main.c        ****       if (not czy_aktywny_numer_telefonu_brama(nr_uzyt)) {
1298:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
1299:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt),
1300:main.c        ****             LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1301:main.c        ****         dodano = TRUE;
1302:main.c        ****         pozycja_dodana = nr_uzyt + 1; // User-facing (1-indexed)
1303:main.c        ****         break;
1304:main.c        ****       }
1305:main.c        ****     }
1306:main.c        **** 
1307:main.c        ****     // Wyslij odpowiedz
1308:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
1309:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
1310:main.c        ****     if (dodano) {
1311:main.c        ****       sprintf((char *)tekst_wysylanego_smsa, "Super User dodany na pozycji %u",
1312:main.c        ****               pozycja_dodana);
1313:main.c        ****     } else {
1314:main.c        ****       strcpy_P((char *)tekst_wysylanego_smsa,
1315:main.c        ****                PSTR("Brak wolnych pozycji Super User (795-800)"));
1316:main.c        ****     }
1317:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
1318:main.c        **** 
1319:main.c        ****     return TRUE;
1320:main.c        ****   }
1321:main.c        ****   case KOMENDA_KOLEJKI_USUN_UZYTKOWNIKA_BRAMA: {
1322:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1323:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
1324:main.c        ****                                      &numer_telefonu_do_ktorego_dzwonic[strlen(
1325:main.c        ****                                          numer_telefonu_do_ktorego_dzwonic)],
1326:main.c        ****                                      &bufor_eeprom[0]);
1327:main.c        ****     // for (uchar nr_uzyt_clip = 0; nr_uzyt_clip <
1328:main.c        ****     // MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip)
1329:main.c        ****     for (uint nr_uzyt_clip = 0;
1330:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
1331:main.c        ****       if (porownaj_numer_telefonu_blok(
1332:main.c        ****               &bufor_eeprom[0], // 1 porwnanie zajmuje ~10us, czyli 170 numerw ~
1333:main.c        ****                                 // 2ms
1334:main.c        ****               (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
1335:main.c        ****         numer_telefonu_do_ktorego_dzwonic[0] = '\0';
1336:main.c        ****         konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
1337:main.c        ****                                          &numer_telefonu_do_ktorego_dzwonic[1],
1338:main.c        ****                                          &bufor_eeprom[0]);
1339:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
1340:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
1341:main.c        ****             LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1342:main.c        ****         break;
1343:main.c        ****       }
1344:main.c        ****     }
1345:main.c        ****     break;
1346:main.c        ****   }
1347:main.c        ****   default:
1348:main.c        ****     return FALSE;
1349:main.c        ****   }
1350:main.c        ****   return TRUE;
1351:main.c        **** }
1352:main.c        **** 
1353:main.c        **** uchar wykonanie_komend_powiadomien(void) {
1354:main.c        ****   const komenda_typ aktualnie_wykonywana_komenda = komendy_kolejka[0];
1355:main.c        **** 
1356:main.c        ****   const uchar czy_gsm_zajety =
1357:main.c        ****       flaga_odczytywanie_smsa || flaga_wysylanie_smsa ||
1358:main.c        ****       wykonywanie_rozmowy_telefonicznej ||
1359:main.c        ****       trwa_rozmowa_przychodzaca_od_uzytkownika ||
1360:main.c        ****       aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
1361:main.c        ****       opoznienie_SIM900_100MS || czekanie_na_odebranie_zachety;
1362:main.c        **** 
1363:main.c        ****   const uchar czy_mozna_wysylac_dane_do_SIM900 =
1364:main.c        ****       !czy_gsm_zajety && CZY_MOZNA_WYSYLAC_DANE_SIM900() &&
1365:main.c        ****       czy_jest_bezczynny_SIM900();
1366:main.c        **** 
1367:main.c        ****   switch (aktualnie_wykonywana_komenda) {
1368:main.c        ****   case KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW: {
1369:main.c        ****     if (not czy_mozna_wysylac_dane_do_SIM900 ||
1370:main.c        ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1371:main.c        ****       dodaj_komende(aktualnie_wykonywana_komenda);
1372:main.c        ****       break;
1373:main.c        ****     }
1374:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1375:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
1376:main.c        ****     *sms++ = '*';
1377:main.c        ****     for (;;) {
1378:main.c        ****       if (czy_aktywny_numer_telefonu_brama(
1379:main.c        ****               numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama)) {
1380:main.c        ****         sms += kopiuj_blok_eeprom_na_telefon(
1381:main.c        ****             (void *)EEPROM_NUMER_TELEFONU_BRAMA(
1382:main.c        ****                 numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama),
1383:main.c        ****             sms, MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER);
1384:main.c        ****         *sms++ = '#';
1385:main.c        ****         *sms++ = '\n';
1386:main.c        ****         ++numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama;
1387:main.c        ****         if ((sms + MAX_LICZBA_ZNAKOW_TELEFON + 1 >=
1388:main.c        ****              &tekst_wysylanego_smsa[MAX_LICZBA_ZNAKOW_SMS]) ||
1389:main.c        ****             (numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama >=
1390:main.c        ****              MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER)) {
1391:main.c        ****           if ((numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama <
1392:main.c        ****                MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER))
1393:main.c        ****             dodaj_komende(aktualnie_wykonywana_komenda);
1394:main.c        ****           *sms = '\0';
1395:main.c        ****           dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
1396:main.c        ****           wysylanie_smsa_clipa = WYSYLANIE_SMSA_WYSYLANIE;
1397:main.c        ****           break;
1398:main.c        ****         }
1399:main.c        ****       } else {
1400:main.c        ****         if (++numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama >=
1401:main.c        ****             MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER) {
1402:main.c        ****           if (sms != &tekst_wysylanego_smsa[0]) {
1403:main.c        ****             *sms = '\0';
1404:main.c        ****             dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
1405:main.c        ****             wysylanie_smsa_clipa = WYSYLANIE_SMSA_WYSYLANIE;
1406:main.c        ****           }
1407:main.c        ****           break;
1408:main.c        ****         }
1409:main.c        ****       }
1410:main.c        ****     }
1411:main.c        ****     break;
1412:main.c        ****   }
1413:main.c        ****   default:
1414:main.c        ****     return FALSE;
1415:main.c        ****   }
1416:main.c        ****   return TRUE;
1417:main.c        **** }
1418:main.c        **** 
1419:main.c        **** void wykonanie_komend(void) {
1420:main.c        ****   if (wykonanie_komend_SIM900())
1421:main.c        ****     ;
1422:main.c        ****   else if (wykonanie_komend_ukladow())
1423:main.c        ****     ;
1424:main.c        ****   else if (wykonanie_komend_powiadomien())
1425:main.c        ****     ;
1426:main.c        ****   else
1427:main.c        ****     ;
1428:main.c        ****   usun_komende();
1429:main.c        **** }
1430:main.c        **** 
1431:main.c        **** void test_sms_clip_100ms(void) {
1432:main.c        ****   // static ulong licznik_sms;
1433:main.c        ****   // if ( ++licznik_sms > 60 * 10 )
1434:main.c        ****   //{
1435:main.c        ****   //	licznik_sms = 0;
1436:main.c        **** 
1437:main.c        ****   // tekst_wysylanego_smsa[0] = 'A';
1438:main.c        ****   // tekst_wysylanego_smsa[1] = 'B';
1439:main.c        ****   // tekst_wysylanego_smsa[2] = 'C';
1440:main.c        ****   // tekst_wysylanego_smsa[3] = 'D';
1441:main.c        ****   // tekst_wysylanego_smsa[4] = 0;
1442:main.c        ****   // static const char tel[] PROGMEM = "731314727";
1443:main.c        ****   ////static const char tel[] PROGMEM = "505691117";
1444:main.c        ****   // memcpy_R(numer_telefonu_wysylanego_smsa, tel);
1445:main.c        ****   // dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
1446:main.c        **** 
1447:main.c        ****   // memcpy_R(numer_telefonu_do_ktorego_dzwonic, tel);
1448:main.c        ****   // dodaj_komende(KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE);
1449:main.c        ****   //}
1450:main.c        **** }
1451:main.c        **** 
1452:main.c        **** void steruj_wejscia_wyjscia_100ms(void) {
1453:main.c        ****   aktualizuj_stan_wyzwolenia_wejsc_100ms();
1454:main.c        ****   steruj_wejsciem_reset_100ms();
1455:main.c        ****   steruj_wyjscia_100ms();
1456:main.c        **** }
1457:main.c        **** 
1458:main.c        **** void zapis_w_eeprom_stanu_wyjsc(void) {
1459:main.c        ****   if (not czy_wolny_eeprom())
1460:main.c        ****     return;
1461:main.c        ****   uchar par = 0;
1462:main.c        ****   if ((stan_wyjscie[0] != 0) ^ (licznik_przelacznik_wyjscia[0] != 0))
1463:main.c        ****     par |= BIT(0);
1464:main.c        ****   if (par != eeprom_read_byte((void *)EEPROM_USTAWIENIE_STANOW_WYJSC))
1465:main.c        ****     zapisz_znaki_w_eeprom(&par, (uint)EEPROM_USTAWIENIE_STANOW_WYJSC, 1);
1466:main.c        **** }
1467:main.c        **** 
1468:main.c        **** // void test_clip_na_101(void)
1469:main.c        **** //{
1470:main.c        **** //	if ( not modul_zalogowany_w_sieci )
1471:main.c        **** //		return;
1472:main.c        **** //	static uint licznik_101;
1473:main.c        **** //	if ( ++licznik_101 < 2 * 60 * 10 )
1474:main.c        **** //		return;
1475:main.c        **** //	licznik_101 = 0;
1476:main.c        **** //	static const char doladowanie[] PROGMEM = "*101#";
1477:main.c        **** //	strcpy_P(numer_telefonu_do_ktorego_dzwonic, doladowanie);
1478:main.c        **** //	dodaj_komende(KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE);
1479:main.c        **** // }
1480:main.c        **** 
1481:main.c        **** void steruj_urzadzeniem_100MS(void) {
1482:main.c        ****   steruj_wejscia_wyjscia_100ms();
1483:main.c        ****   steruj_SIM900_100MS();
1484:main.c        ****   if (licznik_100ms_dioda_led) {
1485:main.c        ****     if (--licznik_100ms_dioda_led == 0)
1486:main.c        ****       ustaw_stan_led(FALSE);
1487:main.c        ****     else
1488:main.c        ****       ustaw_stan_led(TRUE);
1489:main.c        ****   }
1490:main.c        **** 
1491:main.c        ****   // Aktualizacja timera blokady komend REPORT/USER
1492:main.c        ****   if (timer_report_user_100ms > 0) {
1493:main.c        ****     --timer_report_user_100ms;
1494:main.c        ****     if (timer_report_user_100ms == 0) {
1495:main.c        ****       // Okno czasowe minelo - resetuj licznik
1496:main.c        ****       licznik_report_user = 0;
1497:main.c        ****     }
1498:main.c        ****   } else {
1499:main.c        ****     // Timer jest 0 - upewnij sie ze licznik tez jest 0 (ochrona przed
1500:main.c        ****     // bledami)
1501:main.c        ****     licznik_report_user = 0;
1502:main.c        ****   }
1503:main.c        **** 
1504:main.c        ****   // Mechanizm wykrywania zablokowanej kolejki i czyszczenia starych komend
1505:main.c        ****   // SMS
1506:main.c        ****   const komenda_typ pierwsza_komenda = komendy_kolejka[0];
1507:main.c        ****   if (pierwsza_komenda != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
1508:main.c        ****     // Sprawdz czy pierwsza komenda to SMS - jesli tak i stoi zbyt dlugo,
1509:main.c        ****     // wyczysc
1510:main.c        ****     if (pierwsza_komenda >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
1511:main.c        ****         pierwsza_komenda <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU) {
1512:main.c        ****       // To jest komenda SMS - sprawdz czy stoi zbyt dlugo
1513:main.c        ****       if (pierwsza_komenda == ostatnia_pierwsza_komenda) {
1514:main.c        ****         // Ta sama komenda SMS jest na poczatku kolejki - kolejka moze stac
1515:main.c        ****         if (licznik_kolejka_stoi_100ms < MAX_CZAS_KOLEJKA_STOI_100MS)
1516:main.c        ****           ++licznik_kolejka_stoi_100ms;
1517:main.c        ****         else {
1518:main.c        ****           // Komenda SMS stoi juz 30 sekund - wyczysc wszystkie komendy SMS i
1519:main.c        ****           // wznow dzialanie
1520:main.c        ****           filtruj_komendy_z_przedzialu(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT,
1521:main.c        ****                                        KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
1522:main.c        ****           if (licznik_awaryjnych_resetow_kolejki < 0xFFFF)
1523:main.c        ****             ++licznik_awaryjnych_resetow_kolejki;
1524:main.c        **** 
1525:main.c        ****           filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
1526:main.c        **** 
1527:main.c        ****           // Resetuj blokade komend REPORT/USER aby wznowic dzialanie
1528:main.c        ****           licznik_report_user = 0;
1529:main.c        ****           timer_report_user_100ms = 0;
1530:main.c        **** 
1531:main.c        ****           // Resetuj liczniki kolejki
1532:main.c        ****           licznik_kolejka_stoi_100ms = 0;
1533:main.c        ****           ostatnia_pierwsza_komenda = KOMENDA_KOLEJKI_BRAK_KOMENDY;
1534:main.c        **** 
1535:main.c        ****           // Resetuj flage wysylania SMS (na wypadek zablokowania)
1536:main.c        ****           flaga_wysylanie_smsa = 0;
1537:main.c        ****         }
1538:main.c        ****       } else {
1539:main.c        ****         // Pierwsza komenda SMS sie zmienila - kolejka dziala
1540:main.c        ****         ostatnia_pierwsza_komenda = pierwsza_komenda;
1541:main.c        ****         licznik_kolejka_stoi_100ms = 0;
1542:main.c        ****       }
1543:main.c        ****     } else {
1544:main.c        ****       // To nie jest komenda SMS - resetuj licznik (nie interesuje nas)
1545:main.c        ****       ostatnia_pierwsza_komenda = pierwsza_komenda;
1546:main.c        ****       licznik_kolejka_stoi_100ms = 0;
1547:main.c        ****     }
1548:main.c        ****   } else {
1549:main.c        ****     // Kolejka jest pusta
1550:main.c        ****     ostatnia_pierwsza_komenda = KOMENDA_KOLEJKI_BRAK_KOMENDY;
1551:main.c        ****     licznik_kolejka_stoi_100ms = 0;
1552:main.c        ****   }
1553:main.c        **** 
1554:main.c        ****   // Watchdog pilnujacy zakleszczonego wysylania SMS
1555:main.c        ****   if (flaga_wysylanie_smsa) {
1556:main.c        ****     if (licznik_watchdog_wysylanie_smsa_100ms < WATCHDOG_WYSYLANIA_SMS_100MS) {
1557:main.c        ****       ++licznik_watchdog_wysylanie_smsa_100ms;
1558:main.c        ****     } else {
1559:main.c        ****       licznik_watchdog_wysylanie_smsa_100ms = 0;
1560:main.c        ****       // Awaryjne odblokowanie
1561:main.c        ****       watchdog_sms_disarm();
1562:main.c        ****       flaga_wysylanie_smsa = 0;
1563:main.c        ****       liczba_prob_wyslania_smsa = 0;
1564:main.c        ****       czekanie_na_odebranie_zachety = FALSE;
1565:main.c        ****       wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
1566:main.c        **** 
1567:main.c        ****       if (liczba_kolejnych_watchdogow_wysylania < 255)
1568:main.c        ****         ++liczba_kolejnych_watchdogow_wysylania;
1569:main.c        ****       if (liczba_kolejnych_watchdogow_wysylania >= 3) {
1570:main.c        ****         liczba_kolejnych_watchdogow_wysylania = 0;
1571:main.c        ****         reset_modulu_SIM900();
1572:main.c        ****       }
1573:main.c        ****     }
1574:main.c        ****   } else {
1575:main.c        ****     licznik_watchdog_wysylanie_smsa_100ms = 0;
1576:main.c        ****     liczba_kolejnych_watchdogow_wysylania = 0;
1577:main.c        ****   }
1578:main.c        **** 
1579:main.c        ****   if (watchdog_sms_aktywny) {
1580:main.c        ****     if (watchdog_sms_licznik_100ms < WATCHDOG_SMS_TIMEOUT_100MS)
1581:main.c        ****       ++watchdog_sms_licznik_100ms;
1582:main.c        ****     else {
1583:main.c        ****       watchdog_sms_trwa_reset = TRUE;
1584:main.c        ****       cli();
1585:main.c        ****       wdt_enable(WDTO_15MS);
1586:main.c        ****       while (1)
1587:main.c        ****         ;
1588:main.c        ****     }
1589:main.c        ****   } else if (watchdog_sms_safe_mode_100ms) {
1590:main.c        ****     --watchdog_sms_safe_mode_100ms;
1591:main.c        ****   }
1592:main.c        **** 
1593:main.c        ****   // Obsluga szybkich blyskow LED
1594:main.c        ****   if (liczba_blyskow_led > 0) {
1595:main.c        ****     ++stan_cyklu_blysku;
1596:main.c        ****     if (stan_cyklu_blysku >= 6) {
1597:main.c        ****       stan_cyklu_blysku = 0;
1598:main.c        ****       --liczba_blyskow_led;
1599:main.c        ****     }
1600:main.c        ****     ustaw_stan_led(stan_cyklu_blysku < 2);
1601:main.c        ****     return;
1602:main.c        ****   }
1603:main.c        **** 
1604:main.c        ****   // LED: ON gdy nie zalogowany, OFF gdy zalogowany (z mruganiem przy dobrym
1605:main.c        ****   // sygnale)
1606:main.c        ****   if (!modul_zalogowany_w_sieci) {
1607:main.c        ****     // Nie zalogowany - dioda swiecei ciagle
1608:main.c        ****     ustaw_stan_led(TRUE);
1609:main.c        ****   } else {
1610:main.c        ****     // Zalogowany - dioda zgaszona lub mruga w zaleznosci od sygnalu
1611:main.c        ****     if (licznik_100ms_dioda_led) {
1612:main.c        ****       // Mrugniecie (SMS, etc.)
1613:main.c        ****       ustaw_stan_led(TRUE);
1614:main.c        ****     } else {
1615:main.c        ****       // Normalne dzialanie - mrugaj w zaleznosci od poziomu sygnalu
1616:main.c        ****       static uchar licznik_dioda_led_poziom_sieci;
1617:main.c        ****       if (poziom_sieci_gsm < 16) {
1618:main.c        ****         if (++licznik_dioda_led_poziom_sieci >= 50)
1619:main.c        ****           licznik_dioda_led_poziom_sieci = 1;
1620:main.c        ****       } else
1621:main.c        ****         licznik_dioda_led_poziom_sieci = 0;
1622:main.c        **** 
1623:main.c        ****       ustaw_stan_led(licznik_dioda_led_poziom_sieci == 40 ||
1624:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
1625:main.c        ****                      (licznik_dioda_led_poziom_sieci >= 46 &&
1626:main.c        ****                       licznik_dioda_led_poziom_sieci <= 49));
1627:main.c        ****     }
1628:main.c        ****   }
1629:main.c        ****   zapis_w_eeprom_stanu_wyjsc();
1630:main.c        **** }
1631:main.c        **** 
1632:main.c        **** void steruj_urzadzeniem_10MS(void) {
1633:main.c        ****   steruj_wejscia_10ms();
1634:main.c        ****   steruj_SIM900_10MS();
1635:main.c        ****   zapisz_bajt_w_EEPROM();
1636:main.c        ****   // test_dioda_wyjscia();
1637:main.c        ****   // test_wejscie();
1638:main.c        **** }
1639:main.c        **** 
1640:main.c        **** void wolne_zdarzenie_timer(void) {
1641:main.c        ****   WYKONAJ_CLI_SEI(WYLACZ_PRZERWANIE_TIMER());
1642:main.c        ****   if (!CZY_WYKONAC_ZDARZENIE_TIMER()) {
1643:main.c        ****     WYKONAJ_CLI_SEI(WLACZ_PRZERWANIE_TIMER());
1644:main.c        ****     return;
1645:main.c        ****   }
1646:main.c        ****   wykonaj_zdarzenie_timer = FALSE;
1647:main.c        ****   if (wykonac_watki_10MS) {
1648:main.c        ****     wykonac_watki = WYKONAJ_WATKI_10MS;
1649:main.c        ****     wykonac_watki_10MS = FALSE;
1650:main.c        ****   }
1651:main.c        ****   WYKONAJ_CLI_SEI(WLACZ_PRZERWANIE_TIMER());
1652:main.c        ****   if (CZY_WYKONAC_WATKI_10MS()) {
1653:main.c        ****     static uchar licznik_wybuc_watki_100MS = 0;
1654:main.c        **** #define OPOZNIENIE_100_MS 10
1655:main.c        ****     if (++licznik_wybuc_watki_100MS == OPOZNIENIE_100_MS) {
1656:main.c        ****       licznik_wybuc_watki_100MS = 0;
1657:main.c        ****       wykonac_watki = WYKONAJ_WATKI_100MS | WYKONAJ_WATKI_10MS;
1658:main.c        ****     }
1659:main.c        ****     NOP();
1660:main.c        ****     cli();
1661:main.c        ****     if (CZY_ODBIERANIE_DANYCH_SIM900()) {
1662:main.c        ****       WYLACZ_PRZERWANIE_ODBIORU_DANYCH_SIM900();
1663:main.c        ****       sei();
1664:main.c        ****       if (liczba_odebranych_znakow_SIM900 != 0 &&
1665:main.c        ****           ++licznik_opoznienie_oczekiwania_na_bajt_SIM900 >
1666:main.c        ****               MAX_OPOZNIENIE_OCZEKIWANIA_NA_BAJT_SIM900_500_MS) {
1667:main.c        ****         resetuj_odbior_SIM900_po_bledzie();
1668:main.c        ****       } else {
1669:main.c        ****         WYKONAJ_CLI_SEI(WLACZ_PRZERWANIE_ODBIORU_DANYCH_SIM900());
1670:main.c        ****       }
1671:main.c        ****     }
1672:main.c        ****     sei();
1673:main.c        ****   }
1674:main.c        **** }
1675:main.c        **** 
1676:main.c        **** void ustaw_parametry_dla_bezpieczenstwa(void) {
1677:main.c        ****   wdt_reset();
1678:main.c        ****   ustaw_parametry_dla_bezpieczenstwa_rejestry();
1679:main.c        ****   set_sleep_mode(SLEEP_MODE_IDLE);
1680:main.c        **** }
1681:main.c        **** 
1682:main.c        **** void inicjalizuj_parametry_modulu(void) {
1683:main.c        ****   memcpy_E(kod_modulu, ADRES_EEPROM_KOD_DOSTEPU, LICZBA_BAJTOW_KODU_DOSTEPU);
1684:main.c        **** 
1685:main.c        ****   // Auto-naprawa: Jeśli kod jest pusty (FF) lub zerowy, ustaw ABCD
1686:main.c        ****   if (kod_modulu[0] == 0xFF || kod_modulu[0] == 0x00) {
1687:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
1688:main.c        ****     kod_modulu[1] = bufor_eeprom[1] = 'B';
1689:main.c        ****     kod_modulu[2] = bufor_eeprom[2] = 'C';
1690:main.c        ****     kod_modulu[3] = bufor_eeprom[3] = 'D';
1691:main.c        ****     // Zapisz do EEPROM natychmiast (BLOCKING)
1692:main.c        ****     while (!eeprom_is_ready())
1693:main.c        ****       ;
1694:main.c        ****     eeprom_update_block(kod_modulu, (void *)ADRES_EEPROM_KOD_DOSTEPU,
1695:main.c        ****                         LICZBA_BAJTOW_KODU_DOSTEPU);
1696:main.c        ****   }
1697:main.c        **** 
1698:main.c        ****   // Auto-naprawa: Jeśli tryb pracy jest nieokreślony (0xFF), ustaw Publiczny
1699:main.c        ****   // (1)
1700:main.c        ****   tryb_pracy = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_TRYB_PRACY);
1701:main.c        ****   if (tryb_pracy == 0xFF) {
1702:main.c        ****     tryb_pracy = 1; // Domyślnie Publiczny
1703:main.c        ****     while (!eeprom_is_ready())
1704:main.c        ****       ;
1705:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_TRYB_PRACY, 1);
1706:main.c        ****   }
1707:main.c        **** 
1708:main.c        ****   // --- Inicjalizacja trybu CLIP/DTMF ---
1709:main.c        ****   tryb_clip = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_TRYB_CLIP_DTMF);
1710:main.c        ****   if (tryb_clip == 0xFF) {
1711:main.c        ****     tryb_clip = 1; // Domyślnie CLIP (1)
1712:main.c        ****     while (!eeprom_is_ready())
1713:main.c        ****       ;
1714:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_TRYB_CLIP_DTMF, 1);
1715:main.c        ****   }
1716:main.c        **** 
1717:main.c        ****   // Inicjalizacja parametrow czasowych
1718:main.c        ****   czas_start_h = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_START_H);
1719:main.c        ****   czas_start_m = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_START_M);
1720:main.c        ****   czas_stop_h = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_STOP_H);
1721:main.c        ****   czas_stop_m = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_STOP_M);
1722:main.c        **** 
1723:main.c        ****   // Inicjalizacja SKRYBA
1724:main.c        ****   skryba_wlaczona = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA);
1725:main.c        ****   if (skryba_wlaczona == 0xFF)
1726:main.c        ****     skryba_wlaczona = FALSE;
1727:main.c        **** 
1728:main.c        ****   // Odczyt limitu Skryby z EEPROM
1729:main.c        ****   uchar limit_l =
1730:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA_LIMIT_L);
1731:main.c        ****   uchar limit_h =
1732:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA_LIMIT_H);
1733:main.c        ****   if (limit_l == 0xFF && limit_h == 0xFF) {
1734:main.c        ****     // Nie ustawiono - domyslnie 800
1735:main.c        ****     skryba_limit = 800;
1736:main.c        ****   } else {
1737:main.c        ****     skryba_limit = limit_l | (limit_h << 8);
1738:main.c        ****     // Walidacja zakresu
1739:main.c        ****     if (skryba_limit < 1 || skryba_limit > MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA) {
1740:main.c        ****       skryba_limit = 800;
1741:main.c        ****     }
1742:main.c        ****   }
1743:main.c        ****   // Debug initialization
1744:main.c        ****   zapisz_debug_do_eeprom(skryba_wlaczona ? 1 : 0, (uchar)(skryba_limit & 0xFF));
1745:main.c        **** 
1746:main.c        ****   // Auto-naprawa Harmonogramu: Jeśli wartości są nieprawidłowe (ale nie
1747:main.c        ****   // 0xFF), ustaw na OFF
1748:main.c        ****   if ((czas_start_h > 23 && czas_start_h != 0xFF) ||
1749:main.c        ****       (czas_start_m > 59 && czas_start_m != 0xFF) ||
1750:main.c        ****       (czas_stop_h > 23 && czas_stop_h != 0xFF) ||
1751:main.c        ****       (czas_stop_m > 59 && czas_stop_m != 0xFF)) {
1752:main.c        ****     // Zapisz wartosci wylaczajace (0xFF) - BLOCKING
1753:main.c        ****     while (!eeprom_is_ready())
1754:main.c        ****       ;
1755:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_CZAS_START_H, 0xFF);
1756:main.c        ****     while (!eeprom_is_ready())
1757:main.c        ****       ;
1758:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_CZAS_START_M, 0xFF);
1759:main.c        ****     while (!eeprom_is_ready())
1760:main.c        ****       ;
1761:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_CZAS_STOP_H, 0xFF);
1762:main.c        ****     while (!eeprom_is_ready())
1763:main.c        ****       ;
1764:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_CZAS_STOP_M, 0xFF);
1765:main.c        **** 
1766:main.c        ****     czas_start_h = 0xFF;
1767:main.c        ****     czas_start_m = 0xFF;
1768:main.c        ****     czas_stop_h = 0xFF;
1769:main.c        ****     czas_stop_m = 0xFF;
1770:main.c        ****   }
1771:main.c        **** 
1772:main.c        ****   blokada_sterowania_czasowa =
1773:main.c        ****       FALSE; // Domyślnie odblokowane, zaktualizuje sie przy odczycie czasu
1774:main.c        **** 
1775:main.c        ****   // Inicjalizacja blokady systemu (START/STOP)
1776:main.c        ****   blokada_systemu =
1777:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_BLOKADA_SYSTEMU);
1778:main.c        ****   if (blokada_systemu == 0xFF) {
1779:main.c        ****     blokada_systemu = FALSE; // Domyślnie odblokowany
1780:main.c        ****   }
1781:main.c        **** 
1782:main.c        ****   // Inicjalizacja zmiennych debug SKRYBA (jesli 0xFF to wyczysc)
1783:main.c        ****   for (uint16_t addr = ADRES_EEPROM_DEBUG_SKRYBA_1;
1784:main.c        ****        addr <= ADRES_EEPROM_DEBUG_SKRYBA_5; ++addr) {
1785:main.c        ****     if (eeprom_read_byte((const uint8_t *)addr) == 0xFF) {
1786:main.c        ****       while (!eeprom_is_ready())
1787:main.c        ****         ;
1788:main.c        ****       eeprom_update_byte((uint8_t *)addr, 0);
1789:main.c        ****     }
1790:main.c        ****   }
1791:main.c        **** 
1792:main.c        ****   // Inicjalizacja zmiennych debug USER (jesli 0xFF to wyczysc)
1793:main.c        ****   for (uint16_t addr = ADRES_EEPROM_DEBUG_USER_1;
1794:main.c        ****        addr <= ADRES_EEPROM_DEBUG_USER_7; ++addr) {
1795:main.c        ****     if (eeprom_read_byte((const uint8_t *)addr) == 0xFF) {
1796:main.c        ****       while (!eeprom_is_ready())
1797:main.c        ****         ;
1798:main.c        ****       eeprom_update_byte((uint8_t *)addr, 0);
1799:main.c        ****     }
1800:main.c        ****   }
1801:main.c        **** 
1802:main.c        ****   // --- NOWE Z V7 (Ported) ---
1803:main.c        ****   // Reset blokady komend REPORT/USER po inicjalizacji/resecie
1804:main.c        ****   licznik_report_user = 0;
1805:main.c        ****   timer_report_user_100ms = 0;
1806:main.c        **** 
1807:main.c        ****   // Reset flagi wysylania SMS po resecie
1808:main.c        ****   flaga_wysylanie_smsa = 0;
1809:main.c        **** 
1810:main.c        ****   // Zwieksz licznik resetow i zapisz debug
1811:main.c        ****   static uchar licznik_resetow = 0;
1812:main.c        ****   if (licznik_resetow < 255)
1813:main.c        ****     ++licznik_resetow;
1814:main.c        ****   while (!eeprom_is_ready())
1815:main.c        ****     ;
1816:main.c        ****   eeprom_update_byte((void *)EEPROM_DEBUG_LICZNIK_RESETOW, licznik_resetow);
1817:main.c        ****   while (!eeprom_is_ready())
1818:main.c        ****     ;
1819:main.c        ****   zapisz_debug_do_eeprom(0, 2); // Reset (komenda=0 oznacza reset)
1820:main.c        **** }
1821:main.c        **** 
1822:main.c        **** static void opoznienie_startowe(void) {
 189               		.loc 1 1822 0
 190               		.cfi_startproc
 191               	/* prologue: function */
 192               	/* frame size = 0 */
 193               	/* stack size = 0 */
 194               	.L__stack_usage = 0
 195               	.LVL10:
 196               	.LBB364:
 197               	.LBB365:
 198               	.LBB366:
 199               		.file 3 "/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h"
   1:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
   6:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
   9:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  12:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      distribution.
  16:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  17:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  21:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  33:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  35:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  38:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #  endif
  42:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  44:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  48:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /** \file */
  49:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \code
  51:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \endcode
  55:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  56:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     used.
  60:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  61:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  70:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  79:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  83:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** */
  84:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  85:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif
  89:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  90:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  97:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 103:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     integer value.
 107:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****  */
 108:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif
 110:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 111:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif
 114:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 115:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif
 120:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 121:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /**
 122:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 124:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 126:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 129:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 131:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 137:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 142:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 147:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    respectively.
 151:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 152:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    \note
 153:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 154:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 164:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****  */
 165:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** void
 166:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** {
 168:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 176:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 179:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 182:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	#else
 183:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	#endif
 186:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 187:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 200               		.loc 3 187 0
 201 0098 8FEF      		ldi r24,lo8(-28673)
 202 009a 9FE8      		ldi r25,hi8(-28673)
 203 009c 0197      	1:	sbiw r24,1
 204 009e 01F4      		brne 1b
 205 00a0 00C0      		rjmp .
 206 00a2 0000      		nop
 207               	.LVL11:
 208 00a4 8FEF      		ldi r24,lo8(-28673)
 209 00a6 9FE8      		ldi r25,hi8(-28673)
 210 00a8 0197      	1:	sbiw r24,1
 211 00aa 01F4      		brne 1b
 212 00ac 00C0      		rjmp .
 213 00ae 0000      		nop
 214               	.LVL12:
 215 00b0 8FEF      		ldi r24,lo8(-28673)
 216 00b2 9FE8      		ldi r25,hi8(-28673)
 217 00b4 0197      	1:	sbiw r24,1
 218 00b6 01F4      		brne 1b
 219 00b8 00C0      		rjmp .
 220 00ba 0000      		nop
 221               	.LVL13:
 222 00bc 8FEF      		ldi r24,lo8(-28673)
 223 00be 9FE8      		ldi r25,hi8(-28673)
 224 00c0 0197      	1:	sbiw r24,1
 225 00c2 01F4      		brne 1b
 226 00c4 00C0      		rjmp .
 227 00c6 0000      		nop
 228               	.LVL14:
 229 00c8 8FEF      		ldi r24,lo8(-28673)
 230 00ca 9FE8      		ldi r25,hi8(-28673)
 231 00cc 0197      	1:	sbiw r24,1
 232 00ce 01F4      		brne 1b
 233 00d0 00C0      		rjmp .
 234 00d2 0000      		nop
 235               	.LVL15:
 236               	.LBE366:
 237               	.LBE365:
 238               	.LBE364:
1823:main.c        ****   for (uchar i = 0; i < 5; ++i)
1824:main.c        ****     _delay_ms(20);
1825:main.c        ****   wdt_reset();
 239               		.loc 1 1825 0
 240               	/* #APP */
 241               	 ;  1825 "main.c" 1
 242 00d4 A895      		wdr
 243               	 ;  0 "" 2
 244               	/* epilogue start */
1826:main.c        **** }
 245               		.loc 1 1826 0
 246               	/* #NOAPP */
 247 00d6 0895      		ret
 248               		.cfi_endproc
 249               	.LFE70:
 252               	zapisz_debug_do_eeprom:
 253               	.LFB38:
 355:main.c        ****   if (!czy_wolny_eeprom())
 254               		.loc 1 355 0
 255               		.cfi_startproc
 256               	.LVL16:
 257 00d8 CF93      		push r28
 258               	.LCFI2:
 259               		.cfi_def_cfa_offset 3
 260               		.cfi_offset 28, -2
 261 00da DF93      		push r29
 262               	.LCFI3:
 263               		.cfi_def_cfa_offset 4
 264               		.cfi_offset 29, -3
 265 00dc CDB7      		in r28,__SP_L__
 266 00de DEB7      		in r29,__SP_H__
 267               	.LCFI4:
 268               		.cfi_def_cfa_register 28
 269 00e0 2897      		sbiw r28,8
 270               	.LCFI5:
 271               		.cfi_def_cfa_offset 12
 272 00e2 0FB6      		in __tmp_reg__,__SREG__
 273 00e4 F894      		cli
 274 00e6 DEBF      		out __SP_H__,r29
 275 00e8 0FBE      		out __SREG__,__tmp_reg__
 276 00ea CDBF      		out __SP_L__,r28
 277               	/* prologue: function */
 278               	/* frame size = 8 */
 279               	/* stack size = 10 */
 280               	.L__stack_usage = 10
 356:main.c        ****     return;
 281               		.loc 1 356 0
 282 00ec 9091 0000 		lds r25,bufor_pomoc_liczba_znakow_do_zapisu
 283 00f0 9111      		cpse r25,__zero_reg__
 284 00f2 00C0      		rjmp .L17
 356:main.c        ****     return;
 285               		.loc 1 356 0 is_stmt 0 discriminator 1
 286 00f4 9091 0000 		lds r25,liczba_znakow_do_zapisu
 287 00f8 9111      		cpse r25,__zero_reg__
 288 00fa 00C0      		rjmp .L17
 356:main.c        ****     return;
 289               		.loc 1 356 0 discriminator 2
 290 00fc 9091 0000 		lds r25,czy_zajety_bufor_eeprom
 291 0100 9111      		cpse r25,__zero_reg__
 292 0102 00C0      		rjmp .L17
 356:main.c        ****     return;
 293               		.loc 1 356 0 discriminator 3
 294 0104 F999      		sbic 0x1f,1
 295 0106 00C0      		rjmp .L17
 296               	.LVL17:
 297               	.LBB370:
 298               	.LBB371:
 360:main.c        ****   buf[1] = (uchar)(timer_report_user_100ms & 0xFF);
 299               		.loc 1 360 0 is_stmt 1
 300 0108 2091 0000 		lds r18,licznik_report_user
 301 010c 2983      		std Y+1,r18
 361:main.c        ****   buf[2] = (uchar)((timer_report_user_100ms >> 8) & 0xFF);
 302               		.loc 1 361 0
 303 010e 3091 0000 		lds r19,timer_report_user_100ms
 304 0112 2091 0000 		lds r18,timer_report_user_100ms+1
 305 0116 3A83      		std Y+2,r19
 362:main.c        ****   buf[3] = (uchar)flaga_wysylanie_smsa;
 306               		.loc 1 362 0
 307 0118 2B83      		std Y+3,r18
 363:main.c        **** 
 308               		.loc 1 363 0
 309 011a 2091 0000 		lds r18,flaga_wysylanie_smsa
 310 011e 2C83      		std Y+4,r18
 311               	.LVL18:
 312 0120 E0E0      		ldi r30,lo8(komendy_kolejka)
 313 0122 F0E0      		ldi r31,hi8(komendy_kolejka)
 314               	.LVL19:
 315               	.L20:
 316               	.LBB372:
 367:main.c        ****         komendy_kolejka[i] <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
 317               		.loc 1 367 0
 318 0124 2191      		ld r18,Z+
 319               	.LVL20:
 320 0126 235D      		subi r18,lo8(-(45))
 321 0128 2230      		cpi r18,lo8(2)
 322 012a 00F4      		brsh .L19
 369:main.c        ****   }
 323               		.loc 1 369 0
 324 012c 9F5F      		subi r25,lo8(-(1))
 325               	.LVL21:
 326               	.L19:
 366:main.c        ****     if (komendy_kolejka[i] >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
 327               		.loc 1 366 0
 328 012e 20E0      		ldi r18,hi8(komendy_kolejka+30)
 329 0130 E030      		cpi r30,lo8(komendy_kolejka+30)
 330 0132 F207      		cpc r31,r18
 331 0134 01F4      		brne .L20
 332               	.LBE372:
 371:main.c        ****   buf[5] = komenda;
 333               		.loc 1 371 0
 334 0136 9D83      		std Y+5,r25
 372:main.c        ****   buf[6] = akcja;
 335               		.loc 1 372 0
 336 0138 8E83      		std Y+6,r24
 373:main.c        **** 
 337               		.loc 1 373 0
 338 013a 6F83      		std Y+7,r22
 375:main.c        **** }
 339               		.loc 1 375 0
 340 013c 47E0      		ldi r20,lo8(7)
 341 013e 62ED      		ldi r22,lo8(-46)
 342 0140 7FE0      		ldi r23,lo8(15)
 343               	.LVL22:
 344 0142 CE01      		movw r24,r28
 345               	.LVL23:
 346 0144 0196      		adiw r24,1
 347 0146 0E94 0000 		call zapisz_znaki_w_eeprom
 348               	.LVL24:
 349               	.L17:
 350               	/* epilogue start */
 351               	.LBE371:
 352               	.LBE370:
 376:main.c        **** 
 353               		.loc 1 376 0
 354 014a 2896      		adiw r28,8
 355 014c 0FB6      		in __tmp_reg__,__SREG__
 356 014e F894      		cli
 357 0150 DEBF      		out __SP_H__,r29
 358 0152 0FBE      		out __SREG__,__tmp_reg__
 359 0154 CDBF      		out __SP_L__,r28
 360 0156 DF91      		pop r29
 361 0158 CF91      		pop r28
 362 015a 0895      		ret
 363               		.cfi_endproc
 364               	.LFE38:
 366               	.global	test_dioda_wyjscia
 368               	test_dioda_wyjscia:
 369               	.LFB24:
 370               		.file 4 "test_pcb.h"
   1:test_pcb.h    **** void test_dioda_wyjscia(void)
   2:test_pcb.h    **** {
 371               		.loc 4 2 0
 372               		.cfi_startproc
 373               	/* prologue: function */
 374               	/* frame size = 0 */
 375               	/* stack size = 0 */
 376               	.L__stack_usage = 0
   3:test_pcb.h    **** 	static uchar opoznienie_1s;
   4:test_pcb.h    **** 	if ( ++opoznienie_1s < 100 )
 377               		.loc 4 4 0
 378 015c 8091 0000 		lds r24,opoznienie_1s.2970
 379 0160 8F5F      		subi r24,lo8(-(1))
 380 0162 8436      		cpi r24,lo8(100)
 381 0164 00F4      		brsh .L23
 382 0166 8093 0000 		sts opoznienie_1s.2970,r24
 383 016a 0895      		ret
 384               	.L23:
   5:test_pcb.h    **** 		return;
   6:test_pcb.h    **** 	opoznienie_1s = 0;
 385               		.loc 4 6 0
 386 016c 1092 0000 		sts opoznienie_1s.2970,__zero_reg__
   7:test_pcb.h    **** 	static uchar stan;
   8:test_pcb.h    **** 	stan = not stan;
 387               		.loc 4 8 0
 388 0170 8091 0000 		lds r24,stan.2971
 389 0174 91E0      		ldi r25,lo8(1)
 390 0176 8111      		cpse r24,__zero_reg__
 391 0178 90E0      		ldi r25,0
 392               	.L25:
 393 017a 9093 0000 		sts stan.2971,r25
   9:test_pcb.h    **** 	if ( stan )
 394               		.loc 4 9 0
 395 017e 8111      		cpse r24,__zero_reg__
 396 0180 00C0      		rjmp .L26
  10:test_pcb.h    **** 	{
  11:test_pcb.h    **** 		ustaw_stan_led(TRUE);
 397               		.loc 4 11 0 discriminator 2
 398 0182 4098      		cbi 0x8,0
 399 0184 0895      		ret
 400               	.L26:
  12:test_pcb.h    **** 	}
  13:test_pcb.h    **** 	else
  14:test_pcb.h    **** 	{
  15:test_pcb.h    **** 		ustaw_stan_led(FALSE);
 401               		.loc 4 15 0 discriminator 1
 402 0186 409A      		sbi 0x8,0
 403               	/* epilogue start */
  16:test_pcb.h    **** 	}
  17:test_pcb.h    **** }
 404               		.loc 4 17 0 discriminator 1
 405 0188 0895      		ret
 406               		.cfi_endproc
 407               	.LFE24:
 409               	.global	test_wejscie
 411               	test_wejscie:
 412               	.LFB25:
  18:test_pcb.h    **** 
  19:test_pcb.h    **** void test_wejscie(void)
  20:test_pcb.h    **** {
 413               		.loc 4 20 0
 414               		.cfi_startproc
 415               	/* prologue: function */
 416               	/* frame size = 0 */
 417               	/* stack size = 0 */
 418               	.L__stack_usage = 0
 419               	.LBB373:
 420               	.LBB374:
 421               		.file 5 "wewy.h"
   1:wewy.h        **** 
   2:wewy.h        **** #include <avr/io.h>
   3:wewy.h        **** #include "narzedzia.h"
   4:wewy.h        **** #include "konfiguracja_eeprom.h"
   5:wewy.h        **** 
   6:wewy.h        **** #define LICZBA_WEJSC	1
   7:wewy.h        **** extern uchar licznik_wejscie[LICZBA_WEJSC];
   8:wewy.h        **** 
   9:wewy.h        **** extern uchar parametry_wejscia[LICZBA_WEJSC];
  10:wewy.h        **** void kopiuj_parametry_we_wy_z_eeprom(void);
  11:wewy.h        **** 
  12:wewy.h        **** extern ulong czas_trwania_impulsu_na_wejsciu[LICZBA_WEJSC];
  13:wewy.h        **** extern ulong czas_trwania_impulsu_off_na_wejsciu[LICZBA_WEJSC];
  14:wewy.h        **** 
  15:wewy.h        **** #define STAN_LOGICZNY_NA_WEJSCIU_WYZWOLENIE	0x02
  16:wewy.h        **** #define STAN_LOGICZNY_NA_WEJSCIU_ON					0x01
  17:wewy.h        **** #define STAN_LOGICZNY_NA_WEJSCIU_OFF				0x00
  18:wewy.h        **** #define CZY_WYZWOLENIE_NA_WEJSCIU(NR_WEJ)	(stan_logiczny_na_wejsciu[NR_WEJ] & STAN_LOGICZNY_NA_WEJS
  19:wewy.h        **** #define CZY_AKTUALNY_STAN_LOGICZNY_ON(NR_WEJ)	(stan_logiczny_na_wejsciu[NR_WEJ] & STAN_LOGICZNY_NA_
  20:wewy.h        **** #define CZY_AKTUALNY_STAN_LOGICZNY_OFF(NR_WEJ)	(!CZY_AKTUALNY_STAN_LOGICZNY_ON(NR_WEJ))
  21:wewy.h        **** 
  22:wewy.h        **** extern uchar stan_logiczny_na_wejsciu[LICZBA_WEJSC];
  23:wewy.h        **** 
  24:wewy.h        **** void steruj_wejscia_10ms(void);
  25:wewy.h        **** void aktualizuj_stan_wyzwolenia_wejsc_100ms(void);
  26:wewy.h        **** void inicjalizuj_parametry_we_wy(void);
  27:wewy.h        **** 
  28:wewy.h        **** static uchar stan_wejscia(const uchar nr_wejscia) __attribute__((unused));
  29:wewy.h        **** 
  30:wewy.h        **** static uchar stan_wejscia(const uchar nr_wejscia)
  31:wewy.h        **** {
  32:wewy.h        **** 	return licznik_wejscie[nr_wejscia] & 0xf0;
 422               		.loc 5 32 0
 423 018a 8091 0000 		lds r24,licznik_wejscie
 424 018e 807F      		andi r24,lo8(-16)
 425               	.LBE374:
 426               	.LBE373:
  21:test_pcb.h    **** 	ustaw_stan_led(stan_wejscia(0));
 427               		.loc 4 21 0
 428 0190 01F4      		brne .L31
 429               		.loc 4 21 0 is_stmt 0 discriminator 1
 430 0192 409A      		sbi 0x8,0
 431 0194 0895      		ret
 432               	.L31:
 433               		.loc 4 21 0 discriminator 2
 434 0196 4098      		cbi 0x8,0
 435               	/* epilogue start */
  22:test_pcb.h    **** }
 436               		.loc 4 22 0 is_stmt 1 discriminator 2
 437 0198 0895      		ret
 438               		.cfi_endproc
 439               	.LFE25:
 441               	.global	__vector_16
 443               	__vector_16:
 444               	.LFB26:
  75:main.c        ****   if (++licznik_wybudz_watki_10MS >= OPOZNIENIE_TIMERA_0) {
 445               		.loc 1 75 0
 446               		.cfi_startproc
 447 019a 7894      		sei
 448 019c 1F92      		push r1
 449               	.LCFI6:
 450               		.cfi_def_cfa_offset 3
 451               		.cfi_offset 1, -2
 452 019e 0F92      		push r0
 453               	.LCFI7:
 454               		.cfi_def_cfa_offset 4
 455               		.cfi_offset 0, -3
 456 01a0 0FB6      		in r0,__SREG__
 457 01a2 0F92      		push r0
 458 01a4 1124      		clr __zero_reg__
 459 01a6 0BB6      		in r0,__RAMPZ__
 460 01a8 0F92      		push r0
 461 01aa 2F93      		push r18
 462               	.LCFI8:
 463               		.cfi_def_cfa_offset 5
 464               		.cfi_offset 18, -4
 465 01ac 8F93      		push r24
 466               	.LCFI9:
 467               		.cfi_def_cfa_offset 6
 468               		.cfi_offset 24, -5
 469 01ae 9F93      		push r25
 470               	.LCFI10:
 471               		.cfi_def_cfa_offset 7
 472               		.cfi_offset 25, -6
 473 01b0 EF93      		push r30
 474               	.LCFI11:
 475               		.cfi_def_cfa_offset 8
 476               		.cfi_offset 30, -7
 477 01b2 FF93      		push r31
 478               	.LCFI12:
 479               		.cfi_def_cfa_offset 9
 480               		.cfi_offset 31, -8
 481               	/* prologue: Interrupt */
 482               	/* frame size = 0 */
 483               	/* stack size = 9 */
 484               	.L__stack_usage = 9
  76:main.c        ****     licznik_wybudz_watki_10MS = 0;
 485               		.loc 1 76 0
 486 01b4 8091 0000 		lds r24,licznik_wybudz_watki_10MS
 487 01b8 8F5F      		subi r24,lo8(-(1))
 488 01ba 8093 0000 		sts licznik_wybudz_watki_10MS,r24
 489 01be 8231      		cpi r24,lo8(18)
 490 01c0 00F0      		brlo .L34
  77:main.c        ****     wykonac_watki_10MS = TRUE;
 491               		.loc 1 77 0
 492 01c2 1092 0000 		sts licznik_wybudz_watki_10MS,__zero_reg__
  78:main.c        ****   }
 493               		.loc 1 78 0
 494 01c6 8FEF      		ldi r24,lo8(-1)
 495 01c8 8093 0000 		sts wykonac_watki_10MS,r24
 496               	.L34:
  81:main.c        ****     if (!CZY_ODBIERANIE_DANYCH_SIM900() && czy_jest_bezczynny_SIM900()) {
 497               		.loc 1 81 0
 498 01cc 4F9B      		sbis 0x9,7
 499 01ce 00C0      		rjmp .L35
  82:main.c        ****       ustaw_odbior_SIM900();
 500               		.loc 1 82 0
 501 01d0 00B6      		in __tmp_reg__,0x30
 502 01d2 01FC      		sbrc __tmp_reg__,1
 503 01d4 00C0      		rjmp .L36
  82:main.c        ****       ustaw_odbior_SIM900();
 504               		.loc 1 82 0 is_stmt 0 discriminator 1
 505 01d6 8091 0000 		lds r24,komenda_SIM900
 506 01da 8111      		cpse r24,__zero_reg__
 507 01dc 00C0      		rjmp .L36
  83:main.c        ****     }
 508               		.loc 1 83 0 is_stmt 1
 509 01de 1092 0000 		sts liczba_odebranych_znakow_SIM900+1,__zero_reg__
 510 01e2 1092 0000 		sts liczba_odebranych_znakow_SIM900,__zero_reg__
 511 01e6 1092 0000 		sts licznik_opoznienie_oczekiwania_na_bajt_SIM900,__zero_reg__
 512 01ea 80B7      		in r24,0x30
 513 01ec 8260      		ori r24,lo8(2)
 514 01ee 80BF      		out 0x30,r24
 515               	/* #APP */
 516               	 ;  83 "main.c" 1
 517 01f0 F894      		cli
 518               	 ;  0 "" 2
 519               	/* #NOAPP */
 520 01f2 8091 C100 		lds r24,193
 521 01f6 8068      		ori r24,lo8(-128)
 522 01f8 8093 C100 		sts 193,r24
 523               	/* #APP */
 524               	 ;  83 "main.c" 1
 525 01fc 7894      		sei
 526               	 ;  0 "" 2
 527               	 ;  83 "main.c" 1
 528 01fe 0000      		nop
 529               	 ;  0 "" 2
 530               	/* #NOAPP */
 531 0200 4598      		cbi 0x8,5
 532               	.L36:
  85:main.c        ****       cli();
 533               		.loc 1 85 0
 534 0202 3499      		sbic 0x6,4
 535 0204 00C0      		rjmp .L37
  86:main.c        ****       if (CZY_WYSYLANIE_DANYCH_SIM900()) {
 536               		.loc 1 86 0
 537               	/* #APP */
 538               	 ;  86 "main.c" 1
 539 0206 F894      		cli
 540               	 ;  0 "" 2
  87:main.c        ****         WYLACZ_PRZERWANIE_WYSYLANIA_DANYCH_SIM900();
 541               		.loc 1 87 0
 542               	/* #NOAPP */
 543 0208 8091 C100 		lds r24,193
 544 020c 86FF      		sbrs r24,6
 545 020e 00C0      		rjmp .L38
 546               	.LBB375:
  88:main.c        ****         sei();
 547               		.loc 1 88 0
 548 0210 8091 C100 		lds r24,193
 549 0214 8F7B      		andi r24,lo8(-65)
 550 0216 8093 C100 		sts 193,r24
  89:main.c        ****         uchar p = sprawdzaj_wejscie_CTS_SIM900;
 551               		.loc 1 89 0
 552               	/* #APP */
 553               	 ;  89 "main.c" 1
 554 021a 7894      		sei
 555               	 ;  0 "" 2
  90:main.c        ****         if (p && (podlaczony_modul_gsm_SIM900 ||
 556               		.loc 1 90 0
 557               	/* #NOAPP */
 558 021c 8091 0000 		lds r24,sprawdzaj_wejscie_CTS_SIM900
 559               	.LVL25:
  91:main.c        ****                   aktualnie_wysylane_polecenie_SIM900 ==
 560               		.loc 1 91 0
 561 0220 8823      		tst r24
 562 0222 01F0      		breq .L39
  91:main.c        ****                   aktualnie_wysylane_polecenie_SIM900 ==
 563               		.loc 1 91 0 is_stmt 0 discriminator 1
 564 0224 8091 0000 		lds r24,podlaczony_modul_gsm_SIM900
 565               	.LVL26:
 566 0228 8111      		cpse r24,__zero_reg__
 567 022a 00C0      		rjmp .L40
  91:main.c        ****                   aktualnie_wysylane_polecenie_SIM900 ==
 568               		.loc 1 91 0 discriminator 2
 569 022c 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 570 0230 8C38      		cpi r24,lo8(-116)
 571 0232 01F4      		brne .L39
 572               	.L40:
 573               	.LVL27:
  95:main.c        ****           WSTAW_ZNAK_DO_BUFORA_SIM900();
 574               		.loc 1 95 0 is_stmt 1
 575 0234 1092 0000 		sts sprawdzaj_wejscie_CTS_SIM900,__zero_reg__
 576               	.LBB376:
  96:main.c        ****         }
 577               		.loc 1 96 0
 578 0238 8091 0000 		lds r24,nr_wyslanego_znaku_SIM900
 579 023c 9091 0000 		lds r25,nr_wyslanego_znaku_SIM900+1
 580               	.LVL28:
 581 0240 FC01      		movw r30,r24
 582 0242 E050      		subi r30,lo8(-(wysylany_blok_SIM900))
 583 0244 F040      		sbci r31,hi8(-(wysylany_blok_SIM900))
 584 0246 2081      		ld r18,Z
 585               	.LVL29:
 586 0248 0196      		adiw r24,1
 587               	.LVL30:
 588 024a 9093 0000 		sts nr_wyslanego_znaku_SIM900+1,r25
 589 024e 8093 0000 		sts nr_wyslanego_znaku_SIM900,r24
 590 0252 2093 C600 		sts 198,r18
 591               	.LVL31:
 592               	.L39:
 593               	.LBE376:
  98:main.c        ****         WLACZ_PRZERWANIE_WYSYLANIA_DANYCH_SIM900();
 594               		.loc 1 98 0
 595               	/* #APP */
 596               	 ;  98 "main.c" 1
 597 0256 F894      		cli
 598               	 ;  0 "" 2
  99:main.c        ****       }
 599               		.loc 1 99 0
 600               	/* #NOAPP */
 601 0258 8091 C100 		lds r24,193
 602 025c 8064      		ori r24,lo8(64)
 603 025e 8093 C100 		sts 193,r24
 604               	.L38:
 605               	.LBE375:
 101:main.c        ****     }
 606               		.loc 1 101 0
 607               	/* #APP */
 608               	 ;  101 "main.c" 1
 609 0262 7894      		sei
 610               	 ;  0 "" 2
 611               	/* #NOAPP */
 612               	.L37:
 107:main.c        ****       TRUE; // uruchamia zdarzenie_timer, ktra korzysta z pozostaych zmiennych
 613               		.loc 1 107 0
 614 0264 8FEF      		ldi r24,lo8(-1)
 615 0266 8093 0000 		sts wykonaj_zdarzenie_timer,r24
 616               	/* epilogue start */
 109:main.c        **** 
 617               		.loc 1 109 0
 618 026a FF91      		pop r31
 619 026c EF91      		pop r30
 620 026e 9F91      		pop r25
 621 0270 8F91      		pop r24
 622 0272 2F91      		pop r18
 623 0274 0F90      		pop r0
 624 0276 0BBE      		out __RAMPZ__,r0
 625 0278 0F90      		pop r0
 626 027a 0FBE      		out __SREG__,r0
 627 027c 0F90      		pop r0
 628 027e 1F90      		pop r1
 629 0280 1895      		reti
 630               	.L35:
 104:main.c        ****   }
 631               		.loc 1 104 0
 632 0282 459A      		sbi 0x8,5
 633               	/* #APP */
 634               	 ;  104 "main.c" 1
 635 0284 F894      		cli
 636               	 ;  0 "" 2
 637               	/* #NOAPP */
 638 0286 8091 C100 		lds r24,193
 639 028a 8F73      		andi r24,lo8(63)
 640 028c 8093 C100 		sts 193,r24
 641 0290 80B7      		in r24,0x30
 642 0292 8D7F      		andi r24,lo8(-3)
 643 0294 80BF      		out 0x30,r24
 644               	/* #APP */
 645               	 ;  104 "main.c" 1
 646 0296 7894      		sei
 647               	 ;  0 "" 2
 648               	 ;  104 "main.c" 1
 649 0298 0000      		nop
 650               	 ;  0 "" 2
 651               	/* #NOAPP */
 652 029a 00C0      		rjmp .L37
 653               		.cfi_endproc
 654               	.LFE26:
 656               	.global	generuj_raport_sieci
 658               	generuj_raport_sieci:
 659               	.LFB27:
 122:main.c        ****   static const char tekst_gsm[] PROGMEM = "AC800-DTM-TS";
 660               		.loc 1 122 0
 661               		.cfi_startproc
 662               	.LVL32:
 663 029c DF92      		push r13
 664               	.LCFI13:
 665               		.cfi_def_cfa_offset 3
 666               		.cfi_offset 13, -2
 667 029e EF92      		push r14
 668               	.LCFI14:
 669               		.cfi_def_cfa_offset 4
 670               		.cfi_offset 14, -3
 671 02a0 FF92      		push r15
 672               	.LCFI15:
 673               		.cfi_def_cfa_offset 5
 674               		.cfi_offset 15, -4
 675 02a2 0F93      		push r16
 676               	.LCFI16:
 677               		.cfi_def_cfa_offset 6
 678               		.cfi_offset 16, -5
 679 02a4 1F93      		push r17
 680               	.LCFI17:
 681               		.cfi_def_cfa_offset 7
 682               		.cfi_offset 17, -6
 683 02a6 CF93      		push r28
 684               	.LCFI18:
 685               		.cfi_def_cfa_offset 8
 686               		.cfi_offset 28, -7
 687 02a8 DF93      		push r29
 688               	.LCFI19:
 689               		.cfi_def_cfa_offset 9
 690               		.cfi_offset 29, -8
 691               	/* prologue: function */
 692               	/* frame size = 0 */
 693               	/* stack size = 7 */
 694               	.L__stack_usage = 7
 695 02aa 8C01      		movw r16,r24
 124:main.c        **** 
 696               		.loc 1 124 0
 697 02ac DC01      		movw r26,r24
 698 02ae ED90      		ld r14,X+
 699 02b0 FC90      		ld r15,X
 700               	.LVL33:
 126:main.c        ****   ptr += sizeof tekst_gsm - 1;
 701               		.loc 1 126 0
 702 02b2 4CE0      		ldi r20,lo8(12)
 703 02b4 50E0      		ldi r21,0
 704 02b6 60E0      		ldi r22,lo8(tekst_gsm.3002)
 705 02b8 70E0      		ldi r23,hi8(tekst_gsm.3002)
 706 02ba C701      		movw r24,r14
 707               	.LVL34:
 708 02bc 0E94 0000 		call memcpy_P
 709               	.LVL35:
 128:main.c        **** 
 710               		.loc 1 128 0
 711 02c0 E701      		movw r28,r14
 712 02c2 2D96      		adiw r28,13
 713               	.LVL36:
 714 02c4 8AE0      		ldi r24,lo8(10)
 715 02c6 D82E      		mov r13,r24
 716 02c8 F701      		movw r30,r14
 717 02ca D486      		std Z+12,r13
 130:main.c        ****   ptr += strlen((char *)ptr);
 718               		.loc 1 130 0
 719 02cc 60E0      		ldi r22,lo8(__c.3004)
 720 02ce 70E0      		ldi r23,hi8(__c.3004)
 721 02d0 CE01      		movw r24,r28
 722 02d2 0E94 0000 		call strcpy_P
 723               	.LVL37:
 131:main.c        ****   strcat((char *)ptr, rtc_czas);
 724               		.loc 1 131 0
 725               		0:
 726 02d6 0990      		ld __tmp_reg__,Y+
 727 02d8 0020      		tst __tmp_reg__
 728 02da 01F4      		brne 0b
 729               	.LVL38:
 730 02dc 2197      		sbiw r28,1
 731               	.LVL39:
 132:main.c        ****   ptr += strlen((char *)ptr);
 732               		.loc 1 132 0
 733 02de 60E0      		ldi r22,lo8(rtc_czas)
 734 02e0 70E0      		ldi r23,hi8(rtc_czas)
 735 02e2 CE01      		movw r24,r28
 736 02e4 0E94 0000 		call strcat
 737               	.LVL40:
 133:main.c        ****   *ptr++ = '\n';
 738               		.loc 1 133 0
 739               		0:
 740 02e8 0990      		ld __tmp_reg__,Y+
 741 02ea 0020      		tst __tmp_reg__
 742 02ec 01F4      		brne 0b
 743               	.LVL41:
 744 02ee 2197      		sbiw r28,1
 745               	.LVL42:
 134:main.c        **** 
 746               		.loc 1 134 0
 747 02f0 DE01      		movw r26,r28
 748 02f2 DD92      		st X+,r13
 749               	.LVL43:
 750 02f4 CD01      		movw r24,r26
 137:main.c        ****   ptr += sizeof text_sygnal - 1;
 751               		.loc 1 137 0
 752 02f6 4BE0      		ldi r20,lo8(11)
 753 02f8 50E0      		ldi r21,0
 754 02fa 60E0      		ldi r22,lo8(text_sygnal.3006)
 755 02fc 70E0      		ldi r23,hi8(text_sygnal.3006)
 756 02fe 0E94 0000 		call memcpy_P
 757               	.LVL44:
 140:main.c        ****     utoa(poziom_sieci_gsm * 100 / 31, ptr, 10);
 758               		.loc 1 140 0
 759 0302 8091 0000 		lds r24,poziom_sieci_gsm
 760 0306 8032      		cpi r24,lo8(32)
 761 0308 00F4      		brsh .L48
 140:main.c        ****     utoa(poziom_sieci_gsm * 100 / 31, ptr, 10);
 762               		.loc 1 140 0 is_stmt 0 discriminator 1
 763 030a 9091 0000 		lds r25,modul_zalogowany_w_sieci
 764 030e 9923      		tst r25
 765 0310 01F0      		breq .L48
 138:main.c        **** 
 766               		.loc 1 138 0 is_stmt 1
 767 0312 2C96      		adiw r28,12
 768               	.LVL45:
 141:main.c        ****     ptr += strlen(ptr);
 769               		.loc 1 141 0
 770 0314 B4E6      		ldi r27,lo8(100)
 771 0316 8B9F      		mul r24,r27
 772 0318 C001      		movw r24,r0
 773 031a 1124      		clr __zero_reg__
 774               	.LVL46:
 775 031c 6FE1      		ldi r22,lo8(31)
 776 031e 70E0      		ldi r23,0
 777 0320 0E94 0000 		call __divmodhi4
 778 0324 CB01      		movw r24,r22
 779               	.LBB377:
 780               	.LBB378:
 781               		.file 6 "/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h"
   1:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Copyright (c) 2004,2007 Joerg Wunsch
   3:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
   4:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Portions of documentation Copyright (c) 1990, 1991, 1993, 1994
   5:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The Regents of the University of California.
   6:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
   7:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    All rights reserved.
   8:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
   9:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Redistribution and use in source and binary forms, with or without
  10:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    modification, are permitted provided that the following conditions are met:
  11:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  12:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    * Redistributions of source code must retain the above copyright
  13:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer.
  14:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  15:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    * Redistributions in binary form must reproduce the above copyright
  16:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer in
  17:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      the documentation and/or other materials provided with the
  18:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      distribution.
  19:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  20:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    * Neither the name of the copyright holders nor the names of
  21:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      contributors may be used to endorse or promote products derived
  22:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      from this software without specific prior written permission.
  23:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  24:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  28:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  34:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   POSSIBILITY OF SUCH DAMAGE.
  35:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  36:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   $Id$
  37:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
  38:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  39:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef _STDLIB_H_
  40:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define	_STDLIB_H_ 1
  41:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  42:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ASSEMBLER__
  43:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  44:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __DOXYGEN__
  45:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define __need_NULL
  46:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define __need_size_t
  47:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define __need_wchar_t
  48:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #include <stddef.h>
  49:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  50:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ptr_t
  51:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define __ptr_t void *
  52:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  53:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif	/* !__DOXYGEN__ */
  54:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  55:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifdef __cplusplus
  56:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern "C" {
  57:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  58:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  59:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** \file */
  60:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  61:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** \defgroup avr_stdlib <stdlib.h>: General utilities
  62:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \code #include <stdlib.h> \endcode
  63:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  64:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     This file declares some basic C macros and functions as
  65:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     defined by the ISO standard, plus some AVR-specific extensions.
  66:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
  67:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  68:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /*@{*/
  69:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** Result type for function div(). */
  70:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** typedef struct {
  71:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	int quot;                   /**< The Quotient. */
  72:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	int rem;                    /**< The Remainder. */
  73:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** } div_t;
  74:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  75:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** Result type for function ldiv(). */
  76:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** typedef struct {
  77:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	long quot;                  /**< The Quotient. */
  78:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	long rem;                   /**< The Remainder. */
  79:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** } ldiv_t;
  80:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  81:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** Comparision function type for qsort(), just for convenience. */
  82:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** typedef int (*__compar_fn_t)(const void *, const void *);
  83:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  84:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __DOXYGEN__
  85:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  86:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ATTR_CONST__
  87:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # define __ATTR_CONST__ __attribute__((__const__))
  88:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  89:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  90:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ATTR_MALLOC__
  91:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # define __ATTR_MALLOC__ __attribute__((__malloc__))
  92:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  93:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  94:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ATTR_NORETURN__
  95:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # define __ATTR_NORETURN__ __attribute__((__noreturn__))
  96:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  97:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  98:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ATTR_PURE__
  99:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # define __ATTR_PURE__ __attribute__((__pure__))
 100:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 101:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 102:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef	__ATTR_GNU_INLINE__
 103:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # ifdef  __GNUC_STDC_INLINE__
 104:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__   __attribute__((__gnu_inline__))
 105:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # else
 106:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__
 107:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # endif
 108:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 109:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 110:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 111:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 112:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** The abort() function causes abnormal program termination to occur.
 113:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     This realization disables interrupts and jumps to _exit() function
 114:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     with argument equal to 1. In the limited AVR environment, execution is
 115:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     effectively halted by entering an infinite loop. */
 116:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void abort(void) __ATTR_NORETURN__;
 117:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 118:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** The abs() function computes the absolute value of the integer \c i.
 119:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 120:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 121:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern int abs(int __i) __ATTR_CONST__;
 122:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 123:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define	abs(__i) __builtin_abs(__i)
 124:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 125:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 126:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** The labs() function computes the absolute value of the long integer
 127:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c i.
 128:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 129:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 130:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern long labs(long __i) __ATTR_CONST__;
 131:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 132:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define labs(__i) __builtin_labs(__i)
 133:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 134:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 135:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 136:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The bsearch() function searches an array of \c nmemb objects, the
 137:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      initial member of which is pointed to by \c base, for a member
 138:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      that matches the object pointed to by \c key.  The size of each
 139:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      member of the array is specified by \c size.
 140:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 141:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The contents of the array should be in ascending sorted order
 142:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      according to the comparison function referenced by \c compar.
 143:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The \c compar routine is expected to have two arguments which
 144:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      point to the key object and to an array member, in that order,
 145:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      and should return an integer less than, equal to, or greater than
 146:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      zero if the key object is found, respectively, to be less than,
 147:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      to match, or be greater than the array member.
 148:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 149:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The bsearch() function returns a pointer to a matching member of
 150:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      the array, or a null pointer if no match is found.  If two
 151:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      members compare as equal, which member is matched is unspecified.
 152:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 153:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void *bsearch(const void *__key, const void *__base, size_t __nmemb,
 154:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 		     size_t __size, int (*__compar)(const void *, const void *));
 155:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 156:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /* __divmodhi4 and __divmodsi4 from libgcc.a */
 157:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 158:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The div() function computes the value \c num/denom and returns
 159:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c div_t that
 160:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      contains two int members named \c quot and \c rem.
 161:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 162:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern div_t div(int __num, int __denom) __asm__("__divmodhi4") __ATTR_CONST__;
 163:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 164:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The ldiv() function computes the value \c num/denom and returns
 165:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c ldiv_t that
 166:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      contains two long integer members named \c quot and \c rem.
 167:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 168:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern ldiv_t ldiv(long __num, long __denom) __asm__("__divmodsi4") __ATTR_CONST__;
 169:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 170:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 171:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The qsort() function is a modified partition-exchange sort, or
 172:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      quicksort.
 173:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 174:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The qsort() function sorts an array of \c nmemb objects, the
 175:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      initial member of which is pointed to by \c base.  The size of
 176:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      each object is specified by \c size.  The contents of the array
 177:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      base are sorted in ascending order according to a comparison
 178:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      function pointed to by \c compar, which requires two arguments
 179:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      pointing to the objects being compared.
 180:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 181:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The comparison function must return an integer less than, equal
 182:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      to, or greater than zero if the first argument is considered to
 183:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      be respectively less than, equal to, or greater than the second.
 184:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 185:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void qsort(void *__base, size_t __nmemb, size_t __size,
 186:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 		  __compar_fn_t __compar);
 187:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 188:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 189:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The strtol() function converts the string in \c nptr to a long
 190:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     value.  The conversion is done according to the given base, which
 191:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     must be between 2 and 36 inclusive, or be the special value 0.
 192:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 193:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 194:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 195:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 196:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 197:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 198:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 199:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 200:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The remainder of the string is converted to a long value in the
 201:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     obvious manner, stopping at the first character which is not a
 202:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     valid digit in the given base.  (In bases above 10, the letter \c 'A'
 203:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     in either upper or lower case represents 10, \c 'B' represents 11,
 204:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     and so forth, with \c 'Z' representing 35.)
 205:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 206:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     If \c endptr is not NULL, strtol() stores the address of the first
 207:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 208:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     however, strtol() stores the original value of \c nptr in \c
 209:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 210:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     on return, the entire string was valid.)
 211:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 212:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The strtol() function returns the result of the conversion, unless
 213:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     the value would underflow or overflow.  If no conversion could be
 214:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     performed, 0 is returned.  If an overflow or underflow occurs, \c
 215:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE" and the function return value
 216:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     is clamped to \c LONG_MIN or \c LONG_MAX, respectively.
 217:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 218:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern long strtol(const char *__nptr, char **__endptr, int __base);
 219:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 220:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 221:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The strtoul() function converts the string in \c nptr to an
 222:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     unsigned long value.  The conversion is done according to the
 223:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     given base, which must be between 2 and 36 inclusive, or be the
 224:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     special value 0.
 225:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 226:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 227:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 228:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 229:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 230:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 231:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 232:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 233:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The remainder of the string is converted to an unsigned long value
 234:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     in the obvious manner, stopping at the first character which is
 235:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     not a valid digit in the given base.  (In bases above 10, the
 236:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     letter \c 'A' in either upper or lower case represents 10, \c 'B'
 237:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     represents 11, and so forth, with \c 'Z' representing 35.)
 238:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 239:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     If \c endptr is not NULL, strtoul() stores the address of the first
 240:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 241:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     however, strtoul() stores the original value of \c nptr in \c
 242:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 243:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     on return, the entire string was valid.)
 244:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 245:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The strtoul() function return either the result of the conversion
 246:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     or, if there was a leading minus sign, the negation of the result
 247:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     of the conversion, unless the original (non-negated) value would
 248:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     overflow; in the latter case, strtoul() returns ULONG_MAX, and \c
 249:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE".  If no conversion could 
 250:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     be performed, 0 is returned.
 251:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 252:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern unsigned long strtoul(const char *__nptr, char **__endptr, int __base);
 253:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 254:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 255:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The atol() function converts the initial portion of the string
 256:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     pointed to by \p s to long integer representation. In contrast to
 257:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 258:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****         \code strtol(s, (char **)NULL, 10); \endcode
 259:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 260:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 261:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 262:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     stack) and works more quickly.
 263:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 264:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern long atol(const char *__s) __ATTR_PURE__;
 265:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 266:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 267:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The atoi() function converts the initial portion of the string
 268:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     pointed to by \p s to integer representation. In contrast to
 269:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 270:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****         \code (int)strtol(s, (char **)NULL, 10); \endcode
 271:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 272:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 273:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 274:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     stack) and works more quickly.
 275:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 276:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern int atoi(const char *__s) __ATTR_PURE__;
 277:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 278:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 279:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The exit() function terminates the application.  Since there is no
 280:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    environment to return to, \c status is ignored, and code execution
 281:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    will eventually reach an infinite loop, thereby effectively halting
 282:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    all code processing.  Before entering the infinite loop, interrupts
 283:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    are globally disabled.
 284:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 285:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    In a C++ context, global destructors will be called before halting
 286:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    execution.
 287:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 288:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void exit(int __status) __ATTR_NORETURN__;
 289:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 290:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 291:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The malloc() function allocates \c size bytes of memory.
 292:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    If malloc() fails, a NULL pointer is returned.
 293:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 294:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Note that malloc() does \e not initialize the returned memory to
 295:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    zero bytes.
 296:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 297:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    See the chapter about \ref malloc "malloc() usage" for implementation
 298:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    details.
 299:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 300:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void *malloc(size_t __size) __ATTR_MALLOC__;
 301:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 302:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 303:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The free() function causes the allocated memory referenced by \c
 304:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    ptr to be made available for future allocations.  If \c ptr is
 305:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    NULL, no action occurs.
 306:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 307:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void free(void *__ptr);
 308:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 309:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 310:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 311:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 312:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern size_t __malloc_margin;
 313:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 314:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 315:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 316:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 317:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *__malloc_heap_start;
 318:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 319:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 320:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 321:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 322:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *__malloc_heap_end;
 323:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 324:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 325:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Allocate \c nele elements of \c size each.  Identical to calling
 326:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c malloc() using <tt>nele * size</tt> as argument, except the
 327:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    allocated memory will be cleared to zero.
 328:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 329:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void *calloc(size_t __nele, size_t __size) __ATTR_MALLOC__;
 330:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 331:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 332:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The realloc() function tries to change the size of the region
 333:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    allocated at \c ptr to the new \c size value.  It returns a
 334:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    pointer to the new region.  The returned pointer might be the
 335:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    same as the old pointer, or a pointer to a completely different
 336:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    region.
 337:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 338:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The contents of the returned region up to either the old or the new
 339:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    size value (whatever is less) will be identical to the contents of
 340:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    the old region, even in case a new region had to be allocated.
 341:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 342:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    It is acceptable to pass \c ptr as NULL, in which case realloc()
 343:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    will behave identical to malloc().
 344:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 345:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    If the new memory cannot be allocated, realloc() returns NULL, and
 346:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    the region at \c ptr will not be changed.
 347:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 348:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void *realloc(void *__ptr, size_t __size) __ATTR_MALLOC__;
 349:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 350:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern double strtod(const char *__nptr, char **__endptr);
 351:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 352:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** \ingroup avr_stdlib
 353:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \fn  double atof (const char *nptr)
 354:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 355:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The atof() function converts the initial portion of the string pointed
 356:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     to by \a nptr to double representation.
 357:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 358:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     It is equivalent to calling
 359:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	\code strtod(nptr, (char **)0); \endcode
 360:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  */
 361:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern double atof(const char *__nptr);
 362:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 363:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** Highest number that can be generated by rand(). */
 364:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define	RAND_MAX 0x7FFF
 365:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 366:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 367:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The rand() function computes a sequence of pseudo-random integers in the
 368:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      range of 0 to \c RAND_MAX (as defined by the header file <stdlib.h>).
 369:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 370:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The srand() function sets its argument \c seed as the seed for a new
 371:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      sequence of pseudo-random numbers to be returned by rand().  These
 372:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      sequences are repeatable by calling srand() with the same seed value.
 373:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 374:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      If no seed value is provided, the functions are automatically seeded with
 375:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      a value of 1.
 376:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 377:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      In compliance with the C standard, these functions operate on
 378:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      \c int arguments.  Since the underlying algorithm already uses
 379:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      32-bit calculations, this causes a loss of precision.  See
 380:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      \c random() for an alternate set of functions that retains full
 381:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      32-bit precision.
 382:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 383:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern int rand(void);
 384:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 385:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Pseudo-random number generator seeding; see rand().
 386:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 387:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void srand(unsigned int __seed);
 388:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 389:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 390:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Variant of rand() that stores the context in the user-supplied
 391:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    variable located at \c ctx instead of a static library variable
 392:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    so the function becomes re-entrant.
 393:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 394:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern int rand_r(unsigned long *__ctx);
 395:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /*@}*/
 396:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 397:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /*@{*/
 398:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** \name Non-standard (i.e. non-ISO C) functions.
 399:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  \ingroup avr_stdlib
 400:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 401:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 402:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \brief Convert an integer to a string.
 403:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 404:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The function itoa() converts the integer value from \c val into an
 405:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 406:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 407:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 408:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 409:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 410:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (int) + 1 characters, i.e. one
 411:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 412:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 413:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 414:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 415:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 416:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 417:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 418:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 419:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c 'a'.
 420:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     
 421:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     If radix is 10 and val is negative, a minus sign will be prepended.
 422:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 423:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The itoa() function returns the pointer passed as \c s.
 424:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 425:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 426:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *itoa(int val, char *s, int radix);
 427:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #else
 428:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 429:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** char *itoa (int __val, char *__s, int __radix)
 430:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** {
 431:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 432:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__itoa (int, char *, int);
 433:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __itoa (__val, __s, __radix);
 434:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 435:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	*__s = 0;
 436:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __s;
 437:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else {
 438:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__itoa_ncheck (int, char *, unsigned char);
 439:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __itoa_ncheck (__val, __s, __radix);
 440:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     }
 441:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** }
 442:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 443:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 444:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 445:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  \ingroup avr_stdlib
 446:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  
 447:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \brief Convert a long integer to a string.
 448:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 449:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The function ltoa() converts the long integer value from \c val into an
 450:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 451:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 452:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 453:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 454:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 455:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (long int) + 1 characters, i.e. one
 456:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 457:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 458:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 459:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 460:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 461:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 462:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 463:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 464:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c 'a'.
 465:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 466:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    If radix is 10 and val is negative, a minus sign will be prepended.
 467:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 468:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The ltoa() function returns the pointer passed as \c s.
 469:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 470:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 471:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *ltoa(long val, char *s, int radix);
 472:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #else
 473:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 474:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** char *ltoa (long __val, char *__s, int __radix)
 475:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** {
 476:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 477:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__ltoa (long, char *, int);
 478:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __ltoa (__val, __s, __radix);
 479:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 480:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	*__s = 0;
 481:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __s;
 482:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else {
 483:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__ltoa_ncheck (long, char *, unsigned char);
 484:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __ltoa_ncheck (__val, __s, __radix);
 485:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     }
 486:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** }
 487:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 488:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 489:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 490:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  \ingroup avr_stdlib
 491:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 492:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \brief Convert an unsigned integer to a string.
 493:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 494:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The function utoa() converts the unsigned integer value from \c val into an
 495:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 496:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 497:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 498:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 499:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 500:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (unsigned int) + 1 characters, i.e. one
 501:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 502:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 503:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 504:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 505:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 506:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 507:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 508:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 509:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c 'a'.
 510:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 511:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The utoa() function returns the pointer passed as \c s.
 512:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 513:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 514:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *utoa(unsigned int val, char *s, int radix);
 515:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #else
 516:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 517:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** char *utoa (unsigned int __val, char *__s, int __radix)
 518:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** {
 519:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 520:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__utoa (unsigned int, char *, int);
 521:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __utoa (__val, __s, __radix);
 522:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 523:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	*__s = 0;
 524:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __s;
 525:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else {
 526:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__utoa_ncheck (unsigned int, char *, unsigned char);
 527:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __utoa_ncheck (__val, __s, __radix);
 782               		.loc 6 527 0
 783 0326 4AE0      		ldi r20,lo8(10)
 784 0328 BE01      		movw r22,r28
 785 032a 0E94 0000 		call __utoa_ncheck
 786               	.LVL47:
 787               	.LBE378:
 788               	.LBE377:
 142:main.c        ****     *ptr++ = '%';
 789               		.loc 1 142 0
 790               		0:
 791 032e 0990      		ld __tmp_reg__,Y+
 792 0330 0020      		tst __tmp_reg__
 793 0332 01F4      		brne 0b
 794               	.LVL48:
 795 0334 2197      		sbiw r28,1
 796               	.LVL49:
 143:main.c        ****   } else {
 797               		.loc 1 143 0
 798 0336 FE01      		movw r30,r28
 799 0338 3196      		adiw r30,1
 800               	.LVL50:
 801 033a 85E2      		ldi r24,lo8(37)
 802 033c 8883      		st Y,r24
 803               	.L49:
 149:main.c        ****   *buf_sms = ptr;
 804               		.loc 1 149 0
 805 033e 1082      		st Z,__zero_reg__
 150:main.c        **** }
 806               		.loc 1 150 0
 807 0340 D801      		movw r26,r16
 808 0342 ED93      		st X+,r30
 809 0344 FC93      		st X,r31
 810               	/* epilogue start */
 151:main.c        **** 
 811               		.loc 1 151 0
 812 0346 DF91      		pop r29
 813 0348 CF91      		pop r28
 814 034a 1F91      		pop r17
 815 034c 0F91      		pop r16
 816               	.LVL51:
 817 034e FF90      		pop r15
 818 0350 EF90      		pop r14
 819 0352 DF90      		pop r13
 820 0354 0895      		ret
 821               	.LVL52:
 822               	.L48:
 145:main.c        ****     *ptr++ = '-';
 823               		.loc 1 145 0
 824 0356 8DE2      		ldi r24,lo8(45)
 825 0358 8C87      		std Y+12,r24
 826               	.LVL53:
 146:main.c        ****     *ptr++ = '-';
 827               		.loc 1 146 0
 828 035a 8D87      		std Y+13,r24
 147:main.c        ****   }
 829               		.loc 1 147 0
 830 035c FE01      		movw r30,r28
 831 035e 3F96      		adiw r30,15
 832               	.LVL54:
 833 0360 8E87      		std Y+14,r24
 834 0362 00C0      		rjmp .L49
 835               		.cfi_endproc
 836               	.LFE27:
 838               	.global	generuj_raport_uzytkownikow_1
 840               	generuj_raport_uzytkownikow_1:
 841               	.LFB28:
 153:main.c        ****   static const char tekst_gsm[] PROGMEM = "Uzytkownicy ";
 842               		.loc 1 153 0
 843               		.cfi_startproc
 844               	.LVL55:
 845 0364 AF92      		push r10
 846               	.LCFI20:
 847               		.cfi_def_cfa_offset 3
 848               		.cfi_offset 10, -2
 849 0366 BF92      		push r11
 850               	.LCFI21:
 851               		.cfi_def_cfa_offset 4
 852               		.cfi_offset 11, -3
 853 0368 CF92      		push r12
 854               	.LCFI22:
 855               		.cfi_def_cfa_offset 5
 856               		.cfi_offset 12, -4
 857 036a DF92      		push r13
 858               	.LCFI23:
 859               		.cfi_def_cfa_offset 6
 860               		.cfi_offset 13, -5
 861 036c EF92      		push r14
 862               	.LCFI24:
 863               		.cfi_def_cfa_offset 7
 864               		.cfi_offset 14, -6
 865 036e FF92      		push r15
 866               	.LCFI25:
 867               		.cfi_def_cfa_offset 8
 868               		.cfi_offset 15, -7
 869 0370 0F93      		push r16
 870               	.LCFI26:
 871               		.cfi_def_cfa_offset 9
 872               		.cfi_offset 16, -8
 873 0372 1F93      		push r17
 874               	.LCFI27:
 875               		.cfi_def_cfa_offset 10
 876               		.cfi_offset 17, -9
 877 0374 CF93      		push r28
 878               	.LCFI28:
 879               		.cfi_def_cfa_offset 11
 880               		.cfi_offset 28, -10
 881 0376 DF93      		push r29
 882               	.LCFI29:
 883               		.cfi_def_cfa_offset 12
 884               		.cfi_offset 29, -11
 885               	/* prologue: function */
 886               	/* frame size = 0 */
 887               	/* stack size = 10 */
 888               	.L__stack_usage = 10
 889 0378 8C01      		movw r16,r24
 155:main.c        **** 
 890               		.loc 1 155 0
 891 037a FC01      		movw r30,r24
 892 037c C081      		ld r28,Z
 893 037e D181      		ldd r29,Z+1
 894               	.LVL56:
 157:main.c        ****   ptr += sizeof tekst_gsm - 1;
 895               		.loc 1 157 0
 896 0380 4CE0      		ldi r20,lo8(12)
 897 0382 50E0      		ldi r21,0
 898 0384 60E0      		ldi r22,lo8(tekst_gsm.3010)
 899 0386 70E0      		ldi r23,hi8(tekst_gsm.3010)
 900 0388 CE01      		movw r24,r28
 901               	.LVL57:
 902 038a 0E94 0000 		call memcpy_P
 903               	.LVL58:
 158:main.c        ****   uint aktywne_numery = 0;
 904               		.loc 1 158 0
 905 038e 2C96      		adiw r28,12
 906               	.LVL59:
 907 0390 88E0      		ldi r24,lo8(8)
 908 0392 C82E      		mov r12,r24
 909 0394 D12C      		mov r13,__zero_reg__
 160:main.c        ****   // for (uchar nr_uzyt_clip = 0; nr_uzyt_clip <
 910               		.loc 1 160 0
 911 0396 F12C      		mov r15,__zero_reg__
 912 0398 E12C      		mov r14,__zero_reg__
 159:main.c        ****   uint wolne_numery = 0;
 913               		.loc 1 159 0
 914 039a B12C      		mov r11,__zero_reg__
 915 039c A12C      		mov r10,__zero_reg__
 916               	.LVL60:
 917               	.L56:
 918               	.LBB379:
 165:main.c        ****       ++aktywne_numery;
 919               		.loc 1 165 0
 920 039e C601      		movw r24,r12
 921 03a0 0E94 0000 		call eeprom_read_byte
 922               	.LVL61:
 923 03a4 8F3F      		cpi r24,lo8(-1)
 924 03a6 01F0      		breq .L54
 166:main.c        ****     else
 925               		.loc 1 166 0
 926 03a8 FFEF      		ldi r31,-1
 927 03aa AF1A      		sub r10,r31
 928 03ac BF0A      		sbc r11,r31
 929               	.LVL62:
 930               	.L55:
 931 03ae E5E0      		ldi r30,5
 932 03b0 CE0E      		add r12,r30
 933 03b2 D11C      		adc r13,__zero_reg__
 163:main.c        ****        ++nr_uzyt_clip) {
 934               		.loc 1 163 0
 935 03b4 F8EA      		ldi r31,-88
 936 03b6 CF16      		cp r12,r31
 937 03b8 FFE0      		ldi r31,15
 938 03ba DF06      		cpc r13,r31
 939 03bc 01F4      		brne .L56
 940               	.LVL63:
 941               	.LBE379:
 942               	.LBB380:
 943               	.LBB381:
 944               		.loc 6 527 0
 945 03be 4AE0      		ldi r20,lo8(10)
 946 03c0 BE01      		movw r22,r28
 947 03c2 C501      		movw r24,r10
 948 03c4 0E94 0000 		call __utoa_ncheck
 949               	.LVL64:
 950               	.LBE381:
 951               	.LBE380:
 172:main.c        ****   *ptr++ = '/';
 952               		.loc 1 172 0
 953               		0:
 954 03c8 0990      		ld __tmp_reg__,Y+
 955 03ca 0020      		tst __tmp_reg__
 956 03cc 01F4      		brne 0b
 957               	.LVL65:
 958 03ce 2197      		sbiw r28,1
 959               	.LVL66:
 173:main.c        ****   utoa(wolne_numery, ptr, 10);
 960               		.loc 1 173 0
 961 03d0 6E01      		movw r12,r28
 962 03d2 8FEF      		ldi r24,-1
 963 03d4 C81A      		sub r12,r24
 964 03d6 D80A      		sbc r13,r24
 965               	.LVL67:
 966 03d8 8FE2      		ldi r24,lo8(47)
 967 03da 8883      		st Y,r24
 968               	.LVL68:
 969               	.LBB382:
 970               	.LBB383:
 971               		.loc 6 527 0
 972 03dc 4AE0      		ldi r20,lo8(10)
 973 03de B601      		movw r22,r12
 974 03e0 C701      		movw r24,r14
 975 03e2 0E94 0000 		call __utoa_ncheck
 976               	.LVL69:
 977               	.LBE383:
 978               	.LBE382:
 175:main.c        ****   *buf_sms = ptr;
 979               		.loc 1 175 0
 980 03e6 F601      		movw r30,r12
 981               		0:
 982 03e8 0190      		ld __tmp_reg__,Z+
 983 03ea 0020      		tst __tmp_reg__
 984 03ec 01F4      		brne 0b
 985 03ee CF01      		movw r24,r30
 986               	.LVL70:
 987 03f0 0197      		sbiw r24,1
 988               	.LVL71:
 176:main.c        **** }
 989               		.loc 1 176 0
 990 03f2 F801      		movw r30,r16
 991               	.LVL72:
 992 03f4 9183      		std Z+1,r25
 993 03f6 8083      		st Z,r24
 994               	/* epilogue start */
 177:main.c        **** 
 995               		.loc 1 177 0
 996 03f8 DF91      		pop r29
 997 03fa CF91      		pop r28
 998 03fc 1F91      		pop r17
 999 03fe 0F91      		pop r16
 1000               	.LVL73:
 1001 0400 FF90      		pop r15
 1002 0402 EF90      		pop r14
 1003               	.LVL74:
 1004 0404 DF90      		pop r13
 1005 0406 CF90      		pop r12
 1006               	.LVL75:
 1007 0408 BF90      		pop r11
 1008 040a AF90      		pop r10
 1009               	.LVL76:
 1010 040c 0895      		ret
 1011               	.LVL77:
 1012               	.L54:
 1013               	.LBB384:
 168:main.c        ****   }
 1014               		.loc 1 168 0
 1015 040e 8FEF      		ldi r24,-1
 1016 0410 E81A      		sub r14,r24
 1017 0412 F80A      		sbc r15,r24
 1018               	.LVL78:
 1019 0414 00C0      		rjmp .L55
 1020               	.LBE384:
 1021               		.cfi_endproc
 1022               	.LFE28:
 1024               	.global	generuj_raport_uzytkownikow
 1026               	generuj_raport_uzytkownikow:
 1027               	.LFB29:
 179:main.c        ****   static const char tekst_gsm[] PROGMEM = "Uzytkownicy ";
 1028               		.loc 1 179 0
 1029               		.cfi_startproc
 1030               	.LVL79:
 1031 0416 CF92      		push r12
 1032               	.LCFI30:
 1033               		.cfi_def_cfa_offset 3
 1034               		.cfi_offset 12, -2
 1035 0418 DF92      		push r13
 1036               	.LCFI31:
 1037               		.cfi_def_cfa_offset 4
 1038               		.cfi_offset 13, -3
 1039 041a EF92      		push r14
 1040               	.LCFI32:
 1041               		.cfi_def_cfa_offset 5
 1042               		.cfi_offset 14, -4
 1043 041c FF92      		push r15
 1044               	.LCFI33:
 1045               		.cfi_def_cfa_offset 6
 1046               		.cfi_offset 15, -5
 1047 041e 0F93      		push r16
 1048               	.LCFI34:
 1049               		.cfi_def_cfa_offset 7
 1050               		.cfi_offset 16, -6
 1051 0420 1F93      		push r17
 1052               	.LCFI35:
 1053               		.cfi_def_cfa_offset 8
 1054               		.cfi_offset 17, -7
 1055 0422 CF93      		push r28
 1056               	.LCFI36:
 1057               		.cfi_def_cfa_offset 9
 1058               		.cfi_offset 28, -8
 1059 0424 DF93      		push r29
 1060               	.LCFI37:
 1061               		.cfi_def_cfa_offset 10
 1062               		.cfi_offset 29, -9
 1063               	/* prologue: function */
 1064               	/* frame size = 0 */
 1065               	/* stack size = 8 */
 1066               	.L__stack_usage = 8
 1067 0426 8C01      		movw r16,r24
 181:main.c        **** 
 1068               		.loc 1 181 0
 1069 0428 FC01      		movw r30,r24
 1070 042a C081      		ld r28,Z
 1071 042c D181      		ldd r29,Z+1
 1072               	.LVL80:
 183:main.c        ****   ptr += sizeof tekst_gsm - 1;
 1073               		.loc 1 183 0
 1074 042e 4CE0      		ldi r20,lo8(12)
 1075 0430 50E0      		ldi r21,0
 1076 0432 60E0      		ldi r22,lo8(tekst_gsm.3021)
 1077 0434 70E0      		ldi r23,hi8(tekst_gsm.3021)
 1078 0436 CE01      		movw r24,r28
 1079               	.LVL81:
 1080 0438 0E94 0000 		call memcpy_P
 1081               	.LVL82:
 184:main.c        ****   uchar aktywne_numery = 0;
 1082               		.loc 1 184 0
 1083 043c 2C96      		adiw r28,12
 1084               	.LVL83:
 1085 043e 88E0      		ldi r24,lo8(8)
 1086 0440 E82E      		mov r14,r24
 1087 0442 F12C      		mov r15,__zero_reg__
 186:main.c        ****   for (uint nr_uzyt_clip = 0; nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 1088               		.loc 1 186 0
 1089 0444 D12C      		mov r13,__zero_reg__
 185:main.c        ****   uchar wolne_numery = 0;
 1090               		.loc 1 185 0
 1091 0446 C12C      		mov r12,__zero_reg__
 1092               	.LVL84:
 1093               	.L61:
 1094               	.LBB385:
 189:main.c        ****       ++aktywne_numery;
 1095               		.loc 1 189 0
 1096 0448 C701      		movw r24,r14
 1097 044a 0E94 0000 		call eeprom_read_byte
 1098               	.LVL85:
 1099 044e 8F3F      		cpi r24,lo8(-1)
 1100 0450 01F0      		breq .L59
 190:main.c        ****     else
 1101               		.loc 1 190 0
 1102 0452 C394      		inc r12
 1103               	.LVL86:
 1104               	.L60:
 1105 0454 F5E0      		ldi r31,5
 1106 0456 EF0E      		add r14,r31
 1107 0458 F11C      		adc r15,__zero_reg__
 187:main.c        ****        ++nr_uzyt_clip) {
 1108               		.loc 1 187 0
 1109 045a 88EA      		ldi r24,-88
 1110 045c E816      		cp r14,r24
 1111 045e 8FE0      		ldi r24,15
 1112 0460 F806      		cpc r15,r24
 1113 0462 01F4      		brne .L61
 1114               	.LVL87:
 1115               	.LBE385:
 1116               	.LBB386:
 1117               	.LBB387:
 1118               		.loc 6 527 0
 1119 0464 4AE0      		ldi r20,lo8(10)
 1120 0466 BE01      		movw r22,r28
 1121 0468 8C2D      		mov r24,r12
 1122 046a 90E0      		ldi r25,0
 1123 046c 0E94 0000 		call __utoa_ncheck
 1124               	.LVL88:
 1125               	.LBE387:
 1126               	.LBE386:
 195:main.c        ****   *ptr++ = '/';
 1127               		.loc 1 195 0
 1128               		0:
 1129 0470 0990      		ld __tmp_reg__,Y+
 1130 0472 0020      		tst __tmp_reg__
 1131 0474 01F4      		brne 0b
 1132               	.LVL89:
 1133 0476 2197      		sbiw r28,1
 1134               	.LVL90:
 196:main.c        ****   utoa(wolne_numery, ptr, 10);
 1135               		.loc 1 196 0
 1136 0478 7E01      		movw r14,r28
 1137 047a EFEF      		ldi r30,-1
 1138 047c EE1A      		sub r14,r30
 1139 047e FE0A      		sbc r15,r30
 1140               	.LVL91:
 1141 0480 8FE2      		ldi r24,lo8(47)
 1142 0482 8883      		st Y,r24
 1143               	.LVL92:
 1144               	.LBB388:
 1145               	.LBB389:
 1146               		.loc 6 527 0
 1147 0484 4AE0      		ldi r20,lo8(10)
 1148 0486 B701      		movw r22,r14
 1149 0488 8D2D      		mov r24,r13
 1150 048a 90E0      		ldi r25,0
 1151 048c 0E94 0000 		call __utoa_ncheck
 1152               	.LVL93:
 1153               	.LBE389:
 1154               	.LBE388:
 198:main.c        ****   *buf_sms = ptr;
 1155               		.loc 1 198 0
 1156 0490 F701      		movw r30,r14
 1157               		0:
 1158 0492 0190      		ld __tmp_reg__,Z+
 1159 0494 0020      		tst __tmp_reg__
 1160 0496 01F4      		brne 0b
 1161 0498 CF01      		movw r24,r30
 1162               	.LVL94:
 1163 049a 0197      		sbiw r24,1
 1164               	.LVL95:
 199:main.c        **** }
 1165               		.loc 1 199 0
 1166 049c F801      		movw r30,r16
 1167               	.LVL96:
 1168 049e 9183      		std Z+1,r25
 1169 04a0 8083      		st Z,r24
 1170               	/* epilogue start */
 200:main.c        **** 
 1171               		.loc 1 200 0
 1172 04a2 DF91      		pop r29
 1173 04a4 CF91      		pop r28
 1174 04a6 1F91      		pop r17
 1175 04a8 0F91      		pop r16
 1176               	.LVL97:
 1177 04aa FF90      		pop r15
 1178 04ac EF90      		pop r14
 1179               	.LVL98:
 1180 04ae DF90      		pop r13
 1181               	.LVL99:
 1182 04b0 CF90      		pop r12
 1183               	.LVL100:
 1184 04b2 0895      		ret
 1185               	.LVL101:
 1186               	.L59:
 1187               	.LBB390:
 192:main.c        ****   }
 1188               		.loc 1 192 0
 1189 04b4 D394      		inc r13
 1190               	.LVL102:
 1191 04b6 00C0      		rjmp .L60
 1192               	.LBE390:
 1193               		.cfi_endproc
 1194               	.LFE29:
 1196               		.section	.rodata.str1.1,"aMS",@progbits,1
 1197               	.LC0:
 1198 0000 4861 726D 		.string	"Harmonogram: %02d:%02d %02d:%02d"
 1198      6F6E 6F67 
 1198      7261 6D3A 
 1198      2025 3032 
 1198      643A 2530 
 1199               		.text
 1200               	.global	generuj_raport_stanu_urzadzenia
 1202               	generuj_raport_stanu_urzadzenia:
 1203               	.LFB30:
 205:main.c        ****   uchar *sms = (char *)tekst_wysylanego_smsa;
 1204               		.loc 1 205 0
 1205               		.cfi_startproc
 1206 04b8 1F93      		push r17
 1207               	.LCFI38:
 1208               		.cfi_def_cfa_offset 3
 1209               		.cfi_offset 17, -2
 1210 04ba CF93      		push r28
 1211               	.LCFI39:
 1212               		.cfi_def_cfa_offset 4
 1213               		.cfi_offset 28, -3
 1214 04bc DF93      		push r29
 1215               	.LCFI40:
 1216               		.cfi_def_cfa_offset 5
 1217               		.cfi_offset 29, -4
 1218 04be 00D0      		rcall .
 1219               	.LCFI41:
 1220               		.cfi_def_cfa_offset 7
 1221 04c0 CDB7      		in r28,__SP_L__
 1222 04c2 DEB7      		in r29,__SP_H__
 1223               	.LCFI42:
 1224               		.cfi_def_cfa_register 28
 1225               	/* prologue: function */
 1226               	/* frame size = 2 */
 1227               	/* stack size = 5 */
 1228               	.L__stack_usage = 5
 207:main.c        ****   *sms++ = '\n';
 1229               		.loc 1 207 0
 1230 04c4 8AE2      		ldi r24,lo8(42)
 1231 04c6 8093 0000 		sts tekst_wysylanego_smsa,r24
 208:main.c        ****   generuj_raport_sieci(&sms);
 1232               		.loc 1 208 0
 1233 04ca 80E0      		ldi r24,lo8(tekst_wysylanego_smsa+2)
 1234 04cc 90E0      		ldi r25,hi8(tekst_wysylanego_smsa+2)
 1235 04ce 9A83      		std Y+2,r25
 1236 04d0 8983      		std Y+1,r24
 1237 04d2 1AE0      		ldi r17,lo8(10)
 1238 04d4 1093 0000 		sts tekst_wysylanego_smsa+1,r17
 209:main.c        ****   *sms++ = '\n';
 1239               		.loc 1 209 0
 1240 04d8 CE01      		movw r24,r28
 1241 04da 0196      		adiw r24,1
 1242 04dc 0E94 0000 		call generuj_raport_sieci
 1243               	.LVL103:
 210:main.c        ****   generuj_raport_uzytkownikow_1(&sms);
 1244               		.loc 1 210 0
 1245 04e0 E981      		ldd r30,Y+1
 1246 04e2 FA81      		ldd r31,Y+2
 1247 04e4 CF01      		movw r24,r30
 1248 04e6 0196      		adiw r24,1
 1249 04e8 9A83      		std Y+2,r25
 1250 04ea 8983      		std Y+1,r24
 1251 04ec 1083      		st Z,r17
 211:main.c        ****   *sms++ = '\n';
 1252               		.loc 1 211 0
 1253 04ee CE01      		movw r24,r28
 1254 04f0 0196      		adiw r24,1
 1255 04f2 0E94 0000 		call generuj_raport_uzytkownikow_1
 1256               	.LVL104:
 212:main.c        **** 
 1257               		.loc 1 212 0
 1258 04f6 E981      		ldd r30,Y+1
 1259 04f8 FA81      		ldd r31,Y+2
 1260 04fa CF01      		movw r24,r30
 1261 04fc 0196      		adiw r24,1
 1262 04fe 9A83      		std Y+2,r25
 1263 0500 8983      		std Y+1,r24
 1264 0502 1083      		st Z,r17
 215:main.c        ****     strcpy_P((char *)sms, PSTR("Status: Zablokowany"));
 1265               		.loc 1 215 0
 1266 0504 2091 0000 		lds r18,blokada_systemu
 1267 0508 8981      		ldd r24,Y+1
 1268 050a 9A81      		ldd r25,Y+2
 216:main.c        ****   } else {
 1269               		.loc 1 216 0
 1270 050c 60E0      		ldi r22,lo8(__c.3035)
 1271 050e 70E0      		ldi r23,hi8(__c.3035)
 215:main.c        ****     strcpy_P((char *)sms, PSTR("Status: Zablokowany"));
 1272               		.loc 1 215 0
 1273 0510 2111      		cpse r18,__zero_reg__
 1274 0512 00C0      		rjmp .L74
 218:main.c        ****   }
 1275               		.loc 1 218 0
 1276 0514 60E0      		ldi r22,lo8(__c.3037)
 1277 0516 70E0      		ldi r23,hi8(__c.3037)
 1278               	.L74:
 1279 0518 0E94 0000 		call strcpy_P
 1280               	.LVL105:
 220:main.c        ****   *sms++ = '\n';
 1281               		.loc 1 220 0
 1282 051c E981      		ldd r30,Y+1
 1283 051e FA81      		ldd r31,Y+2
 1284               		0:
 1285 0520 0190      		ld __tmp_reg__,Z+
 1286 0522 0020      		tst __tmp_reg__
 1287 0524 01F4      		brne 0b
 221:main.c        **** 
 1288               		.loc 1 221 0
 1289 0526 DF01      		movw r26,r30
 1290 0528 1197      		sbiw r26,1
 1291 052a FA83      		std Y+2,r31
 1292 052c E983      		std Y+1,r30
 1293 052e 8AE0      		ldi r24,lo8(10)
 1294 0530 8C93      		st X,r24
 224:main.c        ****     strcpy_P((char *)sms, PSTR("Tryb: Prywatny"));
 1295               		.loc 1 224 0
 1296 0532 2091 0000 		lds r18,tryb_pracy
 1297 0536 8981      		ldd r24,Y+1
 1298 0538 9A81      		ldd r25,Y+2
 225:main.c        ****   } else {
 1299               		.loc 1 225 0
 1300 053a 60E0      		ldi r22,lo8(__c.3039)
 1301 053c 70E0      		ldi r23,hi8(__c.3039)
 224:main.c        ****     strcpy_P((char *)sms, PSTR("Tryb: Prywatny"));
 1302               		.loc 1 224 0
 1303 053e 2223      		tst r18
 1304 0540 01F0      		breq .L75
 227:main.c        ****   }
 1305               		.loc 1 227 0
 1306 0542 60E0      		ldi r22,lo8(__c.3041)
 1307 0544 70E0      		ldi r23,hi8(__c.3041)
 1308               	.L75:
 1309 0546 0E94 0000 		call strcpy_P
 1310               	.LVL106:
 229:main.c        **** 
 1311               		.loc 1 229 0
 1312 054a 8981      		ldd r24,Y+1
 1313 054c 9A81      		ldd r25,Y+2
 1314 054e FC01      		movw r30,r24
 1315               		0:
 1316 0550 0190      		ld __tmp_reg__,Z+
 1317 0552 0020      		tst __tmp_reg__
 1318 0554 01F4      		brne 0b
 1319 0556 CF01      		movw r24,r30
 1320 0558 0197      		sbiw r24,1
 1321 055a 9A83      		std Y+2,r25
 1322 055c 8983      		std Y+1,r24
 231:main.c        ****     strcpy_P((char *)sms, PSTR(" CLIP"));
 1323               		.loc 1 231 0
 1324 055e 2091 0000 		lds r18,tryb_clip
 232:main.c        ****   } else {
 1325               		.loc 1 232 0
 1326 0562 60E0      		ldi r22,lo8(__c.3043)
 1327 0564 70E0      		ldi r23,hi8(__c.3043)
 231:main.c        ****     strcpy_P((char *)sms, PSTR(" CLIP"));
 1328               		.loc 1 231 0
 1329 0566 2111      		cpse r18,__zero_reg__
 1330 0568 00C0      		rjmp .L76
 234:main.c        ****   }
 1331               		.loc 1 234 0
 1332 056a 60E0      		ldi r22,lo8(__c.3045)
 1333 056c 70E0      		ldi r23,hi8(__c.3045)
 1334               	.L76:
 1335 056e 0E94 0000 		call strcpy_P
 1336               	.LVL107:
 236:main.c        ****   *sms++ = '\n';
 1337               		.loc 1 236 0
 1338 0572 E981      		ldd r30,Y+1
 1339 0574 FA81      		ldd r31,Y+2
 1340               		0:
 1341 0576 0190      		ld __tmp_reg__,Z+
 1342 0578 0020      		tst __tmp_reg__
 1343 057a 01F4      		brne 0b
 237:main.c        **** 
 1344               		.loc 1 237 0
 1345 057c DF01      		movw r26,r30
 1346 057e 1197      		sbiw r26,1
 1347 0580 FA83      		std Y+2,r31
 1348 0582 E983      		std Y+1,r30
 1349 0584 8AE0      		ldi r24,lo8(10)
 1350 0586 8C93      		st X,r24
 239:main.c        ****     strcpy_P((char *)sms, PSTR("Harmonogram: Wylaczony"));
 1351               		.loc 1 239 0
 1352 0588 8091 0000 		lds r24,czas_start_h
 1353 058c 8F3F      		cpi r24,lo8(-1)
 1354 058e 01F4      		brne .L70
 240:main.c        ****   } else {
 1355               		.loc 1 240 0
 1356 0590 60E0      		ldi r22,lo8(__c.3047)
 1357 0592 70E0      		ldi r23,hi8(__c.3047)
 1358 0594 8981      		ldd r24,Y+1
 1359 0596 9A81      		ldd r25,Y+2
 1360 0598 0E94 0000 		call strcpy_P
 1361               	.LVL108:
 1362               	.L71:
 245:main.c        ****   *sms++ = '\n';
 1363               		.loc 1 245 0
 1364 059c E981      		ldd r30,Y+1
 1365 059e FA81      		ldd r31,Y+2
 1366               		0:
 1367 05a0 0190      		ld __tmp_reg__,Z+
 1368 05a2 0020      		tst __tmp_reg__
 1369 05a4 01F4      		brne 0b
 246:main.c        **** 
 1370               		.loc 1 246 0
 1371 05a6 DF01      		movw r26,r30
 1372 05a8 1197      		sbiw r26,1
 1373 05aa FA83      		std Y+2,r31
 1374 05ac E983      		std Y+1,r30
 1375 05ae 8AE0      		ldi r24,lo8(10)
 1376 05b0 8C93      		st X,r24
 249:main.c        ****     strcpy_P((char *)sms, PSTR("Skryba: Wlaczona"));
 1377               		.loc 1 249 0
 1378 05b2 2091 0000 		lds r18,skryba_wlaczona
 1379 05b6 8981      		ldd r24,Y+1
 1380 05b8 9A81      		ldd r25,Y+2
 250:main.c        ****   } else {
 1381               		.loc 1 250 0
 1382 05ba 60E0      		ldi r22,lo8(__c.3049)
 1383 05bc 70E0      		ldi r23,hi8(__c.3049)
 249:main.c        ****     strcpy_P((char *)sms, PSTR("Skryba: Wlaczona"));
 1384               		.loc 1 249 0
 1385 05be 2111      		cpse r18,__zero_reg__
 1386 05c0 00C0      		rjmp .L77
 252:main.c        ****   }
 1387               		.loc 1 252 0
 1388 05c2 60E0      		ldi r22,lo8(__c.3051)
 1389 05c4 70E0      		ldi r23,hi8(__c.3051)
 1390               	.L77:
 1391 05c6 0E94 0000 		call strcpy_P
 1392               	.LVL109:
 254:main.c        ****   *sms++ = '\n';
 1393               		.loc 1 254 0
 1394 05ca E981      		ldd r30,Y+1
 1395 05cc FA81      		ldd r31,Y+2
 1396               		0:
 1397 05ce 0190      		ld __tmp_reg__,Z+
 1398 05d0 0020      		tst __tmp_reg__
 1399 05d2 01F4      		brne 0b
 255:main.c        **** 
 1400               		.loc 1 255 0
 1401 05d4 DF01      		movw r26,r30
 1402 05d6 1197      		sbiw r26,1
 1403 05d8 FA83      		std Y+2,r31
 1404 05da E983      		std Y+1,r30
 1405 05dc 8AE0      		ldi r24,lo8(10)
 1406 05de 8C93      		st X,r24
 258:main.c        **** }
 1407               		.loc 1 258 0
 1408 05e0 60E0      		ldi r22,lo8(tekst_demo.3053)
 1409 05e2 70E0      		ldi r23,hi8(tekst_demo.3053)
 1410 05e4 8981      		ldd r24,Y+1
 1411 05e6 9A81      		ldd r25,Y+2
 1412 05e8 0E94 0000 		call strcpy_P
 1413               	.LVL110:
 1414               	/* epilogue start */
 259:main.c        **** 
 1415               		.loc 1 259 0
 1416 05ec 0F90      		pop __tmp_reg__
 1417 05ee 0F90      		pop __tmp_reg__
 1418 05f0 DF91      		pop r29
 1419 05f2 CF91      		pop r28
 1420 05f4 1F91      		pop r17
 1421 05f6 0895      		ret
 1422               	.L70:
 242:main.c        ****             (int)czas_start_m, (int)czas_stop_h, (int)czas_stop_m);
 1423               		.loc 1 242 0
 1424 05f8 9091 0000 		lds r25,czas_stop_m
 1425 05fc 1F92      		push __zero_reg__
 1426 05fe 9F93      		push r25
 1427 0600 9091 0000 		lds r25,czas_stop_h
 1428 0604 1F92      		push __zero_reg__
 1429 0606 9F93      		push r25
 1430 0608 9091 0000 		lds r25,czas_start_m
 1431 060c 1F92      		push __zero_reg__
 1432 060e 9F93      		push r25
 1433 0610 1F92      		push __zero_reg__
 1434 0612 8F93      		push r24
 1435 0614 80E0      		ldi r24,lo8(.LC0)
 1436 0616 90E0      		ldi r25,hi8(.LC0)
 1437 0618 9F93      		push r25
 1438 061a 8F93      		push r24
 1439 061c 8A81      		ldd r24,Y+2
 1440 061e 8F93      		push r24
 1441 0620 8981      		ldd r24,Y+1
 1442 0622 8F93      		push r24
 1443 0624 0E94 0000 		call sprintf
 1444               	.LVL111:
 1445 0628 0FB6      		in __tmp_reg__,__SREG__
 1446 062a F894      		cli
 1447 062c DEBF      		out __SP_H__,r29
 1448 062e 0FBE      		out __SREG__,__tmp_reg__
 1449 0630 CDBF      		out __SP_L__,r28
 1450 0632 00C0      		rjmp .L71
 1451               		.cfi_endproc
 1452               	.LFE30:
 1454               	.global	czy_numer_jest_super_userem
 1456               	czy_numer_jest_super_userem:
 1457               	.LFB31:
 262:main.c        ****   // Konwertuj numer do formatu EEPROM
 1458               		.loc 1 262 0
 1459               		.cfi_startproc
 1460               	.LVL112:
 1461 0634 0F93      		push r16
 1462               	.LCFI43:
 1463               		.cfi_def_cfa_offset 3
 1464               		.cfi_offset 16, -2
 1465 0636 1F93      		push r17
 1466               	.LCFI44:
 1467               		.cfi_def_cfa_offset 4
 1468               		.cfi_offset 17, -3
 1469 0638 CF93      		push r28
 1470               	.LCFI45:
 1471               		.cfi_def_cfa_offset 5
 1472               		.cfi_offset 28, -4
 1473 063a DF93      		push r29
 1474               	.LCFI46:
 1475               		.cfi_def_cfa_offset 6
 1476               		.cfi_offset 29, -5
 1477 063c 00D0      		rcall .
 1478 063e 00D0      		rcall .
 1479 0640 1F92      		push __zero_reg__
 1480               	.LCFI47:
 1481               		.cfi_def_cfa_offset 11
 1482 0642 CDB7      		in r28,__SP_L__
 1483 0644 DEB7      		in r29,__SP_H__
 1484               	.LCFI48:
 1485               		.cfi_def_cfa_register 28
 1486               	/* prologue: function */
 1487               	/* frame size = 5 */
 1488               	/* stack size = 9 */
 1489               	.L__stack_usage = 9
 267:main.c        **** 
 1490               		.loc 1 267 0
 1491 0646 FC01      		movw r30,r24
 1492               		0:
 1493 0648 0190      		ld __tmp_reg__,Z+
 1494 064a 0020      		tst __tmp_reg__
 1495 064c 01F4      		brne 0b
 1496 064e BF01      		movw r22,r30
 265:main.c        ****       (uchar *)numer_telefonu,
 1497               		.loc 1 265 0
 1498 0650 6150      		subi r22,1
 1499 0652 7109      		sbc r23,__zero_reg__
 1500 0654 AE01      		movw r20,r28
 1501 0656 4F5F      		subi r20,-1
 1502 0658 5F4F      		sbci r21,-1
 1503 065a 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 1504               	.LVL113:
 1505 065e 0AE8      		ldi r16,lo8(-118)
 1506 0660 1FE0      		ldi r17,lo8(15)
 1507               	.LVL114:
 1508               	.L80:
 1509               	.LBB391:
 272:main.c        ****             temp_buf, (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt))) {
 1510               		.loc 1 272 0
 1511 0662 B801      		movw r22,r16
 1512 0664 CE01      		movw r24,r28
 1513 0666 0196      		adiw r24,1
 1514 0668 0E94 0000 		call porownaj_numer_telefonu_blok
 1515               	.LVL115:
 1516 066c 8111      		cpse r24,__zero_reg__
 1517 066e 00C0      		rjmp .L81
 1518 0670 0B5F      		subi r16,-5
 1519 0672 1F4F      		sbci r17,-1
 270:main.c        ****        ++nr_uzyt) {
 1520               		.loc 1 270 0
 1521 0674 083A      		cpi r16,-88
 1522 0676 FFE0      		ldi r31,15
 1523 0678 1F07      		cpc r17,r31
 1524 067a 01F4      		brne .L80
 1525               	.L78:
 1526               	/* epilogue start */
 1527               	.LBE391:
 278:main.c        **** 
 1528               		.loc 1 278 0
 1529 067c 0F90      		pop __tmp_reg__
 1530 067e 0F90      		pop __tmp_reg__
 1531 0680 0F90      		pop __tmp_reg__
 1532 0682 0F90      		pop __tmp_reg__
 1533 0684 0F90      		pop __tmp_reg__
 1534 0686 DF91      		pop r29
 1535 0688 CF91      		pop r28
 1536 068a 1F91      		pop r17
 1537 068c 0F91      		pop r16
 1538 068e 0895      		ret
 1539               	.L81:
 1540               	.LBB392:
 274:main.c        ****     }
 1541               		.loc 1 274 0
 1542 0690 8FEF      		ldi r24,lo8(-1)
 1543 0692 00C0      		rjmp .L78
 1544               	.LBE392:
 1545               		.cfi_endproc
 1546               	.LFE31:
 1548               	.global	ustaw_wyjscie_clip
 1550               	ustaw_wyjscie_clip:
 1551               	.LFB32:
 280:main.c        ****   stan_wyjscie[0] = TRUE;
 1552               		.loc 1 280 0
 1553               		.cfi_startproc
 1554               	/* prologue: function */
 1555               	/* frame size = 0 */
 1556               	/* stack size = 0 */
 1557               	.L__stack_usage = 0
 281:main.c        ****   licznik_przelacznik_wyjscia[0] = 2 * 10ul; // 2 sekundy
 1558               		.loc 1 281 0
 1559 0694 8FEF      		ldi r24,lo8(-1)
 1560 0696 8093 0000 		sts stan_wyjscie,r24
 282:main.c        **** }
 1561               		.loc 1 282 0
 1562 069a 84E1      		ldi r24,lo8(20)
 1563 069c 90E0      		ldi r25,0
 1564 069e A0E0      		ldi r26,0
 1565 06a0 B0E0      		ldi r27,0
 1566 06a2 8093 0000 		sts licznik_przelacznik_wyjscia,r24
 1567 06a6 9093 0000 		sts licznik_przelacznik_wyjscia+1,r25
 1568 06aa A093 0000 		sts licznik_przelacznik_wyjscia+2,r26
 1569 06ae B093 0000 		sts licznik_przelacznik_wyjscia+3,r27
 1570               	/* epilogue start */
 283:main.c        **** 
 1571               		.loc 1 283 0
 1572 06b2 0895      		ret
 1573               		.cfi_endproc
 1574               	.LFE32:
 1576               		.section	.rodata.str1.1
 1577               	.LC1:
 1578 0021 2530 3264 		.string	"%02d:%02d:%02d"
 1578      3A25 3032 
 1578      643A 2530 
 1578      3264 00
 1579               	.LC2:
 1580 0030 2B43 434C 		.string	"+CCLK=\"24/01/01,%02d:%02d:%02d+04\""
 1580      4B3D 2232 
 1580      342F 3031 
 1580      2F30 312C 
 1580      2530 3264 
 1581               	.LC3:
 1582 0053 3A20 00   		.string	": "
 1583               	.LC4:
 1584 0056 4F4B 00   		.string	"OK"
 1585               	.LC5:
 1586 0059 4272 616B 		.string	"Brak takiego numeru w systemie"
 1586      2074 616B 
 1586      6965 676F 
 1586      206E 756D 
 1586      6572 7520 
 1587               	.LC6:
 1588 0078 5770 6973 		.string	"Wpisz numer jaki sprawdzasz, np: USER 793557357"
 1588      7A20 6E75 
 1588      6D65 7220 
 1588      6A61 6B69 
 1588      2073 7072 
 1589               		.text
 1590               	.global	wykonanie_polecenia_sms
 1592               	wykonanie_polecenia_sms:
 1593               	.LFB39:
 378:main.c        ****   tekst_odebranego_smsa[MAX_LICZBA_ZNAKOW_SMS] = 0; // (1) dla pewnoci
 1594               		.loc 1 378 0
 1595               		.cfi_startproc
 1596 06b4 CF92      		push r12
 1597               	.LCFI49:
 1598               		.cfi_def_cfa_offset 3
 1599               		.cfi_offset 12, -2
 1600 06b6 DF92      		push r13
 1601               	.LCFI50:
 1602               		.cfi_def_cfa_offset 4
 1603               		.cfi_offset 13, -3
 1604 06b8 FF92      		push r15
 1605               	.LCFI51:
 1606               		.cfi_def_cfa_offset 5
 1607               		.cfi_offset 15, -4
 1608 06ba 0F93      		push r16
 1609               	.LCFI52:
 1610               		.cfi_def_cfa_offset 6
 1611               		.cfi_offset 16, -5
 1612 06bc 1F93      		push r17
 1613               	.LCFI53:
 1614               		.cfi_def_cfa_offset 7
 1615               		.cfi_offset 17, -6
 1616 06be CF93      		push r28
 1617               	.LCFI54:
 1618               		.cfi_def_cfa_offset 8
 1619               		.cfi_offset 28, -7
 1620 06c0 DF93      		push r29
 1621               	.LCFI55:
 1622               		.cfi_def_cfa_offset 9
 1623               		.cfi_offset 29, -8
 1624 06c2 CDB7      		in r28,__SP_L__
 1625 06c4 DEB7      		in r29,__SP_H__
 1626               	.LCFI56:
 1627               		.cfi_def_cfa_register 28
 1628 06c6 2A97      		sbiw r28,10
 1629               	.LCFI57:
 1630               		.cfi_def_cfa_offset 19
 1631 06c8 0FB6      		in __tmp_reg__,__SREG__
 1632 06ca F894      		cli
 1633 06cc DEBF      		out __SP_H__,r29
 1634 06ce 0FBE      		out __SREG__,__tmp_reg__
 1635 06d0 CDBF      		out __SP_L__,r28
 1636               	/* prologue: function */
 1637               	/* frame size = 10 */
 1638               	/* stack size = 17 */
 1639               	.L__stack_usage = 17
 379:main.c        ****   watchdog_sms_arm();
 1640               		.loc 1 379 0
 1641 06d2 1092 0000 		sts wysylany_blok_SIM900+399,__zero_reg__
 1642               	.LBB432:
 1643               	.LBB433:
 315:main.c        ****   watchdog_sms_licznik_100ms = 0;
 1644               		.loc 1 315 0
 1645 06d6 8FEF      		ldi r24,lo8(-1)
 1646 06d8 8093 0000 		sts watchdog_sms_aktywny,r24
 316:main.c        **** }
 1647               		.loc 1 316 0
 1648 06dc 1092 0000 		sts watchdog_sms_licznik_100ms+1,__zero_reg__
 1649 06e0 1092 0000 		sts watchdog_sms_licznik_100ms,__zero_reg__
 1650               	.LBE433:
 1651               	.LBE432:
 381:main.c        **** 
 1652               		.loc 1 381 0
 1653 06e4 80E0      		ldi r24,lo8(wysylany_blok_SIM900+239)
 1654 06e6 90E0      		ldi r25,hi8(wysylany_blok_SIM900+239)
 1655 06e8 0E94 0000 		call interpretuj_wiadomosc_sms
 1656               	.LVL116:
 1657 06ec 182F      		mov r17,r24
 1658               	.LVL117:
 390:main.c        ****     // Aktualizuj rtc_czas z timestampu SMS (z sekundami z PDU)
 1659               		.loc 1 390 0
 1660 06ee 8091 0000 		lds r24,sms_pomijaj_aktualizacje_czasu
 1661 06f2 8111      		cpse r24,__zero_reg__
 1662 06f4 00C0      		rjmp .L85
 1663               	.LBB434:
 392:main.c        ****             sms_timestamp_minuta, sms_timestamp_sekunda);
 1664               		.loc 1 392 0
 1665 06f6 8091 0000 		lds r24,sms_timestamp_sekunda
 1666 06fa 1F92      		push __zero_reg__
 1667 06fc 8F93      		push r24
 1668 06fe 8091 0000 		lds r24,sms_timestamp_minuta
 1669 0702 1F92      		push __zero_reg__
 1670 0704 8F93      		push r24
 1671 0706 8091 0000 		lds r24,sms_timestamp_godzina
 1672 070a 1F92      		push __zero_reg__
 1673 070c 8F93      		push r24
 1674 070e 80E0      		ldi r24,lo8(.LC1)
 1675 0710 90E0      		ldi r25,hi8(.LC1)
 1676 0712 9F93      		push r25
 1677 0714 8F93      		push r24
 1678 0716 80E0      		ldi r24,lo8(rtc_czas)
 1679 0718 90E0      		ldi r25,hi8(rtc_czas)
 1680 071a 9F93      		push r25
 1681 071c 8F93      		push r24
 1682 071e 0E94 0000 		call sprintf
 1683               	.LVL118:
 397:main.c        ****             sms_timestamp_godzina, sms_timestamp_minuta, sms_timestamp_sekunda);
 1684               		.loc 1 397 0
 1685 0722 8091 0000 		lds r24,sms_timestamp_sekunda
 1686 0726 1F92      		push __zero_reg__
 1687 0728 8F93      		push r24
 1688 072a 8091 0000 		lds r24,sms_timestamp_minuta
 1689 072e 1F92      		push __zero_reg__
 1690 0730 8F93      		push r24
 1691 0732 8091 0000 		lds r24,sms_timestamp_godzina
 1692 0736 1F92      		push __zero_reg__
 1693 0738 8F93      		push r24
 1694 073a 80E0      		ldi r24,lo8(.LC2)
 1695 073c 90E0      		ldi r25,hi8(.LC2)
 1696 073e 9F93      		push r25
 1697 0740 8F93      		push r24
 1698 0742 80E0      		ldi r24,lo8(bufor_ustaw_czas)
 1699 0744 90E0      		ldi r25,hi8(bufor_ustaw_czas)
 1700 0746 9F93      		push r25
 1701 0748 8F93      		push r24
 1702 074a 0E94 0000 		call sprintf
 1703               	.LVL119:
 399:main.c        **** 
 1704               		.loc 1 399 0
 1705 074e 8EEF      		ldi r24,lo8(-2)
 1706 0750 0E94 0000 		call dodaj_komende
 1707               	.LVL120:
 402:main.c        ****       int curr_time = sms_timestamp_godzina * 60 + sms_timestamp_minuta;
 1708               		.loc 1 402 0
 1709 0754 2091 0000 		lds r18,czas_start_h
 1710 0758 0FB6      		in __tmp_reg__,__SREG__
 1711 075a F894      		cli
 1712 075c DEBF      		out __SP_H__,r29
 1713 075e 0FBE      		out __SREG__,__tmp_reg__
 1714 0760 CDBF      		out __SP_L__,r28
 1715 0762 2F3F      		cpi r18,lo8(-1)
 1716 0764 01F4      		brne .+2
 1717 0766 00C0      		rjmp .L86
 1718               	.LBB435:
 403:main.c        ****       int start_time = czas_start_h * 60 + czas_start_m;
 1719               		.loc 1 403 0
 1720 0768 3091 0000 		lds r19,sms_timestamp_godzina
 1721 076c 6CE3      		ldi r22,lo8(60)
 1722 076e 8091 0000 		lds r24,sms_timestamp_minuta
 1723 0772 90E0      		ldi r25,0
 1724 0774 369F      		mul r19,r22
 1725 0776 800D      		add r24,r0
 1726 0778 911D      		adc r25,r1
 1727 077a 1124      		clr __zero_reg__
 1728               	.LVL121:
 404:main.c        ****       int stop_time = czas_stop_h * 60 + czas_stop_m;
 1729               		.loc 1 404 0
 1730 077c 4091 0000 		lds r20,czas_start_m
 1731 0780 50E0      		ldi r21,0
 1732 0782 269F      		mul r18,r22
 1733 0784 400D      		add r20,r0
 1734 0786 511D      		adc r21,r1
 1735 0788 1124      		clr __zero_reg__
 1736               	.LVL122:
 405:main.c        **** 
 1737               		.loc 1 405 0
 1738 078a 7091 0000 		lds r23,czas_stop_h
 1739 078e 2091 0000 		lds r18,czas_stop_m
 1740 0792 30E0      		ldi r19,0
 1741 0794 769F      		mul r23,r22
 1742 0796 200D      		add r18,r0
 1743 0798 311D      		adc r19,r1
 1744 079a 1124      		clr __zero_reg__
 1745               	.LVL123:
 407:main.c        ****         // Normalny przedział (np. 08:00 - 16:00)
 1746               		.loc 1 407 0
 1747 079c 2417      		cp r18,r20
 1748 079e 3507      		cpc r19,r21
 1749 07a0 04F0      		brlt .L87
 410:main.c        ****       } else {
 1750               		.loc 1 410 0
 1751 07a2 8417      		cp r24,r20
 1752 07a4 9507      		cpc r25,r21
 1753 07a6 04F0      		brlt .L113
 410:main.c        ****       } else {
 1754               		.loc 1 410 0 is_stmt 0 discriminator 2
 1755 07a8 41E0      		ldi r20,lo8(1)
 1756               	.LVL124:
 1757 07aa 2817      		cp r18,r24
 1758 07ac 3907      		cpc r19,r25
 1759 07ae 04F0      		brlt .L88
 1760 07b0 40E0      		ldi r20,0
 1761               	.L88:
 409:main.c        ****             !(curr_time >= start_time && curr_time <= stop_time);
 1762               		.loc 1 409 0 is_stmt 1
 1763 07b2 4093 0000 		sts blokada_sterowania_czasowa,r20
 1764               	.LVL125:
 1765               	.L85:
 1766               	.LBE435:
 1767               	.LBE434:
 422:main.c        **** 
 1768               		.loc 1 422 0
 1769 07b6 1092 0000 		sts sms_pomijaj_aktualizacje_czasu,__zero_reg__
 425:main.c        ****     // Gdy zablokowany, akceptuj tylko START i REPORT
 1770               		.loc 1 425 0
 1771 07ba 8091 0000 		lds r24,blokada_systemu
 1772 07be 8823      		tst r24
 1773 07c0 01F0      		breq .L92
 427:main.c        ****         komenda != INTERPRETACJA_SMS_RAPORT) {
 1774               		.loc 1 427 0
 1775 07c2 8DEF      		ldi r24,lo8(-3)
 1776 07c4 810F      		add r24,r17
 1777 07c6 8230      		cpi r24,lo8(2)
 1778 07c8 00F0      		brlo .L92
 432:main.c        ****           1) {
 1779               		.loc 1 432 0
 1780 07ca 87EF      		ldi r24,lo8(-9)
 1781 07cc 9FE0      		ldi r25,lo8(15)
 1782 07ce 0E94 0000 		call eeprom_read_byte
 1783               	.LVL126:
 1784 07d2 8130      		cpi r24,lo8(1)
 1785 07d4 01F4      		brne .L92
 434:main.c        ****         usun_zablokowany_sms();
 1786               		.loc 1 434 0
 1787 07d6 62E0      		ldi r22,lo8(2)
 1788 07d8 0E94 0000 		call zapisz_debug_do_eeprom
 1789               	.LVL127:
 435:main.c        ****         return;
 1790               		.loc 1 435 0
 1791 07dc 0E94 0000 		call usun_zablokowany_sms
 1792               	.LVL128:
 1793               	.L84:
 1794               	/* epilogue start */
 671:main.c        **** 
 1795               		.loc 1 671 0
 1796 07e0 2A96      		adiw r28,10
 1797 07e2 0FB6      		in __tmp_reg__,__SREG__
 1798 07e4 F894      		cli
 1799 07e6 DEBF      		out __SP_H__,r29
 1800 07e8 0FBE      		out __SREG__,__tmp_reg__
 1801 07ea CDBF      		out __SP_L__,r28
 1802 07ec DF91      		pop r29
 1803 07ee CF91      		pop r28
 1804 07f0 1F91      		pop r17
 1805 07f2 0F91      		pop r16
 1806 07f4 FF90      		pop r15
 1807 07f6 DF90      		pop r13
 1808 07f8 CF90      		pop r12
 1809 07fa 0895      		ret
 1810               	.LVL129:
 1811               	.L113:
 1812               	.LBB437:
 1813               	.LBB436:
 410:main.c        ****       } else {
 1814               		.loc 1 410 0
 1815 07fc 41E0      		ldi r20,lo8(1)
 1816               	.LVL130:
 1817 07fe 00C0      		rjmp .L88
 1818               	.LVL131:
 1819               	.L87:
 414:main.c        ****       }
 1820               		.loc 1 414 0
 1821 0800 8417      		cp r24,r20
 1822 0802 9507      		cpc r25,r21
 1823 0804 04F4      		brge .L114
 414:main.c        ****       }
 1824               		.loc 1 414 0 is_stmt 0 discriminator 1
 1825 0806 41E0      		ldi r20,lo8(1)
 1826               	.LVL132:
 1827 0808 2817      		cp r18,r24
 1828 080a 3907      		cpc r19,r25
 1829 080c 04F0      		brlt .L91
 1830 080e 40E0      		ldi r20,0
 1831               	.L91:
 1832 0810 842F      		mov r24,r20
 1833               	.LVL133:
 1834               	.L90:
 413:main.c        ****             !(curr_time >= start_time || curr_time <= stop_time);
 1835               		.loc 1 413 0 is_stmt 1
 1836 0812 8093 0000 		sts blokada_sterowania_czasowa,r24
 1837 0816 00C0      		rjmp .L85
 1838               	.LVL134:
 1839               	.L114:
 414:main.c        ****       }
 1840               		.loc 1 414 0
 1841 0818 80E0      		ldi r24,0
 1842               	.LVL135:
 1843 081a 00C0      		rjmp .L90
 1844               	.LVL136:
 1845               	.L86:
 1846               	.LBE436:
 417:main.c        ****     }
 1847               		.loc 1 417 0
 1848 081c 1092 0000 		sts blokada_sterowania_czasowa,__zero_reg__
 1849 0820 00C0      		rjmp .L85
 1850               	.L92:
 1851               	.LBE437:
 442:main.c        ****       komenda == INTERPRETACJA_SMS_USER) {
 1852               		.loc 1 442 0
 1853 0822 8CEF      		ldi r24,lo8(-4)
 1854 0824 810F      		add r24,r17
 1855 0826 8230      		cpi r24,lo8(2)
 1856 0828 00F4      		brsh .L94
 444:main.c        ****       zapisz_debug_do_eeprom(1, 1);
 1857               		.loc 1 444 0
 1858 082a 8091 0000 		lds r24,licznik_report_user
 1859 082e 8830      		cpi r24,lo8(8)
 1860 0830 00F0      		brlo .L94
 1861               	.L95:
 445:main.c        ****       usun_zablokowany_sms();
 1862               		.loc 1 445 0
 1863 0832 61E0      		ldi r22,lo8(1)
 1864 0834 81E0      		ldi r24,lo8(1)
 1865 0836 0E94 0000 		call zapisz_debug_do_eeprom
 1866               	.LVL137:
 446:main.c        ****       zareaguj_na_usuniety_sms_z_powodu_limitu();
 1867               		.loc 1 446 0
 1868 083a 0E94 0000 		call usun_zablokowany_sms
 1869               	.LVL138:
 447:main.c        ****       watchdog_sms_disarm();
 1870               		.loc 1 447 0
 1871 083e 0E94 0000 		call zareaguj_na_usuniety_sms_z_powodu_limitu
 1872               	.LVL139:
 1873               	.L98:
 670:main.c        **** }
 1874               		.loc 1 670 0
 1875 0842 0E94 0000 		call watchdog_sms_disarm
 1876               	.LVL140:
 1877 0846 00C0      		rjmp .L84
 1878               	.LVL141:
 1879               	.L94:
 454:main.c        ****     // Same number check
 1880               		.loc 1 454 0
 1881 0848 8091 0000 		lds r24,flaga_wysylanie_smsa
 1882 084c 8111      		cpse r24,__zero_reg__
 1883 084e 00C0      		rjmp .L95
 1884 0850 E0E0      		ldi r30,lo8(komendy_kolejka)
 1885 0852 F0E0      		ldi r31,hi8(komendy_kolejka)
 474:main.c        ****   for (uchar i = 0; i < LICZBA_KOMEND; ++i) {
 1886               		.loc 1 474 0
 1887 0854 20E0      		ldi r18,0
 473:main.c        ****   uchar liczba_wszystkich_komend = 0;
 1888               		.loc 1 473 0
 1889 0856 90E0      		ldi r25,0
 1890               	.L97:
 1891               	.LVL142:
 1892               	.LBB438:
 476:main.c        ****       ++liczba_wszystkich_komend;
 1893               		.loc 1 476 0
 1894 0858 8191      		ld r24,Z+
 1895               	.LVL143:
 1896 085a 8823      		tst r24
 1897 085c 01F0      		breq .L96
 477:main.c        ****       if (komendy_kolejka[i] >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
 1898               		.loc 1 477 0
 1899 085e 2F5F      		subi r18,lo8(-(1))
 1900               	.LVL144:
 478:main.c        ****           komendy_kolejka[i] <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
 1901               		.loc 1 478 0
 1902 0860 835D      		subi r24,lo8(-(45))
 1903 0862 8230      		cpi r24,lo8(2)
 1904 0864 00F4      		brsh .L96
 480:main.c        ****     }
 1905               		.loc 1 480 0
 1906 0866 9F5F      		subi r25,lo8(-(1))
 1907               	.LVL145:
 1908               	.L96:
 475:main.c        ****     if (komendy_kolejka[i] != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 1909               		.loc 1 475 0 discriminator 2
 1910 0868 80E0      		ldi r24,hi8(komendy_kolejka+30)
 1911 086a E030      		cpi r30,lo8(komendy_kolejka+30)
 1912 086c F807      		cpc r31,r24
 1913 086e 01F4      		brne .L97
 1914               	.LBE438:
 484:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 1915               		.loc 1 484 0
 1916 0870 2332      		cpi r18,lo8(35)
 1917 0872 00F4      		brsh .L95
 492:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 1918               		.loc 1 492 0
 1919 0874 9630      		cpi r25,lo8(6)
 1920 0876 00F4      		brsh .L95
 500:main.c        ****   case INTERPRETACJA_SMS_POPRAWNY:
 1921               		.loc 1 500 0
 1922 0878 1C30      		cpi r17,lo8(12)
 1923 087a 00F4      		brsh .L98
 1924 087c E12F      		mov r30,r17
 1925               	.LVL146:
 1926 087e F0E0      		ldi r31,0
 1927 0880 E050      		subi r30,lo8(-(gs(.L100)))
 1928 0882 F040      		sbci r31,hi8(-(gs(.L100)))
 1929 0884 0C94 0000 		jmp __tablejump2__
 1930               		.p2align	1
 1931               	.L100:
 1932 0888 0000      		.word gs(.L99)
 1933 088a 0000      		.word gs(.L98)
 1934 088c 0000      		.word gs(.L98)
 1935 088e 0000      		.word gs(.L125)
 1936 0890 0000      		.word gs(.L102)
 1937 0892 0000      		.word gs(.L103)
 1938 0894 0000      		.word gs(.L104)
 1939 0896 0000      		.word gs(.L105)
 1940 0898 0000      		.word gs(.L106)
 1941 089a 0000      		.word gs(.L98)
 1942 089c 0000      		.word gs(.L98)
 1943 089e 0000      		.word gs(.L107)
 1944               	.L99:
 505:main.c        ****     zapisz_debug_do_eeprom(0, 3);
 1945               		.loc 1 505 0
 1946 08a0 81E0      		ldi r24,lo8(1)
 1947 08a2 8093 0000 		sts liczba_blyskow_led,r24
 1948 08a6 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 506:main.c        ****     break;
 1949               		.loc 1 506 0
 1950 08aa 63E0      		ldi r22,lo8(3)
 1951 08ac 80E0      		ldi r24,0
 1952               	.LVL147:
 1953               	.L127:
 518:main.c        ****     break;
 1954               		.loc 1 518 0
 1955 08ae 0E94 0000 		call zapisz_debug_do_eeprom
 1956               	.LVL148:
 519:main.c        ****   }
 1957               		.loc 1 519 0
 1958 08b2 00C0      		rjmp .L98
 1959               	.LVL149:
 1960               	.L102:
 510:main.c        ****     timer_report_user_100ms = OKNO_CZASOWE_REPORT_USER_100MS;
 1961               		.loc 1 510 0
 1962 08b4 8091 0000 		lds r24,licznik_report_user
 1963 08b8 8F5F      		subi r24,lo8(-(1))
 1964 08ba 8093 0000 		sts licznik_report_user,r24
 511:main.c        **** 
 1965               		.loc 1 511 0
 1966 08be 8CE2      		ldi r24,lo8(44)
 1967 08c0 91E0      		ldi r25,lo8(1)
 1968 08c2 9093 0000 		sts timer_report_user_100ms+1,r25
 1969 08c6 8093 0000 		sts timer_report_user_100ms,r24
 513:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 1970               		.loc 1 513 0
 1971 08ca 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 1972 08cc 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 1973 08ce 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 1974 08d0 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 1975 08d2 0E94 0000 		call strcpy
 1976               	.LVL150:
 515:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 1977               		.loc 1 515 0
 1978 08d6 0E94 0000 		call generuj_raport_stanu_urzadzenia
 1979               	.LVL151:
 516:main.c        ****     zapal_diode_led_blyski(2); // Komenda REPORT - 2 blyski
 1980               		.loc 1 516 0
 1981 08da 83ED      		ldi r24,lo8(-45)
 1982 08dc 0E94 0000 		call dodaj_komende
 1983               	.LVL152:
 517:main.c        ****     zapisz_debug_do_eeprom(1, 0);
 1984               		.loc 1 517 0
 1985 08e0 82E0      		ldi r24,lo8(2)
 1986 08e2 8093 0000 		sts liczba_blyskow_led,r24
 1987 08e6 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 518:main.c        ****     break;
 1988               		.loc 1 518 0
 1989 08ea 60E0      		ldi r22,0
 1990 08ec 81E0      		ldi r24,lo8(1)
 1991 08ee 00C0      		rjmp .L127
 1992               	.LVL153:
 1993               	.L106:
 1994               	.LBB439:
 523:main.c        ****     uchar *sms = tekst_wysylanego_smsa + strlen((char *)tekst_wysylanego_smsa);
 1995               		.loc 1 523 0
 1996 08f0 60E0      		ldi r22,lo8(__c.3127)
 1997 08f2 70E0      		ldi r23,hi8(__c.3127)
 1998 08f4 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 1999 08f6 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 2000 08f8 0E94 0000 		call strcpy_P
 2001               	.LVL154:
 524:main.c        **** 
 2002               		.loc 1 524 0
 2003 08fc 00E0      		ldi r16,lo8(tekst_wysylanego_smsa)
 2004 08fe 10E0      		ldi r17,hi8(tekst_wysylanego_smsa)
 2005 0900 F801      		movw r30,r16
 2006               		0:
 2007 0902 0190      		ld __tmp_reg__,Z+
 2008 0904 0020      		tst __tmp_reg__
 2009 0906 01F4      		brne 0b
 2010 0908 8F01      		movw r16,r30
 2011 090a 0150      		subi r16,1
 2012 090c 1109      		sbc r17,__zero_reg__
 2013               	.LVL155:
 527:main.c        ****     sms += strlen((char *)sms);
 2014               		.loc 1 527 0
 2015 090e 60E0      		ldi r22,lo8(__c.3130)
 2016 0910 70E0      		ldi r23,hi8(__c.3130)
 2017 0912 C801      		movw r24,r16
 2018 0914 0E94 0000 		call strcpy_P
 2019               	.LVL156:
 528:main.c        ****     *sms++ =
 2020               		.loc 1 528 0
 2021 0918 F801      		movw r30,r16
 2022               		0:
 2023 091a 0190      		ld __tmp_reg__,Z+
 2024 091c 0020      		tst __tmp_reg__
 2025 091e 01F4      		brne 0b
 2026 0920 CF01      		movw r24,r30
 2027 0922 0197      		sbiw r24,1
 2028 0924 6C01      		movw r12,r24
 2029               	.LVL157:
 530:main.c        ****     *sms++ =
 2030               		.loc 1 530 0
 2031 0926 81EF      		ldi r24,lo8(-15)
 2032 0928 9FE0      		ldi r25,lo8(15)
 2033 092a 0E94 0000 		call eeprom_read_byte
 2034               	.LVL158:
 2035 092e 805D      		subi r24,lo8(-(48))
 529:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_2);
 2036               		.loc 1 529 0
 2037 0930 F601      		movw r30,r12
 2038 0932 8083      		st Z,r24
 532:main.c        ****     *sms++ =
 2039               		.loc 1 532 0
 2040 0934 82EF      		ldi r24,lo8(-14)
 2041 0936 9FE0      		ldi r25,lo8(15)
 2042 0938 0E94 0000 		call eeprom_read_byte
 2043               	.LVL159:
 2044 093c 805D      		subi r24,lo8(-(48))
 531:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_3);
 2045               		.loc 1 531 0
 2046 093e F601      		movw r30,r12
 2047 0940 8183      		std Z+1,r24
 534:main.c        ****     *sms++ =
 2048               		.loc 1 534 0
 2049 0942 83EF      		ldi r24,lo8(-13)
 2050 0944 9FE0      		ldi r25,lo8(15)
 2051 0946 0E94 0000 		call eeprom_read_byte
 2052               	.LVL160:
 2053 094a 805D      		subi r24,lo8(-(48))
 533:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_4);
 2054               		.loc 1 533 0
 2055 094c F601      		movw r30,r12
 2056 094e 8283      		std Z+2,r24
 536:main.c        ****     *sms++ = '\n';
 2057               		.loc 1 536 0
 2058 0950 84EF      		ldi r24,lo8(-12)
 2059 0952 9FE0      		ldi r25,lo8(15)
 2060 0954 0E94 0000 		call eeprom_read_byte
 2061               	.LVL161:
 2062 0958 805D      		subi r24,lo8(-(48))
 535:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_5);
 2063               		.loc 1 535 0
 2064 095a F601      		movw r30,r12
 2065 095c 8383      		std Z+3,r24
 537:main.c        **** 
 2066               		.loc 1 537 0
 2067 095e 8601      		movw r16,r12
 2068 0960 0B5F      		subi r16,-5
 2069 0962 1F4F      		sbci r17,-1
 2070               	.LVL162:
 2071 0964 9AE0      		ldi r25,lo8(10)
 2072 0966 F92E      		mov r15,r25
 2073 0968 F482      		std Z+4,r15
 540:main.c        ****     sms += strlen((char *)sms);
 2074               		.loc 1 540 0
 2075 096a 60E0      		ldi r22,lo8(__c.3132)
 2076 096c 70E0      		ldi r23,hi8(__c.3132)
 2077 096e C801      		movw r24,r16
 2078 0970 0E94 0000 		call strcpy_P
 2079               	.LVL163:
 541:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_1), sms, 10);
 2080               		.loc 1 541 0
 2081 0974 F801      		movw r30,r16
 2082               		0:
 2083 0976 0190      		ld __tmp_reg__,Z+
 2084 0978 0020      		tst __tmp_reg__
 2085 097a 01F4      		brne 0b
 2086 097c 8F01      		movw r16,r30
 2087               	.LVL164:
 2088 097e 0150      		subi r16,1
 2089 0980 1109      		sbc r17,__zero_reg__
 2090               	.LVL165:
 542:main.c        ****     sms += strlen((char *)sms);
 2091               		.loc 1 542 0
 2092 0982 86EE      		ldi r24,lo8(-26)
 2093 0984 9FE0      		ldi r25,lo8(15)
 2094 0986 0E94 0000 		call eeprom_read_byte
 2095               	.LVL166:
 2096               	.LBB440:
 2097               	.LBB441:
 2098               		.loc 6 527 0
 2099 098a 4AE0      		ldi r20,lo8(10)
 2100 098c B801      		movw r22,r16
 2101 098e 90E0      		ldi r25,0
 2102 0990 0E94 0000 		call __utoa_ncheck
 2103               	.LVL167:
 2104               	.LBE441:
 2105               	.LBE440:
 543:main.c        **** 
 2106               		.loc 1 543 0
 2107 0994 F801      		movw r30,r16
 2108               		0:
 2109 0996 0190      		ld __tmp_reg__,Z+
 2110 0998 0020      		tst __tmp_reg__
 2111 099a 01F4      		brne 0b
 2112 099c 8F01      		movw r16,r30
 2113               	.LVL168:
 2114 099e 0150      		subi r16,1
 2115 09a0 1109      		sbc r17,__zero_reg__
 2116               	.LVL169:
 545:main.c        ****     sms += strlen((char *)sms);
 2117               		.loc 1 545 0
 2118 09a2 60E0      		ldi r22,lo8(__c.3134)
 2119 09a4 70E0      		ldi r23,hi8(__c.3134)
 2120 09a6 C801      		movw r24,r16
 2121 09a8 0E94 0000 		call strcpy_P
 2122               	.LVL170:
 546:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_2), sms, 10);
 2123               		.loc 1 546 0
 2124 09ac F801      		movw r30,r16
 2125               		0:
 2126 09ae 0190      		ld __tmp_reg__,Z+
 2127 09b0 0020      		tst __tmp_reg__
 2128 09b2 01F4      		brne 0b
 2129 09b4 8F01      		movw r16,r30
 2130               	.LVL171:
 2131 09b6 0150      		subi r16,1
 2132 09b8 1109      		sbc r17,__zero_reg__
 2133               	.LVL172:
 547:main.c        ****     sms += strlen((char *)sms);
 2134               		.loc 1 547 0
 2135 09ba 87EE      		ldi r24,lo8(-25)
 2136 09bc 9FE0      		ldi r25,lo8(15)
 2137 09be 0E94 0000 		call eeprom_read_byte
 2138               	.LVL173:
 2139               	.LBB442:
 2140               	.LBB443:
 2141               		.loc 6 527 0
 2142 09c2 4AE0      		ldi r20,lo8(10)
 2143 09c4 B801      		movw r22,r16
 2144 09c6 90E0      		ldi r25,0
 2145 09c8 0E94 0000 		call __utoa_ncheck
 2146               	.LVL174:
 2147               	.LBE443:
 2148               	.LBE442:
 548:main.c        **** 
 2149               		.loc 1 548 0
 2150 09cc F801      		movw r30,r16
 2151               		0:
 2152 09ce 0190      		ld __tmp_reg__,Z+
 2153 09d0 0020      		tst __tmp_reg__
 2154 09d2 01F4      		brne 0b
 2155 09d4 8F01      		movw r16,r30
 2156               	.LVL175:
 2157 09d6 0150      		subi r16,1
 2158 09d8 1109      		sbc r17,__zero_reg__
 2159               	.LVL176:
 550:main.c        ****     sms += strlen((char *)sms);
 2160               		.loc 1 550 0
 2161 09da 60E0      		ldi r22,lo8(__c.3136)
 2162 09dc 70E0      		ldi r23,hi8(__c.3136)
 2163 09de C801      		movw r24,r16
 2164 09e0 0E94 0000 		call strcpy_P
 2165               	.LVL177:
 551:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_3), sms, 10);
 2166               		.loc 1 551 0
 2167 09e4 F801      		movw r30,r16
 2168               		0:
 2169 09e6 0190      		ld __tmp_reg__,Z+
 2170 09e8 0020      		tst __tmp_reg__
 2171 09ea 01F4      		brne 0b
 2172 09ec 8F01      		movw r16,r30
 2173               	.LVL178:
 2174 09ee 0150      		subi r16,1
 2175 09f0 1109      		sbc r17,__zero_reg__
 2176               	.LVL179:
 552:main.c        ****     sms += strlen((char *)sms);
 2177               		.loc 1 552 0
 2178 09f2 88EE      		ldi r24,lo8(-24)
 2179 09f4 9FE0      		ldi r25,lo8(15)
 2180 09f6 0E94 0000 		call eeprom_read_byte
 2181               	.LVL180:
 2182               	.LBB444:
 2183               	.LBB445:
 2184               		.loc 6 527 0
 2185 09fa 4AE0      		ldi r20,lo8(10)
 2186 09fc B801      		movw r22,r16
 2187 09fe 90E0      		ldi r25,0
 2188 0a00 0E94 0000 		call __utoa_ncheck
 2189               	.LVL181:
 2190               	.LBE445:
 2191               	.LBE444:
 553:main.c        ****     *sms++ = '\n';
 2192               		.loc 1 553 0
 2193 0a04 F801      		movw r30,r16
 2194               		0:
 2195 0a06 0190      		ld __tmp_reg__,Z+
 2196 0a08 0020      		tst __tmp_reg__
 2197 0a0a 01F4      		brne 0b
 2198 0a0c 3197      		sbiw r30,1
 2199               	.LVL182:
 554:main.c        **** 
 2200               		.loc 1 554 0
 2201 0a0e 8F01      		movw r16,r30
 2202 0a10 0F5F      		subi r16,-1
 2203 0a12 1F4F      		sbci r17,-1
 2204               	.LVL183:
 2205 0a14 F082      		st Z,r15
 556:main.c        ****     sms += strlen((char *)sms);
 2206               		.loc 1 556 0
 2207 0a16 60E0      		ldi r22,lo8(__c.3138)
 2208 0a18 70E0      		ldi r23,hi8(__c.3138)
 2209 0a1a C801      		movw r24,r16
 2210 0a1c 0E94 0000 		call strcpy_P
 2211               	.LVL184:
 557:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_4), sms, 10);
 2212               		.loc 1 557 0
 2213 0a20 F801      		movw r30,r16
 2214               		0:
 2215 0a22 0190      		ld __tmp_reg__,Z+
 2216 0a24 0020      		tst __tmp_reg__
 2217 0a26 01F4      		brne 0b
 2218 0a28 8F01      		movw r16,r30
 2219               	.LVL185:
 2220 0a2a 0150      		subi r16,1
 2221 0a2c 1109      		sbc r17,__zero_reg__
 2222               	.LVL186:
 558:main.c        ****     sms += strlen((char *)sms);
 2223               		.loc 1 558 0
 2224 0a2e 89EE      		ldi r24,lo8(-23)
 2225 0a30 9FE0      		ldi r25,lo8(15)
 2226 0a32 0E94 0000 		call eeprom_read_byte
 2227               	.LVL187:
 2228               	.LBB446:
 2229               	.LBB447:
 2230               		.loc 6 527 0
 2231 0a36 4AE0      		ldi r20,lo8(10)
 2232 0a38 B801      		movw r22,r16
 2233 0a3a 90E0      		ldi r25,0
 2234 0a3c 0E94 0000 		call __utoa_ncheck
 2235               	.LVL188:
 2236               	.LBE447:
 2237               	.LBE446:
 559:main.c        **** 
 2238               		.loc 1 559 0
 2239 0a40 F801      		movw r30,r16
 2240               		0:
 2241 0a42 0190      		ld __tmp_reg__,Z+
 2242 0a44 0020      		tst __tmp_reg__
 2243 0a46 01F4      		brne 0b
 2244 0a48 8F01      		movw r16,r30
 2245               	.LVL189:
 2246 0a4a 0150      		subi r16,1
 2247 0a4c 1109      		sbc r17,__zero_reg__
 2248               	.LVL190:
 561:main.c        ****     sms += strlen((char *)sms);
 2249               		.loc 1 561 0
 2250 0a4e 60E0      		ldi r22,lo8(__c.3140)
 2251 0a50 70E0      		ldi r23,hi8(__c.3140)
 2252 0a52 C801      		movw r24,r16
 2253 0a54 0E94 0000 		call strcpy_P
 2254               	.LVL191:
 562:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_5), sms, 10);
 2255               		.loc 1 562 0
 2256 0a58 F801      		movw r30,r16
 2257               		0:
 2258 0a5a 0190      		ld __tmp_reg__,Z+
 2259 0a5c 0020      		tst __tmp_reg__
 2260 0a5e 01F4      		brne 0b
 2261 0a60 8F01      		movw r16,r30
 2262               	.LVL192:
 2263 0a62 0150      		subi r16,1
 2264 0a64 1109      		sbc r17,__zero_reg__
 2265               	.LVL193:
 563:main.c        ****     sms += strlen((char *)sms);
 2266               		.loc 1 563 0
 2267 0a66 8AEE      		ldi r24,lo8(-22)
 2268 0a68 9FE0      		ldi r25,lo8(15)
 2269 0a6a 0E94 0000 		call eeprom_read_byte
 2270               	.LVL194:
 2271               	.LBB448:
 2272               	.LBB449:
 2273               		.loc 6 527 0
 2274 0a6e 4AE0      		ldi r20,lo8(10)
 2275 0a70 B801      		movw r22,r16
 2276 0a72 90E0      		ldi r25,0
 2277 0a74 0E94 0000 		call __utoa_ncheck
 2278               	.LVL195:
 2279               	.LBE449:
 2280               	.LBE448:
 564:main.c        **** 
 2281               		.loc 1 564 0
 2282 0a78 F801      		movw r30,r16
 2283               		0:
 2284 0a7a 0190      		ld __tmp_reg__,Z+
 2285 0a7c 0020      		tst __tmp_reg__
 2286 0a7e 01F4      		brne 0b
 2287 0a80 8F01      		movw r16,r30
 2288               	.LVL196:
 2289 0a82 0150      		subi r16,1
 2290 0a84 1109      		sbc r17,__zero_reg__
 2291               	.LVL197:
 566:main.c        ****     sms += strlen((char *)sms);
 2292               		.loc 1 566 0
 2293 0a86 60E0      		ldi r22,lo8(__c.3142)
 2294 0a88 70E0      		ldi r23,hi8(__c.3142)
 2295 0a8a C801      		movw r24,r16
 2296 0a8c 0E94 0000 		call strcpy_P
 2297               	.LVL198:
 567:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_6), sms, 10);
 2298               		.loc 1 567 0
 2299 0a90 F801      		movw r30,r16
 2300               		0:
 2301 0a92 0190      		ld __tmp_reg__,Z+
 2302 0a94 0020      		tst __tmp_reg__
 2303 0a96 01F4      		brne 0b
 2304 0a98 8F01      		movw r16,r30
 2305               	.LVL199:
 2306 0a9a 0150      		subi r16,1
 2307 0a9c 1109      		sbc r17,__zero_reg__
 2308               	.LVL200:
 568:main.c        ****     sms += strlen((char *)sms);
 2309               		.loc 1 568 0
 2310 0a9e 8BEE      		ldi r24,lo8(-21)
 2311 0aa0 9FE0      		ldi r25,lo8(15)
 2312 0aa2 0E94 0000 		call eeprom_read_byte
 2313               	.LVL201:
 2314               	.LBB450:
 2315               	.LBB451:
 2316               		.loc 6 527 0
 2317 0aa6 4AE0      		ldi r20,lo8(10)
 2318 0aa8 B801      		movw r22,r16
 2319 0aaa 90E0      		ldi r25,0
 2320 0aac 0E94 0000 		call __utoa_ncheck
 2321               	.LVL202:
 2322               	.LBE451:
 2323               	.LBE450:
 569:main.c        **** 
 2324               		.loc 1 569 0
 2325 0ab0 F801      		movw r30,r16
 2326               		0:
 2327 0ab2 0190      		ld __tmp_reg__,Z+
 2328 0ab4 0020      		tst __tmp_reg__
 2329 0ab6 01F4      		brne 0b
 2330 0ab8 8F01      		movw r16,r30
 2331               	.LVL203:
 2332 0aba 0150      		subi r16,1
 2333 0abc 1109      		sbc r17,__zero_reg__
 2334               	.LVL204:
 571:main.c        ****     sms += strlen((char *)sms);
 2335               		.loc 1 571 0
 2336 0abe 60E0      		ldi r22,lo8(__c.3144)
 2337 0ac0 70E0      		ldi r23,hi8(__c.3144)
 2338 0ac2 C801      		movw r24,r16
 2339 0ac4 0E94 0000 		call strcpy_P
 2340               	.LVL205:
 572:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_7), sms, 10);
 2341               		.loc 1 572 0
 2342 0ac8 F801      		movw r30,r16
 2343               		0:
 2344 0aca 0190      		ld __tmp_reg__,Z+
 2345 0acc 0020      		tst __tmp_reg__
 2346 0ace 01F4      		brne 0b
 2347 0ad0 8F01      		movw r16,r30
 2348               	.LVL206:
 2349 0ad2 0150      		subi r16,1
 2350 0ad4 1109      		sbc r17,__zero_reg__
 2351               	.LVL207:
 573:main.c        ****     sms += strlen((char *)sms);
 2352               		.loc 1 573 0
 2353 0ad6 8CEE      		ldi r24,lo8(-20)
 2354 0ad8 9FE0      		ldi r25,lo8(15)
 2355 0ada 0E94 0000 		call eeprom_read_byte
 2356               	.LVL208:
 2357               	.LBB452:
 2358               	.LBB453:
 2359               		.loc 6 527 0
 2360 0ade 4AE0      		ldi r20,lo8(10)
 2361 0ae0 B801      		movw r22,r16
 2362 0ae2 90E0      		ldi r25,0
 2363 0ae4 0E94 0000 		call __utoa_ncheck
 2364               	.LVL209:
 2365               	.LBE453:
 2366               	.LBE452:
 574:main.c        ****     *sms++ = '\n';
 2367               		.loc 1 574 0
 2368 0ae8 F801      		movw r30,r16
 2369               		0:
 2370 0aea 0190      		ld __tmp_reg__,Z+
 2371 0aec 0020      		tst __tmp_reg__
 2372 0aee 01F4      		brne 0b
 2373 0af0 CF01      		movw r24,r30
 2374               	.LVL210:
 575:main.c        **** 
 2375               		.loc 1 575 0
 2376 0af2 0197      		sbiw r24,1
 2377               	.LVL211:
 2378 0af4 FC01      		movw r30,r24
 2379               	.LVL212:
 2380 0af6 F192      		st Z+,r15
 2381 0af8 CF01      		movw r24,r30
 2382               	.LVL213:
 577:main.c        **** 
 2383               		.loc 1 577 0
 2384 0afa 60E0      		ldi r22,lo8(__c.3146)
 2385 0afc 70E0      		ldi r23,hi8(__c.3146)
 2386 0afe 0E94 0000 		call strcpy_P
 2387               	.LVL214:
 579:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 2388               		.loc 1 579 0
 2389 0b02 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 2390 0b04 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 2391 0b06 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 2392 0b08 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 2393               	.L128:
 2394 0b0a 0E94 0000 		call strcpy
 2395               	.LVL215:
 581:main.c        ****     zapal_diode_led_blyski(2);
 2396               		.loc 1 581 0
 2397 0b0e 83ED      		ldi r24,lo8(-45)
 2398               	.L126:
 2399 0b10 0E94 0000 		call dodaj_komende
 2400               	.LVL216:
 2401               	.L125:
 582:main.c        ****     break;
 2402               		.loc 1 582 0
 2403 0b14 82E0      		ldi r24,lo8(2)
 2404 0b16 8093 0000 		sts liczba_blyskow_led,r24
 2405 0b1a 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 583:main.c        ****   }
 2406               		.loc 1 583 0
 2407 0b1e 00C0      		rjmp .L98
 2408               	.LVL217:
 2409               	.L103:
 2410               	.LBE439:
 2411               	.LBB454:
 586:main.c        ****     timer_report_user_100ms = OKNO_CZASOWE_REPORT_USER_100MS;
 2412               		.loc 1 586 0
 2413 0b20 8091 0000 		lds r24,licznik_report_user
 2414 0b24 8F5F      		subi r24,lo8(-(1))
 2415 0b26 8093 0000 		sts licznik_report_user,r24
 587:main.c        **** 
 2416               		.loc 1 587 0
 2417 0b2a 8CE2      		ldi r24,lo8(44)
 2418 0b2c 91E0      		ldi r25,lo8(1)
 2419 0b2e 9093 0000 		sts timer_report_user_100ms+1,r25
 2420 0b32 8093 0000 		sts timer_report_user_100ms,r24
 589:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 2421               		.loc 1 589 0
 2422 0b36 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 2423 0b38 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 2424 0b3a 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 2425 0b3c 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 2426 0b3e 0E94 0000 		call strcpy
 2427               	.LVL218:
 598:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
 2428               		.loc 1 598 0
 2429 0b42 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 2430 0b44 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 2431 0b46 FB01      		movw r30,r22
 2432               		0:
 2433 0b48 0190      		ld __tmp_reg__,Z+
 2434 0b4a 0020      		tst __tmp_reg__
 2435 0b4c 01F4      		brne 0b
 2436 0b4e BF01      		movw r22,r30
 2437 0b50 6150      		subi r22,1
 2438 0b52 7109      		sbc r23,__zero_reg__
 596:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
 2439               		.loc 1 596 0
 2440 0b54 AE01      		movw r20,r28
 2441 0b56 4F5F      		subi r20,-1
 2442 0b58 5F4F      		sbci r21,-1
 2443 0b5a 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 2444 0b5c 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 2445 0b5e 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 2446               	.LVL219:
 2447 0b62 88E0      		ldi r24,lo8(8)
 2448 0b64 C82E      		mov r12,r24
 2449 0b66 D12C      		mov r13,__zero_reg__
 2450               	.LVL220:
 2451               	.L109:
 2452               	.LBB455:
 606:main.c        ****               temp_buf, (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
 2453               		.loc 1 606 0
 2454 0b68 B601      		movw r22,r12
 2455 0b6a CE01      		movw r24,r28
 2456 0b6c 0196      		adiw r24,1
 2457 0b6e 0E94 0000 		call porownaj_numer_telefonu_blok
 2458               	.LVL221:
 2459 0b72 182F      		mov r17,r24
 2460 0b74 8111      		cpse r24,__zero_reg__
 2461 0b76 00C0      		rjmp .L115
 2462 0b78 F5E0      		ldi r31,5
 2463 0b7a CF0E      		add r12,r31
 2464 0b7c D11C      		adc r13,__zero_reg__
 604:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 2465               		.loc 1 604 0
 2466 0b7e 88EA      		ldi r24,-88
 2467 0b80 C816      		cp r12,r24
 2468 0b82 8FE0      		ldi r24,15
 2469 0b84 D806      		cpc r13,r24
 2470 0b86 01F4      		brne .L109
 2471               	.L108:
 2472               	.LVL222:
 2473               	.LBE455:
 614:main.c        ****            (char *)numer_telefonu_do_ktorego_dzwonic);
 2474               		.loc 1 614 0
 2475 0b88 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 2476 0b8a 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 2477 0b8c 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 2478 0b8e 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 2479 0b90 0E94 0000 		call strcpy
 2480               	.LVL223:
 616:main.c        ****     if (znaleziono) {
 2481               		.loc 1 616 0
 2482 0b94 60E0      		ldi r22,lo8(.LC3)
 2483 0b96 70E0      		ldi r23,hi8(.LC3)
 2484 0b98 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 2485 0b9a 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 2486 0b9c 0E94 0000 		call strcat
 2487               	.LVL224:
 618:main.c        ****     } else {
 2488               		.loc 1 618 0
 2489 0ba0 60E0      		ldi r22,lo8(.LC4)
 2490 0ba2 70E0      		ldi r23,hi8(.LC4)
 617:main.c        ****       strcat((char *)tekst_wysylanego_smsa, "OK");
 2491               		.loc 1 617 0
 2492 0ba4 1111      		cpse r17,__zero_reg__
 2493 0ba6 00C0      		rjmp .L124
 2494               	.LVL225:
 620:main.c        ****     }
 2495               		.loc 1 620 0
 2496 0ba8 60E0      		ldi r22,lo8(.LC5)
 2497 0baa 70E0      		ldi r23,hi8(.LC5)
 2498               	.LVL226:
 2499               	.L124:
 2500 0bac 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 2501 0bae 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 2502 0bb0 0E94 0000 		call strcat
 2503               	.LVL227:
 623:main.c        **** 
 2504               		.loc 1 623 0
 2505 0bb4 83ED      		ldi r24,lo8(-45)
 2506 0bb6 0E94 0000 		call dodaj_komende
 2507               	.LVL228:
 625:main.c        **** 
 2508               		.loc 1 625 0
 2509 0bba 82E0      		ldi r24,lo8(2)
 2510 0bbc 8093 0000 		sts liczba_blyskow_led,r24
 2511 0bc0 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 629:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 2512               		.loc 1 629 0
 2513 0bc4 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 2514 0bc8 8111      		cpse r24,__zero_reg__
 2515 0bca 00C0      		rjmp .L112
 629:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 2516               		.loc 1 629 0 is_stmt 0 discriminator 1
 2517 0bcc 8091 0000 		lds r24,liczba_znakow_do_zapisu
 2518 0bd0 8111      		cpse r24,__zero_reg__
 2519 0bd2 00C0      		rjmp .L112
 629:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 2520               		.loc 1 629 0 discriminator 2
 2521 0bd4 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 2522 0bd8 8111      		cpse r24,__zero_reg__
 2523 0bda 00C0      		rjmp .L112
 629:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 2524               		.loc 1 629 0 discriminator 3
 2525 0bdc 8FB3      		in r24,0x1f
 2526               	.L112:
 637:main.c        ****     break;
 2527               		.loc 1 637 0 is_stmt 1
 2528 0bde 612F      		mov r22,r17
 2529 0be0 82E0      		ldi r24,lo8(2)
 2530 0be2 00C0      		rjmp .L127
 2531               	.LVL229:
 2532               	.L115:
 2533               	.LBB456:
 608:main.c        ****         break;
 2534               		.loc 1 608 0
 2535 0be4 1FEF      		ldi r17,lo8(-1)
 2536 0be6 00C0      		rjmp .L108
 2537               	.LVL230:
 2538               	.L104:
 2539               	.LBE456:
 2540               	.LBE454:
 641:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 2541               		.loc 1 641 0
 2542 0be8 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 2543 0bea 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 2544 0bec 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 2545 0bee 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 2546 0bf0 0E94 0000 		call strcpy
 2547               	.LVL231:
 643:main.c        ****            "Wpisz numer jaki sprawdzasz, np: USER 793557357");
 2548               		.loc 1 643 0
 2549 0bf4 60E0      		ldi r22,lo8(.LC6)
 2550 0bf6 70E0      		ldi r23,hi8(.LC6)
 2551 0bf8 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 2552 0bfa 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 2553 0bfc 00C0      		rjmp .L128
 2554               	.LVL232:
 2555               	.L105:
 650:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 2556               		.loc 1 650 0
 2557 0bfe 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 2558 0c00 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 2559 0c02 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 2560 0c04 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 2561 0c06 0E94 0000 		call strcpy
 2562               	.LVL233:
 652:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW);
 2563               		.loc 1 652 0
 2564 0c0a 1092 0000 		sts numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama,__zero_reg__
 653:main.c        ****     zapal_diode_led_blyski(2);
 2565               		.loc 1 653 0
 2566 0c0e 89E8      		ldi r24,lo8(-119)
 2567 0c10 00C0      		rjmp .L126
 2568               	.LVL234:
 2569               	.L107:
 658:main.c        ****             KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 2570               		.loc 1 658 0
 2571 0c12 63E8      		ldi r22,lo8(-125)
 2572 0c14 82E0      		ldi r24,lo8(2)
 2573 0c16 0E94 0000 		call czy_sa_komendy_z_przedzialu
 2574               	.LVL235:
 2575 0c1a 8111      		cpse r24,__zero_reg__
 2576 0c1c 00C0      		rjmp .L98
 661:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
 2577               		.loc 1 661 0
 2578 0c1e 89E1      		ldi r24,lo8(25)
 2579 0c20 8093 0000 		sts liczba_blyskow_led,r24
 2580 0c24 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 662:main.c        ****     }
 2581               		.loc 1 662 0
 2582 0c28 83E0      		ldi r24,lo8(3)
 2583 0c2a 0E94 0000 		call dodaj_komende
 2584               	.LVL236:
 2585 0c2e 00C0      		rjmp .L98
 2586               		.cfi_endproc
 2587               	.LFE39:
 2589               	.global	steruj_wejsciem_reset_100ms
 2591               	steruj_wejsciem_reset_100ms:
 2592               	.LFB40:
 673:main.c        ****   static uchar licznik_reset;
 2593               		.loc 1 673 0
 2594               		.cfi_startproc
 2595               	/* prologue: function */
 2596               	/* frame size = 0 */
 2597               	/* stack size = 0 */
 2598               	.L__stack_usage = 0
 2599 0c30 8091 0000 		lds r24,licznik_reset.3166
 675:main.c        ****     if (licznik_reset < 20 * 10)
 2600               		.loc 1 675 0
 2601 0c34 9091 0000 		lds r25,stan_logiczny_na_wejsciu
 2602 0c38 90FF      		sbrs r25,0
 2603 0c3a 00C0      		rjmp .L130
 676:main.c        ****       ++licznik_reset;
 2604               		.loc 1 676 0
 2605 0c3c 883C      		cpi r24,lo8(-56)
 2606 0c3e 00F4      		brsh .L129
 677:main.c        ****   } else {
 2607               		.loc 1 677 0
 2608 0c40 8F5F      		subi r24,lo8(-(1))
 2609 0c42 8093 0000 		sts licznik_reset.3166,r24
 2610 0c46 0895      		ret
 2611               	.L130:
 2612               	.LBB459:
 2613               	.LBB460:
 679:main.c        ****       if (not czy_sa_komendy_z_przedzialu(
 2614               		.loc 1 679 0
 2615 0c48 883C      		cpi r24,lo8(-56)
 2616 0c4a 00F0      		brlo .L132
 680:main.c        ****               KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 2617               		.loc 1 680 0
 2618 0c4c 63E8      		ldi r22,lo8(-125)
 2619 0c4e 82E0      		ldi r24,lo8(2)
 2620 0c50 0E94 0000 		call czy_sa_komendy_z_przedzialu
 2621               	.LVL237:
 2622 0c54 8111      		cpse r24,__zero_reg__
 2623 0c56 00C0      		rjmp .L134
 683:main.c        ****     } else if (licznik_reset >= 5 * 10) {
 2624               		.loc 1 683 0
 2625 0c58 83E0      		ldi r24,lo8(3)
 2626               	.L136:
 688:main.c        ****     }
 2627               		.loc 1 688 0
 2628 0c5a 0E94 0000 		call dodaj_komende
 2629               	.LVL238:
 2630               	.L134:
 690:main.c        ****   }
 2631               		.loc 1 690 0
 2632 0c5e 1092 0000 		sts licznik_reset.3166,__zero_reg__
 2633               	.L129:
 2634               	/* epilogue start */
 2635               	.LBE460:
 2636               	.LBE459:
 692:main.c        **** 
 2637               		.loc 1 692 0
 2638 0c62 0895      		ret
 2639               	.L132:
 2640               	.LBB462:
 2641               	.LBB461:
 684:main.c        ****       if (not czy_sa_komendy_z_przedzialu(
 2642               		.loc 1 684 0
 2643 0c64 8233      		cpi r24,lo8(50)
 2644 0c66 00F0      		brlo .L134
 685:main.c        ****               KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 2645               		.loc 1 685 0
 2646 0c68 63E8      		ldi r22,lo8(-125)
 2647 0c6a 82E0      		ldi r24,lo8(2)
 2648 0c6c 0E94 0000 		call czy_sa_komendy_z_przedzialu
 2649               	.LVL239:
 2650 0c70 8111      		cpse r24,__zero_reg__
 2651 0c72 00C0      		rjmp .L134
 688:main.c        ****     }
 2652               		.loc 1 688 0
 2653 0c74 82E0      		ldi r24,lo8(2)
 2654 0c76 00C0      		rjmp .L136
 2655               	.LBE461:
 2656               	.LBE462:
 2657               		.cfi_endproc
 2658               	.LFE40:
 2660               	.global	sprawdz_przychodzaca_rozmowe
 2662               	sprawdz_przychodzaca_rozmowe:
 2663               	.LFB41:
 695:main.c        ****   // Super User: pozycje 795-800 omijaja wszystkie blokady
 2664               		.loc 1 695 0
 2665               		.cfi_startproc
 2666 0c78 CF93      		push r28
 2667               	.LCFI58:
 2668               		.cfi_def_cfa_offset 3
 2669               		.cfi_offset 28, -2
 2670 0c7a DF93      		push r29
 2671               	.LCFI59:
 2672               		.cfi_def_cfa_offset 4
 2673               		.cfi_offset 29, -3
 2674               	/* prologue: function */
 2675               	/* frame size = 0 */
 2676               	/* stack size = 2 */
 2677               	.L__stack_usage = 2
 697:main.c        ****       czy_numer_jest_super_userem(numer_telefonu_ktory_dzwoni);
 2678               		.loc 1 697 0
 2679 0c7c 80E0      		ldi r24,lo8(numer_telefonu_ktory_dzwoni)
 2680 0c7e 90E0      		ldi r25,hi8(numer_telefonu_ktory_dzwoni)
 2681 0c80 0E94 0000 		call czy_numer_jest_super_userem
 2682               	.LVL240:
 700:main.c        ****     return FALSE; // Ignoruj rozmowy gdy system zablokowany (chyba ze super
 2683               		.loc 1 700 0
 2684 0c84 9091 0000 		lds r25,blokada_systemu
 2685 0c88 9923      		tst r25
 2686 0c8a 01F0      		breq .L138
 700:main.c        ****     return FALSE; // Ignoruj rozmowy gdy system zablokowany (chyba ze super
 2687               		.loc 1 700 0 is_stmt 0 discriminator 1
 2688 0c8c 8111      		cpse r24,__zero_reg__
 2689 0c8e 00C0      		rjmp .L138
 2690               	.LVL241:
 2691               	.L141:
 701:main.c        ****                   // user)
 2692               		.loc 1 701 0 is_stmt 1
 2693 0c90 80E0      		ldi r24,0
 2694               	.L137:
 2695               	/* epilogue start */
 746:main.c        **** 
 2696               		.loc 1 746 0
 2697 0c92 DF91      		pop r29
 2698 0c94 CF91      		pop r28
 2699 0c96 0895      		ret
 2700               	.LVL242:
 2701               	.L138:
 705:main.c        ****     return FALSE; // Ignoruj rozmowy gdy blokada czasowa (chyba ze super user)
 2702               		.loc 1 705 0
 2703 0c98 9091 0000 		lds r25,blokada_sterowania_czasowa
 2704 0c9c 9923      		tst r25
 2705 0c9e 01F0      		breq .L140
 705:main.c        ****     return FALSE; // Ignoruj rozmowy gdy blokada czasowa (chyba ze super user)
 2706               		.loc 1 705 0 is_stmt 0 discriminator 1
 2707 0ca0 8823      		tst r24
 2708 0ca2 01F0      		breq .L141
 2709               	.L140:
 2710 0ca4 8091 0000 		lds r24,numer_telefonu_ktory_dzwoni
 2711               	.LVL243:
 710:main.c        ****     if (numer_telefonu_ktory_dzwoni[0] != 0)
 2712               		.loc 1 710 0 is_stmt 1
 2713 0ca8 9091 0000 		lds r25,tryb_clip
 2714 0cac 9111      		cpse r25,__zero_reg__
 2715 0cae 00C0      		rjmp .L142
 711:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA);
 2716               		.loc 1 711 0
 2717 0cb0 8823      		tst r24
 2718 0cb2 01F0      		breq .L143
 712:main.c        **** 
 2719               		.loc 1 712 0
 2720 0cb4 84E8      		ldi r24,lo8(-124)
 2721 0cb6 0E94 0000 		call dodaj_komende
 2722               	.LVL244:
 2723               	.L143:
 715:main.c        ****       return TRUE;
 2724               		.loc 1 715 0
 2725 0cba 8091 0000 		lds r24,tryb_pracy
 2726 0cbe 8130      		cpi r24,lo8(1)
 2727 0cc0 01F4      		brne .L144
 2728               	.L145:
 716:main.c        **** 
 2729               		.loc 1 716 0
 2730 0cc2 8FEF      		ldi r24,lo8(-1)
 2731 0cc4 00C0      		rjmp .L137
 2732               	.L144:
 2733               	.LBB466:
 2734               	.LBB467:
 721:main.c        ****                                          (char *)numer_telefonu_ktory_dzwoni)],
 2735               		.loc 1 721 0
 2736 0cc6 60E0      		ldi r22,lo8(numer_telefonu_ktory_dzwoni)
 2737 0cc8 70E0      		ldi r23,hi8(numer_telefonu_ktory_dzwoni)
 2738 0cca FB01      		movw r30,r22
 2739               		0:
 2740 0ccc 0190      		ld __tmp_reg__,Z+
 2741 0cce 0020      		tst __tmp_reg__
 2742 0cd0 01F4      		brne 0b
 2743 0cd2 BF01      		movw r22,r30
 2744 0cd4 6150      		subi r22,1
 2745 0cd6 7109      		sbc r23,__zero_reg__
 720:main.c        ****                                      &numer_telefonu_ktory_dzwoni[strlen(
 2746               		.loc 1 720 0
 2747 0cd8 40E0      		ldi r20,lo8(bufor_eeprom)
 2748 0cda 50E0      		ldi r21,hi8(bufor_eeprom)
 2749 0cdc 80E0      		ldi r24,lo8(numer_telefonu_ktory_dzwoni)
 2750 0cde 90E0      		ldi r25,hi8(numer_telefonu_ktory_dzwoni)
 2751 0ce0 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 2752               	.LVL245:
 2753 0ce4 C8E0      		ldi r28,lo8(8)
 2754 0ce6 D0E0      		ldi r29,0
 2755               	.LVL246:
 2756               	.L146:
 2757               	.LBB468:
 728:main.c        ****               &bufor_eeprom[0], (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt))) {
 2758               		.loc 1 728 0
 2759 0ce8 BE01      		movw r22,r28
 2760 0cea 80E0      		ldi r24,lo8(bufor_eeprom)
 2761 0cec 90E0      		ldi r25,hi8(bufor_eeprom)
 2762 0cee 0E94 0000 		call porownaj_numer_telefonu_blok
 2763               	.LVL247:
 2764 0cf2 8111      		cpse r24,__zero_reg__
 2765 0cf4 00C0      		rjmp .L145
 2766 0cf6 2596      		adiw r28,5
 726:main.c        ****          ++nr_uzyt) {
 2767               		.loc 1 726 0
 2768 0cf8 C83A      		cpi r28,-88
 2769 0cfa FFE0      		ldi r31,15
 2770 0cfc DF07      		cpc r29,r31
 2771 0cfe 01F4      		brne .L146
 2772 0d00 00C0      		rjmp .L141
 2773               	.L142:
 2774               	.LBE468:
 2775               	.LBE467:
 2776               	.LBE466:
 737:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA);
 2777               		.loc 1 737 0
 2778 0d02 8823      		tst r24
 2779 0d04 01F0      		breq .L147
 738:main.c        **** 
 2780               		.loc 1 738 0
 2781 0d06 84E8      		ldi r24,lo8(-124)
 2782 0d08 0E94 0000 		call dodaj_komende
 2783               	.LVL248:
 2784               	.L147:
 741:main.c        ****     return TRUE;
 2785               		.loc 1 741 0
 2786 0d0c 81E0      		ldi r24,lo8(1)
 2787 0d0e 9091 0000 		lds r25,tryb_pracy
 2788 0d12 9130      		cpi r25,lo8(1)
 2789 0d14 01F0      		breq .L148
 2790 0d16 80E0      		ldi r24,0
 2791               	.L148:
 2792 0d18 8195      		neg r24
 2793 0d1a 00C0      		rjmp .L137
 2794               		.cfi_endproc
 2795               	.LFE41:
 2797               	.global	zakonczono_rozmowe_telefoniczna
 2799               	zakonczono_rozmowe_telefoniczna:
 2800               	.LFB42:
 768:main.c        ****   POMOC_DODAJ2('#', 'a');
 2801               		.loc 1 768 0
 2802               		.cfi_startproc
 2803               	.LVL249:
 2804               	/* prologue: function */
 2805               	/* frame size = 0 */
 2806               	/* stack size = 0 */
 2807               	.L__stack_usage = 0
 770:main.c        ****   licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 2808               		.loc 1 770 0
 2809 0d1c 8CE3      		ldi r24,lo8(60)
 2810               	.LVL250:
 2811 0d1e 8093 0000 		sts opoznienie_SIM900_100MS,r24
 771:main.c        ****   ustaw_maksymalny_czas_dzwonienia = 0;
 2812               		.loc 1 771 0
 2813 0d22 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 2814 0d26 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 772:main.c        ****   maksymalny_czas_dzwonienia = 0;
 2815               		.loc 1 772 0
 2816 0d2a 1092 0000 		sts ustaw_maksymalny_czas_dzwonienia,__zero_reg__
 773:main.c        ****   blokada_clip = FALSE;
 2817               		.loc 1 773 0
 2818 0d2e 1092 0000 		sts maksymalny_czas_dzwonienia,__zero_reg__
 774:main.c        **** }
 2819               		.loc 1 774 0
 2820 0d32 1092 0000 		sts blokada_clip,__zero_reg__
 2821               	/* epilogue start */
 775:main.c        **** 
 2822               		.loc 1 775 0
 2823 0d36 0895      		ret
 2824               		.cfi_endproc
 2825               	.LFE42:
 2827               	.global	zakonczono_wysylanie_smsa
 2829               	zakonczono_wysylanie_smsa:
 2830               	.LFB43:
 784:main.c        ****   POMOC_DODAJ2('#', 'A');
 2831               		.loc 1 784 0
 2832               		.cfi_startproc
 2833               	.LVL251:
 2834               	/* prologue: function */
 2835               	/* frame size = 0 */
 2836               	/* stack size = 0 */
 2837               	.L__stack_usage = 0
 786:main.c        **** 
 2838               		.loc 1 786 0
 2839 0d38 8CE3      		ldi r24,lo8(60)
 2840               	.LVL252:
 2841 0d3a 8093 0000 		sts opoznienie_SIM900_100MS,r24
 788:main.c        **** }
 2842               		.loc 1 788 0
 2843 0d3e 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 2844               	/* epilogue start */
 789:main.c        **** 
 2845               		.loc 1 789 0
 2846 0d42 0895      		ret
 2847               		.cfi_endproc
 2848               	.LFE43:
 2850               	.global	problem_z_wyslaniem_powiadomienia
 2852               	problem_z_wyslaniem_powiadomienia:
 2853               	.LFB44:
 791:main.c        ****   wykonywanie_rozmowy_telefonicznej = FALSE;
 2854               		.loc 1 791 0
 2855               		.cfi_startproc
 2856               	/* prologue: function */
 2857               	/* frame size = 0 */
 2858               	/* stack size = 0 */
 2859               	.L__stack_usage = 0
 792:main.c        ****   licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 2860               		.loc 1 792 0
 2861 0d44 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 793:main.c        ****   wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 2862               		.loc 1 793 0
 2863 0d48 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 2864 0d4c 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 794:main.c        ****   czekanie_na_odebranie_zachety = FALSE;
 2865               		.loc 1 794 0
 2866 0d50 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 2867 0d54 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 2868 0d58 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
 795:main.c        ****   opoznienie_SIM900_100MS = 60;
 2869               		.loc 1 795 0
 2870 0d5c 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
 796:main.c        ****   flaga_wysylanie_smsa = 0;
 2871               		.loc 1 796 0
 2872 0d60 8CE3      		ldi r24,lo8(60)
 2873 0d62 8093 0000 		sts opoznienie_SIM900_100MS,r24
 797:main.c        **** }
 2874               		.loc 1 797 0
 2875 0d66 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
 2876               	/* epilogue start */
 798:main.c        **** 
 2877               		.loc 1 798 0
 2878 0d6a 0895      		ret
 2879               		.cfi_endproc
 2880               	.LFE44:
 2882               	.global	wyzerowanie_danych_SIM900
 2884               	wyzerowanie_danych_SIM900:
 2885               	.LFB45:
   6:main_sim900.h ****   POMOC_DODAJ2('*', 't');
 2886               		.loc 2 6 0
 2887               		.cfi_startproc
 2888               	/* prologue: function */
 2889               	/* frame size = 0 */
 2890               	/* stack size = 0 */
 2891               	.L__stack_usage = 0
 2892               	.LVL253:
   8:main_sim900.h ****   licznik_wysylane_polecenie_SIM900 = 0;
 2893               		.loc 2 8 0
 2894 0d6c 0E94 0000 		call problem_z_wyslaniem_powiadomienia
 2895               	.LVL254:
   9:main_sim900.h ****   aktualnie_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 2896               		.loc 2 9 0
 2897 0d70 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 2898 0d74 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
  10:main_sim900.h ****   liczba_komend_w_kolejce_SIM900 = 0;
 2899               		.loc 2 10 0
 2900 0d78 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
  11:main_sim900.h ****   licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow = 0;
 2901               		.loc 2 11 0
 2902 0d7c 1092 0000 		sts liczba_komend_w_kolejce_SIM900,__zero_reg__
  12:main_sim900.h ****   czekanie_na_odebranie_zachety = FALSE;
 2903               		.loc 2 12 0
 2904 0d80 1092 0000 		sts licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow,__zero_reg__
  13:main_sim900.h ****   flaga_odebrany_znak_zachety = FALSE;
 2905               		.loc 2 13 0
 2906 0d84 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
  14:main_sim900.h ****   trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 2907               		.loc 2 14 0
 2908 0d88 1092 0000 		sts flaga_odebrany_znak_zachety,__zero_reg__
  15:main_sim900.h ****   wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
 2909               		.loc 2 15 0
 2910 0d8c 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
  16:main_sim900.h ****   flaga_odczytywanie_smsa = FALSE;
 2911               		.loc 2 16 0
 2912 0d90 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
  17:main_sim900.h **** }
 2913               		.loc 2 17 0
 2914 0d94 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 2915               	/* epilogue start */
  18:main_sim900.h **** 
 2916               		.loc 2 18 0
 2917 0d98 0895      		ret
 2918               		.cfi_endproc
 2919               	.LFE45:
 2921               	.global	reset_modulu_SIM900
 2923               	reset_modulu_SIM900:
 2924               	.LFB46:
  20:main_sim900.h ****   wyzerowanie_danych_SIM900();
 2925               		.loc 2 20 0
 2926               		.cfi_startproc
 2927               	/* prologue: function */
 2928               	/* frame size = 0 */
 2929               	/* stack size = 0 */
 2930               	.L__stack_usage = 0
  21:main_sim900.h ****   POMOC_DODAJ2('*', 'm');
 2931               		.loc 2 21 0
 2932 0d9a 0E94 0000 		call wyzerowanie_danych_SIM900
 2933               	.LVL255:
  23:main_sim900.h ****   podlaczony_modul_gsm_SIM900 = FALSE;
 2934               		.loc 2 23 0
 2935 0d9e 86E9      		ldi r24,lo8(-106)
 2936 0da0 8093 0000 		sts licznik_100ms_procedura_inicjalizacyjna_SIM900,r24
  24:main_sim900.h ****   podlaczona_karta_SIM_SIM900 = FALSE;
 2937               		.loc 2 24 0
 2938 0da4 1092 0000 		sts podlaczony_modul_gsm_SIM900,__zero_reg__
  25:main_sim900.h ****   licznik_blad_stanu_karty_SIM = 0;
 2939               		.loc 2 25 0
 2940 0da8 1092 0000 		sts podlaczona_karta_SIM_SIM900,__zero_reg__
  26:main_sim900.h ****   licznik_blad_zalogowania_u_operatora = 0;
 2941               		.loc 2 26 0
 2942 0dac 1092 0000 		sts licznik_blad_stanu_karty_SIM,__zero_reg__
  27:main_sim900.h ****   nazwa_operatora[0] = '\0';
 2943               		.loc 2 27 0
 2944 0db0 1092 0000 		sts licznik_blad_zalogowania_u_operatora,__zero_reg__
  28:main_sim900.h ****   licznik_ogolny_blad_zalogowania = 0;
 2945               		.loc 2 28 0
 2946 0db4 1092 0000 		sts nazwa_operatora,__zero_reg__
  29:main_sim900.h ****   blokada_clip = FALSE;
 2947               		.loc 2 29 0
 2948 0db8 1092 0000 		sts licznik_ogolny_blad_zalogowania+1,__zero_reg__
 2949 0dbc 1092 0000 		sts licznik_ogolny_blad_zalogowania,__zero_reg__
  30:main_sim900.h ****   nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 2950               		.loc 2 30 0
 2951 0dc0 1092 0000 		sts blokada_clip,__zero_reg__
  31:main_sim900.h ****   poziom_sieci_gsm = POZIOM_SIECI_BLAD;
 2952               		.loc 2 31 0
 2953 0dc4 1092 0000 		sts nastepne_wysylane_polecenie_SIM900,__zero_reg__
  32:main_sim900.h ****   filtruj_komendy_z_przedzialu(KOMENDA_KOLEJKI_USUN_SMSA_1,
 2954               		.loc 2 32 0
 2955 0dc8 83E6      		ldi r24,lo8(99)
 2956 0dca 8093 0000 		sts poziom_sieci_gsm,r24
  33:main_sim900.h ****                                KOMENDA_KOLEJKI_USUN_SMSA_20);
 2957               		.loc 2 33 0
 2958 0dce 61ED      		ldi r22,lo8(-47)
 2959 0dd0 8EEB      		ldi r24,lo8(-66)
 2960 0dd2 0E94 0000 		call filtruj_komendy_z_przedzialu
 2961               	.LVL256:
  35:main_sim900.h ****       KOMENDA_KOLEJKI_KOMENDA_SIM900,
 2962               		.loc 2 35 0
 2963 0dd6 6EE9      		ldi r22,lo8(-98)
 2964 0dd8 8AE8      		ldi r24,lo8(-118)
 2965 0dda 0E94 0000 		call filtruj_komendy_z_przedzialu
 2966               	.LVL257:
  38:main_sim900.h ****       KOMENDA_KOLEJKI_SPRAWDZ_PIN,
 2967               		.loc 2 38 0
 2968 0dde 68EA      		ldi r22,lo8(-88)
 2969 0de0 8FE9      		ldi r24,lo8(-97)
 2970 0de2 0E94 0000 		call filtruj_komendy_z_przedzialu
 2971               	.LVL258:
  41:main_sim900.h ****                                KOMENDA_KOLEJKI_WYSLIJ_PDU);
 2972               		.loc 2 41 0
 2973 0de6 65ED      		ldi r22,lo8(-43)
 2974 0de8 83ED      		ldi r24,lo8(-45)
 2975 0dea 0E94 0000 		call filtruj_komendy_z_przedzialu
 2976               	.LVL259:
  43:main_sim900.h **** }
 2977               		.loc 2 43 0
 2978 0dee 1092 0000 		sts modul_zalogowany_w_sieci,__zero_reg__
 2979               	/* epilogue start */
  44:main_sim900.h **** 
 2980               		.loc 2 44 0
 2981 0df2 0895      		ret
 2982               		.cfi_endproc
 2983               	.LFE46:
 2985               	.global	obsluga_wysylania_sms
 2987               	obsluga_wysylania_sms:
 2988               	.LFB49:
  52:main_sim900.h **** }
  53:main_sim900.h **** 
  54:main_sim900.h **** void obsluga_wysylania_sms(void) {
 2989               		.loc 2 54 0
 2990               		.cfi_startproc
 2991               	/* prologue: function */
 2992               	/* frame size = 0 */
 2993               	/* stack size = 0 */
 2994               	.L__stack_usage = 0
 2995               	.LVL260:
  55:main_sim900.h ****   POMOC_DODAJ2('#', 'M');
  56:main_sim900.h ****   if (czy_jest_komenda_wyslano_sms()) {
 2996               		.loc 2 56 0
 2997 0df4 8091 0000 		lds r24,komenda_SIM900
 2998 0df8 8D30      		cpi r24,lo8(13)
 2999 0dfa 01F4      		brne .L174
 3000               	.LVL261:
  57:main_sim900.h ****     POMOC_DODAJ2('#', 'T');
  58:main_sim900.h ****     liczba_prob_wyslania_smsa = 0;
 3001               		.loc 2 58 0
 3002 0dfc 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
 3003               	.LVL262:
 3004               	.LBB489:
 3005               	.LBB490:
 788:main.c        **** }
 3006               		.loc 1 788 0
 3007 0e00 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 3008               	.LBE490:
 3009               	.LBE489:
  59:main_sim900.h ****     zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_ok);
  60:main_sim900.h ****     flaga_wysylanie_smsa = 0;
 3010               		.loc 2 60 0
 3011 0e04 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
  61:main_sim900.h ****     opoznienie_SIM900_100MS = 70;
 3012               		.loc 2 61 0
 3013 0e08 86E4      		ldi r24,lo8(70)
 3014 0e0a 8093 0000 		sts opoznienie_SIM900_100MS,r24
  62:main_sim900.h ****     return;
 3015               		.loc 2 62 0
 3016 0e0e 0895      		ret
 3017               	.LVL263:
 3018               	.L174:
  63:main_sim900.h ****   } else if (
  64:main_sim900.h ****       czy_jest_komenda_blad_CMS()) // spawdzi
 3019               		.loc 2 64 0
 3020 0e10 8091 0000 		lds r24,komenda_SIM900
  63:main_sim900.h ****   } else if (
 3021               		.loc 2 63 0
 3022 0e14 8630      		cpi r24,lo8(6)
 3023 0e16 01F4      		brne .L176
  65:main_sim900.h ****                                    // czy_modul_byl_polaczony_z_internetem
  66:main_sim900.h ****   {
  67:main_sim900.h ****     ++liczba_prob_wyslania_smsa;
 3024               		.loc 2 67 0
 3025 0e18 2091 0000 		lds r18,liczba_prob_wyslania_smsa
 3026 0e1c 2F5F      		subi r18,lo8(-(1))
 3027 0e1e 2093 0000 		sts liczba_prob_wyslania_smsa,r18
  68:main_sim900.h ****     if (numer_bledu_cms == CMS_SM_BL_NOT_READY ||
 3028               		.loc 2 68 0
 3029 0e22 8091 0000 		lds r24,numer_bledu_cms
 3030 0e26 9091 0000 		lds r25,numer_bledu_cms+1
 3031 0e2a 8530      		cpi r24,5
 3032 0e2c 32E0      		ldi r19,2
 3033 0e2e 9307      		cpc r25,r19
 3034 0e30 01F0      		breq .L177
 3035               		.loc 2 68 0 is_stmt 0 discriminator 1
 3036 0e32 8A33      		cpi r24,58
 3037 0e34 31E0      		ldi r19,1
 3038 0e36 9307      		cpc r25,r19
 3039 0e38 01F0      		breq .L177
  69:main_sim900.h ****         numer_bledu_cms == CMS_SIM_BUSY ||
 3040               		.loc 2 69 0 is_stmt 1
 3041 0e3a 8330      		cpi r24,3
 3042 0e3c 32E0      		ldi r19,2
 3043 0e3e 9307      		cpc r25,r19
 3044 0e40 01F0      		breq .L177
  70:main_sim900.h ****         numer_bledu_cms == CMS_PC_BUSY // powinien by reset
  71:main_sim900.h ****         || numer_bledu_cms == CMS_INVALID_CHARS_IN_PDU ||
 3045               		.loc 2 71 0
 3046 0e42 8051      		subi r24,16
 3047 0e44 9240      		sbci r25,2
 3048 0e46 0297      		sbiw r24,2
 3049 0e48 00F4      		brsh .L178
 3050               	.L177:
  72:main_sim900.h ****         numer_bledu_cms == CMS_INCORECT_PDU_LENGTH) {
  73:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 3051               		.loc 2 73 0
 3052 0e4a 8CE3      		ldi r24,lo8(60)
 3053 0e4c 8093 0000 		sts opoznienie_SIM900_100MS,r24
  74:main_sim900.h ****       if (liczba_prob_wyslania_smsa < max_liczba_prob_wyslania_smsa) {
  75:main_sim900.h ****         POMOC_DODAJ2('#', 'C');
  76:main_sim900.h ****         POMOC_DODAJ_HEX(numer_bledu_cms >> 8);
  77:main_sim900.h ****         POMOC_DODAJ_HEX(numer_bledu_cms & 0xff);
  78:main_sim900.h ****         dodaj_komende(flaga_wysylanie_smsa);
 3054               		.loc 2 78 0
 3055 0e50 8091 0000 		lds r24,flaga_wysylanie_smsa
  74:main_sim900.h ****       if (liczba_prob_wyslania_smsa < max_liczba_prob_wyslania_smsa) {
 3056               		.loc 2 74 0
 3057 0e54 2230      		cpi r18,lo8(2)
 3058 0e56 00F0      		brlo .L202
 3059               	.LVL264:
 3060               	.L203:
  79:main_sim900.h ****       } else {
  80:main_sim900.h ****         POMOC_DODAJ2('#', 'D');
  81:main_sim900.h ****         POMOC_DODAJ_HEX(numer_bledu_cms >> 8);
  82:main_sim900.h ****         POMOC_DODAJ_HEX(numer_bledu_cms & 0xff);
  83:main_sim900.h ****         liczba_prob_wyslania_smsa = 0;
  84:main_sim900.h ****         zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
  85:main_sim900.h ****       }
  86:main_sim900.h ****     } else {
  87:main_sim900.h ****       POMOC_DODAJ2('#', 'F');
  88:main_sim900.h ****       POMOC_DODAJ_HEX(numer_bledu_cms >> 8);
  89:main_sim900.h ****       POMOC_DODAJ_HEX(numer_bledu_cms & 0xff);
  90:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
  91:main_sim900.h ****       liczba_prob_wyslania_smsa = 0;
 3061               		.loc 2 91 0
 3062 0e58 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
 3063               	.LVL265:
 3064               	.LBB491:
 3065               	.LBB492:
 788:main.c        **** }
 3066               		.loc 1 788 0
 3067 0e5c 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 3068               	.LVL266:
 3069               	.L180:
 3070               	.LBE492:
 3071               	.LBE491:
  92:main_sim900.h ****       zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
  93:main_sim900.h ****     }
  94:main_sim900.h ****     flaga_wysylanie_smsa = 0;
 3072               		.loc 2 94 0
 3073 0e60 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
 3074 0e64 0895      		ret
 3075               	.LVL267:
 3076               	.L178:
  90:main_sim900.h ****       liczba_prob_wyslania_smsa = 0;
 3077               		.loc 2 90 0
 3078 0e66 8CE3      		ldi r24,lo8(60)
 3079 0e68 8093 0000 		sts opoznienie_SIM900_100MS,r24
 3080 0e6c 00C0      		rjmp .L203
 3081               	.LVL268:
 3082               	.L176:
 3083               	.LBB493:
 3084               	.LBB494:
  95:main_sim900.h ****   } else if (czy_jest_komenda_ERROR()) {
 3085               		.loc 2 95 0
 3086 0e6e 8091 0000 		lds r24,komenda_SIM900
 3087 0e72 8430      		cpi r24,lo8(4)
 3088 0e74 01F4      		brne .L181
 3089               	.LVL269:
  96:main_sim900.h ****     POMOC_DODAJ2('#', 'G');
  97:main_sim900.h ****     opoznienie_SIM900_100MS = 60;
 3090               		.loc 2 97 0
 3091 0e76 8CE3      		ldi r24,lo8(60)
 3092 0e78 8093 0000 		sts opoznienie_SIM900_100MS,r24
  98:main_sim900.h ****     czekanie_na_odebranie_zachety = FALSE;
 3093               		.loc 2 98 0
 3094 0e7c 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
  99:main_sim900.h ****     if ((odebrany_blok_SIM900[2] == '>' &&
 3095               		.loc 2 99 0
 3096 0e80 8091 0000 		lds r24,odebrany_blok_SIM900+2
 3097 0e84 8E33      		cpi r24,lo8(62)
 3098 0e86 01F4      		brne .L182
 100:main_sim900.h ****          liczba_odebranych_znakow_SIM900 < 10) ||
 3099               		.loc 2 100 0
 3100 0e88 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 3101 0e8c 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
  99:main_sim900.h ****     if ((odebrany_blok_SIM900[2] == '>' &&
 3102               		.loc 2 99 0
 3103 0e90 0A97      		sbiw r24,10
 3104 0e92 00F0      		brlo .L183
 3105               	.L182:
 101:main_sim900.h ****         flaga_wysylanie_smsa == 0) // SIM900 nie odpowiada
 3106               		.loc 2 101 0
 3107 0e94 8091 0000 		lds r24,flaga_wysylanie_smsa
 100:main_sim900.h ****          liczba_odebranych_znakow_SIM900 < 10) ||
 3108               		.loc 2 100 0
 3109 0e98 8111      		cpse r24,__zero_reg__
 3110 0e9a 00C0      		rjmp .L184
 3111               	.L183:
 3112               	.LVL270:
 102:main_sim900.h ****     {
 103:main_sim900.h ****       POMOC_DODAJ2('#', 'H');
 104:main_sim900.h ****       liczba_prob_wyslania_smsa = 0;
 3113               		.loc 2 104 0
 3114 0e9c 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
 3115               	.LVL271:
 3116               	.LBB495:
 3117               	.LBB496:
 788:main.c        **** }
 3118               		.loc 1 788 0
 3119 0ea0 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 3120               	.LBE496:
 3121               	.LBE495:
 105:main_sim900.h ****       zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
 106:main_sim900.h ****       reset_modulu_SIM900();
 3122               		.loc 2 106 0
 3123 0ea4 0E94 0000 		call reset_modulu_SIM900
 3124               	.LVL272:
 3125 0ea8 00C0      		rjmp .L180
 3126               	.LVL273:
 3127               	.L184:
 107:main_sim900.h ****     } else {
 108:main_sim900.h ****       POMOC_DODAJ2('#', 'I');
 109:main_sim900.h ****       if (++liczba_prob_wyslania_smsa <
 3128               		.loc 2 109 0
 3129 0eaa 9091 0000 		lds r25,liczba_prob_wyslania_smsa
 3130 0eae 9F5F      		subi r25,lo8(-(1))
 3131 0eb0 9093 0000 		sts liczba_prob_wyslania_smsa,r25
 3132 0eb4 9230      		cpi r25,lo8(2)
 3133 0eb6 00F4      		brsh .L203
 3134               	.LVL274:
 3135               	.L202:
 110:main_sim900.h ****           max_liczba_prob_wyslania_smsa) // musi by sta wartoci
 111:main_sim900.h ****         dodaj_komende(flaga_wysylanie_smsa);
 3136               		.loc 2 111 0
 3137 0eb8 0E94 0000 		call dodaj_komende
 3138               	.LVL275:
 3139 0ebc 00C0      		rjmp .L180
 3140               	.LVL276:
 3141               	.L181:
 112:main_sim900.h ****       else {
 113:main_sim900.h ****         liczba_prob_wyslania_smsa = 0;
 114:main_sim900.h ****         zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
 115:main_sim900.h ****       }
 116:main_sim900.h ****     }
 117:main_sim900.h ****     flaga_wysylanie_smsa = 0;
 118:main_sim900.h ****   } else if (czy_jest_komenda_blad_CME()) {
 3142               		.loc 2 118 0
 3143 0ebe 8091 0000 		lds r24,komenda_SIM900
 3144 0ec2 8530      		cpi r24,lo8(5)
 3145 0ec4 01F4      		brne .L185
 3146               	.LVL277:
 119:main_sim900.h ****     POMOC_DODAJ2('#', 'J');
 120:main_sim900.h ****     POMOC_DODAJ_HEX(numer_bledu_cme >> 8);
 3147               		.loc 2 120 0
 3148 0ec6 8091 0000 		lds r24,numer_bledu_cme
 3149 0eca 9091 0000 		lds r25,numer_bledu_cme+1
 3150               	.LVL278:
 121:main_sim900.h ****     POMOC_DODAJ_HEX(numer_bledu_cme & 0xff);
 122:main_sim900.h ****     if (numer_bledu_cme == CME_SIM_NOT_INSERTED ||
 3151               		.loc 2 122 0
 3152 0ece 8A30      		cpi r24,10
 3153 0ed0 9105      		cpc r25,__zero_reg__
 3154 0ed2 01F0      		breq .L186
 3155 0ed4 9C01      		movw r18,r24
 3156 0ed6 2D7F      		andi r18,253
 3157 0ed8 2D30      		cpi r18,13
 3158 0eda 3105      		cpc r19,__zero_reg__
 3159 0edc 01F0      		breq .L186
 123:main_sim900.h ****         numer_bledu_cme == CME_SIM_FAILURE ||
 124:main_sim900.h ****         numer_bledu_cme == CME_SIM_WRONG ||
 3160               		.loc 2 124 0
 3161 0ede 4E97      		sbiw r24,30
 3162 0ee0 01F4      		brne .L173
 3163               	.L186:
 3164               	.LVL279:
 125:main_sim900.h ****         numer_bledu_cme == CME_NO_NETWORK_SERVICE) {
 126:main_sim900.h ****       POMOC_DODAJ2('#', 'K');
 127:main_sim900.h ****       liczba_prob_wyslania_smsa = 0;
 3165               		.loc 2 127 0
 3166 0ee2 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
 3167               	.LVL280:
 3168               	.LBB497:
 3169               	.LBB498:
 786:main.c        **** 
 3170               		.loc 1 786 0
 3171 0ee6 8CE3      		ldi r24,lo8(60)
 3172               	.LVL281:
 3173 0ee8 8093 0000 		sts opoznienie_SIM900_100MS,r24
 788:main.c        **** }
 3174               		.loc 1 788 0
 3175 0eec 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 3176               	.LBE498:
 3177               	.LBE497:
 128:main_sim900.h ****       zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
 129:main_sim900.h ****       reset_modulu_SIM900();
 3178               		.loc 2 129 0
 3179 0ef0 0C94 0000 		jmp reset_modulu_SIM900
 3180               	.LVL282:
 3181               	.L185:
 130:main_sim900.h ****     }
 131:main_sim900.h ****   } else {
 132:main_sim900.h ****     POMOC_DODAJ2('#', 'L');
 133:main_sim900.h ****     POMOC_DODAJ_HEX(komenda_SIM900 >> 8);
 3182               		.loc 2 133 0
 3183 0ef4 8091 0000 		lds r24,komenda_SIM900
 3184               	.LVL283:
 134:main_sim900.h ****     POMOC_DODAJ_HEX(komenda_SIM900 & 0xff);
 3185               		.loc 2 134 0
 3186 0ef8 8091 0000 		lds r24,komenda_SIM900
 3187               	.LVL284:
 3188               	.L173:
 3189               	/* epilogue start */
 3190               	.LBE494:
 3191               	.LBE493:
 135:main_sim900.h ****   }
 136:main_sim900.h **** }
 3192               		.loc 2 136 0
 3193 0efc 0895      		ret
 3194               		.cfi_endproc
 3195               	.LFE49:
 3197               	.global	odpowiedz_na_polecenie
 3199               	odpowiedz_na_polecenie:
 3200               	.LFB50:
 137:main_sim900.h **** 
 138:main_sim900.h **** void odpowiedz_na_polecenie(void) {
 3201               		.loc 2 138 0
 3202               		.cfi_startproc
 3203 0efe 0F93      		push r16
 3204               	.LCFI60:
 3205               		.cfi_def_cfa_offset 3
 3206               		.cfi_offset 16, -2
 3207 0f00 1F93      		push r17
 3208               	.LCFI61:
 3209               		.cfi_def_cfa_offset 4
 3210               		.cfi_offset 17, -3
 3211 0f02 CF93      		push r28
 3212               	.LCFI62:
 3213               		.cfi_def_cfa_offset 5
 3214               		.cfi_offset 28, -4
 3215 0f04 DF93      		push r29
 3216               	.LCFI63:
 3217               		.cfi_def_cfa_offset 6
 3218               		.cfi_offset 29, -5
 3219               	/* prologue: function */
 3220               	/* frame size = 0 */
 3221               	/* stack size = 4 */
 3222               	.L__stack_usage = 4
 139:main_sim900.h **** #define czy_polecenie_sim(POL) czy_polecenie_SIM900(POL, sizeof POL - 1)
 140:main_sim900.h ****   const uchar kom = komenda_SIM900;
 3223               		.loc 2 140 0
 3224 0f06 D091 0000 		lds r29,komenda_SIM900
 3225               	.LVL285:
 141:main_sim900.h **** 
 142:main_sim900.h ****   switch (aktualnie_wysylane_polecenie_SIM900) {
 3226               		.loc 2 142 0
 3227 0f0a C091 0000 		lds r28,aktualnie_wysylane_polecenie_SIM900
 3228 0f0e CE39      		cpi r28,lo8(-98)
 3229 0f10 01F4      		brne .+2
 3230 0f12 00C0      		rjmp .L206
 3231 0f14 00F0      		brlo .+2
 3232 0f16 00C0      		rjmp .L207
 3233 0f18 C539      		cpi r28,lo8(-107)
 3234 0f1a 01F4      		brne .+2
 3235 0f1c 00C0      		rjmp .L208
 3236 0f1e 00F4      		brsh .L209
 3237 0f20 CF38      		cpi r28,lo8(-113)
 3238 0f22 01F4      		brne .+2
 3239 0f24 00C0      		rjmp .L210
 3240 0f26 00F4      		brsh .L211
 3241 0f28 CC38      		cpi r28,lo8(-116)
 3242 0f2a 01F4      		brne .+2
 3243 0f2c 00C0      		rjmp .L212
 3244 0f2e CE38      		cpi r28,lo8(-114)
 3245 0f30 01F4      		brne .+2
 3246 0f32 00C0      		rjmp .L213
 3247               	.L205:
 143:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 144:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_ODEBRANO_POLECENIE_ROZPOCZYNAJACE);
 145:main_sim900.h ****     max_oczekiwanie_na_odpowiedz_at = 0;
 146:main_sim900.h ****     break;
 147:main_sim900.h ****   }
 148:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE: {
 149:main_sim900.h ****     static const char polecenie_zegar[] PROGMEM = "+CCLK:";
 150:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 &&
 151:main_sim900.h ****         polozenie_polecenia_SIM900(polecenie_zegar) != NULL) {
 152:main_sim900.h ****       const uchar *p1 =
 153:main_sim900.h ****           strchr(polozenie_polecenia_SIM900(polecenie_zegar), '\"');
 154:main_sim900.h ****       if (p1++ != NULL) {
 155:main_sim900.h ****         const uchar *p2 = strchr(p1, '\"');
 156:main_sim900.h ****         const uchar *p3 = strchr(p1, ',');
 157:main_sim900.h ****         if (p2 != NULL && p3++ != NULL && p2 > p3) {
 158:main_sim900.h ****           // const uchar g = atoi(p3);
 159:main_sim900.h ****           if ((p3 = strchr(p3, ':')) != NULL && p2 > p3++) {
 160:main_sim900.h ****             // Pobierz czas z odpowiedzi +CCLK: "yy/MM/dd,hh:mm:ss+zz"
 161:main_sim900.h ****             // p3 wskazuje na minuty po pierwszym ':'
 162:main_sim900.h ****             // cofnijmy si do pocztku godziny (p3 wskazuje na mm, wic -3 to hh)
 163:main_sim900.h ****             // ale w kodzie powyej p3 byo przesuwane.
 164:main_sim900.h **** 
 165:main_sim900.h ****             // Restart parsowania dla pewnoci:
 166:main_sim900.h ****             // "24/01/01,12:34:56+00"
 167:main_sim900.h ****             const char *ptr_time = strchr(p1, ',');
 168:main_sim900.h ****             if (ptr_time) {
 169:main_sim900.h ****               ptr_time++; // skip comma
 170:main_sim900.h ****               if (strlen(ptr_time) >= 8) {
 171:main_sim900.h ****                 memcpy(rtc_czas, ptr_time, 8);
 172:main_sim900.h ****                 rtc_czas[8] = '\0';
 173:main_sim900.h **** 
 174:main_sim900.h ****                 // Aktualizacja blokady czasowej
 175:main_sim900.h ****                 if (czas_start_h == 0xFF) {
 176:main_sim900.h ****                   blokada_sterowania_czasowa = FALSE;
 177:main_sim900.h ****                 } else {
 178:main_sim900.h ****                   // Parsowanie aktualnego czasu
 179:main_sim900.h ****                   int curr_h = (rtc_czas[0] - '0') * 10 + (rtc_czas[1] - '0');
 180:main_sim900.h ****                   int curr_m = (rtc_czas[3] - '0') * 10 + (rtc_czas[4] - '0');
 181:main_sim900.h ****                   int curr_time = curr_h * 60 + curr_m;
 182:main_sim900.h **** 
 183:main_sim900.h ****                   int start_time = czas_start_h * 60 + czas_start_m;
 184:main_sim900.h ****                   int stop_time = czas_stop_h * 60 + czas_stop_m;
 185:main_sim900.h **** 
 186:main_sim900.h ****                   if (start_time <= stop_time) {
 187:main_sim900.h ****                     // Normalny przedzial (np. 08:00 - 16:00)
 188:main_sim900.h ****                     if (curr_time >= start_time && curr_time <= stop_time)
 189:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 190:main_sim900.h ****                     else
 191:main_sim900.h ****                       blokada_sterowania_czasowa = TRUE;
 192:main_sim900.h ****                   } else {
 193:main_sim900.h ****                     // Przejscie przez polnoc (np. 22:00 - 06:00)
 194:main_sim900.h ****                     if (curr_time >= start_time || curr_time <= stop_time)
 195:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 196:main_sim900.h ****                     else
 197:main_sim900.h ****                       blokada_sterowania_czasowa = TRUE;
 198:main_sim900.h ****                   }
 199:main_sim900.h ****                 }
 200:main_sim900.h ****               }
 201:main_sim900.h ****             }
 202:main_sim900.h ****           }
 203:main_sim900.h ****         }
 204:main_sim900.h ****       }
 205:main_sim900.h ****     }
 206:main_sim900.h ****     break;
 207:main_sim900.h ****   }
 208:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_PIN: {
 209:main_sim900.h ****     static const char polecenie_pin_ready[] PROGMEM = "+CPIN: READY";
 210:main_sim900.h ****     static uchar nr_zapytania_o_pin;
 211:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 212:main_sim900.h ****       if (polozenie_polecenia_SIM900(polecenie_pin_ready) != NULL) {
 213:main_sim900.h ****         podlaczona_karta_SIM_SIM900 = TRUE;
 214:main_sim900.h ****         bledny_PIN = FALSE;
 215:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 216:main_sim900.h ****       } else
 217:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_PODAJ_PIN);
 218:main_sim900.h ****       nr_zapytania_o_pin = 0;
 219:main_sim900.h ****     } else if (kom == CME_ERROR_KOMENDA_SIM900 &&
 220:main_sim900.h ****                numer_bledu_cme == CME_SIM_BUSY)
 221:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 222:main_sim900.h ****     else if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900()) {
 223:main_sim900.h ****       if (++nr_zapytania_o_pin >= 20) {
 224:main_sim900.h ****         reset_modulu_SIM900();
 225:main_sim900.h ****         nr_zapytania_o_pin = 0;
 226:main_sim900.h ****       } else {
 227:main_sim900.h ****         opoznienie_SIM900_100MS = 20;
 228:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 229:main_sim900.h ****       }
 230:main_sim900.h ****     } else
 231:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 232:main_sim900.h ****     break;
 233:main_sim900.h ****   }
 234:main_sim900.h ****   case KOMENDA_KOLEJKI_PODAJ_PIN: {
 235:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 236:main_sim900.h ****       podlaczona_karta_SIM_SIM900 = TRUE;
 237:main_sim900.h ****       bledny_PIN = FALSE;
 238:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 239:main_sim900.h ****       opoznienie_SIM900_100MS = 50;
 240:main_sim900.h ****     } else if (kom == CME_ERROR_KOMENDA_SIM900 &&
 241:main_sim900.h ****                numer_bledu_cme == CME_SIM_INCORECT_PASWORD)
 242:main_sim900.h ****       bledny_PIN = TRUE;
 243:main_sim900.h ****     else if (kom == CME_ERROR_KOMENDA_SIM900 && numer_bledu_cme == CME_SIM_BUSY)
 244:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 245:main_sim900.h ****     else if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900())
 246:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 247:main_sim900.h ****     else
 248:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 249:main_sim900.h ****     break;
 250:main_sim900.h ****   }
 251:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY: {
 252:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900)
 253:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW);
 254:main_sim900.h ****     else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 255:main_sim900.h ****       if (numer_bledu_cms == CMS_SIM_BUSY ||
 256:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 257:main_sim900.h ****         opoznienie_SIM900_100MS = 60;
 258:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 259:main_sim900.h ****       }
 260:main_sim900.h ****     } else if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900())
 261:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 262:main_sim900.h ****     break;
 263:main_sim900.h ****   }
 264:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW: {
 265:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900)
 266:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW);
 267:main_sim900.h ****     else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 268:main_sim900.h ****       if (numer_bledu_cms == CMS_SIM_BUSY ||
 269:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 270:main_sim900.h ****         opoznienie_SIM900_100MS = 20;
 271:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 272:main_sim900.h ****       }
 273:main_sim900.h ****     } else {
 274:main_sim900.h ****       opoznienie_SIM900_100MS = 10;
 275:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 276:main_sim900.h ****     }
 277:main_sim900.h ****     break;
 278:main_sim900.h ****   }
 279:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_WYSYLANIE_INFO_O_DZWONIACYM: {
 280:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 ||
 281:main_sim900.h ****         (kom == CME_ERROR_KOMENDA_SIM900 &&
 282:main_sim900.h ****          (numer_bledu_cme == CME_OPERATION_NOT_ALLOWED ||
 283:main_sim900.h ****           numer_bledu_cme == CME_OPERATION_NOT_SUPPORTED))) {
 284:main_sim900.h ****       dodaj_komende(nastepne_wysylane_polecenie_SIM900);
 285:main_sim900.h ****       nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 286:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 287:main_sim900.h ****     } else if (kom != OK_KOMENDA_SIM900 &&
 288:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 289:main_sim900.h ****                    MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 290:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 291:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 292:main_sim900.h ****     break;
 293:main_sim900.h ****   }
 294:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_POZIOM_SIECI: {
 295:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 296:main_sim900.h ****       static const uchar urc[] PROGMEM = "+CSQ:";
 297:main_sim900.h ****       const uchar *p1 = polozenie_polecenia_SIM900(urc);
 298:main_sim900.h ****       if (p1 != NULL) {
 299:main_sim900.h ****         p1 += strlen_R(urc) + 1;
 300:main_sim900.h ****         poziom_sieci_gsm = strtol(p1, NULL, 10);
 301:main_sim900.h ****         // if ( poziom_sieci_gsm != POZIOM_SIECI_BLAD )
 302:main_sim900.h ****         //	POMOC_DODAJ2('*', '0' + poziom_sieci_gsm / 4);
 303:main_sim900.h ****         // else
 304:main_sim900.h ****         //{
 305:main_sim900.h ****         //	POMOC_DODAJ2('*', 'c');
 306:main_sim900.h ****         // }
 307:main_sim900.h ****       }
 308:main_sim900.h ****     } else
 309:main_sim900.h ****       poziom_sieci_gsm = POZIOM_SIECI_BLAD;
 310:main_sim900.h ****     break;
 311:main_sim900.h ****   }
 312:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_ZAREJESTROWANIE: {
 313:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 314:main_sim900.h ****       static const uchar urc[] PROGMEM = "+CREG:";
 315:main_sim900.h ****       const uchar *p1 = polozenie_polecenia_SIM900(urc);
 316:main_sim900.h ****       if (p1 != NULL) {
 317:main_sim900.h ****         p1 += strlen_R(urc) + 1;
 318:main_sim900.h ****         if (*p1 != ',')
 319:main_sim900.h ****           ++p1;
 320:main_sim900.h ****         if (*p1 != ',')
 321:main_sim900.h ****           ++p1;
 322:main_sim900.h ****         if (*p1 != ',')
 323:main_sim900.h ****           ++p1;
 324:main_sim900.h ****         ++p1;
 325:main_sim900.h ****         uchar stan_zarejestrowania = (uchar)strtol(p1, NULL, 10);
 326:main_sim900.h ****         if (stan_zarejestrowania == 0 || stan_zarejestrowania == 3 ||
 327:main_sim900.h ****             stan_zarejestrowania == 4) {
 328:main_sim900.h ****           reset_modulu_SIM900();
 329:main_sim900.h ****         } else if (stan_zarejestrowania == 1 || stan_zarejestrowania == 5) {
 330:main_sim900.h ****           modul_zalogowany_w_sieci = TRUE;
 331:main_sim900.h ****         }
 332:main_sim900.h ****       }
 333:main_sim900.h ****     }
 334:main_sim900.h ****     break;
 335:main_sim900.h ****   }
 336:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_STAN_KARTY_SIM: {
 337:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 || (kom == CME_ERROR_KOMENDA_SIM900 &&
 338:main_sim900.h ****                                      (numer_bledu_cme == CME_INVALID_INDEX ||
 339:main_sim900.h ****                                       numer_bledu_cme == CME_NOT_FOUND))) {
 340:main_sim900.h ****       licznik_blad_stanu_karty_SIM = 0;
 341:main_sim900.h ****     } else {
 342:main_sim900.h ****       ++licznik_blad_stanu_karty_SIM;
 343:main_sim900.h ****     }
 344:main_sim900.h ****     break;
 345:main_sim900.h ****   }
 346:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_ZALOGOWANIE_U_OPERATORA: {
 347:main_sim900.h ****     static const char polecenie_operator[] PROGMEM = "+COPS:";
 348:main_sim900.h ****     uchar w = FALSE;
 349:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 && czy_polecenie_sim(polecenie_operator)) {
 350:main_sim900.h ****       const uchar *p1 =
 351:main_sim900.h ****           strchr(polozenie_polecenia_SIM900(polecenie_operator), ',');
 352:main_sim900.h ****       if (p1 != NULL) {
 353:main_sim900.h ****         p1 = strchr(p1, ',');
 354:main_sim900.h ****         if (p1 != NULL) {
 355:main_sim900.h ****           p1 = strchr(p1, '\"');
 356:main_sim900.h ****           if (p1++ != NULL) {
 357:main_sim900.h ****             const uchar *p2 = strchr(p1, '\"');
 358:main_sim900.h ****             if (p2 != NULL && p1 != p2) {
 359:main_sim900.h ****               const uchar m = min(p2 - p1, ROZMIAR_NAZWA_OPERATORA);
 360:main_sim900.h ****               memcpy(nazwa_operatora, p1, m);
 361:main_sim900.h ****               nazwa_operatora[m] = '\0';
 362:main_sim900.h ****               w = TRUE;
 363:main_sim900.h ****             }
 364:main_sim900.h ****           }
 365:main_sim900.h ****         }
 366:main_sim900.h ****       }
 367:main_sim900.h ****     }
 368:main_sim900.h ****     if (w)
 369:main_sim900.h ****       licznik_blad_zalogowania_u_operatora = 0;
 370:main_sim900.h ****     else {
 371:main_sim900.h ****       ++licznik_blad_zalogowania_u_operatora;
 372:main_sim900.h ****     }
 373:main_sim900.h ****     // POMOC_DODAJ2('*', w ? '+' : '-');
 374:main_sim900.h ****     break;
 375:main_sim900.h ****   }
 376:main_sim900.h ****   case KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS: {
 377:main_sim900.h ****     if (kom ==
 378:main_sim900.h ****         CMS_ERROR_KOMENDA_SIM900 /*&& numer_bledu_cms == CMS_SMS_ME_RESERVED*/) // co le interpretu
 379:main_sim900.h ****       ; // nic nie robi
 380:main_sim900.h ****     else if (kom != OK_KOMENDA_SIM900)
 381:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 382:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 383:main_sim900.h ****     break;
 384:main_sim900.h ****   }
 385:main_sim900.h ****   case KOMENDA_KOLEJKI_ODBIERZ_ROZMOWE: {
 386:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 ||
 387:main_sim900.h ****         czy_jest_komenda_uzytkownik_odebral_rozmowe()) {
 388:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = TRUE;
 389:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 390:main_sim900.h **** 
 391:main_sim900.h ****       // DTMF START
 392:main_sim900.h ****       if (!tryb_clip) {
 393:main_sim900.h ****         licznik_timeout_rozmowy_100ms = MAX_LICZNIK_TIMEOUT_ROZMOWY_100MS;
 394:main_sim900.h ****         opoznienie_SIM900_100MS =
 395:main_sim900.h ****             20; // 2 sekundy opoznienia przed wyslaniem tonu
 396:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_TON_DTMF); // Beep potwierdzenia
 397:main_sim900.h ****       }
 398:main_sim900.h ****     } else if ((kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900()) &&
 399:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 400:main_sim900.h ****                    MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 401:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 402:main_sim900.h ****     else if (kom == NO_CARRIER_KOMENDA_SIM900) {
 403:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 404:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 405:main_sim900.h ****     } else
 406:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 407:main_sim900.h ****     break;
 408:main_sim900.h ****   }
 409:main_sim900.h ****   case KOMENDA_KOLEJKI_ODRZUC_ROZMOWE: {
 410:main_sim900.h ****     if (kom != OK_KOMENDA_SIM900)
 411:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 412:main_sim900.h ****     else {
 413:main_sim900.h ****       zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_zakonczenie);
 414:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 415:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 416:main_sim900.h ****     }
 417:main_sim900.h ****     break;
 418:main_sim900.h ****   }
 419:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1:
 420:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_2:
 421:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_3:
 422:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_4:
 423:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_5:
 424:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_6:
 425:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_7:
 426:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_8:
 427:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_9:
 428:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_10:
 429:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_11:
 430:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_12:
 431:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_13:
 432:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_14:
 433:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_15:
 434:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_16:
 435:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_17:
 436:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_18:
 437:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_19:
 438:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20: {
 439:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 440:main_sim900.h ****       // odczytany sms
 441:main_sim900.h ****       const uchar *ptr = polozenie_polecenia_SIM900(PSTR("+CMGR:")); // (1)
 442:main_sim900.h ****       ptr = strchr(ptr, ZNAK_KONCA_ODBIERANIA_ZNAKOW_LF);            // (1)
 443:main_sim900.h ****       // const uchar* ptr = strchr(&odebrany_blok_SIM900[7],
 444:main_sim900.h ****       // ZNAK_KONCA_ODBIERANIA_ZNAKOW_LF);
 445:main_sim900.h ****       if (ptr != NULL) {
 446:main_sim900.h ****         ++ptr;
 447:main_sim900.h ****         const uchar *ptr2 = strchr(ptr, ZNAK_KONCA_WYSYLANIA_ZNAKOW_CR);
 448:main_sim900.h ****         if (ptr2 != NULL) {
 449:main_sim900.h ****           dlugosc_pdu = (ptr2 - ptr) / 2;
 450:main_sim900.h ****           if (dlugosc_pdu > MAX_DLUGOSC_PDU)
 451:main_sim900.h ****             dlugosc_pdu = MAX_DLUGOSC_PDU;
 452:main_sim900.h ****           konwertuj_blok_dwa_znaki_na_znak_pdu(ptr, dlugosc_pdu, bufor_pdu);
 453:main_sim900.h ****           dodaj_komende(KOMENDA_KOLEJKI_INTERPRETUJ_PDU);
 454:main_sim900.h ****           const uchar nr_smsa = aktualnie_wysylane_polecenie_SIM900 -
 455:main_sim900.h ****                                 KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1;
 456:main_sim900.h ****           dodaj_komende(KOMENDA_KOLEJKI_USUN_SMSA_1 + nr_smsa);
 457:main_sim900.h ****           flaga_odczytywanie_smsa = TRUE;
 458:main_sim900.h ****           POMOC_DODAJ2('#', 'O');
 459:main_sim900.h ****         } else
 460:main_sim900.h ****           flaga_odczytywanie_smsa = FALSE;
 461:main_sim900.h ****       } else
 462:main_sim900.h ****         flaga_odczytywanie_smsa = FALSE;
 463:main_sim900.h ****     } else if (kom == CME_ERROR_KOMENDA_SIM900) {
 464:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 465:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 466:main_sim900.h ****     } else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 467:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 468:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 469:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 470:main_sim900.h ****       POMOC_DODAJ2('#', 'P');
 471:main_sim900.h ****       POMOC_DODAJ_HEX(numer_bledu_cms >> 8);
 472:main_sim900.h ****       POMOC_DODAJ_HEX(numer_bledu_cms & 0xff);
 473:main_sim900.h ****     } else {
 474:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 475:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 476:main_sim900.h ****     }
 477:main_sim900.h ****     break;
 478:main_sim900.h ****   }
 479:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_1:
 480:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_2:
 481:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_3:
 482:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_4:
 483:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_5:
 484:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_6:
 485:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_7:
 486:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_8:
 487:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_9:
 488:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_10:
 489:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_11:
 490:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_12:
 491:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_13:
 492:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_14:
 493:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_15:
 494:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_16:
 495:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_17:
 496:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_18:
 497:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_19:
 498:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_20: {
 499:main_sim900.h ****     if (kom == CMS_ERROR_KOMENDA_SIM900 &&
 500:main_sim900.h ****         numer_bledu_cms != CMS_INVALID_MEMORY_INDEX) {
 501:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 502:main_sim900.h ****     } else if (kom == ERROR_KOMENDA_SIM900)
 503:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 504:main_sim900.h ****     else if (czy_jest_blad_SIM900())
 505:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 506:main_sim900.h ****     POMOC_DODAJ2('#', 'Q');
 507:main_sim900.h ****     opoznienie_SIM900_100MS = 25;
 508:main_sim900.h ****     break;
 509:main_sim900.h ****   }
 510:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT: {
 511:main_sim900.h ****     // czekanie_na_odebranie_zachety = FALSE; byo
 512:main_sim900.h ****     break;
 513:main_sim900.h ****   }
 514:main_sim900.h ****   case KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE: {
 515:main_sim900.h ****     if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900()) {
 516:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 517:main_sim900.h ****       if (++liczba_wykonanych_komend_identycznego_polecenia <
 518:main_sim900.h ****           MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 519:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 520:main_sim900.h ****       else {
 521:main_sim900.h ****         liczba_wykonanych_komend_identycznego_polecenia = 0;
 522:main_sim900.h ****         zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 523:main_sim900.h ****         trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 524:main_sim900.h ****         wykonywanie_rozmowy_telefonicznej = FALSE;
 525:main_sim900.h ****         licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 526:main_sim900.h ****       }
 527:main_sim900.h ****     } else
 528:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 529:main_sim900.h ****     break;
 530:main_sim900.h ****   }
 531:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW:
 532:main_sim900.h ****     if (kom != OK_KOMENDA_SIM900) {
 533:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 534:main_sim900.h ****       opoznienie_SIM900_100MS = 20;
 535:main_sim900.h ****       break;
 536:main_sim900.h ****     } // bez break
 537:main_sim900.h ****     goto obsluga_standardowej_instrukcji_at;
 538:main_sim900.h ****   case KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1: {
 539:main_sim900.h ****     if (polozenie_polecenia_SIM900(PSTR(">")) != 0) {
 540:main_sim900.h ****       reset_modulu_SIM900();
 541:main_sim900.h ****       break;
 542:main_sim900.h ****     }
 543:main_sim900.h ****   }
 544:main_sim900.h ****   case KOMENDA_KOLEJKI_WSTAWIENIE_MORING_GDY_DZWONI:
 545:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_WZMOCNIENIE_MIKROFONU:
 546:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_CICHY_TRYB:
 547:main_sim900.h ****   case KOMENDA_KOLEJKI_WYCISZ_DZWONKI:
 548:main_sim900.h ****   case KOMENDA_KOLEJKI_ODBIERAJ_SMS_FLASH:
 549:main_sim900.h ****   case KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ:
 550:main_sim900.h ****   case KOMENDA_KOLEJKI_WLACZ_CZAS_Z_SIECI: {
 551:main_sim900.h ****   obsluga_standardowej_instrukcji_at:
 552:main_sim900.h ****     if (kom != OK_KOMENDA_SIM900 &&
 553:main_sim900.h ****         ++liczba_wykonanych_komend_identycznego_polecenia <
 554:main_sim900.h ****             MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 555:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 556:main_sim900.h ****     else {
 557:main_sim900.h ****       dodaj_komende(nastepne_wysylane_polecenie_SIM900);
 558:main_sim900.h ****       if (nastepne_wysylane_polecenie_SIM900 >=
 559:main_sim900.h ****               KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 560:main_sim900.h ****           nastepne_wysylane_polecenie_SIM900 <=
 561:main_sim900.h ****               KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 562:main_sim900.h ****         flaga_odczytywanie_smsa = FALSE;
 563:main_sim900.h ****       }
 564:main_sim900.h ****       nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 565:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 566:main_sim900.h ****     }
 567:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 568:main_sim900.h ****     break;
 569:main_sim900.h ****   }
 570:main_sim900.h ****   }
 571:main_sim900.h **** #undef czy_polecenie_sim
 572:main_sim900.h ****   wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 3248               		.loc 2 572 0
 3249 0f34 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 3250 0f38 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 3251 0f3c 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
 3252               	/* epilogue start */
 573:main_sim900.h **** }
 3253               		.loc 2 573 0
 3254 0f40 DF91      		pop r29
 3255               	.LVL286:
 3256 0f42 CF91      		pop r28
 3257 0f44 1F91      		pop r17
 3258 0f46 0F91      		pop r16
 3259 0f48 0895      		ret
 3260               	.LVL287:
 3261               	.L211:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3262               		.loc 2 142 0
 3263 0f4a C239      		cpi r28,lo8(-110)
 3264 0f4c 01F4      		brne .+2
 3265 0f4e 00C0      		rjmp .L214
 3266 0f50 C439      		cpi r28,lo8(-108)
 3267 0f52 01F4      		brne .L205
 3268               	.L215:
 552:main_sim900.h ****         ++liczba_wykonanych_komend_identycznego_polecenia <
 3269               		.loc 2 552 0
 3270 0f54 D130      		cpi r29,lo8(1)
 3271 0f56 01F4      		brne .+2
 3272 0f58 00C0      		rjmp .L292
 553:main_sim900.h ****             MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 3273               		.loc 2 553 0 discriminator 1
 3274 0f5a 8091 0000 		lds r24,liczba_wykonanych_komend_identycznego_polecenia
 3275 0f5e 8F5F      		subi r24,lo8(-(1))
 552:main_sim900.h ****         ++liczba_wykonanych_komend_identycznego_polecenia <
 3276               		.loc 2 552 0 discriminator 1
 3277 0f60 8093 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,r24
 3278 0f64 8330      		cpi r24,lo8(3)
 3279 0f66 00F0      		brlo .+2
 3280 0f68 00C0      		rjmp .L292
 555:main_sim900.h ****     else {
 3281               		.loc 2 555 0
 3282 0f6a 8C2F      		mov r24,r28
 3283 0f6c 00C0      		rjmp .L399
 3284               	.L209:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3285               		.loc 2 142 0
 3286 0f6e C939      		cpi r28,lo8(-103)
 3287 0f70 01F4      		brne .+2
 3288 0f72 00C0      		rjmp .L216
 3289 0f74 00F4      		brsh .L217
 3290 0f76 C639      		cpi r28,lo8(-106)
 3291 0f78 01F4      		brne .+2
 3292 0f7a 00C0      		rjmp .L218
 3293 0f7c C739      		cpi r28,lo8(-105)
 3294 0f7e 01F4      		brne .L205
 411:main_sim900.h ****     else {
 3295               		.loc 2 411 0
 3296 0f80 87E9      		ldi r24,lo8(-105)
 410:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3297               		.loc 2 410 0
 3298 0f82 D130      		cpi r29,lo8(1)
 3299 0f84 01F0      		breq .+2
 3300 0f86 00C0      		rjmp .L404
 413:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 3301               		.loc 2 413 0
 3302 0f88 81E0      		ldi r24,lo8(1)
 3303 0f8a 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 3304               	.LVL288:
 414:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 3305               		.loc 2 414 0
 3306 0f8e 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 415:main_sim900.h ****     }
 3307               		.loc 2 415 0
 3308 0f92 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 3309 0f96 00C0      		rjmp .L205
 3310               	.L217:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3311               		.loc 2 142 0
 3312 0f98 CB39      		cpi r28,lo8(-101)
 3313 0f9a 01F4      		brne .+2
 3314 0f9c 00C0      		rjmp .L220
 3315 0f9e 00F4      		brsh .+2
 3316 0fa0 00C0      		rjmp .L221
 3317 0fa2 CD39      		cpi r28,lo8(-99)
 3318 0fa4 01F4      		brne .L205
 313:main_sim900.h ****       static const uchar urc[] PROGMEM = "+CREG:";
 3319               		.loc 2 313 0
 3320 0fa6 D130      		cpi r29,lo8(1)
 3321 0fa8 01F4      		brne .L205
 3322               	.LBB519:
 315:main_sim900.h ****       if (p1 != NULL) {
 3323               		.loc 2 315 0
 3324 0faa 80E0      		ldi r24,lo8(urc.3241)
 3325 0fac 90E0      		ldi r25,hi8(urc.3241)
 3326 0fae 0E94 0000 		call polozenie_polecenia_SIM900
 3327               	.LVL289:
 3328 0fb2 FC01      		movw r30,r24
 3329               	.LVL290:
 316:main_sim900.h ****         p1 += strlen_R(urc) + 1;
 3330               		.loc 2 316 0
 3331 0fb4 892B      		or r24,r25
 3332 0fb6 01F4      		brne .+2
 3333 0fb8 00C0      		rjmp .L205
 3334               	.LVL291:
 3335               	.LBB520:
 318:main_sim900.h ****           ++p1;
 3336               		.loc 2 318 0
 3337 0fba 2781      		ldd r18,Z+7
 3338 0fbc 2C32      		cpi r18,lo8(44)
 3339 0fbe 01F0      		breq .+2
 3340 0fc0 00C0      		rjmp .L264
 317:main_sim900.h ****         if (*p1 != ',')
 3341               		.loc 2 317 0
 3342 0fc2 3796      		adiw r30,7
 3343               	.LVL292:
 3344               	.L265:
 320:main_sim900.h ****           ++p1;
 3345               		.loc 2 320 0
 3346 0fc4 8081      		ld r24,Z
 3347 0fc6 8C32      		cpi r24,lo8(44)
 3348 0fc8 01F0      		breq .L266
 3349 0fca 3196      		adiw r30,1
 3350               	.LVL293:
 3351               	.L266:
 322:main_sim900.h ****           ++p1;
 3352               		.loc 2 322 0
 3353 0fcc 8081      		ld r24,Z
 3354 0fce 8C32      		cpi r24,lo8(44)
 3355 0fd0 01F0      		breq .L267
 3356 0fd2 3196      		adiw r30,1
 3357               	.LVL294:
 3358               	.L267:
 325:main_sim900.h ****         if (stan_zarejestrowania == 0 || stan_zarejestrowania == 3 ||
 3359               		.loc 2 325 0
 3360 0fd4 4AE0      		ldi r20,lo8(10)
 3361 0fd6 50E0      		ldi r21,0
 3362 0fd8 70E0      		ldi r23,0
 3363 0fda 60E0      		ldi r22,0
 3364 0fdc CF01      		movw r24,r30
 3365 0fde 0196      		adiw r24,1
 3366               	.LVL295:
 3367 0fe0 0E94 0000 		call strtol
 3368               	.LVL296:
 326:main_sim900.h ****             stan_zarejestrowania == 4) {
 3369               		.loc 2 326 0
 3370 0fe4 6623      		tst r22
 3371 0fe6 01F0      		breq .L268
 326:main_sim900.h ****             stan_zarejestrowania == 4) {
 3372               		.loc 2 326 0 is_stmt 0 discriminator 1
 3373 0fe8 8DEF      		ldi r24,lo8(-3)
 3374 0fea 860F      		add r24,r22
 3375 0fec 8230      		cpi r24,lo8(2)
 3376 0fee 00F0      		brlo .+2
 3377 0ff0 00C0      		rjmp .L269
 3378               	.LVL297:
 3379               	.L268:
 328:main_sim900.h ****         } else if (stan_zarejestrowania == 1 || stan_zarejestrowania == 5) {
 3380               		.loc 2 328 0 is_stmt 1
 3381 0ff2 0E94 0000 		call reset_modulu_SIM900
 3382               	.LVL298:
 3383 0ff6 00C0      		rjmp .L205
 3384               	.L207:
 3385               	.LBE520:
 3386               	.LBE519:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3387               		.loc 2 142 0
 3388 0ff8 CA3A      		cpi r28,lo8(-86)
 3389 0ffa 00F4      		brsh .L223
 3390 0ffc C63A      		cpi r28,lo8(-90)
 3391 0ffe 00F0      		brlo .+2
 3392 1000 00C0      		rjmp .L215
 3393 1002 C13A      		cpi r28,lo8(-95)
 3394 1004 01F4      		brne .+2
 3395 1006 00C0      		rjmp .L215
 3396 1008 00F4      		brsh .L224
 3397 100a CF39      		cpi r28,lo8(-97)
 3398 100c 01F4      		brne .+2
 3399 100e 00C0      		rjmp .L225
 3400 1010 C03A      		cpi r28,lo8(-96)
 3401 1012 01F0      		breq .+2
 3402 1014 00C0      		rjmp .L205
 265:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW);
 3403               		.loc 2 265 0
 3404 1016 D130      		cpi r29,lo8(1)
 3405 1018 01F0      		breq .+2
 3406 101a 00C0      		rjmp .L256
 266:main_sim900.h ****     else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 3407               		.loc 2 266 0
 3408 101c 8FE8      		ldi r24,lo8(-113)
 3409 101e 00C0      		rjmp .L404
 3410               	.L224:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3411               		.loc 2 142 0
 3412 1020 C23A      		cpi r28,lo8(-94)
 3413 1022 01F4      		brne .+2
 3414 1024 00C0      		rjmp .L227
 3415 1026 C43A      		cpi r28,lo8(-92)
 3416 1028 01F4      		brne .+2
 3417 102a 00C0      		rjmp .L215
 3418 102c 00C0      		rjmp .L205
 3419               	.L223:
 3420 102e C23D      		cpi r28,lo8(-46)
 3421 1030 00F4      		brsh .L228
 3422 1032 CE3B      		cpi r28,lo8(-66)
 3423 1034 00F4      		brsh .+2
 3424 1036 00C0      		rjmp .L396
 499:main_sim900.h ****         numer_bledu_cms != CMS_INVALID_MEMORY_INDEX) {
 3425               		.loc 2 499 0
 3426 1038 D630      		cpi r29,lo8(6)
 3427 103a 01F0      		breq .+2
 3428 103c 00C0      		rjmp .L287
 499:main_sim900.h ****         numer_bledu_cms != CMS_INVALID_MEMORY_INDEX) {
 3429               		.loc 2 499 0 is_stmt 0 discriminator 1
 3430 103e 8091 0000 		lds r24,numer_bledu_cms
 3431 1042 9091 0000 		lds r25,numer_bledu_cms+1
 3432 1046 8134      		cpi r24,65
 3433 1048 9140      		sbci r25,1
 3434 104a 01F4      		brne .+2
 3435 104c 00C0      		rjmp .L288
 3436               	.L401:
 505:main_sim900.h ****     POMOC_DODAJ2('#', 'Q');
 3437               		.loc 2 505 0 is_stmt 1
 3438 104e 8C2F      		mov r24,r28
 3439 1050 0E94 0000 		call dodaj_komende
 3440               	.LVL299:
 3441 1054 00C0      		rjmp .L289
 3442               	.L228:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3443               		.loc 2 142 0
 3444 1056 C63D      		cpi r28,lo8(-42)
 3445 1058 01F4      		brne .+2
 3446 105a 00C0      		rjmp .L231
 3447 105c CD3F      		cpi r28,lo8(-3)
 3448 105e 01F0      		breq .+2
 3449 1060 00C0      		rjmp .L205
 539:main_sim900.h ****       reset_modulu_SIM900();
 3450               		.loc 2 539 0
 3451 1062 80E0      		ldi r24,lo8(__c.3304)
 3452 1064 90E0      		ldi r25,hi8(__c.3304)
 3453 1066 0E94 0000 		call polozenie_polecenia_SIM900
 3454               	.LVL300:
 3455 106a 892B      		or r24,r25
 3456 106c 01F4      		brne .+2
 3457 106e 00C0      		rjmp .L215
 3458 1070 00C0      		rjmp .L268
 3459               	.L212:
 144:main_sim900.h ****     max_oczekiwanie_na_odpowiedz_at = 0;
 3460               		.loc 2 144 0
 3461 1072 8DE8      		ldi r24,lo8(-115)
 3462 1074 0E94 0000 		call dodaj_komende
 3463               	.LVL301:
 145:main_sim900.h ****     break;
 3464               		.loc 2 145 0
 3465 1078 1092 0000 		sts max_oczekiwanie_na_odpowiedz_at,__zero_reg__
 146:main_sim900.h ****   }
 3466               		.loc 2 146 0
 3467 107c 00C0      		rjmp .L205
 3468               	.L206:
 3469               	.LBB522:
 150:main_sim900.h ****         polozenie_polecenia_SIM900(polecenie_zegar) != NULL) {
 3470               		.loc 2 150 0
 3471 107e D130      		cpi r29,lo8(1)
 3472 1080 01F0      		breq .+2
 3473 1082 00C0      		rjmp .L205
 151:main_sim900.h ****       const uchar *p1 =
 3474               		.loc 2 151 0 discriminator 1
 3475 1084 80E0      		ldi r24,lo8(polecenie_zegar.3220)
 3476 1086 90E0      		ldi r25,hi8(polecenie_zegar.3220)
 3477 1088 0E94 0000 		call polozenie_polecenia_SIM900
 3478               	.LVL302:
 150:main_sim900.h ****         polozenie_polecenia_SIM900(polecenie_zegar) != NULL) {
 3479               		.loc 2 150 0 discriminator 1
 3480 108c 0097      		sbiw r24,0
 3481 108e 01F4      		brne .+2
 3482 1090 00C0      		rjmp .L205
 3483               	.LBB523:
 152:main_sim900.h ****           strchr(polozenie_polecenia_SIM900(polecenie_zegar), '\"');
 3484               		.loc 2 152 0
 3485 1092 62E2      		ldi r22,lo8(34)
 3486 1094 70E0      		ldi r23,0
 3487 1096 0E94 0000 		call strchr
 3488               	.LVL303:
 154:main_sim900.h ****         const uchar *p2 = strchr(p1, '\"');
 3489               		.loc 2 154 0
 3490 109a 0097      		sbiw r24,0
 3491 109c 01F4      		brne .+2
 3492 109e 00C0      		rjmp .L205
 3493 10a0 EC01      		movw r28,r24
 3494 10a2 2196      		adiw r28,1
 3495               	.LVL304:
 3496               	.LBB524:
 155:main_sim900.h ****         const uchar *p3 = strchr(p1, ',');
 3497               		.loc 2 155 0
 3498 10a4 62E2      		ldi r22,lo8(34)
 3499 10a6 70E0      		ldi r23,0
 3500 10a8 CE01      		movw r24,r28
 3501 10aa 0E94 0000 		call strchr
 3502               	.LVL305:
 3503 10ae 8C01      		movw r16,r24
 3504               	.LVL306:
 156:main_sim900.h ****         if (p2 != NULL && p3++ != NULL && p2 > p3) {
 3505               		.loc 2 156 0
 3506 10b0 6CE2      		ldi r22,lo8(44)
 3507 10b2 70E0      		ldi r23,0
 3508 10b4 CE01      		movw r24,r28
 3509 10b6 0E94 0000 		call strchr
 3510               	.LVL307:
 157:main_sim900.h ****           // const uchar g = atoi(p3);
 3511               		.loc 2 157 0
 3512 10ba 0115      		cp r16,__zero_reg__
 3513 10bc 1105      		cpc r17,__zero_reg__
 3514 10be 01F4      		brne .+2
 3515 10c0 00C0      		rjmp .L205
 3516               	.LVL308:
 157:main_sim900.h ****           // const uchar g = atoi(p3);
 3517               		.loc 2 157 0 is_stmt 0 discriminator 1
 3518 10c2 0097      		sbiw r24,0
 3519 10c4 01F4      		brne .+2
 3520 10c6 00C0      		rjmp .L205
 157:main_sim900.h ****           // const uchar g = atoi(p3);
 3521               		.loc 2 157 0 discriminator 2
 3522 10c8 EC01      		movw r28,r24
 3523               	.LVL309:
 3524 10ca 2196      		adiw r28,1
 3525               	.LVL310:
 3526 10cc C017      		cp r28,r16
 3527 10ce D107      		cpc r29,r17
 3528 10d0 00F0      		brlo .+2
 3529 10d2 00C0      		rjmp .L205
 159:main_sim900.h ****             // Pobierz czas z odpowiedzi +CCLK: "yy/MM/dd,hh:mm:ss+zz"
 3530               		.loc 2 159 0 is_stmt 1
 3531 10d4 6AE3      		ldi r22,lo8(58)
 3532 10d6 70E0      		ldi r23,0
 3533 10d8 CE01      		movw r24,r28
 3534 10da 0E94 0000 		call strchr
 3535               	.LVL311:
 3536 10de 0097      		sbiw r24,0
 3537 10e0 01F4      		brne .+2
 3538 10e2 00C0      		rjmp .L205
 3539               	.LVL312:
 159:main_sim900.h ****             // Pobierz czas z odpowiedzi +CCLK: "yy/MM/dd,hh:mm:ss+zz"
 3540               		.loc 2 159 0 is_stmt 0 discriminator 1
 3541 10e4 8017      		cp r24,r16
 3542 10e6 9107      		cpc r25,r17
 3543 10e8 00F0      		brlo .+2
 3544 10ea 00C0      		rjmp .L205
 3545               	.LVL313:
 3546               	.LBB525:
 170:main_sim900.h ****                 memcpy(rtc_czas, ptr_time, 8);
 3547               		.loc 2 170 0 is_stmt 1
 3548 10ec FE01      		movw r30,r28
 3549               		0:
 3550 10ee 0190      		ld __tmp_reg__,Z+
 3551 10f0 0020      		tst __tmp_reg__
 3552 10f2 01F4      		brne 0b
 3553 10f4 3197      		sbiw r30,1
 3554 10f6 EC1B      		sub r30,r28
 3555 10f8 FD0B      		sbc r31,r29
 3556 10fa 3897      		sbiw r30,8
 3557 10fc 00F4      		brsh .+2
 3558 10fe 00C0      		rjmp .L205
 171:main_sim900.h ****                 rtc_czas[8] = '\0';
 3559               		.loc 2 171 0
 3560 1100 88E0      		ldi r24,lo8(8)
 3561               	.LVL314:
 3562 1102 FE01      		movw r30,r28
 3563 1104 A0E0      		ldi r26,lo8(rtc_czas)
 3564 1106 B0E0      		ldi r27,hi8(rtc_czas)
 3565               		0:
 3566 1108 0190      		ld r0,Z+
 3567 110a 0D92      		st X+,r0
 3568 110c 8A95      		dec r24
 3569 110e 01F4      		brne 0b
 172:main_sim900.h **** 
 3570               		.loc 2 172 0
 3571 1110 1092 0000 		sts rtc_czas+8,__zero_reg__
 175:main_sim900.h ****                   blokada_sterowania_czasowa = FALSE;
 3572               		.loc 2 175 0
 3573 1114 7091 0000 		lds r23,czas_start_h
 3574 1118 7F3F      		cpi r23,lo8(-1)
 3575 111a 01F4      		brne .L235
 3576               	.L238:
 176:main_sim900.h ****                 } else {
 3577               		.loc 2 176 0
 3578 111c 1092 0000 		sts blokada_sterowania_czasowa,__zero_reg__
 3579 1120 00C0      		rjmp .L205
 3580               	.L235:
 3581               	.LVL315:
 3582               	.LBB526:
 179:main_sim900.h ****                   int curr_m = (rtc_czas[3] - '0') * 10 + (rtc_czas[4] - '0');
 3583               		.loc 2 179 0
 3584 1122 2091 0000 		lds r18,rtc_czas
 3585 1126 2053      		subi r18,48
 3586 1128 330B      		sbc r19,r19
 3587 112a EAE0      		ldi r30,lo8(10)
 3588 112c E29F      		mul r30,r18
 3589 112e C001      		movw r24,r0
 3590 1130 E39F      		mul r30,r19
 3591 1132 900D      		add r25,r0
 3592 1134 1124      		clr __zero_reg__
 3593 1136 2091 0000 		lds r18,rtc_czas+1
 3594 113a 2053      		subi r18,48
 3595 113c 330B      		sbc r19,r19
 3596 113e 820F      		add r24,r18
 3597 1140 931F      		adc r25,r19
 181:main_sim900.h **** 
 3598               		.loc 2 181 0
 3599 1142 6CE3      		ldi r22,lo8(60)
 3600 1144 689F      		mul r22,r24
 3601 1146 A001      		movw r20,r0
 3602 1148 699F      		mul r22,r25
 3603 114a 500D      		add r21,r0
 3604 114c 1124      		clr __zero_reg__
 180:main_sim900.h ****                   int curr_time = curr_h * 60 + curr_m;
 3605               		.loc 2 180 0
 3606 114e 2091 0000 		lds r18,rtc_czas+3
 3607 1152 2053      		subi r18,48
 3608 1154 330B      		sbc r19,r19
 3609 1156 E29F      		mul r30,r18
 3610 1158 C001      		movw r24,r0
 3611 115a E39F      		mul r30,r19
 3612 115c 900D      		add r25,r0
 3613 115e 1124      		clr __zero_reg__
 3614 1160 2091 0000 		lds r18,rtc_czas+4
 3615 1164 2053      		subi r18,48
 3616 1166 330B      		sbc r19,r19
 3617 1168 820F      		add r24,r18
 3618 116a 931F      		adc r25,r19
 181:main_sim900.h **** 
 3619               		.loc 2 181 0
 3620 116c 480F      		add r20,r24
 3621 116e 591F      		adc r21,r25
 3622               	.LVL316:
 183:main_sim900.h ****                   int stop_time = czas_stop_h * 60 + czas_stop_m;
 3623               		.loc 2 183 0
 3624 1170 2091 0000 		lds r18,czas_start_m
 3625 1174 30E0      		ldi r19,0
 3626 1176 769F      		mul r23,r22
 3627 1178 200D      		add r18,r0
 3628 117a 311D      		adc r19,r1
 3629 117c 1124      		clr __zero_reg__
 3630               	.LVL317:
 184:main_sim900.h **** 
 3631               		.loc 2 184 0
 3632 117e 7091 0000 		lds r23,czas_stop_h
 3633 1182 8091 0000 		lds r24,czas_stop_m
 3634 1186 90E0      		ldi r25,0
 3635 1188 769F      		mul r23,r22
 3636 118a 800D      		add r24,r0
 3637 118c 911D      		adc r25,r1
 3638 118e 1124      		clr __zero_reg__
 3639               	.LVL318:
 186:main_sim900.h ****                     // Normalny przedzial (np. 08:00 - 16:00)
 3640               		.loc 2 186 0
 3641 1190 8217      		cp r24,r18
 3642 1192 9307      		cpc r25,r19
 3643 1194 04F0      		brlt .L236
 188:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 3644               		.loc 2 188 0
 3645 1196 4217      		cp r20,r18
 3646 1198 5307      		cpc r21,r19
 3647 119a 04F0      		brlt .L237
 3648               	.L397:
 194:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 3649               		.loc 2 194 0 discriminator 1
 3650 119c 8417      		cp r24,r20
 3651 119e 9507      		cpc r25,r21
 3652 11a0 04F0      		brlt .+2
 3653 11a2 00C0      		rjmp .L238
 3654               	.L237:
 191:main_sim900.h ****                   } else {
 3655               		.loc 2 191 0
 3656 11a4 8FEF      		ldi r24,lo8(-1)
 3657               	.LVL319:
 3658 11a6 8093 0000 		sts blokada_sterowania_czasowa,r24
 3659 11aa 00C0      		rjmp .L205
 3660               	.LVL320:
 3661               	.L236:
 194:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 3662               		.loc 2 194 0
 3663 11ac 4217      		cp r20,r18
 3664 11ae 5307      		cpc r21,r19
 3665 11b0 04F0      		brlt .L397
 3666 11b2 00C0      		rjmp .L238
 3667               	.LVL321:
 3668               	.L225:
 3669               	.LBE526:
 3670               	.LBE525:
 3671               	.LBE524:
 3672               	.LBE523:
 3673               	.LBE522:
 3674               	.LBB527:
 211:main_sim900.h ****       if (polozenie_polecenia_SIM900(polecenie_pin_ready) != NULL) {
 3675               		.loc 2 211 0
 3676 11b4 D130      		cpi r29,lo8(1)
 3677 11b6 01F4      		brne .L239
 212:main_sim900.h ****         podlaczona_karta_SIM_SIM900 = TRUE;
 3678               		.loc 2 212 0
 3679 11b8 80E0      		ldi r24,lo8(polecenie_pin_ready.3231)
 3680 11ba 90E0      		ldi r25,hi8(polecenie_pin_ready.3231)
 3681 11bc 0E94 0000 		call polozenie_polecenia_SIM900
 3682               	.LVL322:
 3683 11c0 892B      		or r24,r25
 3684 11c2 01F0      		breq .L240
 213:main_sim900.h ****         bledny_PIN = FALSE;
 3685               		.loc 2 213 0
 3686 11c4 8FEF      		ldi r24,lo8(-1)
 3687 11c6 8093 0000 		sts podlaczona_karta_SIM_SIM900,r24
 214:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 3688               		.loc 2 214 0
 3689 11ca 1092 0000 		sts bledny_PIN,__zero_reg__
 215:main_sim900.h ****       } else
 3690               		.loc 2 215 0
 3691 11ce 82E9      		ldi r24,lo8(-110)
 3692               	.L398:
 217:main_sim900.h ****       nr_zapytania_o_pin = 0;
 3693               		.loc 2 217 0
 3694 11d0 0E94 0000 		call dodaj_komende
 3695               	.LVL323:
 3696               	.L402:
 225:main_sim900.h ****       } else {
 3697               		.loc 2 225 0
 3698 11d4 1092 0000 		sts nr_zapytania_o_pin.3232,__zero_reg__
 3699 11d8 00C0      		rjmp .L205
 3700               	.L240:
 217:main_sim900.h ****       nr_zapytania_o_pin = 0;
 3701               		.loc 2 217 0
 3702 11da 8EE8      		ldi r24,lo8(-114)
 3703 11dc 00C0      		rjmp .L398
 3704               	.L239:
 219:main_sim900.h ****                numer_bledu_cme == CME_SIM_BUSY)
 3705               		.loc 2 219 0
 3706 11de D530      		cpi r29,lo8(5)
 3707 11e0 01F4      		brne .L242
 219:main_sim900.h ****                numer_bledu_cme == CME_SIM_BUSY)
 3708               		.loc 2 219 0 is_stmt 0 discriminator 1
 3709 11e2 8091 0000 		lds r24,numer_bledu_cme
 3710 11e6 9091 0000 		lds r25,numer_bledu_cme+1
 3711 11ea 0E97      		sbiw r24,14
 3712 11ec 01F4      		brne .L243
 3713               	.L406:
 228:main_sim900.h ****       }
 3714               		.loc 2 228 0 is_stmt 1
 3715 11ee 8FE9      		ldi r24,lo8(-97)
 3716               	.L404:
 3717               	.LBE527:
 266:main_sim900.h ****     else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 3718               		.loc 2 266 0
 3719 11f0 0E94 0000 		call dodaj_komende
 3720               	.LVL324:
 3721 11f4 00C0      		rjmp .L205
 3722               	.L242:
 3723               	.LBB528:
 222:main_sim900.h ****       if (++nr_zapytania_o_pin >= 20) {
 3724               		.loc 2 222 0
 3725 11f6 D430      		cpi r29,lo8(4)
 3726 11f8 01F0      		breq .L244
 3727               	.L243:
 222:main_sim900.h ****       if (++nr_zapytania_o_pin >= 20) {
 3728               		.loc 2 222 0 is_stmt 0 discriminator 1
 3729 11fa 8091 0000 		lds r24,komenda_SIM900
 3730 11fe 8038      		cpi r24,lo8(-128)
 3731 1200 01F4      		brne .L406
 3732               	.L244:
 223:main_sim900.h ****         reset_modulu_SIM900();
 3733               		.loc 2 223 0 is_stmt 1
 3734 1202 8091 0000 		lds r24,nr_zapytania_o_pin.3232
 3735 1206 8F5F      		subi r24,lo8(-(1))
 3736 1208 8093 0000 		sts nr_zapytania_o_pin.3232,r24
 3737 120c 8431      		cpi r24,lo8(20)
 3738 120e 00F0      		brlo .L246
 224:main_sim900.h ****         nr_zapytania_o_pin = 0;
 3739               		.loc 2 224 0
 3740 1210 0E94 0000 		call reset_modulu_SIM900
 3741               	.LVL325:
 3742 1214 00C0      		rjmp .L402
 3743               	.L246:
 227:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3744               		.loc 2 227 0
 3745 1216 84E1      		ldi r24,lo8(20)
 3746 1218 8093 0000 		sts opoznienie_SIM900_100MS,r24
 3747 121c 00C0      		rjmp .L406
 3748               	.L213:
 3749               	.LBE528:
 235:main_sim900.h ****       podlaczona_karta_SIM_SIM900 = TRUE;
 3750               		.loc 2 235 0
 3751 121e D130      		cpi r29,lo8(1)
 3752 1220 01F4      		brne .L247
 236:main_sim900.h ****       bledny_PIN = FALSE;
 3753               		.loc 2 236 0
 3754 1222 8FEF      		ldi r24,lo8(-1)
 3755 1224 8093 0000 		sts podlaczona_karta_SIM_SIM900,r24
 237:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 3756               		.loc 2 237 0
 3757 1228 1092 0000 		sts bledny_PIN,__zero_reg__
 238:main_sim900.h ****       opoznienie_SIM900_100MS = 50;
 3758               		.loc 2 238 0
 3759 122c 82E9      		ldi r24,lo8(-110)
 3760 122e 0E94 0000 		call dodaj_komende
 3761               	.LVL326:
 239:main_sim900.h ****     } else if (kom == CME_ERROR_KOMENDA_SIM900 &&
 3762               		.loc 2 239 0
 3763 1232 82E3      		ldi r24,lo8(50)
 3764               	.L403:
 534:main_sim900.h ****       break;
 3765               		.loc 2 534 0
 3766 1234 8093 0000 		sts opoznienie_SIM900_100MS,r24
 535:main_sim900.h ****     } // bez break
 3767               		.loc 2 535 0
 3768 1238 00C0      		rjmp .L205
 3769               	.L247:
 240:main_sim900.h ****                numer_bledu_cme == CME_SIM_INCORECT_PASWORD)
 3770               		.loc 2 240 0
 3771 123a D530      		cpi r29,lo8(5)
 3772 123c 01F4      		brne .L248
 241:main_sim900.h ****       bledny_PIN = TRUE;
 3773               		.loc 2 241 0 discriminator 1
 3774 123e 8091 0000 		lds r24,numer_bledu_cme
 3775 1242 9091 0000 		lds r25,numer_bledu_cme+1
 240:main_sim900.h ****                numer_bledu_cme == CME_SIM_INCORECT_PASWORD)
 3776               		.loc 2 240 0 discriminator 1
 3777 1246 8031      		cpi r24,16
 3778 1248 9105      		cpc r25,__zero_reg__
 3779 124a 01F4      		brne .L249
 242:main_sim900.h ****     else if (kom == CME_ERROR_KOMENDA_SIM900 && numer_bledu_cme == CME_SIM_BUSY)
 3780               		.loc 2 242 0
 3781 124c 8FEF      		ldi r24,lo8(-1)
 3782 124e 8093 0000 		sts bledny_PIN,r24
 3783 1252 00C0      		rjmp .L205
 3784               	.L249:
 243:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3785               		.loc 2 243 0 discriminator 1
 3786 1254 0E97      		sbiw r24,14
 3787 1256 01F4      		brne .L250
 3788               	.L251:
 244:main_sim900.h ****     else if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900())
 3789               		.loc 2 244 0
 3790 1258 8EE8      		ldi r24,lo8(-114)
 3791 125a 00C0      		rjmp .L404
 3792               	.L248:
 245:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3793               		.loc 2 245 0
 3794 125c D430      		cpi r29,lo8(4)
 3795 125e 01F0      		breq .L251
 3796               	.L250:
 245:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3797               		.loc 2 245 0 is_stmt 0 discriminator 1
 3798 1260 8091 0000 		lds r24,komenda_SIM900
 3799 1264 00C0      		rjmp .L251
 3800               	.L214:
 252:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW);
 3801               		.loc 2 252 0 is_stmt 1
 3802 1266 D130      		cpi r29,lo8(1)
 3803 1268 01F4      		brne .L252
 3804               	.L405:
 275:main_sim900.h ****     }
 3805               		.loc 2 275 0
 3806 126a 80EA      		ldi r24,lo8(-96)
 3807 126c 00C0      		rjmp .L404
 3808               	.L252:
 254:main_sim900.h ****       if (numer_bledu_cms == CMS_SIM_BUSY ||
 3809               		.loc 2 254 0
 3810 126e D630      		cpi r29,lo8(6)
 3811 1270 01F4      		brne .L253
 255:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 3812               		.loc 2 255 0
 3813 1272 8091 0000 		lds r24,numer_bledu_cms
 3814 1276 9091 0000 		lds r25,numer_bledu_cms+1
 3815 127a 8A33      		cpi r24,58
 3816 127c 21E0      		ldi r18,1
 3817 127e 9207      		cpc r25,r18
 3818 1280 01F0      		breq .L254
 255:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 3819               		.loc 2 255 0 is_stmt 0 discriminator 1
 3820 1282 8530      		cpi r24,5
 3821 1284 9240      		sbci r25,2
 3822 1286 01F0      		breq .+2
 3823 1288 00C0      		rjmp .L205
 3824               	.L254:
 257:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3825               		.loc 2 257 0 is_stmt 1
 3826 128a 8CE3      		ldi r24,lo8(60)
 3827 128c 8093 0000 		sts opoznienie_SIM900_100MS,r24
 3828               	.L255:
 261:main_sim900.h ****     break;
 3829               		.loc 2 261 0
 3830 1290 82E9      		ldi r24,lo8(-110)
 3831 1292 00C0      		rjmp .L404
 3832               	.L253:
 260:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3833               		.loc 2 260 0
 3834 1294 D430      		cpi r29,lo8(4)
 3835 1296 01F0      		breq .L255
 260:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3836               		.loc 2 260 0 is_stmt 0 discriminator 1
 3837 1298 8091 0000 		lds r24,komenda_SIM900
 3838 129c 8038      		cpi r24,lo8(-128)
 3839 129e 01F0      		breq .+2
 3840 12a0 00C0      		rjmp .L205
 3841 12a2 00C0      		rjmp .L255
 3842               	.L256:
 267:main_sim900.h ****       if (numer_bledu_cms == CMS_SIM_BUSY ||
 3843               		.loc 2 267 0 is_stmt 1
 3844 12a4 D630      		cpi r29,lo8(6)
 3845 12a6 01F4      		brne .L257
 268:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 3846               		.loc 2 268 0
 3847 12a8 8091 0000 		lds r24,numer_bledu_cms
 3848 12ac 9091 0000 		lds r25,numer_bledu_cms+1
 3849 12b0 8A33      		cpi r24,58
 3850 12b2 21E0      		ldi r18,1
 3851 12b4 9207      		cpc r25,r18
 3852 12b6 01F0      		breq .L258
 268:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 3853               		.loc 2 268 0 is_stmt 0 discriminator 1
 3854 12b8 8530      		cpi r24,5
 3855 12ba 9240      		sbci r25,2
 3856 12bc 01F0      		breq .+2
 3857 12be 00C0      		rjmp .L205
 3858               	.L258:
 270:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3859               		.loc 2 270 0 is_stmt 1
 3860 12c0 84E1      		ldi r24,lo8(20)
 3861               	.L407:
 274:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3862               		.loc 2 274 0
 3863 12c2 8093 0000 		sts opoznienie_SIM900_100MS,r24
 3864 12c6 00C0      		rjmp .L405
 3865               	.L257:
 3866 12c8 8AE0      		ldi r24,lo8(10)
 3867 12ca 00C0      		rjmp .L407
 3868               	.L227:
 280:main_sim900.h ****         (kom == CME_ERROR_KOMENDA_SIM900 &&
 3869               		.loc 2 280 0
 3870 12cc D130      		cpi r29,lo8(1)
 3871 12ce 01F0      		breq .L259
 280:main_sim900.h ****         (kom == CME_ERROR_KOMENDA_SIM900 &&
 3872               		.loc 2 280 0 is_stmt 0 discriminator 1
 3873 12d0 D530      		cpi r29,lo8(5)
 3874 12d2 01F4      		brne .L260
 282:main_sim900.h ****           numer_bledu_cme == CME_OPERATION_NOT_SUPPORTED))) {
 3875               		.loc 2 282 0 is_stmt 1
 3876 12d4 8091 0000 		lds r24,numer_bledu_cme
 3877 12d8 9091 0000 		lds r25,numer_bledu_cme+1
 3878 12dc 0397      		sbiw r24,3
 281:main_sim900.h ****          (numer_bledu_cme == CME_OPERATION_NOT_ALLOWED ||
 3879               		.loc 2 281 0
 3880 12de 0297      		sbiw r24,2
 3881 12e0 00F4      		brsh .L260
 3882               	.L259:
 284:main_sim900.h ****       nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 3883               		.loc 2 284 0
 3884 12e2 8091 0000 		lds r24,nastepne_wysylane_polecenie_SIM900
 3885 12e6 0E94 0000 		call dodaj_komende
 3886               	.LVL327:
 3887               	.L293:
 564:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 3888               		.loc 2 564 0
 3889 12ea 1092 0000 		sts nastepne_wysylane_polecenie_SIM900,__zero_reg__
 565:main_sim900.h ****     }
 3890               		.loc 2 565 0
 3891 12ee 1092 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,__zero_reg__
 3892 12f2 00C0      		rjmp .L261
 3893               	.L260:
 288:main_sim900.h ****                    MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 3894               		.loc 2 288 0 discriminator 1
 3895 12f4 8091 0000 		lds r24,liczba_wykonanych_komend_identycznego_polecenia
 3896 12f8 8F5F      		subi r24,lo8(-(1))
 287:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 3897               		.loc 2 287 0 discriminator 1
 3898 12fa 8093 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,r24
 3899 12fe 8330      		cpi r24,lo8(3)
 3900 1300 00F4      		brsh .L261
 290:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 3901               		.loc 2 290 0
 3902 1302 82EA      		ldi r24,lo8(-94)
 3903               	.L399:
 3904 1304 0E94 0000 		call dodaj_komende
 3905               	.LVL328:
 3906               	.L261:
 291:main_sim900.h ****     break;
 3907               		.loc 2 291 0
 3908 1308 82E0      		ldi r24,lo8(2)
 3909 130a 00C0      		rjmp .L403
 3910               	.L220:
 295:main_sim900.h ****       static const uchar urc[] PROGMEM = "+CSQ:";
 3911               		.loc 2 295 0
 3912 130c D130      		cpi r29,lo8(1)
 3913 130e 01F4      		brne .L263
 3914               	.LBB529:
 297:main_sim900.h ****       if (p1 != NULL) {
 3915               		.loc 2 297 0
 3916 1310 80E0      		ldi r24,lo8(urc.3238)
 3917 1312 90E0      		ldi r25,hi8(urc.3238)
 3918 1314 0E94 0000 		call polozenie_polecenia_SIM900
 3919               	.LVL329:
 298:main_sim900.h ****         p1 += strlen_R(urc) + 1;
 3920               		.loc 2 298 0
 3921 1318 0097      		sbiw r24,0
 3922 131a 01F4      		brne .+2
 3923 131c 00C0      		rjmp .L205
 3924               	.LVL330:
 300:main_sim900.h ****         // if ( poziom_sieci_gsm != POZIOM_SIECI_BLAD )
 3925               		.loc 2 300 0
 3926 131e 4AE0      		ldi r20,lo8(10)
 3927 1320 50E0      		ldi r21,0
 3928 1322 70E0      		ldi r23,0
 3929 1324 60E0      		ldi r22,0
 3930 1326 0696      		adiw r24,6
 3931               	.LVL331:
 3932 1328 0E94 0000 		call strtol
 3933               	.LVL332:
 3934 132c 6093 0000 		sts poziom_sieci_gsm,r22
 3935 1330 00C0      		rjmp .L205
 3936               	.L263:
 3937               	.LBE529:
 309:main_sim900.h ****     break;
 3938               		.loc 2 309 0
 3939 1332 83E6      		ldi r24,lo8(99)
 3940 1334 8093 0000 		sts poziom_sieci_gsm,r24
 3941 1338 00C0      		rjmp .L205
 3942               	.LVL333:
 3943               	.L264:
 3944               	.LBB530:
 3945               	.LBB521:
 319:main_sim900.h ****         if (*p1 != ',')
 3946               		.loc 2 319 0
 3947 133a 3896      		adiw r30,8
 3948               	.LVL334:
 3949 133c 00C0      		rjmp .L265
 3950               	.LVL335:
 3951               	.L269:
 329:main_sim900.h ****           modul_zalogowany_w_sieci = TRUE;
 3952               		.loc 2 329 0
 3953 133e 6B7F      		andi r22,lo8(-5)
 3954               	.LVL336:
 3955 1340 6130      		cpi r22,lo8(1)
 3956 1342 01F0      		breq .+2
 3957 1344 00C0      		rjmp .L205
 330:main_sim900.h ****         }
 3958               		.loc 2 330 0
 3959 1346 8FEF      		ldi r24,lo8(-1)
 3960 1348 8093 0000 		sts modul_zalogowany_w_sieci,r24
 3961 134c 00C0      		rjmp .L205
 3962               	.L216:
 3963               	.LBE521:
 3964               	.LBE530:
 337:main_sim900.h ****                                      (numer_bledu_cme == CME_INVALID_INDEX ||
 3965               		.loc 2 337 0
 3966 134e D130      		cpi r29,lo8(1)
 3967 1350 01F0      		breq .L270
 337:main_sim900.h ****                                      (numer_bledu_cme == CME_INVALID_INDEX ||
 3968               		.loc 2 337 0 is_stmt 0 discriminator 1
 3969 1352 D530      		cpi r29,lo8(5)
 3970 1354 01F4      		brne .L271
 338:main_sim900.h ****                                       numer_bledu_cme == CME_NOT_FOUND))) {
 3971               		.loc 2 338 0 is_stmt 1 discriminator 2
 3972 1356 8091 0000 		lds r24,numer_bledu_cme
 3973 135a 9091 0000 		lds r25,numer_bledu_cme+1
 3974 135e 4597      		sbiw r24,21
 337:main_sim900.h ****                                      (numer_bledu_cme == CME_INVALID_INDEX ||
 3975               		.loc 2 337 0 discriminator 2
 3976 1360 0297      		sbiw r24,2
 3977 1362 00F4      		brsh .L271
 3978               	.L270:
 340:main_sim900.h ****     } else {
 3979               		.loc 2 340 0
 3980 1364 1092 0000 		sts licznik_blad_stanu_karty_SIM,__zero_reg__
 3981 1368 00C0      		rjmp .L205
 3982               	.L271:
 342:main_sim900.h ****     }
 3983               		.loc 2 342 0
 3984 136a 8091 0000 		lds r24,licznik_blad_stanu_karty_SIM
 3985 136e 8F5F      		subi r24,lo8(-(1))
 3986 1370 8093 0000 		sts licznik_blad_stanu_karty_SIM,r24
 3987 1374 00C0      		rjmp .L205
 3988               	.L221:
 3989               	.LVL337:
 3990               	.LBB531:
 349:main_sim900.h ****       const uchar *p1 =
 3991               		.loc 2 349 0
 3992 1376 D130      		cpi r29,lo8(1)
 3993 1378 01F0      		breq .+2
 3994 137a 00C0      		rjmp .L272
 3995               	.LVL338:
 3996               	.LBB532:
 3997               	.LBB533:
  47:main_sim900.h **** }
 3998               		.loc 2 47 0
 3999 137c 46E0      		ldi r20,lo8(6)
 4000 137e 50E0      		ldi r21,0
 4001 1380 60E0      		ldi r22,lo8(polecenie_operator.3246)
 4002 1382 70E0      		ldi r23,hi8(polecenie_operator.3246)
 4003 1384 80E0      		ldi r24,lo8(odebrany_blok_SIM900+2)
 4004 1386 90E0      		ldi r25,hi8(odebrany_blok_SIM900+2)
 4005 1388 0E94 0000 		call strncmp_P
 4006               	.LVL339:
 4007               	.LBE533:
 4008               	.LBE532:
 349:main_sim900.h ****       const uchar *p1 =
 4009               		.loc 2 349 0
 4010 138c 892B      		or r24,r25
 4011 138e 01F4      		brne .L272
 4012               	.LBB534:
 351:main_sim900.h ****       if (p1 != NULL) {
 4013               		.loc 2 351 0
 4014 1390 80E0      		ldi r24,lo8(polecenie_operator.3246)
 4015 1392 90E0      		ldi r25,hi8(polecenie_operator.3246)
 4016 1394 0E94 0000 		call polozenie_polecenia_SIM900
 4017               	.LVL340:
 350:main_sim900.h ****           strchr(polozenie_polecenia_SIM900(polecenie_operator), ',');
 4018               		.loc 2 350 0
 4019 1398 6CE2      		ldi r22,lo8(44)
 4020 139a 70E0      		ldi r23,0
 4021 139c 0E94 0000 		call strchr
 4022               	.LVL341:
 352:main_sim900.h ****         p1 = strchr(p1, ',');
 4023               		.loc 2 352 0
 4024 13a0 0097      		sbiw r24,0
 4025 13a2 01F0      		breq .L272
 353:main_sim900.h ****         if (p1 != NULL) {
 4026               		.loc 2 353 0
 4027 13a4 6CE2      		ldi r22,lo8(44)
 4028 13a6 70E0      		ldi r23,0
 4029 13a8 0E94 0000 		call strchr
 4030               	.LVL342:
 354:main_sim900.h ****           p1 = strchr(p1, '\"');
 4031               		.loc 2 354 0
 4032 13ac 0097      		sbiw r24,0
 4033 13ae 01F0      		breq .L272
 355:main_sim900.h ****           if (p1++ != NULL) {
 4034               		.loc 2 355 0
 4035 13b0 62E2      		ldi r22,lo8(34)
 4036 13b2 70E0      		ldi r23,0
 4037 13b4 0E94 0000 		call strchr
 4038               	.LVL343:
 356:main_sim900.h ****             const uchar *p2 = strchr(p1, '\"');
 4039               		.loc 2 356 0
 4040 13b8 0097      		sbiw r24,0
 4041 13ba 01F0      		breq .L272
 4042 13bc 8C01      		movw r16,r24
 4043 13be 0F5F      		subi r16,-1
 4044 13c0 1F4F      		sbci r17,-1
 4045               	.LVL344:
 4046               	.LBB535:
 357:main_sim900.h ****             if (p2 != NULL && p1 != p2) {
 4047               		.loc 2 357 0
 4048 13c2 62E2      		ldi r22,lo8(34)
 4049 13c4 70E0      		ldi r23,0
 4050 13c6 C801      		movw r24,r16
 4051 13c8 0E94 0000 		call strchr
 4052               	.LVL345:
 358:main_sim900.h ****               const uchar m = min(p2 - p1, ROZMIAR_NAZWA_OPERATORA);
 4053               		.loc 2 358 0
 4054 13cc 0097      		sbiw r24,0
 4055 13ce 01F0      		breq .L272
 358:main_sim900.h ****               const uchar m = min(p2 - p1, ROZMIAR_NAZWA_OPERATORA);
 4056               		.loc 2 358 0 is_stmt 0 discriminator 1
 4057 13d0 0817      		cp r16,r24
 4058 13d2 1907      		cpc r17,r25
 4059 13d4 01F0      		breq .L272
 4060               	.LVL346:
 4061               	.LBB536:
 359:main_sim900.h ****               memcpy(nazwa_operatora, p1, m);
 4062               		.loc 2 359 0 is_stmt 1
 4063 13d6 801B      		sub r24,r16
 4064 13d8 910B      		sbc r25,r17
 4065               	.LVL347:
 4066 13da 8C30      		cpi r24,12
 4067 13dc 9105      		cpc r25,__zero_reg__
 4068 13de 04F0      		brlt .L273
 4069 13e0 8BE0      		ldi r24,lo8(11)
 4070 13e2 90E0      		ldi r25,0
 4071               	.L273:
 4072 13e4 EC01      		movw r28,r24
 4073 13e6 DD27      		clr r29
 360:main_sim900.h ****               nazwa_operatora[m] = '\0';
 4074               		.loc 2 360 0
 4075 13e8 AE01      		movw r20,r28
 4076 13ea B801      		movw r22,r16
 4077 13ec 80E0      		ldi r24,lo8(nazwa_operatora)
 4078 13ee 90E0      		ldi r25,hi8(nazwa_operatora)
 4079 13f0 0E94 0000 		call memcpy
 4080               	.LVL348:
 361:main_sim900.h ****               w = TRUE;
 4081               		.loc 2 361 0
 4082 13f4 C050      		subi r28,lo8(-(nazwa_operatora))
 4083 13f6 D040      		sbci r29,hi8(-(nazwa_operatora))
 4084 13f8 1882      		st Y,__zero_reg__
 4085               	.LVL349:
 4086               	.LBE536:
 4087               	.LBE535:
 4088               	.LBE534:
 369:main_sim900.h ****     else {
 4089               		.loc 2 369 0
 4090 13fa 1092 0000 		sts licznik_blad_zalogowania_u_operatora,__zero_reg__
 4091 13fe 00C0      		rjmp .L205
 4092               	.LVL350:
 4093               	.L272:
 371:main_sim900.h ****     }
 4094               		.loc 2 371 0
 4095 1400 8091 0000 		lds r24,licznik_blad_zalogowania_u_operatora
 4096 1404 8F5F      		subi r24,lo8(-(1))
 4097 1406 8093 0000 		sts licznik_blad_zalogowania_u_operatora,r24
 4098 140a 00C0      		rjmp .L205
 4099               	.LVL351:
 4100               	.L208:
 4101               	.LBE531:
 377:main_sim900.h ****         CMS_ERROR_KOMENDA_SIM900 /*&& numer_bledu_cms == CMS_SMS_ME_RESERVED*/) // co le interpretu
 4102               		.loc 2 377 0
 4103 140c D630      		cpi r29,lo8(6)
 4104 140e 01F4      		brne .+2
 4105 1410 00C0      		rjmp .L261
 381:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 4106               		.loc 2 381 0
 4107 1412 85E9      		ldi r24,lo8(-107)
 380:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 4108               		.loc 2 380 0
 4109 1414 D130      		cpi r29,lo8(1)
 4110 1416 01F0      		breq .+2
 4111 1418 00C0      		rjmp .L399
 4112 141a 00C0      		rjmp .L261
 4113               	.L218:
 386:main_sim900.h ****         czy_jest_komenda_uzytkownik_odebral_rozmowe()) {
 4114               		.loc 2 386 0
 4115 141c D130      		cpi r29,lo8(1)
 4116 141e 01F0      		breq .L275
 387:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = TRUE;
 4117               		.loc 2 387 0 discriminator 1
 4118 1420 8091 0000 		lds r24,komenda_SIM900
 386:main_sim900.h ****         czy_jest_komenda_uzytkownik_odebral_rozmowe()) {
 4119               		.loc 2 386 0 discriminator 1
 4120 1424 8C30      		cpi r24,lo8(12)
 4121 1426 01F4      		brne .L276
 4122               	.L275:
 388:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 4123               		.loc 2 388 0
 4124 1428 8FEF      		ldi r24,lo8(-1)
 4125 142a 8093 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,r24
 389:main_sim900.h **** 
 4126               		.loc 2 389 0
 4127 142e 1092 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,__zero_reg__
 392:main_sim900.h ****         licznik_timeout_rozmowy_100ms = MAX_LICZNIK_TIMEOUT_ROZMOWY_100MS;
 4128               		.loc 2 392 0
 4129 1432 8091 0000 		lds r24,tryb_clip
 4130 1436 8111      		cpse r24,__zero_reg__
 4131 1438 00C0      		rjmp .L205
 393:main_sim900.h ****         opoznienie_SIM900_100MS =
 4132               		.loc 2 393 0
 4133 143a 8CE2      		ldi r24,lo8(44)
 4134 143c 91E0      		ldi r25,lo8(1)
 4135 143e 9093 0000 		sts licznik_timeout_rozmowy_100ms+1,r25
 4136 1442 8093 0000 		sts licznik_timeout_rozmowy_100ms,r24
 394:main_sim900.h ****             20; // 2 sekundy opoznienia przed wyslaniem tonu
 4137               		.loc 2 394 0
 4138 1446 84E1      		ldi r24,lo8(20)
 4139 1448 8093 0000 		sts opoznienie_SIM900_100MS,r24
 396:main_sim900.h ****       }
 4140               		.loc 2 396 0
 4141 144c 85EA      		ldi r24,lo8(-91)
 4142 144e 00C0      		rjmp .L404
 4143               	.L276:
 398:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 4144               		.loc 2 398 0
 4145 1450 D430      		cpi r29,lo8(4)
 4146 1452 01F0      		breq .L277
 398:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 4147               		.loc 2 398 0 is_stmt 0 discriminator 2
 4148 1454 8091 0000 		lds r24,komenda_SIM900
 4149 1458 8038      		cpi r24,lo8(-128)
 4150 145a 01F4      		brne .L278
 4151               	.L277:
 399:main_sim900.h ****                    MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 4152               		.loc 2 399 0 is_stmt 1 discriminator 3
 4153 145c 8091 0000 		lds r24,liczba_wykonanych_komend_identycznego_polecenia
 4154 1460 8F5F      		subi r24,lo8(-(1))
 398:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 4155               		.loc 2 398 0 discriminator 3
 4156 1462 8093 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,r24
 4157 1466 8330      		cpi r24,lo8(3)
 4158 1468 00F4      		brsh .L278
 401:main_sim900.h ****     else if (kom == NO_CARRIER_KOMENDA_SIM900) {
 4159               		.loc 2 401 0
 4160 146a 86E9      		ldi r24,lo8(-106)
 4161 146c 00C0      		rjmp .L404
 4162               	.L278:
 402:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 4163               		.loc 2 402 0
 4164 146e D330      		cpi r29,lo8(3)
 4165 1470 01F4      		brne .L279
 403:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 4166               		.loc 2 403 0
 4167 1472 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 4168               	.L279:
 406:main_sim900.h ****     break;
 4169               		.loc 2 406 0
 4170 1476 1092 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,__zero_reg__
 4171 147a 00C0      		rjmp .L205
 4172               	.L396:
 439:main_sim900.h ****       // odczytany sms
 4173               		.loc 2 439 0
 4174 147c D130      		cpi r29,lo8(1)
 4175 147e 01F4      		brne .L281
 4176               	.LBB537:
 441:main_sim900.h ****       ptr = strchr(ptr, ZNAK_KONCA_ODBIERANIA_ZNAKOW_LF);            // (1)
 4177               		.loc 2 441 0
 4178 1480 80E0      		ldi r24,lo8(__c.3275)
 4179 1482 90E0      		ldi r25,hi8(__c.3275)
 4180 1484 0E94 0000 		call polozenie_polecenia_SIM900
 4181               	.LVL352:
 442:main_sim900.h ****       // const uchar* ptr = strchr(&odebrany_blok_SIM900[7],
 4182               		.loc 2 442 0
 4183 1488 6AE0      		ldi r22,lo8(10)
 4184 148a 70E0      		ldi r23,0
 4185 148c 0E94 0000 		call strchr
 4186               	.LVL353:
 445:main_sim900.h ****         ++ptr;
 4187               		.loc 2 445 0
 4188 1490 0097      		sbiw r24,0
 4189 1492 01F0      		breq .L282
 4190               	.LBB538:
 446:main_sim900.h ****         const uchar *ptr2 = strchr(ptr, ZNAK_KONCA_WYSYLANIA_ZNAKOW_CR);
 4191               		.loc 2 446 0
 4192 1494 EC01      		movw r28,r24
 4193 1496 2196      		adiw r28,1
 4194               	.LVL354:
 447:main_sim900.h ****         if (ptr2 != NULL) {
 4195               		.loc 2 447 0
 4196 1498 6DE0      		ldi r22,lo8(13)
 4197 149a 70E0      		ldi r23,0
 4198 149c CE01      		movw r24,r28
 4199 149e 0E94 0000 		call strchr
 4200               	.LVL355:
 448:main_sim900.h ****           dlugosc_pdu = (ptr2 - ptr) / 2;
 4201               		.loc 2 448 0
 4202 14a2 0097      		sbiw r24,0
 4203 14a4 01F0      		breq .L282
 4204               	.LBB539:
 449:main_sim900.h ****           if (dlugosc_pdu > MAX_DLUGOSC_PDU)
 4205               		.loc 2 449 0
 4206 14a6 8C1B      		sub r24,r28
 4207 14a8 9D0B      		sbc r25,r29
 4208               	.LVL356:
 4209 14aa 97FD      		sbrc r25,7
 4210 14ac 0196      		adiw r24,1
 4211               	.L283:
 4212 14ae 9595      		asr r25
 4213 14b0 8795      		ror r24
 450:main_sim900.h ****             dlugosc_pdu = MAX_DLUGOSC_PDU;
 4214               		.loc 2 450 0
 4215 14b2 893C      		cpi r24,lo8(-55)
 4216 14b4 00F4      		brsh .L284
 4217               	.L400:
 451:main_sim900.h ****           konwertuj_blok_dwa_znaki_na_znak_pdu(ptr, dlugosc_pdu, bufor_pdu);
 4218               		.loc 2 451 0
 4219 14b6 8093 0000 		sts dlugosc_pdu,r24
 452:main_sim900.h ****           dodaj_komende(KOMENDA_KOLEJKI_INTERPRETUJ_PDU);
 4220               		.loc 2 452 0
 4221 14ba 40E0      		ldi r20,lo8(bufor_pdu)
 4222 14bc 50E0      		ldi r21,hi8(bufor_pdu)
 4223 14be 6091 0000 		lds r22,dlugosc_pdu
 4224 14c2 CE01      		movw r24,r28
 4225 14c4 0E94 0000 		call konwertuj_blok_dwa_znaki_na_znak_pdu
 4226               	.LVL357:
 453:main_sim900.h ****           const uchar nr_smsa = aktualnie_wysylane_polecenie_SIM900 -
 4227               		.loc 2 453 0
 4228 14c8 82ED      		ldi r24,lo8(-46)
 4229 14ca 0E94 0000 		call dodaj_komende
 4230               	.LVL358:
 456:main_sim900.h ****           flaga_odczytywanie_smsa = TRUE;
 4231               		.loc 2 456 0
 4232 14ce 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4233 14d2 8C5E      		subi r24,lo8(-(20))
 4234 14d4 0E94 0000 		call dodaj_komende
 4235               	.LVL359:
 457:main_sim900.h ****           POMOC_DODAJ2('#', 'O');
 4236               		.loc 2 457 0
 4237 14d8 8FEF      		ldi r24,lo8(-1)
 4238 14da 8093 0000 		sts flaga_odczytywanie_smsa,r24
 4239               	.LVL360:
 4240 14de 00C0      		rjmp .L205
 4241               	.LVL361:
 4242               	.L284:
 451:main_sim900.h ****           konwertuj_blok_dwa_znaki_na_znak_pdu(ptr, dlugosc_pdu, bufor_pdu);
 4243               		.loc 2 451 0
 4244 14e0 88EC      		ldi r24,lo8(-56)
 4245 14e2 00C0      		rjmp .L400
 4246               	.LVL362:
 4247               	.L282:
 4248               	.LBE539:
 460:main_sim900.h ****       } else
 4249               		.loc 2 460 0
 4250 14e4 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 4251 14e8 00C0      		rjmp .L205
 4252               	.L281:
 4253               	.LBE538:
 4254               	.LBE537:
 463:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 4255               		.loc 2 463 0
 4256 14ea D630      		cpi r29,lo8(6)
 4257 14ec 01F0      		breq .L286
 4258               	.L408:
 468:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 4259               		.loc 2 468 0
 4260 14ee 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 469:main_sim900.h ****       POMOC_DODAJ2('#', 'P');
 4261               		.loc 2 469 0
 4262 14f2 8CE3      		ldi r24,lo8(60)
 4263 14f4 00C0      		rjmp .L403
 4264               	.L286:
 467:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 4265               		.loc 2 467 0
 4266 14f6 8C2F      		mov r24,r28
 4267 14f8 0E94 0000 		call dodaj_komende
 4268               	.LVL363:
 4269 14fc 00C0      		rjmp .L408
 4270               	.L287:
 502:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 4271               		.loc 2 502 0
 4272 14fe D430      		cpi r29,lo8(4)
 4273 1500 01F4      		brne .+2
 4274 1502 00C0      		rjmp .L401
 4275               	.L288:
 504:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 4276               		.loc 2 504 0
 4277 1504 8091 0000 		lds r24,komenda_SIM900
 4278 1508 8038      		cpi r24,lo8(-128)
 4279 150a 01F4      		brne .+2
 4280 150c 00C0      		rjmp .L401
 4281               	.L289:
 4282               	.LVL364:
 507:main_sim900.h ****     break;
 4283               		.loc 2 507 0
 4284 150e 89E1      		ldi r24,lo8(25)
 4285 1510 00C0      		rjmp .L403
 4286               	.LVL365:
 4287               	.L231:
 515:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 4288               		.loc 2 515 0
 4289 1512 D430      		cpi r29,lo8(4)
 4290 1514 01F0      		breq .L290
 515:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 4291               		.loc 2 515 0 is_stmt 0 discriminator 1
 4292 1516 8091 0000 		lds r24,komenda_SIM900
 4293 151a 8038      		cpi r24,lo8(-128)
 4294 151c 01F0      		breq .+2
 4295 151e 00C0      		rjmp .L279
 4296               	.L290:
 516:main_sim900.h ****       if (++liczba_wykonanych_komend_identycznego_polecenia <
 4297               		.loc 2 516 0 is_stmt 1
 4298 1520 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 517:main_sim900.h ****           MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 4299               		.loc 2 517 0
 4300 1524 8091 0000 		lds r24,liczba_wykonanych_komend_identycznego_polecenia
 4301 1528 8F5F      		subi r24,lo8(-(1))
 4302 152a 8093 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,r24
 4303 152e 8330      		cpi r24,lo8(3)
 4304 1530 00F4      		brsh .L291
 519:main_sim900.h ****       else {
 4305               		.loc 2 519 0
 4306 1532 86ED      		ldi r24,lo8(-42)
 4307 1534 00C0      		rjmp .L404
 4308               	.L291:
 521:main_sim900.h ****         zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 4309               		.loc 2 521 0
 4310 1536 1092 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,__zero_reg__
 522:main_sim900.h ****         trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 4311               		.loc 2 522 0
 4312 153a 80E0      		ldi r24,0
 4313 153c 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 4314               	.LVL366:
 523:main_sim900.h ****         wykonywanie_rozmowy_telefonicznej = FALSE;
 4315               		.loc 2 523 0
 4316 1540 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 524:main_sim900.h ****         licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 4317               		.loc 2 524 0
 4318 1544 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 525:main_sim900.h ****       }
 4319               		.loc 2 525 0
 4320 1548 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 4321 154c 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 4322 1550 00C0      		rjmp .L205
 4323               	.L210:
 532:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 4324               		.loc 2 532 0
 4325 1552 D130      		cpi r29,lo8(1)
 4326 1554 01F0      		breq .L292
 533:main_sim900.h ****       opoznienie_SIM900_100MS = 20;
 4327               		.loc 2 533 0
 4328 1556 8FE8      		ldi r24,lo8(-113)
 4329 1558 0E94 0000 		call dodaj_komende
 4330               	.LVL367:
 534:main_sim900.h ****       break;
 4331               		.loc 2 534 0
 4332 155c 84E1      		ldi r24,lo8(20)
 4333 155e 00C0      		rjmp .L403
 4334               	.L292:
 557:main_sim900.h ****       if (nastepne_wysylane_polecenie_SIM900 >=
 4335               		.loc 2 557 0
 4336 1560 8091 0000 		lds r24,nastepne_wysylane_polecenie_SIM900
 4337 1564 0E94 0000 		call dodaj_komende
 4338               	.LVL368:
 559:main_sim900.h ****           nastepne_wysylane_polecenie_SIM900 <=
 4339               		.loc 2 559 0
 4340 1568 8091 0000 		lds r24,nastepne_wysylane_polecenie_SIM900
 4341 156c 8A5A      		subi r24,lo8(-(86))
 558:main_sim900.h ****               KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 4342               		.loc 2 558 0
 4343 156e 8431      		cpi r24,lo8(20)
 4344 1570 00F0      		brlo .+2
 4345 1572 00C0      		rjmp .L293
 562:main_sim900.h ****       }
 4346               		.loc 2 562 0
 4347 1574 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 4348 1578 00C0      		rjmp .L293
 4349               		.cfi_endproc
 4350               	.LFE50:
 4352               	.global	obsluga_komendy_SIM900
 4354               	obsluga_komendy_SIM900:
 4355               	.LFB51:
 574:main_sim900.h **** 
 575:main_sim900.h **** void obsluga_komendy_SIM900(void) {
 4356               		.loc 2 575 0
 4357               		.cfi_startproc
 4358 157a 0F93      		push r16
 4359               	.LCFI64:
 4360               		.cfi_def_cfa_offset 3
 4361               		.cfi_offset 16, -2
 4362 157c 1F93      		push r17
 4363               	.LCFI65:
 4364               		.cfi_def_cfa_offset 4
 4365               		.cfi_offset 17, -3
 4366 157e CF93      		push r28
 4367               	.LCFI66:
 4368               		.cfi_def_cfa_offset 5
 4369               		.cfi_offset 28, -4
 4370 1580 DF93      		push r29
 4371               	.LCFI67:
 4372               		.cfi_def_cfa_offset 6
 4373               		.cfi_offset 29, -5
 4374               	/* prologue: function */
 4375               	/* frame size = 0 */
 4376               	/* stack size = 4 */
 4377               	.L__stack_usage = 4
 576:main_sim900.h ****   if (!czy_jest_bezczynny_SIM900())
 4378               		.loc 2 576 0
 4379 1582 8091 0000 		lds r24,komenda_SIM900
 577:main_sim900.h ****     POMOC_SIM900_DODAJ(odebrany_blok_SIM900);
 578:main_sim900.h **** 
 579:main_sim900.h ****   if (czy_jest_blad_SIM900() || oproznij_bufor_SIM900_po_bledzie) {
 4380               		.loc 2 579 0
 4381 1586 8091 0000 		lds r24,komenda_SIM900
 4382 158a 8038      		cpi r24,lo8(-128)
 4383 158c 01F0      		breq .L410
 4384               		.loc 2 579 0 is_stmt 0 discriminator 1
 4385 158e 8091 0000 		lds r24,oproznij_bufor_SIM900_po_bledzie
 4386 1592 8823      		tst r24
 4387 1594 01F0      		breq .L411
 4388               	.L410:
 580:main_sim900.h ****     komenda_SIM900 = BLAD_SIM900;
 4389               		.loc 2 580 0 is_stmt 1
 4390 1596 80E8      		ldi r24,lo8(-128)
 4391 1598 8093 0000 		sts komenda_SIM900,r24
 581:main_sim900.h ****     odpowiedz_na_polecenie();
 4392               		.loc 2 581 0
 4393 159c 0E94 0000 		call odpowiedz_na_polecenie
 4394               	.LVL369:
 582:main_sim900.h ****     opoznienie_SIM900_100MS = 50;
 4395               		.loc 2 582 0
 4396 15a0 82E3      		ldi r24,lo8(50)
 4397 15a2 8093 0000 		sts opoznienie_SIM900_100MS,r24
 583:main_sim900.h ****     oproznij_bufor_SIM900_po_bledzie = TRUE;
 4398               		.loc 2 583 0
 4399 15a6 8FEF      		ldi r24,lo8(-1)
 4400 15a8 8093 0000 		sts oproznij_bufor_SIM900_po_bledzie,r24
 4401               	.LVL370:
 4402               	.L409:
 4403               	/* epilogue start */
 584:main_sim900.h ****     POMOC_DODAJ2('*', 'd');
 585:main_sim900.h ****     return;
 586:main_sim900.h ****   }
 587:main_sim900.h **** 
 588:main_sim900.h ****   if (czy_jest_komenda_wyslane_polecenie_SIM900()) {
 589:main_sim900.h ****     if ((liczba_wysylanych_znakow_SIM900 != liczba_odebranych_znakow_SIM900 ||
 590:main_sim900.h ****          memcmp(odebrany_blok_SIM900, wysylany_blok_SIM900,
 591:main_sim900.h ****                 liczba_wysylanych_znakow_SIM900) != 0) &&
 592:main_sim900.h ****         !czekanie_na_odebranie_zachety) {
 593:main_sim900.h ****       komenda_SIM900 = BLAD_SIM900;
 594:main_sim900.h ****       oproznij_bufor_SIM900_po_bledzie = TRUE;
 595:main_sim900.h ****       opoznienie_SIM900_100MS = 50;
 596:main_sim900.h ****       POMOC_DODAJ2('*', 'e');
 597:main_sim900.h ****     }
 598:main_sim900.h ****     return;
 599:main_sim900.h ****   }
 600:main_sim900.h **** 
 601:main_sim900.h ****   if (czy_jest_komenda_rozmowa_telefoniczna()) {
 602:main_sim900.h ****     POMOC_DODAJ2('#', 'b');
 603:main_sim900.h ****     // numer_telefonu_ktory_dzwoni[0] = '\0';  // REMOVED: Niepotrzebne
 604:main_sim900.h ****     // czyszczenie - numer jest zaraz nadpisywany
 605:main_sim900.h ****     const uchar *p1 = strchr(polozenie_polecenia_SIM900(PSTR("+CLIP:")), '\"');
 606:main_sim900.h ****     if (p1++ != NULL) {
 607:main_sim900.h ****       const uchar *p2 = strchr(p1, '\"');
 608:main_sim900.h ****       if (p2 != NULL) {
 609:main_sim900.h ****         const uchar l = p2 - p1;
 610:main_sim900.h ****         if (l < MAX_LICZBA_ZNAKOW_TELEFON) {
 611:main_sim900.h ****           memcpy(numer_telefonu_ktory_dzwoni, p1, l);
 612:main_sim900.h ****           numer_telefonu_ktory_dzwoni[l] = '\0';
 613:main_sim900.h ****           POMOC_DODAJ_HEX(l);
 614:main_sim900.h ****           if (licznik_blad_zalogowania_u_operatora != 0)
 615:main_sim900.h ****             licznik_blad_zalogowania_u_operatora = 0;
 616:main_sim900.h ****           if (poziom_sieci_gsm == 0 || poziom_sieci_gsm == POZIOM_SIECI_BLAD)
 617:main_sim900.h ****             poziom_sieci_gsm = 16;
 618:main_sim900.h ****         }
 619:main_sim900.h ****       }
 620:main_sim900.h ****     }
 621:main_sim900.h ****     filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_PRZYCHODZACA_ROZMOWE);
 622:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 623:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 624:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 625:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 626:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 627:main_sim900.h ****     }
 628:main_sim900.h ****     wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 629:main_sim900.h ****     return;
 630:main_sim900.h ****   }
 631:main_sim900.h **** 
 632:main_sim900.h ****   if (czy_jest_komenda_zakonczenie_rozmowy_telefonicznej()) {
 633:main_sim900.h ****     POMOC_DODAJ2('#', 'c');
 634:main_sim900.h ****     zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 635:main_sim900.h ****     trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 636:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 637:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 638:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 ==
 639:main_sim900.h ****         KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE) {
 640:main_sim900.h ****       wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 641:main_sim900.h ****     }
 642:main_sim900.h ****     return;
 643:main_sim900.h ****   }
 644:main_sim900.h **** 
 645:main_sim900.h ****   if (czy_jest_komenda_uzytkownik_odebral_dzwonek()) {
 646:main_sim900.h ****     POMOC_DODAJ2('#', 'd');
 647:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 == KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE)
 648:main_sim900.h ****       odpowiedz_na_polecenie();
 649:main_sim900.h ****     if (ustaw_maksymalny_czas_dzwonienia == 0)
 650:main_sim900.h ****       maksymalny_czas_dzwonienia = 90; // standardowy czas czekania 9 sekund
 651:main_sim900.h ****     else {
 652:main_sim900.h ****       maksymalny_czas_dzwonienia = ustaw_maksymalny_czas_dzwonienia;
 653:main_sim900.h ****       ustaw_maksymalny_czas_dzwonienia = 0;
 654:main_sim900.h ****     }
 655:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = TRUE;
 656:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 657:main_sim900.h ****     return;
 658:main_sim900.h ****   }
 659:main_sim900.h **** 
 660:main_sim900.h ****   // Obsluga +DTMF:
 661:main_sim900.h ****   const uchar *ptr_dtmf = polozenie_polecenia_SIM900(PSTR("+DTMF:"));
 662:main_sim900.h ****   if (ptr_dtmf != NULL) {
 663:main_sim900.h ****     POMOC_DODAJ2('#', 'D');
 664:main_sim900.h ****     ptr_dtmf += 7; // Skip "+DTMF: "
 665:main_sim900.h ****     while (*ptr_dtmf == ' ')
 666:main_sim900.h ****       ++ptr_dtmf;
 667:main_sim900.h ****     const uchar dtmf_key = *ptr_dtmf;
 668:main_sim900.h ****     POMOC_DODAJ(dtmf_key);
 669:main_sim900.h **** 
 670:main_sim900.h ****     if (!tryb_clip) // Tylko w trybie DTMF
 671:main_sim900.h ****     {
 672:main_sim900.h ****       if (dtmf_key == '1') {
 673:main_sim900.h ****         stan_wyjscie[0] = TRUE;
 674:main_sim900.h ****         licznik_przelacznik_wyjscia[0] = 2 * 10ul; // 2 sekundy retrigger
 675:main_sim900.h ****         zapal_diode_led(10);
 676:main_sim900.h ****       }
 677:main_sim900.h ****     }
 678:main_sim900.h ****     resetuj_komende_SIM900(); // Krytyczne dla kolejnych znakow
 679:main_sim900.h ****     return;
 680:main_sim900.h ****   }
 681:main_sim900.h **** 
 682:main_sim900.h ****   if (czy_jest_komenda_uzytkownik_odebral_rozmowe()) {
 683:main_sim900.h ****     POMOC_DODAJ2('#', 'e');
 684:main_sim900.h ****     if (tryb_clip) {
 685:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 686:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
 687:main_sim900.h ****     }
 688:main_sim900.h ****     return;
 689:main_sim900.h ****   }
 690:main_sim900.h ****   if (czy_jest_komenda_brak_sygnalu_tonowego()) {
 691:main_sim900.h ****     POMOC_DODAJ2('#', 'f');
 692:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 == KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE)
 693:main_sim900.h ****       odpowiedz_na_polecenie();
 694:main_sim900.h ****     zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 695:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 696:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 697:main_sim900.h ****     return;
 698:main_sim900.h ****   }
 699:main_sim900.h **** 
 700:main_sim900.h ****   if (czy_jest_komenda_telefon_zajety()) {
 701:main_sim900.h ****     POMOC_DODAJ2('#', 'g');
 702:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 == KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE)
 703:main_sim900.h ****       odpowiedz_na_polecenie();
 704:main_sim900.h ****     zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 705:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 706:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 707:main_sim900.h ****     return;
 708:main_sim900.h ****   }
 709:main_sim900.h **** 
 710:main_sim900.h ****   if (czy_jest_komenda_nowy_SMS()) {
 711:main_sim900.h ****     const uchar *ptr = strchr(polozenie_polecenia_SIM900(PSTR("+CMTI:")), ',');
 712:main_sim900.h ****     if (ptr != NULL) {
 713:main_sim900.h ****       uint numer_smsa = (uint)strtoul(ptr + 1, NULL, 10);
 714:main_sim900.h ****       if (numer_smsa > 0 && numer_smsa <= 20) // Hardcoded 20
 715:main_sim900.h ****       {
 716:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 + numer_smsa - 1);
 717:main_sim900.h ****         opoznienie_SIM900_100MS = 1; // 20 (1)
 718:main_sim900.h ****       }
 719:main_sim900.h ****     }
 720:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 721:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 722:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 723:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 724:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 725:main_sim900.h ****       wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 726:main_sim900.h ****     }
 727:main_sim900.h ****     return;
 728:main_sim900.h ****   }
 729:main_sim900.h **** 
 730:main_sim900.h ****   if (czy_jest_komenda_otrzymano_sms_flash()) {
 731:main_sim900.h ****     opoznienie_SIM900_100MS = 20;
 732:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 733:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 734:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 735:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 736:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 737:main_sim900.h ****       wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 738:main_sim900.h ****     }
 739:main_sim900.h ****     const uchar *p1 = strchr(polozenie_polecenia_SIM900(PSTR("+CUSD:")), '\"');
 740:main_sim900.h ****     if (p1++ != NULL) {
 741:main_sim900.h ****       uchar *p2 = strchr(p1, '\"');
 742:main_sim900.h ****       if (p2 != NULL) {
 743:main_sim900.h ****         //*p2 = '\0';
 744:main_sim900.h ****         // tekst_wysylanego_smsa[0] = '*';
 745:main_sim900.h ****         // strncpy(&tekst_wysylanego_smsa[1], p1, MAX_LICZBA_ZNAKOW_SMS - 1);
 746:main_sim900.h ****         // tekst_wysylanego_smsa[MAX_LICZBA_ZNAKOW_SMS] = 0;
 747:main_sim900.h ****       }
 748:main_sim900.h ****     }
 749:main_sim900.h ****     return;
 750:main_sim900.h ****   }
 751:main_sim900.h **** 
 752:main_sim900.h ****   if (flaga_wysylanie_smsa)
 753:main_sim900.h ****     obsluga_wysylania_sms();
 754:main_sim900.h **** 
 755:main_sim900.h ****   if (liczba_odebranych_znakow_SIM900 != 0 &&
 756:main_sim900.h ****       komenda_SIM900 != BRAK_KOMENDY_SIM900)
 757:main_sim900.h ****     odpowiedz_na_polecenie();
 758:main_sim900.h **** }
 4404               		.loc 2 758 0
 4405 15ac DF91      		pop r29
 4406 15ae CF91      		pop r28
 4407 15b0 1F91      		pop r17
 4408 15b2 0F91      		pop r16
 4409 15b4 0895      		ret
 4410               	.L411:
 588:main_sim900.h ****     if ((liczba_wysylanych_znakow_SIM900 != liczba_odebranych_znakow_SIM900 ||
 4411               		.loc 2 588 0
 4412 15b6 8091 0000 		lds r24,komenda_SIM900
 4413 15ba 8138      		cpi r24,lo8(-127)
 4414 15bc 01F4      		brne .L413
 589:main_sim900.h ****          memcmp(odebrany_blok_SIM900, wysylany_blok_SIM900,
 4415               		.loc 2 589 0
 4416 15be 2091 0000 		lds r18,liczba_wysylanych_znakow_SIM900
 4417 15c2 3091 0000 		lds r19,liczba_wysylanych_znakow_SIM900+1
 4418 15c6 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 4419 15ca 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
 4420 15ce 2817      		cp r18,r24
 4421 15d0 3907      		cpc r19,r25
 4422 15d2 01F4      		brne .L414
 590:main_sim900.h ****                 liczba_wysylanych_znakow_SIM900) != 0) &&
 4423               		.loc 2 590 0 discriminator 1
 4424 15d4 4091 0000 		lds r20,liczba_wysylanych_znakow_SIM900
 4425 15d8 5091 0000 		lds r21,liczba_wysylanych_znakow_SIM900+1
 4426 15dc 60E0      		ldi r22,lo8(wysylany_blok_SIM900)
 4427 15de 70E0      		ldi r23,hi8(wysylany_blok_SIM900)
 4428 15e0 80E0      		ldi r24,lo8(odebrany_blok_SIM900)
 4429 15e2 90E0      		ldi r25,hi8(odebrany_blok_SIM900)
 4430 15e4 0E94 0000 		call memcmp
 4431               	.LVL371:
 589:main_sim900.h ****          memcmp(odebrany_blok_SIM900, wysylany_blok_SIM900,
 4432               		.loc 2 589 0 discriminator 1
 4433 15e8 892B      		or r24,r25
 4434 15ea 01F0      		breq .L409
 4435               	.L414:
 592:main_sim900.h ****       komenda_SIM900 = BLAD_SIM900;
 4436               		.loc 2 592 0
 4437 15ec 8091 0000 		lds r24,czekanie_na_odebranie_zachety
 591:main_sim900.h ****         !czekanie_na_odebranie_zachety) {
 4438               		.loc 2 591 0
 4439 15f0 8111      		cpse r24,__zero_reg__
 4440 15f2 00C0      		rjmp .L409
 593:main_sim900.h ****       oproznij_bufor_SIM900_po_bledzie = TRUE;
 4441               		.loc 2 593 0
 4442 15f4 80E8      		ldi r24,lo8(-128)
 4443 15f6 8093 0000 		sts komenda_SIM900,r24
 594:main_sim900.h ****       opoznienie_SIM900_100MS = 50;
 4444               		.loc 2 594 0
 4445 15fa 8FEF      		ldi r24,lo8(-1)
 4446 15fc 8093 0000 		sts oproznij_bufor_SIM900_po_bledzie,r24
 595:main_sim900.h ****       POMOC_DODAJ2('*', 'e');
 4447               		.loc 2 595 0
 4448 1600 82E3      		ldi r24,lo8(50)
 4449 1602 8093 0000 		sts opoznienie_SIM900_100MS,r24
 4450               	.LVL372:
 4451 1606 00C0      		rjmp .L409
 4452               	.LVL373:
 4453               	.L413:
 4454               	.LBB554:
 4455               	.LBB555:
 601:main_sim900.h ****     POMOC_DODAJ2('#', 'b');
 4456               		.loc 2 601 0
 4457 1608 8091 0000 		lds r24,komenda_SIM900
 4458 160c 8A30      		cpi r24,lo8(10)
 4459 160e 01F0      		breq .+2
 4460 1610 00C0      		rjmp .L416
 4461               	.LVL374:
 4462               	.LBB556:
 605:main_sim900.h ****     if (p1++ != NULL) {
 4463               		.loc 2 605 0
 4464 1612 80E0      		ldi r24,lo8(__c.3317)
 4465 1614 90E0      		ldi r25,hi8(__c.3317)
 4466 1616 0E94 0000 		call polozenie_polecenia_SIM900
 4467               	.LVL375:
 4468 161a 62E2      		ldi r22,lo8(34)
 4469 161c 70E0      		ldi r23,0
 4470 161e 0E94 0000 		call strchr
 4471               	.LVL376:
 606:main_sim900.h ****       const uchar *p2 = strchr(p1, '\"');
 4472               		.loc 2 606 0
 4473 1622 0097      		sbiw r24,0
 4474 1624 01F0      		breq .L418
 4475 1626 8C01      		movw r16,r24
 4476 1628 0F5F      		subi r16,-1
 4477 162a 1F4F      		sbci r17,-1
 4478               	.LVL377:
 4479               	.LBB557:
 607:main_sim900.h ****       if (p2 != NULL) {
 4480               		.loc 2 607 0
 4481 162c 62E2      		ldi r22,lo8(34)
 4482 162e 70E0      		ldi r23,0
 4483 1630 C801      		movw r24,r16
 4484 1632 0E94 0000 		call strchr
 4485               	.LVL378:
 608:main_sim900.h ****         const uchar l = p2 - p1;
 4486               		.loc 2 608 0
 4487 1636 0097      		sbiw r24,0
 4488 1638 01F0      		breq .L418
 4489               	.LBB558:
 609:main_sim900.h ****         if (l < MAX_LICZBA_ZNAKOW_TELEFON) {
 4490               		.loc 2 609 0
 4491 163a EC01      		movw r28,r24
 4492 163c C01B      		sub r28,r16
 4493 163e D10B      		sbc r29,r17
 4494               	.LVL379:
 610:main_sim900.h ****           memcpy(numer_telefonu_ktory_dzwoni, p1, l);
 4495               		.loc 2 610 0
 4496 1640 C031      		cpi r28,lo8(16)
 4497 1642 00F4      		brsh .L418
 4498 1644 DD27      		clr r29
 4499               	.LVL380:
 611:main_sim900.h ****           numer_telefonu_ktory_dzwoni[l] = '\0';
 4500               		.loc 2 611 0
 4501 1646 AE01      		movw r20,r28
 4502 1648 B801      		movw r22,r16
 4503 164a 80E0      		ldi r24,lo8(numer_telefonu_ktory_dzwoni)
 4504 164c 90E0      		ldi r25,hi8(numer_telefonu_ktory_dzwoni)
 4505               	.LVL381:
 4506 164e 0E94 0000 		call memcpy
 4507               	.LVL382:
 612:main_sim900.h ****           POMOC_DODAJ_HEX(l);
 4508               		.loc 2 612 0
 4509 1652 C050      		subi r28,lo8(-(numer_telefonu_ktory_dzwoni))
 4510 1654 D040      		sbci r29,hi8(-(numer_telefonu_ktory_dzwoni))
 4511 1656 1882      		st Y,__zero_reg__
 4512               	.LVL383:
 614:main_sim900.h ****             licznik_blad_zalogowania_u_operatora = 0;
 4513               		.loc 2 614 0
 4514 1658 8091 0000 		lds r24,licznik_blad_zalogowania_u_operatora
 4515 165c 8111      		cpse r24,__zero_reg__
 615:main_sim900.h ****           if (poziom_sieci_gsm == 0 || poziom_sieci_gsm == POZIOM_SIECI_BLAD)
 4516               		.loc 2 615 0
 4517 165e 1092 0000 		sts licznik_blad_zalogowania_u_operatora,__zero_reg__
 4518               	.L420:
 616:main_sim900.h ****             poziom_sieci_gsm = 16;
 4519               		.loc 2 616 0
 4520 1662 8091 0000 		lds r24,poziom_sieci_gsm
 4521 1666 8823      		tst r24
 4522 1668 01F0      		breq .L421
 4523 166a 8336      		cpi r24,lo8(99)
 4524 166c 01F4      		brne .L418
 4525               	.L421:
 617:main_sim900.h ****         }
 4526               		.loc 2 617 0
 4527 166e 80E1      		ldi r24,lo8(16)
 4528 1670 8093 0000 		sts poziom_sieci_gsm,r24
 4529               	.LVL384:
 4530               	.L418:
 4531               	.LBE558:
 4532               	.LBE557:
 621:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 4533               		.loc 2 621 0
 4534 1674 88E9      		ldi r24,lo8(-104)
 4535 1676 0E94 0000 		call filtruj_i_dodaj_komende
 4536               	.LVL385:
 623:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 4537               		.loc 2 623 0
 4538 167a 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4539 167e 8A5A      		subi r24,lo8(-(86))
 622:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 4540               		.loc 2 622 0
 4541 1680 8431      		cpi r24,lo8(20)
 4542 1682 00F4      		brsh .L422
 4543               	.LVL386:
 4544               	.L478:
 626:main_sim900.h ****     }
 4545               		.loc 2 626 0
 4546 1684 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 4547               	.L422:
 628:main_sim900.h ****     return;
 4548               		.loc 2 628 0
 4549 1688 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 4550 168c 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 4551 1690 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
 4552 1694 00C0      		rjmp .L409
 4553               	.L416:
 4554               	.LBE556:
 632:main_sim900.h ****     POMOC_DODAJ2('#', 'c');
 4555               		.loc 2 632 0
 4556 1696 8091 0000 		lds r24,komenda_SIM900
 4557 169a 8330      		cpi r24,lo8(3)
 4558 169c 01F4      		brne .L423
 4559               	.LVL387:
 634:main_sim900.h ****     trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 4560               		.loc 2 634 0
 4561 169e 80E0      		ldi r24,0
 4562 16a0 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 4563               	.LVL388:
 635:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 4564               		.loc 2 635 0
 4565 16a4 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 636:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 4566               		.loc 2 636 0
 4567 16a8 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 637:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 ==
 4568               		.loc 2 637 0
 4569 16ac 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 4570 16b0 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 638:main_sim900.h ****         KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE) {
 4571               		.loc 2 638 0
 4572 16b4 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4573 16b8 863D      		cpi r24,lo8(-42)
 4574 16ba 01F0      		breq .+2
 4575 16bc 00C0      		rjmp .L409
 4576 16be 00C0      		rjmp .L422
 4577               	.LVL389:
 4578               	.L423:
 645:main_sim900.h ****     POMOC_DODAJ2('#', 'd');
 4579               		.loc 2 645 0
 4580 16c0 8091 0000 		lds r24,komenda_SIM900
 4581 16c4 8230      		cpi r24,lo8(2)
 4582 16c6 01F4      		brne .L424
 4583               	.LVL390:
 647:main_sim900.h ****       odpowiedz_na_polecenie();
 4584               		.loc 2 647 0
 4585 16c8 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4586 16cc 863D      		cpi r24,lo8(-42)
 4587 16ce 01F4      		brne .L425
 648:main_sim900.h ****     if (ustaw_maksymalny_czas_dzwonienia == 0)
 4588               		.loc 2 648 0
 4589 16d0 0E94 0000 		call odpowiedz_na_polecenie
 4590               	.LVL391:
 4591               	.L425:
 649:main_sim900.h ****       maksymalny_czas_dzwonienia = 90; // standardowy czas czekania 9 sekund
 4592               		.loc 2 649 0
 4593 16d4 8091 0000 		lds r24,ustaw_maksymalny_czas_dzwonienia
 4594 16d8 8111      		cpse r24,__zero_reg__
 4595 16da 00C0      		rjmp .L426
 650:main_sim900.h ****     else {
 4596               		.loc 2 650 0
 4597 16dc 8AE5      		ldi r24,lo8(90)
 4598 16de 8093 0000 		sts maksymalny_czas_dzwonienia,r24
 4599               	.L427:
 655:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 4600               		.loc 2 655 0
 4601 16e2 8FEF      		ldi r24,lo8(-1)
 4602 16e4 8093 0000 		sts wykonywanie_rozmowy_telefonicznej,r24
 4603               	.LVL392:
 4604               	.L479:
 696:main_sim900.h ****     return;
 4605               		.loc 2 696 0
 4606 16e8 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 4607 16ec 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 4608 16f0 00C0      		rjmp .L409
 4609               	.LVL393:
 4610               	.L426:
 652:main_sim900.h ****       ustaw_maksymalny_czas_dzwonienia = 0;
 4611               		.loc 2 652 0
 4612 16f2 8093 0000 		sts maksymalny_czas_dzwonienia,r24
 653:main_sim900.h ****     }
 4613               		.loc 2 653 0
 4614 16f6 1092 0000 		sts ustaw_maksymalny_czas_dzwonienia,__zero_reg__
 4615 16fa 00C0      		rjmp .L427
 4616               	.LVL394:
 4617               	.L424:
 661:main_sim900.h ****   if (ptr_dtmf != NULL) {
 4618               		.loc 2 661 0
 4619 16fc 80E0      		ldi r24,lo8(__c.3322)
 4620 16fe 90E0      		ldi r25,hi8(__c.3322)
 4621 1700 0E94 0000 		call polozenie_polecenia_SIM900
 4622               	.LVL395:
 662:main_sim900.h ****     POMOC_DODAJ2('#', 'D');
 4623               		.loc 2 662 0
 4624 1704 0097      		sbiw r24,0
 4625 1706 01F0      		breq .L428
 4626               	.LVL396:
 4627               	.LBB559:
 664:main_sim900.h ****     while (*ptr_dtmf == ' ')
 4628               		.loc 2 664 0
 4629 1708 FC01      		movw r30,r24
 4630 170a 3796      		adiw r30,7
 4631               	.LVL397:
 4632               	.L429:
 665:main_sim900.h ****       ++ptr_dtmf;
 4633               		.loc 2 665 0
 4634 170c 8191      		ld r24,Z+
 4635               	.LVL398:
 4636 170e 8032      		cpi r24,lo8(32)
 4637 1710 01F0      		breq .L429
 4638               	.LVL399:
 670:main_sim900.h ****     {
 4639               		.loc 2 670 0
 4640 1712 9091 0000 		lds r25,tryb_clip
 4641 1716 9111      		cpse r25,__zero_reg__
 4642 1718 00C0      		rjmp .L430
 672:main_sim900.h ****         stan_wyjscie[0] = TRUE;
 4643               		.loc 2 672 0
 4644 171a 8133      		cpi r24,lo8(49)
 4645 171c 01F4      		brne .L430
 673:main_sim900.h ****         licznik_przelacznik_wyjscia[0] = 2 * 10ul; // 2 sekundy retrigger
 4646               		.loc 2 673 0
 4647 171e 8FEF      		ldi r24,lo8(-1)
 4648               	.LVL400:
 4649 1720 8093 0000 		sts stan_wyjscie,r24
 4650               	.LVL401:
 674:main_sim900.h ****         zapal_diode_led(10);
 4651               		.loc 2 674 0
 4652 1724 84E1      		ldi r24,lo8(20)
 4653 1726 90E0      		ldi r25,0
 4654 1728 A0E0      		ldi r26,0
 4655 172a B0E0      		ldi r27,0
 4656 172c 8093 0000 		sts licznik_przelacznik_wyjscia,r24
 4657 1730 9093 0000 		sts licznik_przelacznik_wyjscia+1,r25
 4658 1734 A093 0000 		sts licznik_przelacznik_wyjscia+2,r26
 4659 1738 B093 0000 		sts licznik_przelacznik_wyjscia+3,r27
 675:main_sim900.h ****       }
 4660               		.loc 2 675 0
 4661 173c 8BE0      		ldi r24,lo8(11)
 4662 173e 8093 0000 		sts licznik_100ms_dioda_led,r24
 4663               	.L430:
 678:main_sim900.h ****     return;
 4664               		.loc 2 678 0
 4665 1742 1092 0000 		sts komenda_SIM900,__zero_reg__
 4666 1746 00C0      		rjmp .L409
 4667               	.LVL402:
 4668               	.L428:
 4669               	.LBE559:
 682:main_sim900.h ****     POMOC_DODAJ2('#', 'e');
 4670               		.loc 2 682 0
 4671 1748 8091 0000 		lds r24,komenda_SIM900
 4672               	.LVL403:
 4673 174c 8C30      		cpi r24,lo8(12)
 4674 174e 01F4      		brne .L431
 4675               	.LVL404:
 684:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 4676               		.loc 2 684 0
 4677 1750 8091 0000 		lds r24,tryb_clip
 4678 1754 8823      		tst r24
 4679 1756 01F4      		brne .+2
 4680 1758 00C0      		rjmp .L409
 685:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
 4681               		.loc 2 685 0
 4682 175a 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 686:main_sim900.h ****     }
 4683               		.loc 2 686 0
 4684 175e 87E9      		ldi r24,lo8(-105)
 4685               	/* epilogue start */
 4686               	.LBE555:
 4687               	.LBE554:
 4688               		.loc 2 758 0
 4689 1760 DF91      		pop r29
 4690 1762 CF91      		pop r28
 4691 1764 1F91      		pop r17
 4692 1766 0F91      		pop r16
 4693               	.LBB565:
 4694               	.LBB563:
 686:main_sim900.h ****     }
 4695               		.loc 2 686 0
 4696 1768 0C94 0000 		jmp dodaj_komende
 4697               	.LVL405:
 4698               	.L431:
 690:main_sim900.h ****     POMOC_DODAJ2('#', 'f');
 4699               		.loc 2 690 0
 4700 176c 8091 0000 		lds r24,komenda_SIM900
 4701 1770 8930      		cpi r24,lo8(9)
 4702 1772 01F4      		brne .L432
 4703               	.L476:
 4704               	.LVL406:
 692:main_sim900.h ****       odpowiedz_na_polecenie();
 4705               		.loc 2 692 0
 4706 1774 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4707 1778 863D      		cpi r24,lo8(-42)
 4708 177a 01F4      		brne .L433
 693:main_sim900.h ****     zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 4709               		.loc 2 693 0
 4710 177c 0E94 0000 		call odpowiedz_na_polecenie
 4711               	.LVL407:
 4712               	.L433:
 694:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 4713               		.loc 2 694 0
 4714 1780 80E0      		ldi r24,0
 4715 1782 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 4716               	.LVL408:
 695:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 4717               		.loc 2 695 0
 4718 1786 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 4719 178a 00C0      		rjmp .L479
 4720               	.LVL409:
 4721               	.L432:
 700:main_sim900.h ****     POMOC_DODAJ2('#', 'g');
 4722               		.loc 2 700 0
 4723 178c 8091 0000 		lds r24,komenda_SIM900
 4724 1790 8730      		cpi r24,lo8(7)
 4725 1792 01F0      		breq .L476
 710:main_sim900.h ****     const uchar *ptr = strchr(polozenie_polecenia_SIM900(PSTR("+CMTI:")), ',');
 4726               		.loc 2 710 0
 4727 1794 8091 0000 		lds r24,komenda_SIM900
 4728 1798 8830      		cpi r24,lo8(8)
 4729 179a 01F4      		brne .L436
 4730               	.LBB560:
 711:main_sim900.h ****     if (ptr != NULL) {
 4731               		.loc 2 711 0
 4732 179c 80E0      		ldi r24,lo8(__c.3329)
 4733 179e 90E0      		ldi r25,hi8(__c.3329)
 4734 17a0 0E94 0000 		call polozenie_polecenia_SIM900
 4735               	.LVL410:
 4736 17a4 6CE2      		ldi r22,lo8(44)
 4737 17a6 70E0      		ldi r23,0
 4738 17a8 0E94 0000 		call strchr
 4739               	.LVL411:
 712:main_sim900.h ****       uint numer_smsa = (uint)strtoul(ptr + 1, NULL, 10);
 4740               		.loc 2 712 0
 4741 17ac 0097      		sbiw r24,0
 4742 17ae 01F0      		breq .L438
 4743               	.LBB561:
 713:main_sim900.h ****       if (numer_smsa > 0 && numer_smsa <= 20) // Hardcoded 20
 4744               		.loc 2 713 0
 4745 17b0 4AE0      		ldi r20,lo8(10)
 4746 17b2 50E0      		ldi r21,0
 4747 17b4 70E0      		ldi r23,0
 4748 17b6 60E0      		ldi r22,0
 4749 17b8 0196      		adiw r24,1
 4750               	.LVL412:
 4751 17ba 0E94 0000 		call strtoul
 4752               	.LVL413:
 714:main_sim900.h ****       {
 4753               		.loc 2 714 0
 4754 17be 9B01      		movw r18,r22
 4755 17c0 2150      		subi r18,1
 4756 17c2 3109      		sbc r19,__zero_reg__
 4757 17c4 2431      		cpi r18,20
 4758 17c6 3105      		cpc r19,__zero_reg__
 4759 17c8 00F4      		brsh .L438
 716:main_sim900.h ****         opoznienie_SIM900_100MS = 1; // 20 (1)
 4760               		.loc 2 716 0
 4761 17ca 89EA      		ldi r24,lo8(-87)
 4762 17cc 860F      		add r24,r22
 4763 17ce 0E94 0000 		call dodaj_komende
 4764               	.LVL414:
 717:main_sim900.h ****       }
 4765               		.loc 2 717 0
 4766 17d2 81E0      		ldi r24,lo8(1)
 4767               	.L477:
 4768 17d4 8093 0000 		sts opoznienie_SIM900_100MS,r24
 4769               	.L438:
 4770               	.LBE561:
 721:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 4771               		.loc 2 721 0
 4772 17d8 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4773 17dc 8A5A      		subi r24,lo8(-(86))
 720:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 4774               		.loc 2 720 0
 4775 17de 8431      		cpi r24,lo8(20)
 4776 17e0 00F4      		brsh .+2
 4777 17e2 00C0      		rjmp .L478
 4778 17e4 00C0      		rjmp .L409
 4779               	.L436:
 4780               	.LBE560:
 730:main_sim900.h ****     opoznienie_SIM900_100MS = 20;
 4781               		.loc 2 730 0
 4782 17e6 8091 0000 		lds r24,komenda_SIM900
 4783 17ea 8E30      		cpi r24,lo8(14)
 4784 17ec 01F4      		brne .L440
 4785               	.LBB562:
 731:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 4786               		.loc 2 731 0
 4787 17ee 84E1      		ldi r24,lo8(20)
 4788 17f0 00C0      		rjmp .L477
 4789               	.L440:
 4790               	.LBE562:
 752:main_sim900.h ****     obsluga_wysylania_sms();
 4791               		.loc 2 752 0
 4792 17f2 8091 0000 		lds r24,flaga_wysylanie_smsa
 4793 17f6 8111      		cpse r24,__zero_reg__
 753:main_sim900.h **** 
 4794               		.loc 2 753 0
 4795 17f8 0E94 0000 		call obsluga_wysylania_sms
 4796               	.LVL415:
 4797               	.L442:
 755:main_sim900.h ****       komenda_SIM900 != BRAK_KOMENDY_SIM900)
 4798               		.loc 2 755 0
 4799 17fc 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 4800 1800 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
 4801 1804 892B      		or r24,r25
 4802 1806 01F4      		brne .+2
 4803 1808 00C0      		rjmp .L409
 756:main_sim900.h ****     odpowiedz_na_polecenie();
 4804               		.loc 2 756 0
 4805 180a 8091 0000 		lds r24,komenda_SIM900
 755:main_sim900.h ****       komenda_SIM900 != BRAK_KOMENDY_SIM900)
 4806               		.loc 2 755 0
 4807 180e 8823      		tst r24
 4808 1810 01F4      		brne .+2
 4809 1812 00C0      		rjmp .L409
 4810               	/* epilogue start */
 4811               	.LBE563:
 4812               	.LBE565:
 4813               		.loc 2 758 0
 4814 1814 DF91      		pop r29
 4815 1816 CF91      		pop r28
 4816 1818 1F91      		pop r17
 4817 181a 0F91      		pop r16
 4818               	.LBB566:
 4819               	.LBB564:
 757:main_sim900.h **** }
 4820               		.loc 2 757 0
 4821 181c 0C94 0000 		jmp odpowiedz_na_polecenie
 4822               	.LVL416:
 4823               	.LBE564:
 4824               	.LBE566:
 4825               		.cfi_endproc
 4826               	.LFE51:
 4828               	.global	wyslanie_polecenia_ROM
 4830               	wyslanie_polecenia_ROM:
 4831               	.LFB52:
 759:main_sim900.h **** 
 760:main_sim900.h **** uchar wyslanie_polecenia_ROM(const uchar czy_mozna_wysylac_dane_do_SIM900,
 761:main_sim900.h ****                              const komenda_typ wykonywana_komenda,
 762:main_sim900.h ****                              const komenda_typ nastepne_wysylane_polecenie,
 763:main_sim900.h ****                              PGM_P instrukcja) {
 4832               		.loc 2 763 0
 4833               		.cfi_startproc
 4834               	.LVL417:
 4835               	/* prologue: function */
 4836               	/* frame size = 0 */
 4837               	/* stack size = 0 */
 4838               	.L__stack_usage = 0
 764:main_sim900.h ****   if (!czy_mozna_wysylac_dane_do_SIM900) {
 4839               		.loc 2 764 0
 4840 1820 8111      		cpse r24,__zero_reg__
 4841 1822 00C0      		rjmp .L481
 765:main_sim900.h ****     dodaj_komende(wykonywana_komenda);
 4842               		.loc 2 765 0
 4843 1824 862F      		mov r24,r22
 4844               	.LVL418:
 4845 1826 0E94 0000 		call dodaj_komende
 4846               	.LVL419:
 766:main_sim900.h ****     return FALSE;
 4847               		.loc 2 766 0
 4848 182a 80E0      		ldi r24,0
 4849 182c 0895      		ret
 4850               	.LVL420:
 4851               	.L481:
 767:main_sim900.h ****   }
 768:main_sim900.h ****   wysylane_polecenie_SIM900 = wykonywana_komenda;
 4852               		.loc 2 768 0
 4853 182e 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 4854 1832 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 4855 1836 6093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r22
 769:main_sim900.h ****   nastepne_wysylane_polecenie_SIM900 = nastepne_wysylane_polecenie;
 4856               		.loc 2 769 0
 4857 183a 4093 0000 		sts nastepne_wysylane_polecenie_SIM900,r20
 770:main_sim900.h ****   wyslij_polecenie_ROM_SIM900(instrukcja);
 4858               		.loc 2 770 0
 4859 183e C901      		movw r24,r18
 4860               	.LVL421:
 4861 1840 0E94 0000 		call wyslij_polecenie_ROM_SIM900
 4862               	.LVL422:
 771:main_sim900.h ****   return TRUE;
 4863               		.loc 2 771 0
 4864 1844 8FEF      		ldi r24,lo8(-1)
 4865               	/* epilogue start */
 772:main_sim900.h **** }
 4866               		.loc 2 772 0
 4867 1846 0895      		ret
 4868               		.cfi_endproc
 4869               	.LFE52:
 4871               	.global	wyslij_sms
 4873               	wyslij_sms:
 4874               	.LFB53:
 773:main_sim900.h **** 
 774:main_sim900.h **** #ifndef memcpy_E
 775:main_sim900.h **** #define memcpy_E(sink, source, l)                                              \
 776:main_sim900.h ****   eeprom_read_block((sink), (void *)(source), (l))
 777:main_sim900.h **** #endif
 778:main_sim900.h **** 
 779:main_sim900.h **** void wyslij_sms(const uchar wyslij_pdu) {
 4875               		.loc 2 779 0
 4876               		.cfi_startproc
 4877               	.LVL423:
 4878 1848 0F93      		push r16
 4879               	.LCFI68:
 4880               		.cfi_def_cfa_offset 3
 4881               		.cfi_offset 16, -2
 4882 184a CF93      		push r28
 4883               	.LCFI69:
 4884               		.cfi_def_cfa_offset 4
 4885               		.cfi_offset 28, -3
 4886 184c DF93      		push r29
 4887               	.LCFI70:
 4888               		.cfi_def_cfa_offset 5
 4889               		.cfi_offset 29, -4
 4890               	/* prologue: function */
 4891               	/* frame size = 0 */
 4892               	/* stack size = 3 */
 4893               	.L__stack_usage = 3
 780:main_sim900.h ****   czekanie_na_odebranie_zachety = TRUE;
 4894               		.loc 2 780 0
 4895 184e 9FEF      		ldi r25,lo8(-1)
 4896 1850 9093 0000 		sts czekanie_na_odebranie_zachety,r25
 781:main_sim900.h ****   flaga_odebrany_znak_zachety = FALSE;
 4897               		.loc 2 781 0
 4898 1854 1092 0000 		sts flaga_odebrany_znak_zachety,__zero_reg__
 782:main_sim900.h ****   if (!wyslij_pdu) {
 4899               		.loc 2 782 0
 4900 1858 8111      		cpse r24,__zero_reg__
 4901 185a 00C0      		rjmp .L484
 4902               	.LBB567:
 783:main_sim900.h ****     // Zmiana: 5 blyskow LED przy wysylaniu SMS
 784:main_sim900.h ****     zapal_diode_led_blyski(5);
 4903               		.loc 2 784 0
 4904 185c 85E0      		ldi r24,lo8(5)
 4905               	.LVL424:
 4906 185e 8093 0000 		sts liczba_blyskow_led,r24
 4907 1862 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 785:main_sim900.h ****     flaga_wysylanie_smsa = KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT;
 4908               		.loc 2 785 0
 4909 1866 83ED      		ldi r24,lo8(-45)
 4910 1868 8093 0000 		sts flaga_wysylanie_smsa,r24
 786:main_sim900.h ****     bufor_pdu[0] = 0xff; // memcpy_E(bufor_pdu, (void*)EEPROM_ADRES_CENTRUM_SMS,
 4911               		.loc 2 786 0
 4912 186c 9093 0000 		sts bufor_pdu,r25
 787:main_sim900.h ****                          // LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 788:main_sim900.h ****     konwertuj_blok_eeprom_na_telefon(
 4913               		.loc 2 788 0
 4914 1870 4AE0      		ldi r20,lo8(10)
 4915 1872 60E0      		ldi r22,lo8(bufor_eeprom)
 4916 1874 70E0      		ldi r23,hi8(bufor_eeprom)
 4917 1876 80E0      		ldi r24,lo8(bufor_pdu)
 4918 1878 90E0      		ldi r25,hi8(bufor_pdu)
 4919 187a 0E94 0000 		call konwertuj_blok_eeprom_na_telefon
 4920               	.LVL425:
 789:main_sim900.h ****         bufor_pdu, bufor_eeprom, 2 * LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 790:main_sim900.h ****     uchar *ptr = zapisz_naglowek_pdu(bufor_pdu, numer_telefonu_wysylanego_smsa,
 4921               		.loc 2 790 0
 4922 187e 00E0      		ldi r16,0
 4923 1880 20E0      		ldi r18,0
 4924 1882 40E0      		ldi r20,lo8(bufor_eeprom)
 4925 1884 50E0      		ldi r21,hi8(bufor_eeprom)
 4926 1886 60E0      		ldi r22,lo8(numer_telefonu_wysylanego_smsa)
 4927 1888 70E0      		ldi r23,hi8(numer_telefonu_wysylanego_smsa)
 4928 188a 80E0      		ldi r24,lo8(bufor_pdu)
 4929 188c 90E0      		ldi r25,hi8(bufor_pdu)
 4930 188e 0E94 0000 		call zapisz_naglowek_pdu
 4931               	.LVL426:
 791:main_sim900.h ****                                      bufor_eeprom, 0x00, 0x00);
 792:main_sim900.h ****     dlugosc_pdu = ascii_to_pdu(ptr, tekst_wysylanego_smsa) - bufor_pdu;
 4932               		.loc 2 792 0
 4933 1892 40E0      		ldi r20,lo8(tekst_wysylanego_smsa)
 4934 1894 50E0      		ldi r21,hi8(tekst_wysylanego_smsa)
 4935 1896 FA01      		movw r30,r20
 4936               		0:
 4937 1898 0190      		ld __tmp_reg__,Z+
 4938 189a 0020      		tst __tmp_reg__
 4939 189c 01F4      		brne 0b
 4940 189e AF01      		movw r20,r30
 4941 18a0 4150      		subi r20,1
 4942 18a2 5109      		sbc r21,__zero_reg__
 4943 18a4 60E0      		ldi r22,lo8(tekst_wysylanego_smsa)
 4944 18a6 70E0      		ldi r23,hi8(tekst_wysylanego_smsa)
 4945 18a8 0E94 0000 		call ascii_to_pdu_blok
 4946               	.LVL427:
 4947               	.L486:
 4948               	.LBE567:
 4949               	.LBB568:
 793:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 794:main_sim900.h ****     uchar l = strlen(numer_telefonu_wysylanego_smsa);
 795:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
 796:main_sim900.h ****       POMOC_DODAJ(numer_telefonu_wysylanego_smsa[i]);
 797:main_sim900.h ****     POMOC_DODAJ(' ');
 798:main_sim900.h ****     l = strlen(tekst_wysylanego_smsa);
 799:main_sim900.h ****     if (l > 20)
 800:main_sim900.h ****       l = 20;
 801:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
 802:main_sim900.h ****       POMOC_DODAJ(tekst_wysylanego_smsa[i]);
 803:main_sim900.h **** #endif
 804:main_sim900.h ****   } else {
 805:main_sim900.h ****     // Zmiana: 5 blyskow LED przy wysylaniu PDU
 806:main_sim900.h ****     zapal_diode_led_blyski(5);
 807:main_sim900.h ****     flaga_wysylanie_smsa = KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU;
 808:main_sim900.h ****     const uchar TP_DCS = tekst_wysylanego_smsa[0]; // message class
 809:main_sim900.h ****     bufor_pdu[0] = 0xff; // memcpy_E(bufor_pdu, (void*)EEPROM_ADRES_CENTRUM_SMS,
 810:main_sim900.h ****                          // LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 811:main_sim900.h ****     konwertuj_blok_eeprom_na_telefon(
 812:main_sim900.h ****         bufor_pdu, bufor_eeprom, 2 * LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 813:main_sim900.h ****     uchar *ptr = zapisz_naglowek_pdu(bufor_pdu, numer_telefonu_wysylanego_smsa,
 814:main_sim900.h ****                                      bufor_eeprom, 0x00, TP_DCS);
 815:main_sim900.h ****     memcpy(ptr, &tekst_wysylanego_smsa[2], tekst_wysylanego_smsa[1]);
 816:main_sim900.h ****     dlugosc_pdu = (ptr + tekst_wysylanego_smsa[1]) - bufor_pdu;
 4950               		.loc 2 816 0
 4951 18ac 8050      		subi r24,lo8(bufor_pdu)
 4952 18ae 9040      		sbci r25,hi8(bufor_pdu)
 4953 18b0 8093 0000 		sts dlugosc_pdu,r24
 4954               	.LBE568:
 817:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 818:main_sim900.h ****     uchar l = strlen(numer_telefonu_wysylanego_smsa);
 819:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
 820:main_sim900.h ****       POMOC_DODAJ(numer_telefonu_wysylanego_smsa[i]);
 821:main_sim900.h ****     POMOC_DODAJ(' ');
 822:main_sim900.h ****     POMOC_DODAJ('P');
 823:main_sim900.h ****     POMOC_DODAJ('D');
 824:main_sim900.h ****     POMOC_DODAJ('U');
 825:main_sim900.h **** #endif
 826:main_sim900.h ****   }
 827:main_sim900.h ****   const uchar oktety = dlugosc_pdu - 1 - bufor_pdu[0];
 4955               		.loc 2 827 0
 4956 18b4 C091 0000 		lds r28,dlugosc_pdu
 4957 18b8 C150      		subi r28,lo8(-(-1))
 4958 18ba 8091 0000 		lds r24,bufor_pdu
 4959 18be C81B      		sub r28,r24
 4960               	.LVL428:
 828:main_sim900.h ****   static const char instrukcja_wyslij_smsa[] PROGMEM = "+cmgs=";
 829:main_sim900.h ****   memcpy_R(wysylane_dane_RAM_SIM900, instrukcja_wyslij_smsa);
 4961               		.loc 2 829 0
 4962 18c0 46E0      		ldi r20,lo8(6)
 4963 18c2 50E0      		ldi r21,0
 4964 18c4 60E0      		ldi r22,lo8(instrukcja_wyslij_smsa.3349)
 4965 18c6 70E0      		ldi r23,hi8(instrukcja_wyslij_smsa.3349)
 4966 18c8 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 4967 18ca 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 4968 18cc 0E94 0000 		call memcpy_P
 4969               	.LVL429:
 4970               	.LBB569:
 4971               	.LBB570:
 4972               		.loc 6 527 0
 4973 18d0 4AE0      		ldi r20,lo8(10)
 4974 18d2 60E0      		ldi r22,lo8(wysylany_blok_SIM900+8)
 4975 18d4 70E0      		ldi r23,hi8(wysylany_blok_SIM900+8)
 4976               	.LVL430:
 4977 18d6 8C2F      		mov r24,r28
 4978 18d8 90E0      		ldi r25,0
 4979 18da 0E94 0000 		call __utoa_ncheck
 4980               	.LVL431:
 4981               	.LBE570:
 4982               	.LBE569:
 830:main_sim900.h ****   utoa(oktety, wysylane_dane_RAM_SIM900 + strlen_R(instrukcja_wyslij_smsa), 10);
 831:main_sim900.h ****   max_oczekiwanie_na_odpowiedz = 250;
 4983               		.loc 2 831 0
 4984 18de 8AEF      		ldi r24,lo8(-6)
 4985 18e0 8093 0000 		sts max_oczekiwanie_na_odpowiedz,r24
 4986               	/* epilogue start */
 832:main_sim900.h ****   wyslij_polecenie_RAM_SIM900();
 833:main_sim900.h ****   POMOC_DODAJ2('#', 'S');
 834:main_sim900.h **** }
 4987               		.loc 2 834 0
 4988 18e4 DF91      		pop r29
 4989 18e6 CF91      		pop r28
 4990               	.LVL432:
 4991 18e8 0F91      		pop r16
 832:main_sim900.h ****   wyslij_polecenie_RAM_SIM900();
 4992               		.loc 2 832 0
 4993 18ea 0C94 0000 		jmp wyslij_polecenie_RAM_SIM900
 4994               	.LVL433:
 4995               	.L484:
 4996               	.LBB571:
 806:main_sim900.h ****     flaga_wysylanie_smsa = KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU;
 4997               		.loc 2 806 0
 4998 18ee 85E0      		ldi r24,lo8(5)
 4999               	.LVL434:
 5000 18f0 8093 0000 		sts liczba_blyskow_led,r24
 5001 18f4 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 807:main_sim900.h ****     const uchar TP_DCS = tekst_wysylanego_smsa[0]; // message class
 5002               		.loc 2 807 0
 5003 18f8 84ED      		ldi r24,lo8(-44)
 5004 18fa 8093 0000 		sts flaga_wysylanie_smsa,r24
 808:main_sim900.h ****     bufor_pdu[0] = 0xff; // memcpy_E(bufor_pdu, (void*)EEPROM_ADRES_CENTRUM_SMS,
 5005               		.loc 2 808 0
 5006 18fe 0091 0000 		lds r16,tekst_wysylanego_smsa
 5007               	.LVL435:
 809:main_sim900.h ****                          // LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 5008               		.loc 2 809 0
 5009 1902 9093 0000 		sts bufor_pdu,r25
 811:main_sim900.h ****         bufor_pdu, bufor_eeprom, 2 * LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 5010               		.loc 2 811 0
 5011 1906 4AE0      		ldi r20,lo8(10)
 5012 1908 60E0      		ldi r22,lo8(bufor_eeprom)
 5013 190a 70E0      		ldi r23,hi8(bufor_eeprom)
 5014 190c 80E0      		ldi r24,lo8(bufor_pdu)
 5015 190e 90E0      		ldi r25,hi8(bufor_pdu)
 5016 1910 0E94 0000 		call konwertuj_blok_eeprom_na_telefon
 5017               	.LVL436:
 813:main_sim900.h ****                                      bufor_eeprom, 0x00, TP_DCS);
 5018               		.loc 2 813 0
 5019 1914 20E0      		ldi r18,0
 5020 1916 40E0      		ldi r20,lo8(bufor_eeprom)
 5021 1918 50E0      		ldi r21,hi8(bufor_eeprom)
 5022 191a 60E0      		ldi r22,lo8(numer_telefonu_wysylanego_smsa)
 5023 191c 70E0      		ldi r23,hi8(numer_telefonu_wysylanego_smsa)
 5024 191e 80E0      		ldi r24,lo8(bufor_pdu)
 5025 1920 90E0      		ldi r25,hi8(bufor_pdu)
 5026 1922 0E94 0000 		call zapisz_naglowek_pdu
 5027               	.LVL437:
 5028 1926 EC01      		movw r28,r24
 5029               	.LVL438:
 815:main_sim900.h ****     dlugosc_pdu = (ptr + tekst_wysylanego_smsa[1]) - bufor_pdu;
 5030               		.loc 2 815 0
 5031 1928 4091 0000 		lds r20,tekst_wysylanego_smsa+1
 5032 192c 50E0      		ldi r21,0
 5033 192e 60E0      		ldi r22,lo8(tekst_wysylanego_smsa+2)
 5034 1930 70E0      		ldi r23,hi8(tekst_wysylanego_smsa+2)
 5035 1932 0E94 0000 		call memcpy
 5036               	.LVL439:
 816:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 5037               		.loc 2 816 0
 5038 1936 8091 0000 		lds r24,tekst_wysylanego_smsa+1
 5039 193a 8C0F      		add r24,r28
 5040 193c 9D2F      		mov r25,r29
 5041 193e 911D      		adc r25,__zero_reg__
 5042 1940 00C0      		rjmp .L486
 5043               	.LBE571:
 5044               		.cfi_endproc
 5045               	.LFE53:
 5047               	.global	wykonanie_komend_SIM900
 5049               	wykonanie_komend_SIM900:
 5050               	.LFB54:
 835:main_sim900.h **** 
 836:main_sim900.h **** uchar wykonanie_komend_SIM900(void) {
 5051               		.loc 2 836 0
 5052               		.cfi_startproc
 5053 1942 EF92      		push r14
 5054               	.LCFI71:
 5055               		.cfi_def_cfa_offset 3
 5056               		.cfi_offset 14, -2
 5057 1944 FF92      		push r15
 5058               	.LCFI72:
 5059               		.cfi_def_cfa_offset 4
 5060               		.cfi_offset 15, -3
 5061 1946 0F93      		push r16
 5062               	.LCFI73:
 5063               		.cfi_def_cfa_offset 5
 5064               		.cfi_offset 16, -4
 5065 1948 1F93      		push r17
 5066               	.LCFI74:
 5067               		.cfi_def_cfa_offset 6
 5068               		.cfi_offset 17, -5
 5069 194a CF93      		push r28
 5070               	.LCFI75:
 5071               		.cfi_def_cfa_offset 7
 5072               		.cfi_offset 28, -6
 5073 194c DF93      		push r29
 5074               	.LCFI76:
 5075               		.cfi_def_cfa_offset 8
 5076               		.cfi_offset 29, -7
 5077 194e 00D0      		rcall .
 5078 1950 1F92      		push __zero_reg__
 5079               	.LCFI77:
 5080               		.cfi_def_cfa_offset 11
 5081 1952 CDB7      		in r28,__SP_L__
 5082 1954 DEB7      		in r29,__SP_H__
 5083               	.LCFI78:
 5084               		.cfi_def_cfa_register 28
 5085               	/* prologue: function */
 5086               	/* frame size = 3 */
 5087               	/* stack size = 9 */
 5088               	.L__stack_usage = 9
 837:main_sim900.h ****   const uchar czy_gsm_zajety =
 838:main_sim900.h ****       flaga_odczytywanie_smsa || flaga_wysylanie_smsa ||
 5089               		.loc 2 838 0
 5090 1956 9091 0000 		lds r25,flaga_odczytywanie_smsa
 839:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej ||
 840:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika ||
 841:main_sim900.h ****       aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
 842:main_sim900.h ****       opoznienie_SIM900_100MS || czekanie_na_odebranie_zachety;
 5091               		.loc 2 842 0
 5092 195a 9111      		cpse r25,__zero_reg__
 5093 195c 00C0      		rjmp .L589
 838:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej ||
 5094               		.loc 2 838 0
 5095 195e 8091 0000 		lds r24,flaga_wysylanie_smsa
 5096 1962 8111      		cpse r24,__zero_reg__
 5097 1964 00C0      		rjmp .L589
 838:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej ||
 5098               		.loc 2 838 0 is_stmt 0 discriminator 1
 5099 1966 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5100 196a 8111      		cpse r24,__zero_reg__
 5101 196c 00C0      		rjmp .L589
 839:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej ||
 5102               		.loc 2 839 0 is_stmt 1
 5103 196e 8091 0000 		lds r24,trwa_rozmowa_przychodzaca_od_uzytkownika
 5104 1972 8111      		cpse r24,__zero_reg__
 5105 1974 00C0      		rjmp .L589
 840:main_sim900.h ****       aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
 5106               		.loc 2 840 0
 5107 1976 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 5108 197a 8111      		cpse r24,__zero_reg__
 5109 197c 00C0      		rjmp .L589
 841:main_sim900.h ****       opoznienie_SIM900_100MS || czekanie_na_odebranie_zachety;
 5110               		.loc 2 841 0
 5111 197e 8091 0000 		lds r24,opoznienie_SIM900_100MS
 5112 1982 8111      		cpse r24,__zero_reg__
 5113 1984 00C0      		rjmp .L589
 5114               		.loc 2 842 0 discriminator 2
 5115 1986 2091 0000 		lds r18,czekanie_na_odebranie_zachety
 5116 198a 81E0      		ldi r24,lo8(1)
 5117 198c 2111      		cpse r18,__zero_reg__
 5118 198e 00C0      		rjmp .L489
 5119 1990 80E0      		ldi r24,0
 5120               	.L489:
 5121               	.LVL440:
 843:main_sim900.h **** 
 844:main_sim900.h ****   const uchar czy_mozna_wysylac_dane_do_SIM900 =
 845:main_sim900.h ****       !czy_gsm_zajety && CZY_MOZNA_WYSYLAC_DANE_SIM900() &&
 5122               		.loc 2 845 0 discriminator 2
 5123 1992 8111      		cpse r24,__zero_reg__
 5124 1994 00C0      		rjmp .L592
 5125               	.LVL441:
 5126               		.loc 2 845 0 is_stmt 0 discriminator 1
 5127 1996 2091 C100 		lds r18,193
 5128 199a 26FD      		sbrc r18,6
 5129 199c 00C0      		rjmp .L592
 5130               		.loc 2 845 0 discriminator 3
 5131 199e 2091 0000 		lds r18,podlaczony_modul_gsm_SIM900
 5132 19a2 2223      		tst r18
 5133 19a4 01F0      		breq .L592
 846:main_sim900.h ****       czy_jest_bezczynny_SIM900();
 5134               		.loc 2 846 0 is_stmt 1 discriminator 5
 5135 19a6 2091 0000 		lds r18,komenda_SIM900
 845:main_sim900.h ****       czy_jest_bezczynny_SIM900();
 5136               		.loc 2 845 0 discriminator 5
 5137 19aa 01E0      		ldi r16,lo8(1)
 5138 19ac 2111      		cpse r18,__zero_reg__
 5139 19ae 00C0      		rjmp .L592
 5140               	.LVL442:
 5141               	.L490:
 847:main_sim900.h **** 
 848:main_sim900.h ****   const komenda_typ wykonywana_komenda = komendy_kolejka[0];
 5142               		.loc 2 848 0
 5143 19b0 1091 0000 		lds r17,komendy_kolejka
 5144               	.LVL443:
 849:main_sim900.h ****   switch (wykonywana_komenda) {
 5145               		.loc 2 849 0
 5146 19b4 E12E      		mov r14,r17
 5147 19b6 F12C      		mov r15,__zero_reg__
 5148 19b8 1D39      		cpi r17,lo8(-99)
 5149 19ba 01F4      		brne .+2
 5150 19bc 00C0      		rjmp .L493
 5151 19be 00F0      		brlo .+2
 5152 19c0 00C0      		rjmp .L494
 5153 19c2 1239      		cpi r17,lo8(-110)
 5154 19c4 01F4      		brne .+2
 5155 19c6 00C0      		rjmp .L495
 5156 19c8 00F4      		brsh .L496
 5157 19ca 1D38      		cpi r17,lo8(-115)
 5158 19cc 01F4      		brne .+2
 5159 19ce 00C0      		rjmp .L497
 5160 19d0 00F4      		brsh .L498
 5161 19d2 1B38      		cpi r17,lo8(-117)
 5162 19d4 01F4      		brne .+2
 5163 19d6 00C0      		rjmp .L499
 5164 19d8 00F0      		brlo .+2
 5165 19da 00C0      		rjmp .L500
 5166 19dc 1A38      		cpi r17,lo8(-118)
 5167 19de 01F4      		brne .+2
 5168 19e0 00C0      		rjmp .L501
 5169               	.L492:
 850:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 851:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU: {
 852:main_sim900.h ****     POWTORZ_JESLI(flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS);
 853:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 854:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 855:main_sim900.h ****     wyslij_sms(wykonywana_komenda == KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
 856:main_sim900.h ****     break;
 857:main_sim900.h ****   }
 858:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_PDU: {
 859:main_sim900.h ****     czekanie_na_odebranie_zachety = FALSE;
 860:main_sim900.h ****     konwertuj_pdu_na_blok_wysylany(wysylany_blok_SIM900, bufor_pdu,
 861:main_sim900.h ****                                    dlugosc_pdu);
 862:main_sim900.h ****     const uint liczba_znakow = 2 * dlugosc_pdu + 1;
 863:main_sim900.h ****     wysylany_blok_SIM900[liczba_znakow - 1] = ZNAK_CTRL_Z;
 864:main_sim900.h ****     wyslij_znaki_SIM900(liczba_znakow);
 865:main_sim900.h ****     break;
 866:main_sim900.h ****   }
 867:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1:
 868:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_2:
 869:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_3:
 870:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_4:
 871:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_5:
 872:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_6:
 873:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_7:
 874:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_8:
 875:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_9:
 876:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_10:
 877:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_11:
 878:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_12:
 879:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_13:
 880:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_14:
 881:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_15:
 882:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_16:
 883:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_17:
 884:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_18:
 885:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_19:
 886:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20: {
 887:main_sim900.h ****     POWTORZ_JESLI(flaga_odczytywanie_smsa || !modul_zalogowany_w_sieci ||
 888:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 889:main_sim900.h ****                   wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK ||
 890:main_sim900.h ****                   flaga_wysylanie_smsa ||
 891:main_sim900.h ****                   aktualnie_wysylane_polecenie_SIM900 ==
 892:main_sim900.h ****                       KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 893:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 894:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 895:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW,
 896:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW) ||
 897:main_sim900.h ****                   czy_sa_komendy_z_przedzialu(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT,
 898:main_sim900.h ****                                               KOMENDA_KOLEJKI_WYSLIJ_PDU) ||
 899:main_sim900.h ****                   czy_sa_komendy_z_przedzialu(
 900:main_sim900.h ****                       KOMENDA_KOLEJKI_ODBIERZ_ROZMOWE,
 901:main_sim900.h ****                       KOMENDA_KOLEJKI_SPRAWDZ_PRZYCHODZACA_ROZMOWE));
 902:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 903:main_sim900.h ****     flaga_odczytywanie_smsa = TRUE;
 904:main_sim900.h ****     static const char instrukcja_odczytaj_smsa[] PROGMEM = "+cmgr=";
 905:main_sim900.h ****     memcpy_R(wysylane_dane_RAM_SIM900, instrukcja_odczytaj_smsa);
 906:main_sim900.h ****     const uint nr_smsa =
 907:main_sim900.h ****         wykonywana_komenda - KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 + 1;
 908:main_sim900.h ****     utoa(nr_smsa, wysylane_dane_RAM_SIM900 + strlen_R(instrukcja_odczytaj_smsa),
 909:main_sim900.h ****          10);
 910:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 911:main_sim900.h ****     POMOC_DODAJ2('#', 'X');
 912:main_sim900.h ****     break;
 913:main_sim900.h ****   }
 914:main_sim900.h ****   case KOMENDA_KOLEJKI_INTERPRETUJ_PDU: {
 915:main_sim900.h ****     const uchar *ptr = pobierz_numer_telefonu_nadawcy_z_PDU(
 916:main_sim900.h ****         bufor_pdu, numer_telefonu_odebranego_smsa,
 917:main_sim900.h ****         &nie_wysylaj_echa_z_powodu_nietypowego_smsa);
 918:main_sim900.h ****     if (ptr == 0) // (1)
 919:main_sim900.h ****     {
 920:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 921:main_sim900.h ****       break;
 922:main_sim900.h ****     }
 923:main_sim900.h ****     {
 924:main_sim900.h ****       uchar rok, miesiac, dzien;
 925:main_sim900.h ****       ptr = pobierz_date_z_PDU(ptr, &rok, &miesiac, &dzien);
 926:main_sim900.h ****     }
 927:main_sim900.h ****     {
 928:main_sim900.h ****       uchar godzina, minuta, sekunda;
 929:main_sim900.h ****       ptr = pobierz_czas_z_PDU(ptr, &godzina, &minuta, &sekunda);
 930:main_sim900.h **** 
 931:main_sim900.h ****       // Zapisz timestamp z SMS do późniejszego użycia
 932:main_sim900.h ****       // (zostanie użyty w wykonanie_polecenia_sms jeśli kod ABCD jest poprawny)
 933:main_sim900.h ****       sms_timestamp_godzina = godzina;
 934:main_sim900.h ****       sms_timestamp_minuta = minuta;
 935:main_sim900.h ****       extern uchar sms_timestamp_sekunda;
 936:main_sim900.h ****       sms_timestamp_sekunda = sekunda;
 937:main_sim900.h ****     }
 938:main_sim900.h ****     ptr_start_pdu_z_wiadomoscia = (uchar *)ptr;
 939:main_sim900.h ****     pdu_to_ascii(ptr, tekst_odebranego_smsa, MAX_LICZBA_ZNAKOW_SMS + 1);
 940:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 941:main_sim900.h ****     const uchar l = min(strlen(tekst_odebranego_smsa), 20);
 942:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
 943:main_sim900.h ****       POMOC_DODAJ(tekst_odebranego_smsa[i]);
 944:main_sim900.h **** #endif
 945:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_INTERPRETUJ_ODEBRANEGO_SMSA);
 946:main_sim900.h ****     break;
 947:main_sim900.h ****   }
 948:main_sim900.h ****   case KOMENDA_KOLEJKI_INTERPRETUJ_ODEBRANEGO_SMSA: {
 949:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 950:main_sim900.h ****     zapal_diode_led(10);
 951:main_sim900.h ****     wykonanie_polecenia_sms();
 952:main_sim900.h ****     flaga_odczytywanie_smsa = FALSE;
 953:main_sim900.h ****     break;
 954:main_sim900.h ****   }
 955:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_1:
 956:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_2:
 957:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_3:
 958:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_4:
 959:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_5:
 960:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_6:
 961:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_7:
 962:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_8:
 963:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_9:
 964:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_10:
 965:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_11:
 966:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_12:
 967:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_13:
 968:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_14:
 969:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_15:
 970:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_16:
 971:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_17:
 972:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_18:
 973:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_19:
 974:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_20: {
 975:main_sim900.h ****     POWTORZ_JESLI(flaga_odczytywanie_smsa || flaga_trwa_rozmowa_wychodzaca ||
 976:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 977:main_sim900.h ****                   czekanie_na_odebranie_zachety)
 978:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 979:main_sim900.h ****     static const char instrukcja_usun_smsa[] PROGMEM = "+cmgd=";
 980:main_sim900.h ****     memcpy_R(wysylane_dane_RAM_SIM900, instrukcja_usun_smsa);
 981:main_sim900.h ****     const uint nr_smsa = wykonywana_komenda - KOMENDA_KOLEJKI_USUN_SMSA_1 + 1;
 982:main_sim900.h ****     utoa(nr_smsa, wysylane_dane_RAM_SIM900 + strlen_R(instrukcja_usun_smsa),
 983:main_sim900.h ****          10);
 984:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 985:main_sim900.h ****     POMOC_DODAJ2('#', 'Y');
 986:main_sim900.h ****     break;
 987:main_sim900.h ****   }
 988:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_PRZYCHODZACA_ROZMOWE: {
 989:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 990:main_sim900.h ****     zapal_diode_led(10);
 991:main_sim900.h **** 
 992:main_sim900.h ****     uchar status_ok =
 993:main_sim900.h ****         sprawdz_przychodzaca_rozmowe(); // Returns TRUE if number authorized
 994:main_sim900.h **** 
 995:main_sim900.h ****     if (status_ok) {
 996:main_sim900.h ****       if (tryb_clip) {
 997:main_sim900.h ****         // Tryb CLIP: wlacz wyjscie i ODRZUC polaczenie
 998:main_sim900.h ****         if (polozenie_polecenia_SIM900(PSTR("+CMTI:")) == NULL) {
 999:main_sim900.h ****           ustaw_wyjscie_clip();
1000:main_sim900.h ****         }
1001:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
1002:main_sim900.h ****       } else {
1003:main_sim900.h ****         // Tryb DTMF: ODBIERZ polaczenie
1004:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_ODBIERZ_ROZMOWE);
1005:main_sim900.h ****       }
1006:main_sim900.h ****     } else {
1007:main_sim900.h ****       // Status NIE OK - odrzuc
1008:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
1009:main_sim900.h ****     }
1010:main_sim900.h ****     blokada_clip = TRUE;
1011:main_sim900.h ****     break;
1012:main_sim900.h ****   }
1013:main_sim900.h ****   case KOMENDA_KOLEJKI_ODRZUC_ROZMOWE: {
1014:main_sim900.h ****     POWTORZ_JESLI(
1015:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
1016:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
1017:main_sim900.h ****         czekanie_na_odebranie_zachety || wykonywanie_rozmowy_telefonicznej ||
1018:main_sim900.h ****         !CZY_MOZNA_WYSYLAC_DANE_SIM900() || !czy_jest_bezczynny_SIM900());
1019:main_sim900.h ****     wysylane_polecenie_SIM900 = wykonywana_komenda;
1020:main_sim900.h ****     static const char instrukcja_odrzuc_rozmowe[] PROGMEM = "h";
1021:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_odrzuc_rozmowe);
1022:main_sim900.h ****     break;
1023:main_sim900.h ****   }
1024:main_sim900.h ****   case KOMENDA_KOLEJKI_ODBIERZ_ROZMOWE: {
1025:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1026:main_sim900.h ****     static const char instrukcja_odbierz_rozmowe[] PROGMEM = "a";
1027:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_odbierz_rozmowe);
1028:main_sim900.h ****     POMOC_DODAJ2('#', 'p');
1029:main_sim900.h ****     break;
1030:main_sim900.h ****   }
1031:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_TON_DTMF: {
1032:main_sim900.h ****     // Czekaj na koncowke inicjalizacji polaczenia/opoznienia?
1033:main_sim900.h ****     POWTORZ_JESLI(opoznienie_SIM900_100MS);
1034:main_sim900.h ****     if (!CZY_MOZNA_WYSYLAC_DANE_SIM900() || !czy_jest_bezczynny_SIM900() ||
1035:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
1036:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
1037:main_sim900.h ****       break;
1038:main_sim900.h ****     }
1039:main_sim900.h ****     wysylane_polecenie_SIM900 = wykonywana_komenda;
1040:main_sim900.h ****     static const char instrukcja_vts[] PROGMEM = "+vts=1";
1041:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_vts);
1042:main_sim900.h ****     POMOC_DODAJ2('#', 'V');
1043:main_sim900.h ****     break;
1044:main_sim900.h ****   }
1045:main_sim900.h ****   case KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE: {
1046:main_sim900.h ****     POWTORZ_JESLI(!modul_zalogowany_w_sieci || opoznienie_SIM900_100MS);
1047:main_sim900.h ****     if (wykonywanie_rozmowy_telefonicznej)
1048:main_sim900.h ****       break;
1049:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1050:main_sim900.h ****     zapal_diode_led(20);
1051:main_sim900.h ****     wysylane_dane_RAM_SIM900[0] = 'd';
1052:main_sim900.h ****     // static const char doladowanie[] PROGMEM = "*100*59484869838559#";
1053:main_sim900.h ****     // strcpy_P(numer_telefonu_do_ktorego_dzwonic, doladowanie);
1054:main_sim900.h ****     strcpy(wysylane_dane_RAM_SIM900 + 1, numer_telefonu_do_ktorego_dzwonic);
1055:main_sim900.h ****     uchar l = strlen(numer_telefonu_do_ktorego_dzwonic) + 1;
1056:main_sim900.h ****     wysylane_dane_RAM_SIM900[l] = ';';
1057:main_sim900.h ****     wysylane_dane_RAM_SIM900[l + 1] = '\0';
1058:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
1059:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 300;
1060:main_sim900.h ****     POMOC_DODAJ2('#', 'h');
1061:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
1062:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
1063:main_sim900.h ****       POMOC_DODAJ(numer_telefonu_do_ktorego_dzwonic[i]);
1064:main_sim900.h **** #endif
1065:main_sim900.h ****     break;
1066:main_sim900.h ****   }
1067:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_POZIOM_SIECI: {
1068:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1069:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1070:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1071:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1072:main_sim900.h ****       if (poziom_sieci_gsm == POZIOM_SIECI_BLAD ||
1073:main_sim900.h ****           poziom_sieci_gsm == 0) // poziom sieci bez zmian
1074:main_sim900.h ****         poziom_sieci_gsm = 16;
1075:main_sim900.h ****       break;
1076:main_sim900.h ****     }
1077:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1078:main_sim900.h ****     static const char instrukcja_poziom_sieci[] PROGMEM = "+csq";
1079:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_poziom_sieci);
1080:main_sim900.h ****     break;
1081:main_sim900.h ****   }
1082:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_ZAREJESTROWANIE: {
1083:main_sim900.h ****     // Usunięto warunek !modul_zalogowany_w_sieci - musimy sprawdzać ZAWSZE!
1084:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1085:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1086:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1087:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1088:main_sim900.h ****       break;
1089:main_sim900.h ****     }
1090:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1091:main_sim900.h ****     static const char instrukcja_creg[] PROGMEM = "+creg?";
1092:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_creg);
1093:main_sim900.h ****     break;
1094:main_sim900.h ****   }
1095:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_STAN_KARTY_SIM: {
1096:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1097:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1098:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1099:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1100:main_sim900.h ****       licznik_blad_stanu_karty_SIM = 0;
1101:main_sim900.h ****       break;
1102:main_sim900.h ****     }
1103:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1104:main_sim900.h ****     static const char instrukcja_odczyt_ksiazki[] PROGMEM = "+cpbr=26";
1105:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_odczyt_ksiazki);
1106:main_sim900.h ****     break;
1107:main_sim900.h ****   }
1108:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_ZALOGOWANIE_U_OPERATORA: {
1109:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1110:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1111:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1112:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1113:main_sim900.h ****       licznik_blad_zalogowania_u_operatora = 0;
1114:main_sim900.h ****       break;
1115:main_sim900.h ****     }
1116:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1117:main_sim900.h ****     static const char instrukcja_sprawdz_operatora[] PROGMEM = "+cops?";
1118:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_sprawdz_operatora);
1119:main_sim900.h ****     break;
1120:main_sim900.h ****   }
1121:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE: {
1122:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1123:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1124:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1125:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK)
1126:main_sim900.h ****       break;
1127:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1128:main_sim900.h ****     static const char instrukcja_cclk[] PROGMEM = "+cclk?";
1129:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_cclk);
1130:main_sim900.h ****     break;
1131:main_sim900.h ****   }
1132:main_sim900.h ****   case KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS: {
1133:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1134:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM = "+cdscb";
1135:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_ustawienie_pamieci);
1136:main_sim900.h ****     break;
1137:main_sim900.h ****   }
1138:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW: {
1139:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1140:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM =
1141:main_sim900.h ****         "+cpms=\"SM\",\"SM\",\"SM\"";
1142:main_sim900.h ****     nastepne_wysylane_polecenie_SIM900 =
1143:main_sim900.h ****         KOMENDA_KOLEJKI_WSTAWIENIE_MORING_GDY_DZWONI;
1144:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_ustawienie_pamieci);
1145:main_sim900.h ****     break;
1146:main_sim900.h ****   }
1147:main_sim900.h ****   case KOMENDA_KOLEJKI_PODLACZONY_MODUL_GSM: {
1148:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT);
1149:main_sim900.h ****     opoznienie_zatrzymaj_odpytywanie_urzadzenia = 20;
1150:main_sim900.h ****     ustaw_odbior_SIM900();
1151:main_sim900.h ****     break;
1152:main_sim900.h ****   }
1153:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: { // po wczeniu zasilania wysya 2
1154:main_sim900.h ****                                               // razy, bo za pierwszym razem nie
1155:main_sim900.h ****                                               // dziaa kontrola RTS / CTS w
1156:main_sim900.h ****                                               // SIM800
1157:main_sim900.h ****     if (max_oczekiwanie_na_odpowiedz_at)
1158:main_sim900.h ****       break;
1159:main_sim900.h ****     if (opoznienie_zatrzymaj_odpytywanie_urzadzenia) {
1160:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
1161:main_sim900.h ****       break;
1162:main_sim900.h ****     }
1163:main_sim900.h ****     if (CZY_WYSYLANIE_DANYCH_SIM900()) {
1164:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
1165:main_sim900.h ****       break;
1166:main_sim900.h ****     }
1167:main_sim900.h ****     ustaw_odbior_SIM900();
1168:main_sim900.h ****     wysylane_polecenie_SIM900 = wykonywana_komenda;
1169:main_sim900.h ****     max_oczekiwanie_na_odpowiedz_at = 20;
1170:main_sim900.h ****     static const char instrukcja_at[] PROGMEM = "+ifc=2,2";
1171:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_at);
1172:main_sim900.h ****     break;
1173:main_sim900.h ****   }
1174:main_sim900.h ****   case KOMENDA_KOLEJKI_ODEBRANO_POLECENIE_ROZPOCZYNAJACE: {
1175:main_sim900.h ****     podlaczony_modul_gsm_SIM900 = TRUE;
1176:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_PIN);
1177:main_sim900.h ****     opoznienie_SIM900_100MS = 40;
1178:main_sim900.h ****     break;
1179:main_sim900.h ****   }
1180:main_sim900.h ****   case KOMENDA_KOLEJKI_PODAJ_PIN: {
1181:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1182:main_sim900.h ****     static const char instrukcja_podaj_pin[] PROGMEM = "+cpin=\"1976\"";
1183:main_sim900.h ****     strcpy_P(wysylane_dane_RAM_SIM900, instrukcja_podaj_pin);
1184:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
1185:main_sim900.h ****     break;
1186:main_sim900.h ****   }
1187:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY: {
1188:main_sim900.h ****     static uchar drugi_raz = FALSE;
1189:main_sim900.h ****     if (drugi_raz) {
1190:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW);
1191:main_sim900.h ****       break;
1192:main_sim900.h ****     }
1193:main_sim900.h ****     drugi_raz = TRUE;
1194:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1195:main_sim900.h ****     static const char instrukcja_usun_wszystkie_smsy[] PROGMEM = "+cmgda=6";
1196:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_usun_wszystkie_smsy);
1197:main_sim900.h ****     break;
1198:main_sim900.h ****   }
1199:main_sim900.h ****   case KOMENDA_KOLEJKI_KOMENDA_SIM900: {
1200:main_sim900.h ****     obsluga_komendy_SIM900();
1201:main_sim900.h ****     if (komenda_SIM900 != KOMENDA_SIM900_WYSLANE_POLECENIE)
1202:main_sim900.h ****       max_oczekiwanie_na_odpowiedz = 20;
1203:main_sim900.h ****     resetuj_komende_SIM900();
1204:main_sim900.h ****     break;
1205:main_sim900.h ****   }
1206:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_WZMOCNIENIE_MIKROFONU: {
1207:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1208:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1209:main_sim900.h ****     static const char instrukcja[] PROGMEM =
1210:main_sim900.h ****         "+cmic=0,15"; // ustawienie od 0 ... 15
1211:main_sim900.h ****     strcpy_P(wysylane_dane_RAM_SIM900, instrukcja);
1212:main_sim900.h ****     nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_ROZPOCZNIJ_PRACE;
1213:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
1214:main_sim900.h ****     break;
1215:main_sim900.h ****   }
1216:main_sim900.h ****   case KOMENDA_KOLEJKI_ROZPOCZNIJ_PRACE: {
1217:main_sim900.h ****     POMOC_DODAJ2('*', 'h');
1218:main_sim900.h ****     if (podlaczona_karta_SIM_SIM900) {
1219:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS);
1220:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_MODUL_ZALOGOWANY);
1221:main_sim900.h ****     }
1222:main_sim900.h ****     break;
1223:main_sim900.h ****   }
1224:main_sim900.h ****   case KOMENDA_KOLEJKI_MODUL_ZALOGOWANY: {
1225:main_sim900.h ****     // Nie ustawiamy modul_zalogowany_w_sieci tutaj!
1226:main_sim900.h ****     // Flaga jest ustawiana tylko przez +CREG gdy faktycznie zalogowany
1227:main_sim900.h ****     break;
1228:main_sim900.h ****   }
1229:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_ZEGAR_SIM900: {
1230:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1231:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1232:main_sim900.h ****     strcpy(wysylane_dane_RAM_SIM900, bufor_ustaw_czas);
1233:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
1234:main_sim900.h ****     break;
1235:main_sim900.h ****   }
1236:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_PIN:
1237:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW:
1238:main_sim900.h ****   case KOMENDA_KOLEJKI_WSTAWIENIE_MORING_GDY_DZWONI:
1239:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_WYSYLANIE_INFO_O_DZWONIACYM:
1240:main_sim900.h ****   case KOMENDA_KOLEJKI_WLACZ_DETEKCJE_DTMF:
1241:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_CICHY_TRYB:
1242:main_sim900.h ****   case KOMENDA_KOLEJKI_WYCISZ_DZWONKI:
1243:main_sim900.h ****   case KOMENDA_KOLEJKI_ODBIERAJ_SMS_FLASH:
1244:main_sim900.h ****   case KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ:
1245:main_sim900.h ****   case KOMENDA_KOLEJKI_WLACZ_CZAS_Z_SIECI: {
1246:main_sim900.h **** 
1247:main_sim900.h **** #define MAX_ROZMIAR_POLECENIA_GSM 14
1248:main_sim900.h **** 
1249:main_sim900.h ****     static const char instrukcje[10][MAX_ROZMIAR_POLECENIA_GSM] PROGMEM = {
1250:main_sim900.h ****         "+cpin?",         "+cnmi=2,1,2,1", "+moring=1", "+clip=1",
1251:main_sim900.h ****         "+ddet=1,10,1",   "+calm=1",       "+crsl=1",   "+cusd=1",
1252:main_sim900.h ****         "+cpbw=26,\"1\"", "+clts=0",
1253:main_sim900.h ****     };
1254:main_sim900.h ****     static const komenda_typ nastepna_komenda[10] PROGMEM = {
1255:main_sim900.h ****         KOMENDA_KOLEJKI_BRAK_KOMENDY,
1256:main_sim900.h ****         KOMENDA_KOLEJKI_BRAK_KOMENDY,
1257:main_sim900.h ****         KOMENDA_KOLEJKI_USTAW_WYSYLANIE_INFO_O_DZWONIACYM,
1258:main_sim900.h ****         KOMENDA_KOLEJKI_WLACZ_DETEKCJE_DTMF,
1259:main_sim900.h ****         KOMENDA_KOLEJKI_USTAW_CICHY_TRYB,
1260:main_sim900.h ****         KOMENDA_KOLEJKI_WYCISZ_DZWONKI,
1261:main_sim900.h ****         KOMENDA_KOLEJKI_ODBIERAJ_SMS_FLASH,
1262:main_sim900.h ****         KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ,
1263:main_sim900.h ****         KOMENDA_KOLEJKI_WLACZ_CZAS_Z_SIECI,
1264:main_sim900.h ****         KOMENDA_KOLEJKI_USTAW_WZMOCNIENIE_MIKROFONU,
1265:main_sim900.h ****     };
1266:main_sim900.h ****     // RE-DOING THIS CHUNK TO BE SAFE AND CORRECT
1267:main_sim900.h **** 
1268:main_sim900.h ****     const uchar nr = wykonywana_komenda - KOMENDA_KOLEJKI_SPRAWDZ_PIN;
1269:main_sim900.h ****     if (!wyslanie_polecenia_ROM(
1270:main_sim900.h ****             czy_mozna_wysylac_dane_do_SIM900, wykonywana_komenda,
1271:main_sim900.h ****             pgm_read_word(&nastepna_komenda[nr]), &instrukcje[nr][0]))
1272:main_sim900.h ****       break;
1273:main_sim900.h ****     POMOC_DODAJ2('*', 's');
1274:main_sim900.h ****     POMOC_DODAJ_HEX(nr);
1275:main_sim900.h ****     break;
1276:main_sim900.h ****   }
1277:main_sim900.h ****   default:
1278:main_sim900.h ****     return FALSE;
 5170               		.loc 2 1278 0
 5171 19e2 80E0      		ldi r24,0
 5172               	.LVL444:
 5173               	.L487:
 5174               	/* epilogue start */
1279:main_sim900.h ****   }
1280:main_sim900.h ****   return TRUE;
1281:main_sim900.h **** }
 5175               		.loc 2 1281 0
 5176 19e4 0F90      		pop __tmp_reg__
 5177 19e6 0F90      		pop __tmp_reg__
 5178 19e8 0F90      		pop __tmp_reg__
 5179 19ea DF91      		pop r29
 5180 19ec CF91      		pop r28
 5181 19ee 1F91      		pop r17
 5182 19f0 0F91      		pop r16
 5183               	.LVL445:
 5184 19f2 FF90      		pop r15
 5185 19f4 EF90      		pop r14
 5186               	.LVL446:
 5187 19f6 0895      		ret
 5188               	.L589:
 842:main_sim900.h **** 
 5189               		.loc 2 842 0
 5190 19f8 81E0      		ldi r24,lo8(1)
 5191               	.L592:
 845:main_sim900.h ****       czy_jest_bezczynny_SIM900();
 5192               		.loc 2 845 0
 5193 19fa 00E0      		ldi r16,0
 5194 19fc 00C0      		rjmp .L490
 5195               	.LVL447:
 5196               	.L498:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5197               		.loc 2 849 0
 5198 19fe 1F38      		cpi r17,lo8(-113)
 5199 1a00 01F4      		brne .+2
 5200 1a02 00C0      		rjmp .L502
 5201 1a04 00F4      		brsh .+2
 5202 1a06 00C0      		rjmp .L503
 5203 1a08 1039      		cpi r17,lo8(-112)
 5204 1a0a 01F4      		brne .+2
 5205 1a0c 00C0      		rjmp .L504
 5206 1a0e 1139      		cpi r17,lo8(-111)
 5207 1a10 01F4      		brne .L492
 5208               	.L609:
1280:main_sim900.h **** }
 5209               		.loc 2 1280 0
 5210 1a12 8FEF      		ldi r24,lo8(-1)
 5211 1a14 00C0      		rjmp .L487
 5212               	.L496:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5213               		.loc 2 849 0
 5214 1a16 1739      		cpi r17,lo8(-105)
 5215 1a18 01F4      		brne .+2
 5216 1a1a 00C0      		rjmp .L506
 5217 1a1c 00F4      		brsh .L507
 5218 1a1e 1539      		cpi r17,lo8(-107)
 5219 1a20 01F4      		brne .+2
 5220 1a22 00C0      		rjmp .L508
 5221 1a24 00F0      		brlo .+2
 5222 1a26 00C0      		rjmp .L509
 5223 1a28 1439      		cpi r17,lo8(-108)
 5224 1a2a 01F4      		brne .L492
 5225               	.LBB572:
1207:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5226               		.loc 2 1207 0
 5227 1a2c 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5228 1a30 8111      		cpse r24,__zero_reg__
 5229 1a32 00C0      		rjmp .L580
1207:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5230               		.loc 2 1207 0 is_stmt 0 discriminator 2
 5231 1a34 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5232 1a38 8111      		cpse r24,__zero_reg__
 5233 1a3a 00C0      		rjmp .L580
1207:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5234               		.loc 2 1207 0 discriminator 4
 5235 1a3c 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5236 1a40 8111      		cpse r24,__zero_reg__
 5237 1a42 00C0      		rjmp .L580
1207:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5238               		.loc 2 1207 0 discriminator 6
 5239 1a44 F99B      		sbis 0x1f,1
 5240 1a46 00C0      		rjmp .L581
 5241               	.L580:
1207:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5242               		.loc 2 1207 0 discriminator 7
 5243 1a48 84E9      		ldi r24,lo8(-108)
 5244 1a4a 00C0      		rjmp .L650
 5245               	.L507:
 5246               	.LBE572:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5247               		.loc 2 849 0 is_stmt 1
 5248 1a4c 1939      		cpi r17,lo8(-103)
 5249 1a4e 01F4      		brne .+2
 5250 1a50 00C0      		rjmp .L511
 5251 1a52 00F4      		brsh .+2
 5252 1a54 00C0      		rjmp .L512
 5253 1a56 1A39      		cpi r17,lo8(-102)
 5254 1a58 01F4      		brne .+2
 5255 1a5a 00C0      		rjmp .L513
 5256 1a5c 1B39      		cpi r17,lo8(-101)
 5257 1a5e 01F4      		brne .L492
 5258               	.LBB573:
1068:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5259               		.loc 2 1068 0
 5260 1a60 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 5261 1a64 9111      		cpse r25,__zero_reg__
 5262 1a66 00C0      		rjmp .L560
1068:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5263               		.loc 2 1068 0 is_stmt 0 discriminator 1
 5264 1a68 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 5265 1a6c 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5266 1a70 232B      		or r18,r19
 5267 1a72 01F4      		brne .L560
1068:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5268               		.loc 2 1068 0 discriminator 2
 5269 1a74 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 5270 1a78 9111      		cpse r25,__zero_reg__
 5271 1a7a 00C0      		rjmp .L560
1069:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 5272               		.loc 2 1069 0 is_stmt 1
 5273 1a7c 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 5274 1a80 9111      		cpse r25,__zero_reg__
 5275 1a82 00C0      		rjmp .L560
1070:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 5276               		.loc 2 1070 0
 5277 1a84 8111      		cpse r24,__zero_reg__
 5278 1a86 00C0      		rjmp .L560
1070:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 5279               		.loc 2 1070 0 is_stmt 0 discriminator 1
 5280 1a88 8091 0000 		lds r24,wysylanie_smsa_clipa
 5281 1a8c 8823      		tst r24
 5282 1a8e 01F4      		brne .+2
 5283 1a90 00C0      		rjmp .L561
 5284               	.L560:
1072:main_sim900.h ****           poziom_sieci_gsm == 0) // poziom sieci bez zmian
 5285               		.loc 2 1072 0 is_stmt 1
 5286 1a92 8091 0000 		lds r24,poziom_sieci_gsm
 5287 1a96 8336      		cpi r24,lo8(99)
 5288 1a98 01F0      		breq .L562
1072:main_sim900.h ****           poziom_sieci_gsm == 0) // poziom sieci bez zmian
 5289               		.loc 2 1072 0 is_stmt 0 discriminator 1
 5290 1a9a 8111      		cpse r24,__zero_reg__
 5291 1a9c 00C0      		rjmp .L609
 5292               	.L562:
1074:main_sim900.h ****       break;
 5293               		.loc 2 1074 0 is_stmt 1
 5294 1a9e 80E1      		ldi r24,lo8(16)
 5295 1aa0 8093 0000 		sts poziom_sieci_gsm,r24
 5296 1aa4 00C0      		rjmp .L609
 5297               	.L494:
 5298               	.LBE573:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5299               		.loc 2 849 0
 5300 1aa6 123D      		cpi r17,lo8(-46)
 5301 1aa8 00F0      		brlo .+2
 5302 1aaa 00C0      		rjmp .L515
 5303 1aac 1E3B      		cpi r17,lo8(-66)
 5304 1aae 00F0      		brlo .+2
 5305 1ab0 00C0      		rjmp .L516
 5306 1ab2 153A      		cpi r17,lo8(-91)
 5307 1ab4 01F4      		brne .+2
 5308 1ab6 00C0      		rjmp .L517
 5309 1ab8 00F4      		brsh .L518
 5310 1aba 1E39      		cpi r17,lo8(-98)
 5311 1abc 01F4      		brne .+2
 5312 1abe 00C0      		rjmp .L519
 5313               	.L520:
 5314               	.LBB574:
1268:main_sim900.h ****     if (!wyslanie_polecenia_ROM(
 5315               		.loc 2 1268 0
 5316 1ac0 21E6      		ldi r18,lo8(97)
 5317 1ac2 210F      		add r18,r17
 5318               	.LVL448:
 5319               	.LBB575:
1271:main_sim900.h ****       break;
 5320               		.loc 2 1271 0
 5321 1ac4 E22F      		mov r30,r18
 5322 1ac6 F0E0      		ldi r31,0
 5323 1ac8 E050      		subi r30,lo8(-(nastepna_komenda.3468))
 5324 1aca F040      		sbci r31,hi8(-(nastepna_komenda.3468))
 5325               	.LVL449:
 5326               	/* #APP */
 5327               	 ;  1271 "main_sim900.h" 1
 5328 1acc 4591      		lpm r20, Z+
 5329 1ace 5491      		lpm r21, Z
 5330               		
 5331               	 ;  0 "" 2
 5332               	.LVL450:
 5333               	/* #NOAPP */
 5334               	.LBE575:
1269:main_sim900.h ****             czy_mozna_wysylac_dane_do_SIM900, wykonywana_komenda,
 5335               		.loc 2 1269 0
 5336 1ad0 FEE0      		ldi r31,lo8(14)
 5337 1ad2 2F9F      		mul r18,r31
 5338 1ad4 9001      		movw r18,r0
 5339 1ad6 1124      		clr __zero_reg__
 5340               	.LVL451:
 5341 1ad8 2050      		subi r18,lo8(-(instrukcje.3467))
 5342 1ada 3040      		sbci r19,hi8(-(instrukcje.3467))
 5343 1adc 612F      		mov r22,r17
 5344 1ade 802F      		mov r24,r16
 5345 1ae0 0E94 0000 		call wyslanie_polecenia_ROM
 5346               	.LVL452:
 5347 1ae4 00C0      		rjmp .L609
 5348               	.LVL453:
 5349               	.L518:
 5350               	.LBE574:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5351               		.loc 2 849 0
 5352 1ae6 1A3A      		cpi r17,lo8(-86)
 5353 1ae8 00F0      		brlo .L520
 5354               	.LBB576:
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5355               		.loc 2 887 0
 5356 1aea 9111      		cpse r25,__zero_reg__
 5357 1aec 00C0      		rjmp .L656
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5358               		.loc 2 887 0 is_stmt 0 discriminator 2
 5359 1aee 8091 0000 		lds r24,modul_zalogowany_w_sieci
 5360 1af2 8823      		tst r24
 5361 1af4 01F4      		brne .+2
 5362 1af6 00C0      		rjmp .L656
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5363               		.loc 2 887 0 discriminator 4
 5364 1af8 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5365 1afc 8111      		cpse r24,__zero_reg__
 5366 1afe 00C0      		rjmp .L656
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5367               		.loc 2 887 0 discriminator 6
 5368 1b00 8091 0000 		lds r24,licznik_bezpieczenstwa_wykonywana_rozmowa
 5369 1b04 9091 0000 		lds r25,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5370 1b08 892B      		or r24,r25
 5371 1b0a 01F0      		breq .+2
 5372 1b0c 00C0      		rjmp .L656
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5373               		.loc 2 887 0 discriminator 8
 5374 1b0e 8091 0000 		lds r24,opoznienie_SIM900_100MS
 5375 1b12 8111      		cpse r24,__zero_reg__
 5376 1b14 00C0      		rjmp .L656
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5377               		.loc 2 887 0 discriminator 10
 5378 1b16 8091 0000 		lds r24,wysylanie_smsa_clipa
 5379 1b1a 8111      		cpse r24,__zero_reg__
 5380 1b1c 00C0      		rjmp .L656
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5381               		.loc 2 887 0 discriminator 12
 5382 1b1e 8091 0000 		lds r24,flaga_wysylanie_smsa
 5383 1b22 8111      		cpse r24,__zero_reg__
 5384 1b24 00C0      		rjmp .L656
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5385               		.loc 2 887 0 discriminator 14
 5386 1b26 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 5387 1b2a 8239      		cpi r24,lo8(-110)
 5388 1b2c 01F4      		brne .+2
 5389 1b2e 00C0      		rjmp .L656
 893:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 5390               		.loc 2 893 0 is_stmt 1
 5391 1b30 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5392 1b34 8111      		cpse r24,__zero_reg__
 5393 1b36 00C0      		rjmp .L656
 893:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 5394               		.loc 2 893 0 is_stmt 0 discriminator 2
 5395 1b38 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5396 1b3c 8111      		cpse r24,__zero_reg__
 5397 1b3e 00C0      		rjmp .L656
 893:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 5398               		.loc 2 893 0 discriminator 4
 5399 1b40 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5400 1b44 8111      		cpse r24,__zero_reg__
 5401 1b46 00C0      		rjmp .L656
 893:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 5402               		.loc 2 893 0 discriminator 6
 5403 1b48 F999      		sbic 0x1f,1
 5404 1b4a 00C0      		rjmp .L656
 894:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW,
 5405               		.loc 2 894 0 is_stmt 1
 5406 1b4c 61E0      		ldi r22,lo8(1)
 5407 1b4e 81E0      		ldi r24,lo8(1)
 5408 1b50 0E94 0000 		call czy_sa_komendy_z_przedzialu
 5409               	.LVL454:
 5410 1b54 8111      		cpse r24,__zero_reg__
 5411 1b56 00C0      		rjmp .L656
 894:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW,
 5412               		.loc 2 894 0 is_stmt 0 discriminator 2
 5413 1b58 65ED      		ldi r22,lo8(-43)
 5414 1b5a 83ED      		ldi r24,lo8(-45)
 5415 1b5c 0E94 0000 		call czy_sa_komendy_z_przedzialu
 5416               	.LVL455:
 5417 1b60 8111      		cpse r24,__zero_reg__
 5418 1b62 00C0      		rjmp .L656
 894:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW,
 5419               		.loc 2 894 0 discriminator 4
 5420 1b64 68E9      		ldi r22,lo8(-104)
 5421 1b66 86E9      		ldi r24,lo8(-106)
 5422 1b68 0E94 0000 		call czy_sa_komendy_z_przedzialu
 5423               	.LVL456:
 5424 1b6c 8111      		cpse r24,__zero_reg__
 5425 1b6e 00C0      		rjmp .L656
 902:main_sim900.h ****     flaga_odczytywanie_smsa = TRUE;
 5426               		.loc 2 902 0 is_stmt 1
 5427 1b70 0023      		tst r16
 5428 1b72 01F4      		brne .+2
 5429 1b74 00C0      		rjmp .L656
 902:main_sim900.h ****     flaga_odczytywanie_smsa = TRUE;
 5430               		.loc 2 902 0 is_stmt 0 discriminator 2
 5431 1b76 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5432 1b7a 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5433 1b7e 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
 903:main_sim900.h ****     static const char instrukcja_odczytaj_smsa[] PROGMEM = "+cmgr=";
 5434               		.loc 2 903 0 is_stmt 1 discriminator 2
 5435 1b82 8FEF      		ldi r24,lo8(-1)
 5436 1b84 8093 0000 		sts flaga_odczytywanie_smsa,r24
 905:main_sim900.h ****     const uint nr_smsa =
 5437               		.loc 2 905 0 discriminator 2
 5438 1b88 46E0      		ldi r20,lo8(6)
 5439 1b8a 50E0      		ldi r21,0
 5440 1b8c 60E0      		ldi r22,lo8(instrukcja_odczytaj_smsa.3381)
 5441 1b8e 70E0      		ldi r23,hi8(instrukcja_odczytaj_smsa.3381)
 5442 1b90 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 5443 1b92 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 5444 1b94 0E94 0000 		call memcpy_P
 5445               	.LVL457:
 5446               	.LBB577:
 5447               	.LBB578:
 5448               		.loc 6 527 0 discriminator 2
 5449 1b98 4AE0      		ldi r20,lo8(10)
 5450 1b9a 60E0      		ldi r22,lo8(wysylany_blok_SIM900+8)
 5451 1b9c 70E0      		ldi r23,hi8(wysylany_blok_SIM900+8)
 5452               	.LVL458:
 5453 1b9e C701      		movw r24,r14
 5454 1ba0 895A      		subi r24,-87
 5455 1ba2 9109      		sbc r25,__zero_reg__
 5456               	.LVL459:
 5457               	.L657:
 5458               	.LBE578:
 5459               	.LBE577:
 5460               	.LBE576:
 5461               	.LBB579:
 5462               	.LBB580:
 5463               	.LBB581:
 5464 1ba4 0E94 0000 		call __utoa_ncheck
 5465               	.LVL460:
 5466               	.L651:
 5467               	.LBE581:
 5468               	.LBE580:
 5469               	.LBE579:
1233:main_sim900.h ****     break;
 5470               		.loc 2 1233 0 discriminator 2
 5471 1ba8 0E94 0000 		call wyslij_polecenie_RAM_SIM900
 5472               	.LVL461:
 5473 1bac 00C0      		rjmp .L609
 5474               	.L515:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5475               		.loc 2 849 0
 5476 1bae 153D      		cpi r17,lo8(-43)
 5477 1bb0 01F4      		brne .+2
 5478 1bb2 00C0      		rjmp .L522
 5479 1bb4 00F4      		brsh .L523
 5480 1bb6 123D      		cpi r17,lo8(-46)
 5481 1bb8 01F4      		brne .L648
 5482               	.LBB584:
 915:main_sim900.h ****         bufor_pdu, numer_telefonu_odebranego_smsa,
 5483               		.loc 2 915 0
 5484 1bba 40E0      		ldi r20,lo8(nie_wysylaj_echa_z_powodu_nietypowego_smsa)
 5485 1bbc 50E0      		ldi r21,hi8(nie_wysylaj_echa_z_powodu_nietypowego_smsa)
 5486 1bbe 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 5487 1bc0 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 5488 1bc2 80E0      		ldi r24,lo8(bufor_pdu)
 5489 1bc4 90E0      		ldi r25,hi8(bufor_pdu)
 5490 1bc6 0E94 0000 		call pobierz_numer_telefonu_nadawcy_z_PDU
 5491               	.LVL462:
 918:main_sim900.h ****     {
 5492               		.loc 2 918 0
 5493 1bca 0097      		sbiw r24,0
 5494 1bcc 01F0      		breq .+2
 5495 1bce 00C0      		rjmp .L542
 5496               	.LVL463:
 5497               	.L652:
 5498               	.LBE584:
 952:main_sim900.h ****     break;
 5499               		.loc 2 952 0
 5500 1bd0 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 5501 1bd4 00C0      		rjmp .L609
 5502               	.L523:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5503               		.loc 2 849 0
 5504 1bd6 183D      		cpi r17,lo8(-40)
 5505 1bd8 01F4      		brne .+2
 5506 1bda 00C0      		rjmp .L526
 5507 1bdc 1E3F      		cpi r17,lo8(-2)
 5508 1bde 01F4      		brne .+2
 5509 1be0 00C0      		rjmp .L527
 5510 1be2 163D      		cpi r17,lo8(-42)
 5511 1be4 01F0      		breq .+2
 5512 1be6 00C0      		rjmp .L492
 5513               	.LBB587:
1046:main_sim900.h ****     if (wykonywanie_rozmowy_telefonicznej)
 5514               		.loc 2 1046 0
 5515 1be8 8091 0000 		lds r24,modul_zalogowany_w_sieci
 5516 1bec 8823      		tst r24
 5517 1bee 01F0      		breq .L558
1046:main_sim900.h ****     if (wykonywanie_rozmowy_telefonicznej)
 5518               		.loc 2 1046 0 is_stmt 0 discriminator 2
 5519 1bf0 8091 0000 		lds r24,opoznienie_SIM900_100MS
 5520 1bf4 8823      		tst r24
 5521 1bf6 01F4      		brne .+2
 5522 1bf8 00C0      		rjmp .L559
 5523               	.L558:
1046:main_sim900.h ****     if (wykonywanie_rozmowy_telefonicznej)
 5524               		.loc 2 1046 0 discriminator 3
 5525 1bfa 86ED      		ldi r24,lo8(-42)
 5526 1bfc 00C0      		rjmp .L650
 5527               	.L648:
 5528               	.LBE587:
 852:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 5529               		.loc 2 852 0 is_stmt 1
 5530 1bfe 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5531 1c02 8111      		cpse r24,__zero_reg__
 5532 1c04 00C0      		rjmp .L656
 852:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 5533               		.loc 2 852 0 is_stmt 0 discriminator 2
 5534 1c06 8091 0000 		lds r24,licznik_bezpieczenstwa_wykonywana_rozmowa
 5535 1c0a 9091 0000 		lds r25,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5536 1c0e 892B      		or r24,r25
 5537 1c10 01F4      		brne .L656
 852:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 5538               		.loc 2 852 0 discriminator 4
 5539 1c12 8091 0000 		lds r24,opoznienie_SIM900_100MS
 5540 1c16 8823      		tst r24
 5541 1c18 01F0      		breq .L530
 5542               	.L656:
 5543               	.LBB588:
 978:main_sim900.h ****     static const char instrukcja_usun_smsa[] PROGMEM = "+cmgd=";
 5544               		.loc 2 978 0 is_stmt 1 discriminator 1
 5545 1c1a 812F      		mov r24,r17
 5546 1c1c 00C0      		rjmp .L650
 5547               	.L530:
 5548               	.LBE588:
 853:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5549               		.loc 2 853 0
 5550 1c1e 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5551 1c22 8111      		cpse r24,__zero_reg__
 5552 1c24 00C0      		rjmp .L656
 853:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5553               		.loc 2 853 0 is_stmt 0 discriminator 2
 5554 1c26 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5555 1c2a 8111      		cpse r24,__zero_reg__
 5556 1c2c 00C0      		rjmp .L656
 853:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5557               		.loc 2 853 0 discriminator 4
 5558 1c2e 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5559 1c32 8111      		cpse r24,__zero_reg__
 5560 1c34 00C0      		rjmp .L656
 853:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5561               		.loc 2 853 0 discriminator 6
 5562 1c36 F999      		sbic 0x1f,1
 5563 1c38 00C0      		rjmp .L656
 854:main_sim900.h ****     wyslij_sms(wykonywana_komenda == KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
 5564               		.loc 2 854 0 is_stmt 1
 5565 1c3a 0023      		tst r16
 5566 1c3c 01F0      		breq .L656
 854:main_sim900.h ****     wyslij_sms(wykonywana_komenda == KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
 5567               		.loc 2 854 0 is_stmt 0 discriminator 2
 5568 1c3e 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5569 1c42 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5570 1c46 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
 855:main_sim900.h ****     break;
 5571               		.loc 2 855 0 is_stmt 1 discriminator 2
 5572 1c4a 81E0      		ldi r24,lo8(1)
 5573 1c4c 143D      		cpi r17,lo8(-44)
 5574 1c4e 01F0      		breq .L534
 5575 1c50 80E0      		ldi r24,0
 5576               	.L534:
 5577 1c52 0E94 0000 		call wyslij_sms
 5578               	.LVL464:
 5579 1c56 00C0      		rjmp .L609
 5580               	.L522:
 5581               	.LBB589:
 859:main_sim900.h ****     konwertuj_pdu_na_blok_wysylany(wysylany_blok_SIM900, bufor_pdu,
 5582               		.loc 2 859 0
 5583 1c58 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
 860:main_sim900.h ****                                    dlugosc_pdu);
 5584               		.loc 2 860 0
 5585 1c5c 4091 0000 		lds r20,dlugosc_pdu
 5586 1c60 60E0      		ldi r22,lo8(bufor_pdu)
 5587 1c62 70E0      		ldi r23,hi8(bufor_pdu)
 5588 1c64 80E0      		ldi r24,lo8(wysylany_blok_SIM900)
 5589 1c66 90E0      		ldi r25,hi8(wysylany_blok_SIM900)
 5590 1c68 0E94 0000 		call konwertuj_pdu_na_blok_wysylany
 5591               	.LVL465:
 862:main_sim900.h ****     wysylany_blok_SIM900[liczba_znakow - 1] = ZNAK_CTRL_Z;
 5592               		.loc 2 862 0
 5593 1c6c 8091 0000 		lds r24,dlugosc_pdu
 5594 1c70 90E0      		ldi r25,0
 5595 1c72 880F      		lsl r24
 5596 1c74 991F      		rol r25
 5597 1c76 0196      		adiw r24,1
 5598               	.LVL466:
 863:main_sim900.h ****     wyslij_znaki_SIM900(liczba_znakow);
 5599               		.loc 2 863 0
 5600 1c78 FC01      		movw r30,r24
 5601 1c7a E050      		subi r30,lo8(-(wysylany_blok_SIM900-1))
 5602 1c7c F040      		sbci r31,hi8(-(wysylany_blok_SIM900-1))
 5603 1c7e 2AE1      		ldi r18,lo8(26)
 5604 1c80 2083      		st Z,r18
 864:main_sim900.h ****     break;
 5605               		.loc 2 864 0
 5606 1c82 0E94 0000 		call wyslij_znaki_SIM900
 5607               	.LVL467:
 5608 1c86 00C0      		rjmp .L609
 5609               	.LVL468:
 5610               	.L542:
 5611               	.LBE589:
 5612               	.LBB590:
 5613               	.LBB585:
 925:main_sim900.h ****     }
 5614               		.loc 2 925 0
 5615 1c88 9E01      		movw r18,r28
 5616 1c8a 2F5F      		subi r18,-1
 5617 1c8c 3F4F      		sbci r19,-1
 5618 1c8e AE01      		movw r20,r28
 5619 1c90 4E5F      		subi r20,-2
 5620 1c92 5F4F      		sbci r21,-1
 5621 1c94 BE01      		movw r22,r28
 5622 1c96 6D5F      		subi r22,-3
 5623 1c98 7F4F      		sbci r23,-1
 5624 1c9a 0E94 0000 		call pobierz_date_z_PDU
 5625               	.LVL469:
 5626               	.LBE585:
 5627               	.LBB586:
 929:main_sim900.h **** 
 5628               		.loc 2 929 0
 5629 1c9e 9E01      		movw r18,r28
 5630 1ca0 2F5F      		subi r18,-1
 5631 1ca2 3F4F      		sbci r19,-1
 5632 1ca4 AE01      		movw r20,r28
 5633 1ca6 4E5F      		subi r20,-2
 5634 1ca8 5F4F      		sbci r21,-1
 5635 1caa BE01      		movw r22,r28
 5636 1cac 6D5F      		subi r22,-3
 5637 1cae 7F4F      		sbci r23,-1
 5638 1cb0 0E94 0000 		call pobierz_czas_z_PDU
 5639               	.LVL470:
 933:main_sim900.h ****       sms_timestamp_minuta = minuta;
 5640               		.loc 2 933 0
 5641 1cb4 2B81      		ldd r18,Y+3
 5642 1cb6 2093 0000 		sts sms_timestamp_godzina,r18
 934:main_sim900.h ****       extern uchar sms_timestamp_sekunda;
 5643               		.loc 2 934 0
 5644 1cba 2A81      		ldd r18,Y+2
 5645 1cbc 2093 0000 		sts sms_timestamp_minuta,r18
 936:main_sim900.h ****     }
 5646               		.loc 2 936 0
 5647 1cc0 2981      		ldd r18,Y+1
 5648 1cc2 2093 0000 		sts sms_timestamp_sekunda,r18
 5649               	.LBE586:
 938:main_sim900.h ****     pdu_to_ascii(ptr, tekst_odebranego_smsa, MAX_LICZBA_ZNAKOW_SMS + 1);
 5650               		.loc 2 938 0
 5651 1cc6 9093 0000 		sts ptr_start_pdu_z_wiadomoscia+1,r25
 5652 1cca 8093 0000 		sts ptr_start_pdu_z_wiadomoscia,r24
 939:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 5653               		.loc 2 939 0
 5654 1cce 41EA      		ldi r20,lo8(-95)
 5655 1cd0 60E0      		ldi r22,lo8(wysylany_blok_SIM900+239)
 5656 1cd2 70E0      		ldi r23,hi8(wysylany_blok_SIM900+239)
 5657 1cd4 0E94 0000 		call pdu_to_ascii
 5658               	.LVL471:
 5659               	.L543:
 5660               	.LBE590:
 949:main_sim900.h ****     zapal_diode_led(10);
 5661               		.loc 2 949 0 discriminator 7
 5662 1cd8 88ED      		ldi r24,lo8(-40)
 5663               	.L650:
1230:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5664               		.loc 2 1230 0 discriminator 7
 5665 1cda 0E94 0000 		call dodaj_komende
 5666               	.LVL472:
 5667 1cde 00C0      		rjmp .L609
 5668               	.L526:
 949:main_sim900.h ****     zapal_diode_led(10);
 5669               		.loc 2 949 0
 5670 1ce0 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5671 1ce4 8111      		cpse r24,__zero_reg__
 5672 1ce6 00C0      		rjmp .L543
 949:main_sim900.h ****     zapal_diode_led(10);
 5673               		.loc 2 949 0 is_stmt 0 discriminator 2
 5674 1ce8 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5675 1cec 8111      		cpse r24,__zero_reg__
 5676 1cee 00C0      		rjmp .L543
 949:main_sim900.h ****     zapal_diode_led(10);
 5677               		.loc 2 949 0 discriminator 4
 5678 1cf0 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5679 1cf4 8111      		cpse r24,__zero_reg__
 5680 1cf6 00C0      		rjmp .L543
 949:main_sim900.h ****     zapal_diode_led(10);
 5681               		.loc 2 949 0 discriminator 6
 5682 1cf8 F999      		sbic 0x1f,1
 5683 1cfa 00C0      		rjmp .L543
 950:main_sim900.h ****     wykonanie_polecenia_sms();
 5684               		.loc 2 950 0 is_stmt 1
 5685 1cfc 8BE0      		ldi r24,lo8(11)
 5686 1cfe 8093 0000 		sts licznik_100ms_dioda_led,r24
 951:main_sim900.h ****     flaga_odczytywanie_smsa = FALSE;
 5687               		.loc 2 951 0
 5688 1d02 0E94 0000 		call wykonanie_polecenia_sms
 5689               	.LVL473:
 5690 1d06 00C0      		rjmp .L652
 5691               	.L516:
 5692               	.LBB591:
 975:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5693               		.loc 2 975 0
 5694 1d08 9111      		cpse r25,__zero_reg__
 5695 1d0a 00C0      		rjmp .L656
 975:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5696               		.loc 2 975 0 is_stmt 0 discriminator 2
 5697 1d0c 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5698 1d10 8111      		cpse r24,__zero_reg__
 5699 1d12 00C0      		rjmp .L656
 975:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5700               		.loc 2 975 0 discriminator 4
 5701 1d14 8091 0000 		lds r24,licznik_bezpieczenstwa_wykonywana_rozmowa
 5702 1d18 9091 0000 		lds r25,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5703 1d1c 892B      		or r24,r25
 5704 1d1e 01F0      		breq .+2
 5705 1d20 00C0      		rjmp .L656
 975:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5706               		.loc 2 975 0 discriminator 6
 5707 1d22 8091 0000 		lds r24,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 5708 1d26 8111      		cpse r24,__zero_reg__
 5709 1d28 00C0      		rjmp .L656
 975:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5710               		.loc 2 975 0 discriminator 8
 5711 1d2a 8091 0000 		lds r24,czekanie_na_odebranie_zachety
 5712 1d2e 8111      		cpse r24,__zero_reg__
 5713 1d30 00C0      		rjmp .L656
 978:main_sim900.h ****     static const char instrukcja_usun_smsa[] PROGMEM = "+cmgd=";
 5714               		.loc 2 978 0 is_stmt 1
 5715 1d32 0023      		tst r16
 5716 1d34 01F4      		brne .+2
 5717 1d36 00C0      		rjmp .L656
 978:main_sim900.h ****     static const char instrukcja_usun_smsa[] PROGMEM = "+cmgd=";
 5718               		.loc 2 978 0 is_stmt 0 discriminator 2
 5719 1d38 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5720 1d3c 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5721 1d40 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
 980:main_sim900.h ****     const uint nr_smsa = wykonywana_komenda - KOMENDA_KOLEJKI_USUN_SMSA_1 + 1;
 5722               		.loc 2 980 0 is_stmt 1 discriminator 2
 5723 1d44 46E0      		ldi r20,lo8(6)
 5724 1d46 50E0      		ldi r21,0
 5725 1d48 60E0      		ldi r22,lo8(instrukcja_usun_smsa.3414)
 5726 1d4a 70E0      		ldi r23,hi8(instrukcja_usun_smsa.3414)
 5727 1d4c 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 5728 1d4e 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 5729 1d50 0E94 0000 		call memcpy_P
 5730               	.LVL474:
 5731               	.LBB583:
 5732               	.LBB582:
 5733               		.loc 6 527 0 discriminator 2
 5734 1d54 4AE0      		ldi r20,lo8(10)
 5735 1d56 60E0      		ldi r22,lo8(wysylany_blok_SIM900+8)
 5736 1d58 70E0      		ldi r23,hi8(wysylany_blok_SIM900+8)
 5737               	.LVL475:
 5738 1d5a C701      		movw r24,r14
 5739 1d5c 8D5B      		subi r24,-67
 5740 1d5e 9109      		sbc r25,__zero_reg__
 5741               	.LVL476:
 5742 1d60 00C0      		rjmp .L657
 5743               	.LVL477:
 5744               	.L512:
 5745               	.LBE582:
 5746               	.LBE583:
 5747               	.LBE591:
 5748               	.LBB592:
 989:main_sim900.h ****     zapal_diode_led(10);
 5749               		.loc 2 989 0
 5750 1d62 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5751 1d66 8111      		cpse r24,__zero_reg__
 5752 1d68 00C0      		rjmp .L548
 989:main_sim900.h ****     zapal_diode_led(10);
 5753               		.loc 2 989 0 is_stmt 0 discriminator 2
 5754 1d6a 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5755 1d6e 8111      		cpse r24,__zero_reg__
 5756 1d70 00C0      		rjmp .L548
 989:main_sim900.h ****     zapal_diode_led(10);
 5757               		.loc 2 989 0 discriminator 4
 5758 1d72 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5759 1d76 8111      		cpse r24,__zero_reg__
 5760 1d78 00C0      		rjmp .L548
 989:main_sim900.h ****     zapal_diode_led(10);
 5761               		.loc 2 989 0 discriminator 6
 5762 1d7a F99B      		sbis 0x1f,1
 5763 1d7c 00C0      		rjmp .L549
 5764               	.L548:
 989:main_sim900.h ****     zapal_diode_led(10);
 5765               		.loc 2 989 0 discriminator 7
 5766 1d7e 88E9      		ldi r24,lo8(-104)
 5767 1d80 00C0      		rjmp .L650
 5768               	.L549:
 990:main_sim900.h **** 
 5769               		.loc 2 990 0 is_stmt 1
 5770 1d82 8BE0      		ldi r24,lo8(11)
 5771 1d84 8093 0000 		sts licznik_100ms_dioda_led,r24
 992:main_sim900.h ****         sprawdz_przychodzaca_rozmowe(); // Returns TRUE if number authorized
 5772               		.loc 2 992 0
 5773 1d88 0E94 0000 		call sprawdz_przychodzaca_rozmowe
 5774               	.LVL478:
 995:main_sim900.h ****       if (tryb_clip) {
 5775               		.loc 2 995 0
 5776 1d8c 8823      		tst r24
 5777 1d8e 01F0      		breq .L550
 996:main_sim900.h ****         // Tryb CLIP: wlacz wyjscie i ODRZUC polaczenie
 5778               		.loc 2 996 0
 5779 1d90 8091 0000 		lds r24,tryb_clip
 5780               	.LVL479:
 5781 1d94 8823      		tst r24
 5782 1d96 01F0      		breq .L551
 998:main_sim900.h ****           ustaw_wyjscie_clip();
 5783               		.loc 2 998 0
 5784 1d98 80E0      		ldi r24,lo8(__c.3418)
 5785 1d9a 90E0      		ldi r25,hi8(__c.3418)
 5786 1d9c 0E94 0000 		call polozenie_polecenia_SIM900
 5787               	.LVL480:
 5788 1da0 892B      		or r24,r25
 5789 1da2 01F4      		brne .L550
 999:main_sim900.h ****         }
 5790               		.loc 2 999 0
 5791 1da4 0E94 0000 		call ustaw_wyjscie_clip
 5792               	.LVL481:
 5793               	.L550:
1001:main_sim900.h ****       } else {
 5794               		.loc 2 1001 0
 5795 1da8 87E9      		ldi r24,lo8(-105)
 5796               	.L649:
1004:main_sim900.h ****       }
 5797               		.loc 2 1004 0
 5798 1daa 0E94 0000 		call dodaj_komende
 5799               	.LVL482:
1010:main_sim900.h ****     break;
 5800               		.loc 2 1010 0
 5801 1dae 8FEF      		ldi r24,lo8(-1)
 5802 1db0 8093 0000 		sts blokada_clip,r24
1011:main_sim900.h ****   }
 5803               		.loc 2 1011 0
 5804 1db4 00C0      		rjmp .L487
 5805               	.L551:
1004:main_sim900.h ****       }
 5806               		.loc 2 1004 0
 5807 1db6 86E9      		ldi r24,lo8(-106)
 5808 1db8 00C0      		rjmp .L649
 5809               	.L506:
 5810               	.LBE592:
 5811               	.LBB593:
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5812               		.loc 2 1014 0
 5813 1dba 8091 0000 		lds r24,flaga_wysylanie_smsa
 5814 1dbe 8111      		cpse r24,__zero_reg__
 5815 1dc0 00C0      		rjmp .L553
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5816               		.loc 2 1014 0 is_stmt 0 discriminator 2
 5817 1dc2 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5818 1dc6 8111      		cpse r24,__zero_reg__
 5819 1dc8 00C0      		rjmp .L553
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5820               		.loc 2 1014 0 discriminator 4
 5821 1dca 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 5822 1dce 8111      		cpse r24,__zero_reg__
 5823 1dd0 00C0      		rjmp .L553
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5824               		.loc 2 1014 0 discriminator 6
 5825 1dd2 8091 0000 		lds r24,czekanie_na_odebranie_zachety
 5826 1dd6 8111      		cpse r24,__zero_reg__
 5827 1dd8 00C0      		rjmp .L553
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5828               		.loc 2 1014 0 discriminator 10
 5829 1dda 8091 C100 		lds r24,193
 5830 1dde 86FD      		sbrc r24,6
 5831 1de0 00C0      		rjmp .L553
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5832               		.loc 2 1014 0 discriminator 12
 5833 1de2 8091 0000 		lds r24,podlaczony_modul_gsm_SIM900
 5834 1de6 8823      		tst r24
 5835 1de8 01F0      		breq .L553
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5836               		.loc 2 1014 0 discriminator 14
 5837 1dea 8091 0000 		lds r24,komenda_SIM900
 5838 1dee 8823      		tst r24
 5839 1df0 01F0      		breq .L554
 5840               	.L553:
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5841               		.loc 2 1014 0 discriminator 15
 5842 1df2 87E9      		ldi r24,lo8(-105)
 5843 1df4 00C0      		rjmp .L650
 5844               	.L554:
1019:main_sim900.h ****     static const char instrukcja_odrzuc_rozmowe[] PROGMEM = "h";
 5845               		.loc 2 1019 0 is_stmt 1
 5846 1df6 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5847 1dfa 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5848 1dfe 87E9      		ldi r24,lo8(-105)
 5849 1e00 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1021:main_sim900.h ****     break;
 5850               		.loc 2 1021 0
 5851 1e04 80E0      		ldi r24,lo8(instrukcja_odrzuc_rozmowe.3421)
 5852 1e06 90E0      		ldi r25,hi8(instrukcja_odrzuc_rozmowe.3421)
 5853               	.L653:
 5854               	.LBE593:
 5855               	.LBB594:
1196:main_sim900.h ****     break;
 5856               		.loc 2 1196 0 discriminator 2
 5857 1e08 0E94 0000 		call wyslij_polecenie_ROM_SIM900
 5858               	.LVL483:
 5859 1e0c 00C0      		rjmp .L609
 5860               	.L509:
 5861               	.LBE594:
 5862               	.LBB595:
1025:main_sim900.h ****     static const char instrukcja_odbierz_rozmowe[] PROGMEM = "a";
 5863               		.loc 2 1025 0
 5864 1e0e 86E9      		ldi r24,lo8(-106)
 5865 1e10 0023      		tst r16
 5866 1e12 01F4      		brne .+2
 5867 1e14 00C0      		rjmp .L650
1025:main_sim900.h ****     static const char instrukcja_odbierz_rozmowe[] PROGMEM = "a";
 5868               		.loc 2 1025 0 is_stmt 0 discriminator 2
 5869 1e16 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5870 1e1a 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5871 1e1e 86E9      		ldi r24,lo8(-106)
 5872 1e20 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1027:main_sim900.h ****     POMOC_DODAJ2('#', 'p');
 5873               		.loc 2 1027 0 is_stmt 1 discriminator 2
 5874 1e24 80E0      		ldi r24,lo8(instrukcja_odbierz_rozmowe.3423)
 5875 1e26 90E0      		ldi r25,hi8(instrukcja_odbierz_rozmowe.3423)
 5876 1e28 00C0      		rjmp .L653
 5877               	.L517:
 5878               	.LBE595:
 5879               	.LBB596:
1033:main_sim900.h ****     if (!CZY_MOZNA_WYSYLAC_DANE_SIM900() || !czy_jest_bezczynny_SIM900() ||
 5880               		.loc 2 1033 0
 5881 1e2a 8091 0000 		lds r24,opoznienie_SIM900_100MS
 5882 1e2e 8823      		tst r24
 5883 1e30 01F0      		breq .L556
 5884               	.L557:
1033:main_sim900.h ****     if (!CZY_MOZNA_WYSYLAC_DANE_SIM900() || !czy_jest_bezczynny_SIM900() ||
 5885               		.loc 2 1033 0 is_stmt 0 discriminator 1
 5886 1e32 85EA      		ldi r24,lo8(-91)
 5887 1e34 00C0      		rjmp .L650
 5888               	.L556:
1034:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 5889               		.loc 2 1034 0 is_stmt 1
 5890 1e36 8091 C100 		lds r24,193
 5891 1e3a 86FD      		sbrc r24,6
 5892 1e3c 00C0      		rjmp .L557
1034:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 5893               		.loc 2 1034 0 is_stmt 0 discriminator 1
 5894 1e3e 8091 0000 		lds r24,podlaczony_modul_gsm_SIM900
 5895 1e42 8823      		tst r24
 5896 1e44 01F0      		breq .L557
1034:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 5897               		.loc 2 1034 0 discriminator 2
 5898 1e46 8091 0000 		lds r24,komenda_SIM900
 5899 1e4a 8111      		cpse r24,__zero_reg__
 5900 1e4c 00C0      		rjmp .L557
1034:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 5901               		.loc 2 1034 0 discriminator 3
 5902 1e4e 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 5903 1e52 8111      		cpse r24,__zero_reg__
 5904 1e54 00C0      		rjmp .L557
1039:main_sim900.h ****     static const char instrukcja_vts[] PROGMEM = "+vts=1";
 5905               		.loc 2 1039 0 is_stmt 1
 5906 1e56 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5907 1e5a 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5908 1e5e 85EA      		ldi r24,lo8(-91)
 5909 1e60 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1041:main_sim900.h ****     POMOC_DODAJ2('#', 'V');
 5910               		.loc 2 1041 0
 5911 1e64 80E0      		ldi r24,lo8(instrukcja_vts.3425)
 5912 1e66 90E0      		ldi r25,hi8(instrukcja_vts.3425)
 5913 1e68 00C0      		rjmp .L653
 5914               	.L559:
 5915               	.LBE596:
 5916               	.LBB597:
1047:main_sim900.h ****       break;
 5917               		.loc 2 1047 0
 5918 1e6a 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5919 1e6e 8111      		cpse r24,__zero_reg__
 5920 1e70 00C0      		rjmp .L609
1049:main_sim900.h ****     zapal_diode_led(20);
 5921               		.loc 2 1049 0
 5922 1e72 0023      		tst r16
 5923 1e74 01F4      		brne .+2
 5924 1e76 00C0      		rjmp .L558
1049:main_sim900.h ****     zapal_diode_led(20);
 5925               		.loc 2 1049 0 is_stmt 0 discriminator 2
 5926 1e78 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5927 1e7c 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5928 1e80 86ED      		ldi r24,lo8(-42)
 5929 1e82 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1050:main_sim900.h ****     wysylane_dane_RAM_SIM900[0] = 'd';
 5930               		.loc 2 1050 0 is_stmt 1 discriminator 2
 5931 1e86 85E1      		ldi r24,lo8(21)
 5932 1e88 8093 0000 		sts licznik_100ms_dioda_led,r24
1051:main_sim900.h ****     // static const char doladowanie[] PROGMEM = "*100*59484869838559#";
 5933               		.loc 2 1051 0 discriminator 2
 5934 1e8c 84E6      		ldi r24,lo8(100)
 5935 1e8e 8093 0000 		sts wysylany_blok_SIM900+2,r24
1054:main_sim900.h ****     uchar l = strlen(numer_telefonu_do_ktorego_dzwonic) + 1;
 5936               		.loc 2 1054 0 discriminator 2
 5937 1e92 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 5938 1e94 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 5939 1e96 80E0      		ldi r24,lo8(wysylany_blok_SIM900+3)
 5940 1e98 90E0      		ldi r25,hi8(wysylany_blok_SIM900+3)
 5941 1e9a 0E94 0000 		call strcpy
 5942               	.LVL484:
1055:main_sim900.h ****     wysylane_dane_RAM_SIM900[l] = ';';
 5943               		.loc 2 1055 0 discriminator 2
 5944 1e9e 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 5945 1ea0 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 5946 1ea2 FC01      		movw r30,r24
 5947               		0:
 5948 1ea4 0190      		ld __tmp_reg__,Z+
 5949 1ea6 0020      		tst __tmp_reg__
 5950 1ea8 01F4      		brne 0b
 5951 1eaa CF01      		movw r24,r30
 5952 1eac 8050      		subi r24,lo8(numer_telefonu_do_ktorego_dzwonic+1)
 5953 1eae 9040      		sbci r25,hi8(numer_telefonu_do_ktorego_dzwonic+1)
 5954               	.LVL485:
 5955 1eb0 8F5F      		subi r24,lo8(-(1))
 5956               	.LVL486:
1056:main_sim900.h ****     wysylane_dane_RAM_SIM900[l + 1] = '\0';
 5957               		.loc 2 1056 0 discriminator 2
 5958 1eb2 90E0      		ldi r25,0
 5959 1eb4 FC01      		movw r30,r24
 5960               	.LVL487:
 5961 1eb6 E050      		subi r30,lo8(-(wysylany_blok_SIM900+2))
 5962 1eb8 F040      		sbci r31,hi8(-(wysylany_blok_SIM900+2))
 5963 1eba 2BE3      		ldi r18,lo8(59)
 5964 1ebc 2083      		st Z,r18
1057:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 5965               		.loc 2 1057 0 discriminator 2
 5966 1ebe 8050      		subi r24,lo8(-(wysylany_blok_SIM900+3))
 5967 1ec0 9040      		sbci r25,hi8(-(wysylany_blok_SIM900+3))
 5968 1ec2 FC01      		movw r30,r24
 5969 1ec4 1082      		st Z,__zero_reg__
1058:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 300;
 5970               		.loc 2 1058 0 discriminator 2
 5971 1ec6 0E94 0000 		call wyslij_polecenie_RAM_SIM900
 5972               	.LVL488:
1059:main_sim900.h ****     POMOC_DODAJ2('#', 'h');
 5973               		.loc 2 1059 0 discriminator 2
 5974 1eca 8CE2      		ldi r24,lo8(44)
 5975 1ecc 91E0      		ldi r25,lo8(1)
 5976 1ece 9093 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,r25
 5977 1ed2 8093 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,r24
 5978               	.LVL489:
 5979 1ed6 00C0      		rjmp .L609
 5980               	.LVL490:
 5981               	.L561:
 5982               	.LBE597:
 5983               	.LBB598:
1077:main_sim900.h ****     static const char instrukcja_poziom_sieci[] PROGMEM = "+csq";
 5984               		.loc 2 1077 0
 5985 1ed8 8BE9      		ldi r24,lo8(-101)
 5986 1eda 0023      		tst r16
 5987 1edc 01F4      		brne .+2
 5988 1ede 00C0      		rjmp .L650
1077:main_sim900.h ****     static const char instrukcja_poziom_sieci[] PROGMEM = "+csq";
 5989               		.loc 2 1077 0 is_stmt 0 discriminator 2
 5990 1ee0 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5991 1ee4 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5992 1ee8 8BE9      		ldi r24,lo8(-101)
 5993 1eea 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1079:main_sim900.h ****     break;
 5994               		.loc 2 1079 0 is_stmt 1 discriminator 2
 5995 1eee 80E0      		ldi r24,lo8(instrukcja_poziom_sieci.3429)
 5996 1ef0 90E0      		ldi r25,hi8(instrukcja_poziom_sieci.3429)
 5997 1ef2 00C0      		rjmp .L653
 5998               	.L493:
 5999               	.LBE598:
 6000               	.LBB599:
1084:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6001               		.loc 2 1084 0
 6002 1ef4 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 6003 1ef8 9111      		cpse r25,__zero_reg__
 6004 1efa 00C0      		rjmp .L609
1084:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6005               		.loc 2 1084 0 is_stmt 0 discriminator 1
 6006 1efc 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 6007 1f00 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 6008 1f04 232B      		or r18,r19
 6009 1f06 01F0      		breq .+2
 6010 1f08 00C0      		rjmp .L609
1084:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6011               		.loc 2 1084 0 discriminator 2
 6012 1f0a 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6013 1f0e 9111      		cpse r25,__zero_reg__
 6014 1f10 00C0      		rjmp .L609
1085:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 6015               		.loc 2 1085 0 is_stmt 1
 6016 1f12 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 6017 1f16 9111      		cpse r25,__zero_reg__
 6018 1f18 00C0      		rjmp .L609
1086:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 6019               		.loc 2 1086 0
 6020 1f1a 8111      		cpse r24,__zero_reg__
 6021 1f1c 00C0      		rjmp .L609
1086:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 6022               		.loc 2 1086 0 is_stmt 0 discriminator 1
 6023 1f1e 8091 0000 		lds r24,wysylanie_smsa_clipa
 6024 1f22 8111      		cpse r24,__zero_reg__
 6025 1f24 00C0      		rjmp .L609
1090:main_sim900.h ****     static const char instrukcja_creg[] PROGMEM = "+creg?";
 6026               		.loc 2 1090 0 is_stmt 1
 6027 1f26 8DE9      		ldi r24,lo8(-99)
 6028 1f28 0023      		tst r16
 6029 1f2a 01F4      		brne .+2
 6030 1f2c 00C0      		rjmp .L650
1090:main_sim900.h ****     static const char instrukcja_creg[] PROGMEM = "+creg?";
 6031               		.loc 2 1090 0 is_stmt 0 discriminator 2
 6032 1f2e 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6033 1f32 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6034 1f36 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
1092:main_sim900.h ****     break;
 6035               		.loc 2 1092 0 is_stmt 1 discriminator 2
 6036 1f3a 80E0      		ldi r24,lo8(instrukcja_creg.3431)
 6037 1f3c 90E0      		ldi r25,hi8(instrukcja_creg.3431)
 6038 1f3e 00C0      		rjmp .L653
 6039               	.L511:
 6040               	.LBE599:
 6041               	.LBB600:
1096:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6042               		.loc 2 1096 0
 6043 1f40 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 6044 1f44 9111      		cpse r25,__zero_reg__
 6045 1f46 00C0      		rjmp .L565
1096:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6046               		.loc 2 1096 0 is_stmt 0 discriminator 1
 6047 1f48 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 6048 1f4c 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 6049 1f50 232B      		or r18,r19
 6050 1f52 01F4      		brne .L565
1096:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6051               		.loc 2 1096 0 discriminator 2
 6052 1f54 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6053 1f58 9111      		cpse r25,__zero_reg__
 6054 1f5a 00C0      		rjmp .L565
1097:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 6055               		.loc 2 1097 0 is_stmt 1
 6056 1f5c 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 6057 1f60 9111      		cpse r25,__zero_reg__
 6058 1f62 00C0      		rjmp .L565
1098:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 6059               		.loc 2 1098 0
 6060 1f64 8111      		cpse r24,__zero_reg__
 6061 1f66 00C0      		rjmp .L565
1098:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 6062               		.loc 2 1098 0 is_stmt 0 discriminator 1
 6063 1f68 8091 0000 		lds r24,wysylanie_smsa_clipa
 6064 1f6c 8823      		tst r24
 6065 1f6e 01F0      		breq .L566
 6066               	.L565:
1100:main_sim900.h ****       break;
 6067               		.loc 2 1100 0 is_stmt 1
 6068 1f70 1092 0000 		sts licznik_blad_stanu_karty_SIM,__zero_reg__
 6069 1f74 00C0      		rjmp .L609
 6070               	.L566:
1103:main_sim900.h ****     static const char instrukcja_odczyt_ksiazki[] PROGMEM = "+cpbr=26";
 6071               		.loc 2 1103 0
 6072 1f76 89E9      		ldi r24,lo8(-103)
 6073 1f78 0023      		tst r16
 6074 1f7a 01F4      		brne .+2
 6075 1f7c 00C0      		rjmp .L650
1103:main_sim900.h ****     static const char instrukcja_odczyt_ksiazki[] PROGMEM = "+cpbr=26";
 6076               		.loc 2 1103 0 is_stmt 0 discriminator 2
 6077 1f7e 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6078 1f82 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6079 1f86 89E9      		ldi r24,lo8(-103)
 6080 1f88 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1105:main_sim900.h ****     break;
 6081               		.loc 2 1105 0 is_stmt 1 discriminator 2
 6082 1f8c 80E0      		ldi r24,lo8(instrukcja_odczyt_ksiazki.3433)
 6083 1f8e 90E0      		ldi r25,hi8(instrukcja_odczyt_ksiazki.3433)
 6084 1f90 00C0      		rjmp .L653
 6085               	.L513:
 6086               	.LBE600:
 6087               	.LBB601:
1109:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6088               		.loc 2 1109 0
 6089 1f92 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 6090 1f96 9111      		cpse r25,__zero_reg__
 6091 1f98 00C0      		rjmp .L568
1109:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6092               		.loc 2 1109 0 is_stmt 0 discriminator 1
 6093 1f9a 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 6094 1f9e 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 6095 1fa2 232B      		or r18,r19
 6096 1fa4 01F4      		brne .L568
1109:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6097               		.loc 2 1109 0 discriminator 2
 6098 1fa6 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6099 1faa 9111      		cpse r25,__zero_reg__
 6100 1fac 00C0      		rjmp .L568
1110:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 6101               		.loc 2 1110 0 is_stmt 1
 6102 1fae 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 6103 1fb2 9111      		cpse r25,__zero_reg__
 6104 1fb4 00C0      		rjmp .L568
1111:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 6105               		.loc 2 1111 0
 6106 1fb6 8111      		cpse r24,__zero_reg__
 6107 1fb8 00C0      		rjmp .L568
1111:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 6108               		.loc 2 1111 0 is_stmt 0 discriminator 1
 6109 1fba 8091 0000 		lds r24,wysylanie_smsa_clipa
 6110 1fbe 8823      		tst r24
 6111 1fc0 01F0      		breq .L569
 6112               	.L568:
1113:main_sim900.h ****       break;
 6113               		.loc 2 1113 0 is_stmt 1
 6114 1fc2 1092 0000 		sts licznik_blad_zalogowania_u_operatora,__zero_reg__
 6115 1fc6 00C0      		rjmp .L609
 6116               	.L569:
1116:main_sim900.h ****     static const char instrukcja_sprawdz_operatora[] PROGMEM = "+cops?";
 6117               		.loc 2 1116 0
 6118 1fc8 8AE9      		ldi r24,lo8(-102)
 6119 1fca 0023      		tst r16
 6120 1fcc 01F4      		brne .+2
 6121 1fce 00C0      		rjmp .L650
1116:main_sim900.h ****     static const char instrukcja_sprawdz_operatora[] PROGMEM = "+cops?";
 6122               		.loc 2 1116 0 is_stmt 0 discriminator 2
 6123 1fd0 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6124 1fd4 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6125 1fd8 8AE9      		ldi r24,lo8(-102)
 6126 1fda 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1118:main_sim900.h ****     break;
 6127               		.loc 2 1118 0 is_stmt 1 discriminator 2
 6128 1fde 80E0      		ldi r24,lo8(instrukcja_sprawdz_operatora.3435)
 6129 1fe0 90E0      		ldi r25,hi8(instrukcja_sprawdz_operatora.3435)
 6130 1fe2 00C0      		rjmp .L653
 6131               	.L519:
 6132               	.LBE601:
 6133               	.LBB602:
1122:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6134               		.loc 2 1122 0
 6135 1fe4 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 6136 1fe8 9111      		cpse r25,__zero_reg__
 6137 1fea 00C0      		rjmp .L609
1122:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6138               		.loc 2 1122 0 is_stmt 0 discriminator 1
 6139 1fec 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 6140 1ff0 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 6141 1ff4 232B      		or r18,r19
 6142 1ff6 01F0      		breq .+2
 6143 1ff8 00C0      		rjmp .L609
1122:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6144               		.loc 2 1122 0 discriminator 2
 6145 1ffa 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6146 1ffe 9111      		cpse r25,__zero_reg__
 6147 2000 00C0      		rjmp .L609
1123:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 6148               		.loc 2 1123 0 is_stmt 1
 6149 2002 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 6150 2006 9111      		cpse r25,__zero_reg__
 6151 2008 00C0      		rjmp .L609
1124:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK)
 6152               		.loc 2 1124 0
 6153 200a 8111      		cpse r24,__zero_reg__
 6154 200c 00C0      		rjmp .L609
1124:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK)
 6155               		.loc 2 1124 0 is_stmt 0 discriminator 1
 6156 200e 8091 0000 		lds r24,wysylanie_smsa_clipa
 6157 2012 8111      		cpse r24,__zero_reg__
 6158 2014 00C0      		rjmp .L609
1127:main_sim900.h ****     static const char instrukcja_cclk[] PROGMEM = "+cclk?";
 6159               		.loc 2 1127 0 is_stmt 1
 6160 2016 8EE9      		ldi r24,lo8(-98)
 6161 2018 0023      		tst r16
 6162 201a 01F4      		brne .+2
 6163 201c 00C0      		rjmp .L650
1127:main_sim900.h ****     static const char instrukcja_cclk[] PROGMEM = "+cclk?";
 6164               		.loc 2 1127 0 is_stmt 0 discriminator 2
 6165 201e 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6166 2022 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6167 2026 8EE9      		ldi r24,lo8(-98)
 6168 2028 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1129:main_sim900.h ****     break;
 6169               		.loc 2 1129 0 is_stmt 1 discriminator 2
 6170 202c 80E0      		ldi r24,lo8(instrukcja_cclk.3437)
 6171 202e 90E0      		ldi r25,hi8(instrukcja_cclk.3437)
 6172 2030 00C0      		rjmp .L653
 6173               	.L508:
 6174               	.LBE602:
 6175               	.LBB603:
1133:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM = "+cdscb";
 6176               		.loc 2 1133 0
 6177 2032 85E9      		ldi r24,lo8(-107)
 6178 2034 0023      		tst r16
 6179 2036 01F4      		brne .+2
 6180 2038 00C0      		rjmp .L650
1133:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM = "+cdscb";
 6181               		.loc 2 1133 0 is_stmt 0 discriminator 2
 6182 203a 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6183 203e 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6184 2042 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
1135:main_sim900.h ****     break;
 6185               		.loc 2 1135 0 is_stmt 1 discriminator 2
 6186 2046 80E0      		ldi r24,lo8(instrukcja_ustawienie_pamieci.3439)
 6187 2048 90E0      		ldi r25,hi8(instrukcja_ustawienie_pamieci.3439)
 6188 204a 00C0      		rjmp .L653
 6189               	.L502:
 6190               	.LBE603:
 6191               	.LBB604:
1139:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM =
 6192               		.loc 2 1139 0
 6193 204c 8FE8      		ldi r24,lo8(-113)
 6194 204e 0023      		tst r16
 6195 2050 01F4      		brne .+2
 6196 2052 00C0      		rjmp .L650
1139:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM =
 6197               		.loc 2 1139 0 is_stmt 0 discriminator 2
 6198 2054 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6199 2058 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6200 205c 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
1142:main_sim900.h ****         KOMENDA_KOLEJKI_WSTAWIENIE_MORING_GDY_DZWONI;
 6201               		.loc 2 1142 0 is_stmt 1 discriminator 2
 6202 2060 81EA      		ldi r24,lo8(-95)
 6203 2062 8093 0000 		sts nastepne_wysylane_polecenie_SIM900,r24
1144:main_sim900.h ****     break;
 6204               		.loc 2 1144 0 discriminator 2
 6205 2066 80E0      		ldi r24,lo8(instrukcja_ustawienie_pamieci.3441)
 6206 2068 90E0      		ldi r25,hi8(instrukcja_ustawienie_pamieci.3441)
 6207 206a 00C0      		rjmp .L653
 6208               	.L499:
 6209               	.LBE604:
1148:main_sim900.h ****     opoznienie_zatrzymaj_odpytywanie_urzadzenia = 20;
 6210               		.loc 2 1148 0
 6211 206c 8CE8      		ldi r24,lo8(-116)
 6212 206e 0E94 0000 		call dodaj_komende
 6213               	.LVL491:
1149:main_sim900.h ****     ustaw_odbior_SIM900();
 6214               		.loc 2 1149 0
 6215 2072 84E1      		ldi r24,lo8(20)
 6216 2074 8093 0000 		sts opoznienie_zatrzymaj_odpytywanie_urzadzenia,r24
1150:main_sim900.h ****     break;
 6217               		.loc 2 1150 0
 6218 2078 1092 0000 		sts liczba_odebranych_znakow_SIM900+1,__zero_reg__
 6219 207c 1092 0000 		sts liczba_odebranych_znakow_SIM900,__zero_reg__
 6220 2080 1092 0000 		sts licznik_opoznienie_oczekiwania_na_bajt_SIM900,__zero_reg__
 6221 2084 80B7      		in r24,0x30
 6222 2086 8260      		ori r24,lo8(2)
 6223 2088 80BF      		out 0x30,r24
 6224               	/* #APP */
 6225               	 ;  1150 "main_sim900.h" 1
 6226 208a F894      		cli
 6227               	 ;  0 "" 2
 6228               	/* #NOAPP */
 6229 208c 8091 C100 		lds r24,193
 6230 2090 8068      		ori r24,lo8(-128)
 6231 2092 8093 C100 		sts 193,r24
 6232               	/* #APP */
 6233               	 ;  1150 "main_sim900.h" 1
 6234 2096 7894      		sei
 6235               	 ;  0 "" 2
 6236               	 ;  1150 "main_sim900.h" 1
 6237 2098 0000      		nop
 6238               	 ;  0 "" 2
 6239               	/* #NOAPP */
 6240 209a 4598      		cbi 0x8,5
 6241 209c 00C0      		rjmp .L609
 6242               	.L500:
 6243               	.LBB605:
1157:main_sim900.h ****       break;
 6244               		.loc 2 1157 0
 6245 209e 8091 0000 		lds r24,max_oczekiwanie_na_odpowiedz_at
 6246 20a2 8111      		cpse r24,__zero_reg__
 6247 20a4 00C0      		rjmp .L609
1159:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
 6248               		.loc 2 1159 0
 6249 20a6 8091 0000 		lds r24,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6250 20aa 8823      		tst r24
 6251 20ac 01F0      		breq .L574
 6252               	.L575:
1160:main_sim900.h ****       break;
 6253               		.loc 2 1160 0
 6254 20ae 8CE8      		ldi r24,lo8(-116)
 6255 20b0 00C0      		rjmp .L650
 6256               	.L574:
1163:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
 6257               		.loc 2 1163 0
 6258 20b2 8091 C100 		lds r24,193
 6259 20b6 86FD      		sbrc r24,6
 6260 20b8 00C0      		rjmp .L575
1167:main_sim900.h ****     wysylane_polecenie_SIM900 = wykonywana_komenda;
 6261               		.loc 2 1167 0
 6262 20ba 1092 0000 		sts liczba_odebranych_znakow_SIM900+1,__zero_reg__
 6263 20be 1092 0000 		sts liczba_odebranych_znakow_SIM900,__zero_reg__
 6264 20c2 1092 0000 		sts licznik_opoznienie_oczekiwania_na_bajt_SIM900,__zero_reg__
 6265 20c6 80B7      		in r24,0x30
 6266 20c8 8260      		ori r24,lo8(2)
 6267 20ca 80BF      		out 0x30,r24
 6268               	/* #APP */
 6269               	 ;  1167 "main_sim900.h" 1
 6270 20cc F894      		cli
 6271               	 ;  0 "" 2
 6272               	/* #NOAPP */
 6273 20ce 8091 C100 		lds r24,193
 6274 20d2 8068      		ori r24,lo8(-128)
 6275 20d4 8093 C100 		sts 193,r24
 6276               	/* #APP */
 6277               	 ;  1167 "main_sim900.h" 1
 6278 20d8 7894      		sei
 6279               	 ;  0 "" 2
 6280               	 ;  1167 "main_sim900.h" 1
 6281 20da 0000      		nop
 6282               	 ;  0 "" 2
 6283               	/* #NOAPP */
 6284 20dc 4598      		cbi 0x8,5
1168:main_sim900.h ****     max_oczekiwanie_na_odpowiedz_at = 20;
 6285               		.loc 2 1168 0
 6286 20de 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6287 20e2 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6288 20e6 8CE8      		ldi r24,lo8(-116)
 6289 20e8 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1169:main_sim900.h ****     static const char instrukcja_at[] PROGMEM = "+ifc=2,2";
 6290               		.loc 2 1169 0
 6291 20ec 84E1      		ldi r24,lo8(20)
 6292 20ee 8093 0000 		sts max_oczekiwanie_na_odpowiedz_at,r24
1171:main_sim900.h ****     break;
 6293               		.loc 2 1171 0
 6294 20f2 80E0      		ldi r24,lo8(instrukcja_at.3444)
 6295 20f4 90E0      		ldi r25,hi8(instrukcja_at.3444)
 6296 20f6 00C0      		rjmp .L653
 6297               	.L497:
 6298               	.LBE605:
1175:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_PIN);
 6299               		.loc 2 1175 0
 6300 20f8 8FEF      		ldi r24,lo8(-1)
 6301 20fa 8093 0000 		sts podlaczony_modul_gsm_SIM900,r24
1176:main_sim900.h ****     opoznienie_SIM900_100MS = 40;
 6302               		.loc 2 1176 0
 6303 20fe 8FE9      		ldi r24,lo8(-97)
 6304 2100 0E94 0000 		call dodaj_komende
 6305               	.LVL492:
1177:main_sim900.h ****     break;
 6306               		.loc 2 1177 0
 6307 2104 88E2      		ldi r24,lo8(40)
 6308 2106 8093 0000 		sts opoznienie_SIM900_100MS,r24
 6309 210a 00C0      		rjmp .L609
 6310               	.L503:
 6311               	.LBB606:
1181:main_sim900.h ****     static const char instrukcja_podaj_pin[] PROGMEM = "+cpin=\"1976\"";
 6312               		.loc 2 1181 0
 6313 210c 8EE8      		ldi r24,lo8(-114)
 6314 210e 0023      		tst r16
 6315 2110 01F4      		brne .+2
 6316 2112 00C0      		rjmp .L650
1181:main_sim900.h ****     static const char instrukcja_podaj_pin[] PROGMEM = "+cpin=\"1976\"";
 6317               		.loc 2 1181 0 is_stmt 0 discriminator 2
 6318 2114 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6319 2118 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6320 211c 8EE8      		ldi r24,lo8(-114)
 6321 211e 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1183:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 6322               		.loc 2 1183 0 is_stmt 1 discriminator 2
 6323 2122 60E0      		ldi r22,lo8(instrukcja_podaj_pin.3447)
 6324 2124 70E0      		ldi r23,hi8(instrukcja_podaj_pin.3447)
 6325 2126 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 6326 2128 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 6327 212a 0E94 0000 		call strcpy_P
 6328               	.LVL493:
 6329 212e 00C0      		rjmp .L651
 6330               	.L495:
 6331               	.LBE606:
 6332               	.LBB607:
1189:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW);
 6333               		.loc 2 1189 0
 6334 2130 8091 0000 		lds r24,drugi_raz.3449
 6335 2134 8823      		tst r24
 6336 2136 01F0      		breq .L577
1190:main_sim900.h ****       break;
 6337               		.loc 2 1190 0
 6338 2138 80EA      		ldi r24,lo8(-96)
 6339 213a 00C0      		rjmp .L650
 6340               	.L577:
1193:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6341               		.loc 2 1193 0
 6342 213c 8FEF      		ldi r24,lo8(-1)
 6343 213e 8093 0000 		sts drugi_raz.3449,r24
1194:main_sim900.h ****     static const char instrukcja_usun_wszystkie_smsy[] PROGMEM = "+cmgda=6";
 6344               		.loc 2 1194 0
 6345 2142 82E9      		ldi r24,lo8(-110)
 6346 2144 0023      		tst r16
 6347 2146 01F4      		brne .+2
 6348 2148 00C0      		rjmp .L650
1194:main_sim900.h ****     static const char instrukcja_usun_wszystkie_smsy[] PROGMEM = "+cmgda=6";
 6349               		.loc 2 1194 0 is_stmt 0 discriminator 2
 6350 214a 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6351 214e 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6352 2152 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
1196:main_sim900.h ****     break;
 6353               		.loc 2 1196 0 is_stmt 1 discriminator 2
 6354 2156 80E0      		ldi r24,lo8(instrukcja_usun_wszystkie_smsy.3450)
 6355 2158 90E0      		ldi r25,hi8(instrukcja_usun_wszystkie_smsy.3450)
 6356 215a 00C0      		rjmp .L653
 6357               	.L501:
 6358               	.LBE607:
1200:main_sim900.h ****     if (komenda_SIM900 != KOMENDA_SIM900_WYSLANE_POLECENIE)
 6359               		.loc 2 1200 0
 6360 215c 0E94 0000 		call obsluga_komendy_SIM900
 6361               	.LVL494:
1201:main_sim900.h ****       max_oczekiwanie_na_odpowiedz = 20;
 6362               		.loc 2 1201 0
 6363 2160 8091 0000 		lds r24,komenda_SIM900
 6364 2164 8138      		cpi r24,lo8(-127)
 6365 2166 01F0      		breq .L579
1202:main_sim900.h ****     resetuj_komende_SIM900();
 6366               		.loc 2 1202 0
 6367 2168 84E1      		ldi r24,lo8(20)
 6368 216a 8093 0000 		sts max_oczekiwanie_na_odpowiedz,r24
 6369               	.L579:
1203:main_sim900.h ****     break;
 6370               		.loc 2 1203 0
 6371 216e 1092 0000 		sts komenda_SIM900,__zero_reg__
 6372 2172 00C0      		rjmp .L609
 6373               	.L581:
 6374               	.LBB608:
1208:main_sim900.h ****     static const char instrukcja[] PROGMEM =
 6375               		.loc 2 1208 0
 6376 2174 0023      		tst r16
 6377 2176 01F4      		brne .+2
 6378 2178 00C0      		rjmp .L580
1208:main_sim900.h ****     static const char instrukcja[] PROGMEM =
 6379               		.loc 2 1208 0 is_stmt 0 discriminator 2
 6380 217a 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6381 217e 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6382 2182 84E9      		ldi r24,lo8(-108)
 6383 2184 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1211:main_sim900.h ****     nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_ROZPOCZNIJ_PRACE;
 6384               		.loc 2 1211 0 is_stmt 1 discriminator 2
 6385 2188 60E0      		ldi r22,lo8(instrukcja.3453)
 6386 218a 70E0      		ldi r23,hi8(instrukcja.3453)
 6387 218c 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 6388 218e 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 6389 2190 0E94 0000 		call strcpy_P
 6390               	.LVL495:
1212:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 6391               		.loc 2 1212 0 discriminator 2
 6392 2194 80E9      		ldi r24,lo8(-112)
 6393 2196 8093 0000 		sts nastepne_wysylane_polecenie_SIM900,r24
 6394 219a 00C0      		rjmp .L651
 6395               	.L504:
 6396               	.LVL496:
 6397               	.LBE608:
1218:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS);
 6398               		.loc 2 1218 0
 6399 219c 8091 0000 		lds r24,podlaczona_karta_SIM_SIM900
 6400 21a0 8823      		tst r24
 6401 21a2 01F4      		brne .+2
 6402 21a4 00C0      		rjmp .L609
1219:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_MODUL_ZALOGOWANY);
 6403               		.loc 2 1219 0
 6404 21a6 85E9      		ldi r24,lo8(-107)
 6405 21a8 0E94 0000 		call dodaj_komende
 6406               	.LVL497:
1220:main_sim900.h ****     }
 6407               		.loc 2 1220 0
 6408 21ac 81E9      		ldi r24,lo8(-111)
 6409 21ae 00C0      		rjmp .L650
 6410               	.LVL498:
 6411               	.L527:
1230:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6412               		.loc 2 1230 0
 6413 21b0 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 6414 21b4 8111      		cpse r24,__zero_reg__
 6415 21b6 00C0      		rjmp .L582
1230:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6416               		.loc 2 1230 0 is_stmt 0 discriminator 2
 6417 21b8 8091 0000 		lds r24,liczba_znakow_do_zapisu
 6418 21bc 8111      		cpse r24,__zero_reg__
 6419 21be 00C0      		rjmp .L582
1230:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6420               		.loc 2 1230 0 discriminator 4
 6421 21c0 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 6422 21c4 8111      		cpse r24,__zero_reg__
 6423 21c6 00C0      		rjmp .L582
1230:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6424               		.loc 2 1230 0 discriminator 6
 6425 21c8 F99B      		sbis 0x1f,1
 6426 21ca 00C0      		rjmp .L583
 6427               	.L582:
1230:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6428               		.loc 2 1230 0 discriminator 7
 6429 21cc 8EEF      		ldi r24,lo8(-2)
 6430 21ce 00C0      		rjmp .L650
 6431               	.L583:
1231:main_sim900.h ****     strcpy(wysylane_dane_RAM_SIM900, bufor_ustaw_czas);
 6432               		.loc 2 1231 0 is_stmt 1
 6433 21d0 0023      		tst r16
 6434 21d2 01F0      		breq .L582
1231:main_sim900.h ****     strcpy(wysylane_dane_RAM_SIM900, bufor_ustaw_czas);
 6435               		.loc 2 1231 0 is_stmt 0 discriminator 2
 6436 21d4 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6437 21d8 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6438 21dc 8EEF      		ldi r24,lo8(-2)
 6439 21de 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1232:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 6440               		.loc 2 1232 0 is_stmt 1 discriminator 2
 6441 21e2 60E0      		ldi r22,lo8(bufor_ustaw_czas)
 6442 21e4 70E0      		ldi r23,hi8(bufor_ustaw_czas)
 6443 21e6 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 6444 21e8 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 6445 21ea 0E94 0000 		call strcpy
 6446               	.LVL499:
 6447 21ee 00C0      		rjmp .L651
 6448               		.cfi_endproc
 6449               	.LFE54:
 6451               	.global	steruj_SIM900_100MS
 6453               	steruj_SIM900_100MS:
 6454               	.LFB55:
1282:main_sim900.h **** 
1283:main_sim900.h **** void steruj_SIM900_100MS(void) {
 6455               		.loc 2 1283 0
 6456               		.cfi_startproc
 6457               	/* prologue: function */
 6458               	/* frame size = 0 */
 6459               	/* stack size = 0 */
 6460               	.L__stack_usage = 0
1284:main_sim900.h ****   if (opoznienie_SIM900_100MS && --opoznienie_SIM900_100MS == 0)
 6461               		.loc 2 1284 0
 6462 21f0 8091 0000 		lds r24,opoznienie_SIM900_100MS
 6463 21f4 8823      		tst r24
 6464 21f6 01F0      		breq .L660
 6465               		.loc 2 1284 0 is_stmt 0 discriminator 1
 6466 21f8 8150      		subi r24,lo8(-(-1))
 6467 21fa 8093 0000 		sts opoznienie_SIM900_100MS,r24
 6468 21fe 8111      		cpse r24,__zero_reg__
 6469 2200 00C0      		rjmp .L660
1285:main_sim900.h ****     oproznij_bufor_SIM900_po_bledzie = FALSE;
 6470               		.loc 2 1285 0 is_stmt 1
 6471 2202 1092 0000 		sts oproznij_bufor_SIM900_po_bledzie,__zero_reg__
 6472               	.L660:
1286:main_sim900.h **** 
1287:main_sim900.h ****   if (opoznienie_wysylania_clipow_100MS)
 6473               		.loc 2 1287 0
 6474 2206 8091 0000 		lds r24,opoznienie_wysylania_clipow_100MS
 6475 220a 9091 0000 		lds r25,opoznienie_wysylania_clipow_100MS+1
 6476 220e 0097      		sbiw r24,0
 6477 2210 01F0      		breq .L662
1288:main_sim900.h ****     --opoznienie_wysylania_clipow_100MS;
 6478               		.loc 2 1288 0
 6479 2212 0197      		sbiw r24,1
 6480 2214 9093 0000 		sts opoznienie_wysylania_clipow_100MS+1,r25
 6481 2218 8093 0000 		sts opoznienie_wysylania_clipow_100MS,r24
 6482               	.L662:
1289:main_sim900.h **** 
1290:main_sim900.h ****   // Timeout rozmowy - automatyczne rozlaczenie po 30 sekundach
1291:main_sim900.h ****   if (licznik_timeout_rozmowy_100ms) {
 6483               		.loc 2 1291 0
 6484 221c 8091 0000 		lds r24,licznik_timeout_rozmowy_100ms
 6485 2220 9091 0000 		lds r25,licznik_timeout_rozmowy_100ms+1
 6486 2224 0097      		sbiw r24,0
 6487 2226 01F0      		breq .L664
1292:main_sim900.h ****     if (--licznik_timeout_rozmowy_100ms == 0 &&
 6488               		.loc 2 1292 0
 6489 2228 0197      		sbiw r24,1
 6490 222a 9093 0000 		sts licznik_timeout_rozmowy_100ms+1,r25
 6491 222e 8093 0000 		sts licznik_timeout_rozmowy_100ms,r24
 6492 2232 892B      		or r24,r25
 6493 2234 01F4      		brne .L664
 6494               		.loc 2 1292 0 is_stmt 0 discriminator 1
 6495 2236 8091 0000 		lds r24,trwa_rozmowa_przychodzaca_od_uzytkownika
 6496 223a 8823      		tst r24
 6497 223c 01F0      		breq .L664
1293:main_sim900.h ****         trwa_rozmowa_przychodzaca_od_uzytkownika) {
1294:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
 6498               		.loc 2 1294 0 is_stmt 1
 6499 223e 87E9      		ldi r24,lo8(-105)
 6500 2240 0E94 0000 		call dodaj_komende
 6501               	.LVL500:
 6502               	.L664:
1295:main_sim900.h ****       POMOC_DODAJ2('#', 'X'); // Timeout marker
1296:main_sim900.h ****     }
1297:main_sim900.h ****   }
1298:main_sim900.h **** 
1299:main_sim900.h ****   if (max_oczekiwanie_na_odpowiedz_at) {
 6503               		.loc 2 1299 0
 6504 2244 8091 0000 		lds r24,max_oczekiwanie_na_odpowiedz_at
 6505 2248 8823      		tst r24
 6506 224a 01F0      		breq .L667
1300:main_sim900.h ****     if (--max_oczekiwanie_na_odpowiedz_at == 0) {
 6507               		.loc 2 1300 0
 6508 224c 8150      		subi r24,lo8(-(-1))
 6509 224e 8093 0000 		sts max_oczekiwanie_na_odpowiedz_at,r24
 6510 2252 8111      		cpse r24,__zero_reg__
 6511 2254 00C0      		rjmp .L667
1301:main_sim900.h ****       wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 6512               		.loc 2 1301 0
 6513 2256 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6514 225a 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6515 225e 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
1302:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT);
 6516               		.loc 2 1302 0
 6517 2262 8CE8      		ldi r24,lo8(-116)
 6518 2264 0E94 0000 		call dodaj_komende
 6519               	.LVL501:
1303:main_sim900.h ****       sprawdzaj_wejscie_CTS_SIM900 = FALSE;
 6520               		.loc 2 1303 0
 6521 2268 1092 0000 		sts sprawdzaj_wejscie_CTS_SIM900,__zero_reg__
1304:main_sim900.h ****       zakoncz_wysylanie_SIM900();
 6522               		.loc 2 1304 0
 6523               	/* #APP */
 6524               	 ;  1304 "main_sim900.h" 1
 6525 226c F894      		cli
 6526               	 ;  0 "" 2
 6527               	/* #NOAPP */
 6528 226e 8091 C100 		lds r24,193
 6529 2272 8F7B      		andi r24,lo8(-65)
 6530 2274 8093 C100 		sts 193,r24
 6531               	/* #APP */
 6532               	 ;  1304 "main_sim900.h" 1
 6533 2278 7894      		sei
 6534               	 ;  0 "" 2
 6535               	 ;  1304 "main_sim900.h" 1
 6536 227a 0000      		nop
 6537               	 ;  0 "" 2
 6538               	/* #NOAPP */
 6539               	.L667:
1305:main_sim900.h ****     }
1306:main_sim900.h ****   }
1307:main_sim900.h **** 
1308:main_sim900.h ****   if (procedura_inicjalizacyjna_SIM900_100MS())
 6540               		.loc 2 1308 0
 6541 227c 0E94 0000 		call procedura_inicjalizacyjna_SIM900_100MS
 6542               	.LVL502:
 6543 2280 8823      		tst r24
 6544 2282 01F0      		breq .L669
1309:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_PODLACZONY_MODUL_GSM);
 6545               		.loc 2 1309 0
 6546 2284 8BE8      		ldi r24,lo8(-117)
 6547 2286 0E94 0000 		call dodaj_komende
 6548               	.LVL503:
 6549               	.L669:
1310:main_sim900.h **** 
1311:main_sim900.h ****   if (maksymalny_czas_dzwonienia) {
 6550               		.loc 2 1311 0
 6551 228a 8091 0000 		lds r24,maksymalny_czas_dzwonienia
 6552 228e 8823      		tst r24
 6553 2290 01F0      		breq .L671
1312:main_sim900.h ****     if (--maksymalny_czas_dzwonienia == 0) {
 6554               		.loc 2 1312 0
 6555 2292 8150      		subi r24,lo8(-(-1))
 6556 2294 8093 0000 		sts maksymalny_czas_dzwonienia,r24
 6557 2298 8111      		cpse r24,__zero_reg__
 6558 229a 00C0      		rjmp .L671
 6559               	.LVL504:
1313:main_sim900.h ****       POMOC_DODAJ2('#', 'i');
1314:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
 6560               		.loc 2 1314 0
 6561 229c 87E9      		ldi r24,lo8(-105)
 6562 229e 0E94 0000 		call dodaj_komende
 6563               	.LVL505:
 6564               	.L671:
1315:main_sim900.h ****     }
1316:main_sim900.h ****   }
1317:main_sim900.h **** 
1318:main_sim900.h ****   if (licznik_bezpieczenstwa_wykonywana_rozmowa) {
 6565               		.loc 2 1318 0
 6566 22a2 8091 0000 		lds r24,licznik_bezpieczenstwa_wykonywana_rozmowa
 6567 22a6 9091 0000 		lds r25,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 6568 22aa 0097      		sbiw r24,0
 6569 22ac 01F0      		breq .L674
1319:main_sim900.h ****     if (--licznik_bezpieczenstwa_wykonywana_rozmowa == 0) {
 6570               		.loc 2 1319 0
 6571 22ae 0197      		sbiw r24,1
 6572 22b0 9093 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,r25
 6573 22b4 8093 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,r24
 6574 22b8 892B      		or r24,r25
 6575 22ba 01F4      		brne .L674
 6576               	.LVL506:
1320:main_sim900.h ****       POMOC_DODAJ2('#', 'j');
1321:main_sim900.h ****       zakonczono_rozmowe_telefoniczna(
 6577               		.loc 2 1321 0
 6578 22bc 82E0      		ldi r24,lo8(2)
 6579 22be 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 6580               	.LVL507:
1322:main_sim900.h ****           powod_zakonczenia_rozmowy_przekroczony_czas);
1323:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 6581               		.loc 2 1323 0
 6582 22c2 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
1324:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 6583               		.loc 2 1324 0
 6584 22c6 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 6585               	.LVL508:
 6586               	.L674:
 6587               	.LBB609:
1325:main_sim900.h ****     }
1326:main_sim900.h ****   }
1327:main_sim900.h **** 
1328:main_sim900.h **** #ifndef WYLACZ_AUTOMATYCZNE_KONTROLOWANIE_SIMCOM
1329:main_sim900.h **** 
1330:main_sim900.h ****   { // poziom sieci i zalogowanie u operatora
1331:main_sim900.h ****     static uchar licznik_cyklu_8_sek = 0;
1332:main_sim900.h ****     if (++licznik_cyklu_8_sek == 48)
 6588               		.loc 2 1332 0
 6589 22ca 8091 0000 		lds r24,licznik_cyklu_8_sek.3477
 6590 22ce 8F5F      		subi r24,lo8(-(1))
 6591 22d0 8093 0000 		sts licznik_cyklu_8_sek.3477,r24
 6592 22d4 8033      		cpi r24,lo8(48)
 6593 22d6 01F0      		breq .+2
 6594 22d8 00C0      		rjmp .L676
1333:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_POZIOM_SIECI);
 6595               		.loc 2 1333 0
 6596 22da 8BE9      		ldi r24,lo8(-101)
 6597               	.L718:
1334:main_sim900.h ****     else if (licznik_cyklu_8_sek == 52)
1335:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_ZAREJESTROWANIE);
1336:main_sim900.h ****     else if (licznik_cyklu_8_sek == 56)
1337:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_ZALOGOWANIE_U_OPERATORA);
1338:main_sim900.h ****     else if (licznik_cyklu_8_sek == 60) {
1339:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_STAN_KARTY_SIM);
1340:main_sim900.h ****     } else if (licznik_cyklu_8_sek >= 80) {
1341:main_sim900.h ****       licznik_cyklu_8_sek = 0;
1342:main_sim900.h ****       if (modul_zalogowany_w_sieci)
1343:main_sim900.h ****         filtruj_i_dodaj_komende(
 6598               		.loc 2 1343 0
 6599 22dc 0E94 0000 		call filtruj_i_dodaj_komende
 6600               	.LVL509:
 6601               	.L677:
 6602               	.LBE609:
1344:main_sim900.h ****             KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE);
1345:main_sim900.h ****     }
1346:main_sim900.h ****   }
1347:main_sim900.h **** 
1348:main_sim900.h ****   if (opoznienie_zatrzymaj_odpytywanie_urzadzenia)
 6603               		.loc 2 1348 0
 6604 22e0 8091 0000 		lds r24,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6605 22e4 8823      		tst r24
 6606 22e6 01F0      		breq .L683
1349:main_sim900.h ****     --opoznienie_zatrzymaj_odpytywanie_urzadzenia;
 6607               		.loc 2 1349 0
 6608 22e8 8150      		subi r24,lo8(-(-1))
 6609 22ea 8093 0000 		sts opoznienie_zatrzymaj_odpytywanie_urzadzenia,r24
 6610               	.L683:
1350:main_sim900.h **** 
1351:main_sim900.h ****   if (modul_zalogowany_w_sieci &&
 6611               		.loc 2 1351 0
 6612 22ee 8091 0000 		lds r24,modul_zalogowany_w_sieci
 6613 22f2 8823      		tst r24
 6614 22f4 01F4      		brne .+2
 6615 22f6 00C0      		rjmp .L684
1352:main_sim900.h ****       (poziom_sieci_gsm == POZIOM_SIECI_BLAD || poziom_sieci_gsm == 0)) {
 6616               		.loc 2 1352 0 discriminator 1
 6617 22f8 8091 0000 		lds r24,poziom_sieci_gsm
1351:main_sim900.h ****       (poziom_sieci_gsm == POZIOM_SIECI_BLAD || poziom_sieci_gsm == 0)) {
 6618               		.loc 2 1351 0 discriminator 1
 6619 22fc 8336      		cpi r24,lo8(99)
 6620 22fe 01F0      		breq .L685
 6621               		.loc 2 1352 0
 6622 2300 8111      		cpse r24,__zero_reg__
 6623 2302 00C0      		rjmp .L684
 6624               	.L685:
1353:main_sim900.h ****     if (licznik_awaria_brak_zasiegu < MAX_LICZNIK_AWARIA_BRAK_ZASIEGU) {
 6625               		.loc 2 1353 0
 6626 2304 8091 0000 		lds r24,licznik_awaria_brak_zasiegu
 6627 2308 9091 0000 		lds r25,licznik_awaria_brak_zasiegu+1
 6628 230c 8835      		cpi r24,88
 6629 230e 22E0      		ldi r18,2
 6630 2310 9207      		cpc r25,r18
 6631 2312 00F4      		brsh .L687
1354:main_sim900.h ****       if (++licznik_awaria_brak_zasiegu == MAX_LICZNIK_AWARIA_BRAK_ZASIEGU) {
 6632               		.loc 2 1354 0
 6633 2314 0196      		adiw r24,1
 6634 2316 8835      		cpi r24,88
 6635 2318 22E0      		ldi r18,2
 6636 231a 9207      		cpc r25,r18
 6637 231c 01F4      		brne .+2
 6638 231e 00C0      		rjmp .L688
 6639 2320 9093 0000 		sts licznik_awaria_brak_zasiegu+1,r25
 6640 2324 8093 0000 		sts licznik_awaria_brak_zasiegu,r24
 6641               	.L687:
1355:main_sim900.h ****         licznik_awaria_brak_zasiegu = 0;
1356:main_sim900.h ****         POMOC_DODAJ2('*', 'j');
1357:main_sim900.h ****         reset_modulu_SIM900();
1358:main_sim900.h ****       }
1359:main_sim900.h ****     }
1360:main_sim900.h ****   } else
1361:main_sim900.h ****     licznik_awaria_brak_zasiegu = 0;
1362:main_sim900.h **** 
1363:main_sim900.h ****   if (CZY_BLAD_KARTY_SIM() || CZY_BLAD_ZALOGOWANIA_U_OPERATORA()) {
 6642               		.loc 2 1363 0
 6643 2328 8091 0000 		lds r24,licznik_blad_stanu_karty_SIM
 6644 232c 8630      		cpi r24,lo8(6)
 6645 232e 00F4      		brsh .L690
 6646               		.loc 2 1363 0 is_stmt 0 discriminator 1
 6647 2330 8091 0000 		lds r24,licznik_blad_zalogowania_u_operatora
 6648 2334 8431      		cpi r24,lo8(20)
 6649 2336 00F0      		brlo .L691
 6650               	.L690:
 6651               	.LVL510:
1364:main_sim900.h ****     POMOC_DODAJ2('*', 'k');
1365:main_sim900.h ****     reset_modulu_SIM900();
 6652               		.loc 2 1365 0 is_stmt 1
 6653 2338 0E94 0000 		call reset_modulu_SIM900
 6654               	.LVL511:
 6655               	.L691:
1366:main_sim900.h ****   }
1367:main_sim900.h **** #endif
1368:main_sim900.h **** 
1369:main_sim900.h ****   if (licznik_reset_modulu_SIM900) {
 6656               		.loc 2 1369 0
 6657 233c 8091 0000 		lds r24,licznik_reset_modulu_SIM900
 6658 2340 8823      		tst r24
 6659 2342 01F0      		breq .L693
1370:main_sim900.h ****     if (--licznik_reset_modulu_SIM900 == 0) {
 6660               		.loc 2 1370 0
 6661 2344 8150      		subi r24,lo8(-(-1))
 6662 2346 8093 0000 		sts licznik_reset_modulu_SIM900,r24
 6663 234a 8111      		cpse r24,__zero_reg__
 6664 234c 00C0      		rjmp .L693
 6665               	.LVL512:
1371:main_sim900.h ****       POMOC_DODAJ2('*', 'l');
1372:main_sim900.h ****       reset_modulu_SIM900();
 6666               		.loc 2 1372 0
 6667 234e 0E94 0000 		call reset_modulu_SIM900
 6668               	.LVL513:
 6669               	.L693:
1373:main_sim900.h ****     }
1374:main_sim900.h ****   }
1375:main_sim900.h **** 
1376:main_sim900.h ****   if (!modul_zalogowany_w_sieci) {
 6670               		.loc 2 1376 0
 6671 2352 8091 0000 		lds r24,modul_zalogowany_w_sieci
 6672 2356 8111      		cpse r24,__zero_reg__
 6673 2358 00C0      		rjmp .L695
1377:main_sim900.h ****     if (++licznik_ogolny_blad_zalogowania > MAX_LICZNIK_OGOLNY_BLAD_ZALOGOWANIA)
 6674               		.loc 2 1377 0
 6675 235a 8091 0000 		lds r24,licznik_ogolny_blad_zalogowania
 6676 235e 9091 0000 		lds r25,licznik_ogolny_blad_zalogowania+1
 6677 2362 0196      		adiw r24,1
 6678 2364 9093 0000 		sts licznik_ogolny_blad_zalogowania+1,r25
 6679 2368 8093 0000 		sts licznik_ogolny_blad_zalogowania,r24
 6680 236c 813B      		cpi r24,-79
 6681 236e 9440      		sbci r25,4
 6682 2370 00F0      		brlo .L658
1378:main_sim900.h ****       reset_modulu_SIM900();
 6683               		.loc 2 1378 0
 6684 2372 0C94 0000 		jmp reset_modulu_SIM900
 6685               	.LVL514:
 6686               	.L676:
 6687               	.LBB610:
1334:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_ZAREJESTROWANIE);
 6688               		.loc 2 1334 0
 6689 2376 8433      		cpi r24,lo8(52)
 6690 2378 01F4      		brne .L678
1335:main_sim900.h ****     else if (licznik_cyklu_8_sek == 56)
 6691               		.loc 2 1335 0
 6692 237a 8DE9      		ldi r24,lo8(-99)
 6693 237c 00C0      		rjmp .L718
 6694               	.L678:
1336:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_ZALOGOWANIE_U_OPERATORA);
 6695               		.loc 2 1336 0
 6696 237e 8833      		cpi r24,lo8(56)
 6697 2380 01F4      		brne .L679
1337:main_sim900.h ****     else if (licznik_cyklu_8_sek == 60) {
 6698               		.loc 2 1337 0
 6699 2382 8AE9      		ldi r24,lo8(-102)
 6700 2384 00C0      		rjmp .L718
 6701               	.L679:
1338:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_STAN_KARTY_SIM);
 6702               		.loc 2 1338 0
 6703 2386 8C33      		cpi r24,lo8(60)
 6704 2388 01F4      		brne .L680
1339:main_sim900.h ****     } else if (licznik_cyklu_8_sek >= 80) {
 6705               		.loc 2 1339 0
 6706 238a 89E9      		ldi r24,lo8(-103)
 6707 238c 00C0      		rjmp .L718
 6708               	.L680:
1340:main_sim900.h ****       licznik_cyklu_8_sek = 0;
 6709               		.loc 2 1340 0
 6710 238e 8035      		cpi r24,lo8(80)
 6711 2390 00F4      		brsh .+2
 6712 2392 00C0      		rjmp .L677
 6713 2394 8091 0000 		lds r24,modul_zalogowany_w_sieci
1341:main_sim900.h ****       if (modul_zalogowany_w_sieci)
 6714               		.loc 2 1341 0
 6715 2398 1092 0000 		sts licznik_cyklu_8_sek.3477,__zero_reg__
1342:main_sim900.h ****         filtruj_i_dodaj_komende(
 6716               		.loc 2 1342 0
 6717 239c 8823      		tst r24
 6718 239e 01F4      		brne .+2
 6719 23a0 00C0      		rjmp .L677
1343:main_sim900.h ****             KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE);
 6720               		.loc 2 1343 0
 6721 23a2 8EE9      		ldi r24,lo8(-98)
 6722 23a4 00C0      		rjmp .L718
 6723               	.L688:
 6724               	.LBE610:
1355:main_sim900.h ****         POMOC_DODAJ2('*', 'j');
 6725               		.loc 2 1355 0
 6726 23a6 1092 0000 		sts licznik_awaria_brak_zasiegu+1,__zero_reg__
 6727 23aa 1092 0000 		sts licznik_awaria_brak_zasiegu,__zero_reg__
 6728               	.LVL515:
1357:main_sim900.h ****       }
 6729               		.loc 2 1357 0
 6730 23ae 0E94 0000 		call reset_modulu_SIM900
 6731               	.LVL516:
 6732 23b2 00C0      		rjmp .L687
 6733               	.LVL517:
 6734               	.L684:
1361:main_sim900.h **** 
 6735               		.loc 2 1361 0
 6736 23b4 1092 0000 		sts licznik_awaria_brak_zasiegu+1,__zero_reg__
 6737 23b8 1092 0000 		sts licznik_awaria_brak_zasiegu,__zero_reg__
 6738 23bc 00C0      		rjmp .L687
 6739               	.L695:
1379:main_sim900.h ****   } else
1380:main_sim900.h ****     licznik_ogolny_blad_zalogowania = 0;
 6740               		.loc 2 1380 0
 6741 23be 1092 0000 		sts licznik_ogolny_blad_zalogowania+1,__zero_reg__
 6742 23c2 1092 0000 		sts licznik_ogolny_blad_zalogowania,__zero_reg__
 6743               	.L658:
 6744               	/* epilogue start */
1381:main_sim900.h **** }
 6745               		.loc 2 1381 0
 6746 23c6 0895      		ret
 6747               		.cfi_endproc
 6748               	.LFE55:
 6750               	.global	steruj_SIM900_10MS
 6752               	steruj_SIM900_10MS:
 6753               	.LFB56:
1382:main_sim900.h **** 
1383:main_sim900.h **** void steruj_SIM900_10MS(void) {
 6754               		.loc 2 1383 0
 6755               		.cfi_startproc
 6756               	/* prologue: function */
 6757               	/* frame size = 0 */
 6758               	/* stack size = 0 */
 6759               	.L__stack_usage = 0
1384:main_sim900.h ****   if (czy_jest_komenda_SIM900())
 6760               		.loc 2 1384 0
 6761 23c8 8091 0000 		lds r24,komenda_SIM900
 6762 23cc 8823      		tst r24
 6763 23ce 01F4      		brne .+2
 6764 23d0 00C0      		rjmp .L720
 6765               	.L722:
1385:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_KOMENDA_SIM900);
 6766               		.loc 2 1385 0
 6767 23d2 8AE8      		ldi r24,lo8(-118)
 6768 23d4 0E94 0000 		call dodaj_komende
 6769               	.LVL518:
 6770               	.L721:
1386:main_sim900.h **** 
1387:main_sim900.h ****   if (flaga_odebrany_znak_zachety) {
 6771               		.loc 2 1387 0
 6772 23d8 8091 0000 		lds r24,flaga_odebrany_znak_zachety
 6773 23dc 8823      		tst r24
 6774 23de 01F0      		breq .L723
1388:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_PDU);
 6775               		.loc 2 1388 0
 6776 23e0 85ED      		ldi r24,lo8(-43)
 6777 23e2 0E94 0000 		call dodaj_komende
 6778               	.LVL519:
1389:main_sim900.h ****     // czekanie_na_odebranie_zachety = FALSE;	// byo
1390:main_sim900.h ****     flaga_odebrany_znak_zachety = FALSE;
 6779               		.loc 2 1390 0
 6780 23e6 1092 0000 		sts flaga_odebrany_znak_zachety,__zero_reg__
 6781               	.LVL520:
 6782               	.L723:
 6783               	.LBB611:
1391:main_sim900.h ****     POMOC_DODAJ2('#', 'm');
1392:main_sim900.h ****   }
1393:main_sim900.h **** 
1394:main_sim900.h ****   { // kontrola wysyania sms-w i clipw
1395:main_sim900.h ****     static uint licznik_bezpieczenstwa = 0;
1396:main_sim900.h ****     if (modul_zalogowany_w_sieci && flaga_wysylanie_smsa) {
 6784               		.loc 2 1396 0
 6785 23ea 8091 0000 		lds r24,modul_zalogowany_w_sieci
 6786 23ee 8823      		tst r24
 6787 23f0 01F4      		brne .+2
 6788 23f2 00C0      		rjmp .L724
 6789               		.loc 2 1396 0 is_stmt 0 discriminator 1
 6790 23f4 8091 0000 		lds r24,flaga_wysylanie_smsa
 6791 23f8 8823      		tst r24
 6792 23fa 01F4      		brne .+2
 6793 23fc 00C0      		rjmp .L724
1397:main_sim900.h ****       if (++licznik_bezpieczenstwa >= 5000) // 50 sek
 6794               		.loc 2 1397 0 is_stmt 1
 6795 23fe 8091 0000 		lds r24,licznik_bezpieczenstwa.3481
 6796 2402 9091 0000 		lds r25,licznik_bezpieczenstwa.3481+1
 6797 2406 0196      		adiw r24,1
 6798 2408 8838      		cpi r24,-120
 6799 240a 23E1      		ldi r18,19
 6800 240c 9207      		cpc r25,r18
 6801 240e 00F0      		brlo .+2
 6802 2410 00C0      		rjmp .L725
 6803 2412 9093 0000 		sts licznik_bezpieczenstwa.3481+1,r25
 6804 2416 8093 0000 		sts licznik_bezpieczenstwa.3481,r24
 6805               	.L726:
 6806               	.LBE611:
 6807               	.LBB612:
1398:main_sim900.h ****       {
1399:main_sim900.h ****         POMOC_DODAJ2('#', 'Z');
1400:main_sim900.h ****         licznik_bezpieczenstwa = 0;
1401:main_sim900.h ****         komenda_SIM900 = ERROR_KOMENDA_SIM900;
1402:main_sim900.h ****         obsluga_wysylania_sms();
1403:main_sim900.h ****       }
1404:main_sim900.h ****     } else
1405:main_sim900.h ****       licznik_bezpieczenstwa = 0;
1406:main_sim900.h ****   }
1407:main_sim900.h **** 
1408:main_sim900.h ****   { // kontrola programu: zbyt dugi okres wykonywania polecenia do SIM900 lub
1409:main_sim900.h ****     // jego brak
1410:main_sim900.h ****     static komenda_typ poprzednia_komenda;
1411:main_sim900.h ****     static uint licznik_poprzednia_komenda;
1412:main_sim900.h ****     static uint licznik_odebranych_znakow;
1413:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY &&
 6808               		.loc 2 1413 0
 6809 241a 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 6810 241e 9091 0000 		lds r25,trwa_rozmowa_przychodzaca_od_uzytkownika
 6811 2422 8823      		tst r24
 6812 2424 01F4      		brne .+2
 6813 2426 00C0      		rjmp .L727
 6814               		.loc 2 1413 0 is_stmt 0 discriminator 1
 6815 2428 2091 0000 		lds r18,poprzednia_komenda.3482
 6816 242c 8213      		cpse r24,r18
 6817 242e 00C0      		rjmp .L728
1414:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 == poprzednia_komenda &&
 6818               		.loc 2 1414 0 is_stmt 1
 6819 2430 9111      		cpse r25,__zero_reg__
 6820 2432 00C0      		rjmp .L729
 6821               	.LVL521:
 6822               	.LBB613:
1415:main_sim900.h ****         !trwa_rozmowa_przychodzaca_od_uzytkownika) {
1416:main_sim900.h ****       uint max_licznik_poprzednia_komenda = 5 * 100; // 5 sek;
1417:main_sim900.h ****       if (aktualnie_wysylane_polecenie_SIM900 ==
 6823               		.loc 2 1417 0
 6824 2434 8C38      		cpi r24,lo8(-116)
 6825 2436 01F0      		breq .L743
1418:main_sim900.h ****               KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT ||
 6826               		.loc 2 1418 0
 6827 2438 9BE2      		ldi r25,lo8(43)
 6828 243a 980F      		add r25,r24
1416:main_sim900.h ****       if (aktualnie_wysylane_polecenie_SIM900 ==
 6829               		.loc 2 1416 0
 6830 243c 44EF      		ldi r20,lo8(-12)
 6831 243e 51E0      		ldi r21,lo8(1)
 6832               		.loc 2 1418 0
 6833 2440 9230      		cpi r25,lo8(2)
 6834 2442 00F4      		brsh .L730
 6835               	.L743:
1419:main_sim900.h ****           aktualnie_wysylane_polecenie_SIM900 == KOMENDA_KOLEJKI_WYSLIJ_PDU ||
1420:main_sim900.h ****           aktualnie_wysylane_polecenie_SIM900 ==
1421:main_sim900.h ****               KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE)
1422:main_sim900.h ****         max_licznik_poprzednia_komenda = 2 * 60 * 100; // 2 minuty
 6836               		.loc 2 1422 0
 6837 2444 40EE      		ldi r20,lo8(-32)
 6838 2446 5EE2      		ldi r21,lo8(46)
 6839               	.L730:
 6840               	.LVL522:
1423:main_sim900.h **** 
1424:main_sim900.h ****       if (aktualnie_wysylane_polecenie_SIM900 ==
1425:main_sim900.h ****               KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT // zmienione (1)
1426:main_sim900.h ****           || aktualnie_wysylane_polecenie_SIM900 ==
 6841               		.loc 2 1426 0
 6842 2448 9DE2      		ldi r25,lo8(45)
 6843 244a 980F      		add r25,r24
1424:main_sim900.h ****               KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT // zmienione (1)
 6844               		.loc 2 1424 0
 6845 244c 9230      		cpi r25,lo8(2)
 6846 244e 00F4      		brsh .L731
1427:main_sim900.h ****                  KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
1428:main_sim900.h ****         max_licznik_poprzednia_komenda = 15 * 100;
 6847               		.loc 2 1428 0
 6848 2450 4CED      		ldi r20,lo8(-36)
 6849 2452 55E0      		ldi r21,lo8(5)
 6850               	.LVL523:
 6851               	.L731:
1429:main_sim900.h **** 
1430:main_sim900.h ****       if (++licznik_poprzednia_komenda >= max_licznik_poprzednia_komenda) {
 6852               		.loc 2 1430 0
 6853 2454 2091 0000 		lds r18,licznik_poprzednia_komenda.3483
 6854 2458 3091 0000 		lds r19,licznik_poprzednia_komenda.3483+1
 6855 245c 2F5F      		subi r18,-1
 6856 245e 3F4F      		sbci r19,-1
 6857 2460 2417      		cp r18,r20
 6858 2462 3507      		cpc r19,r21
 6859 2464 00F4      		brsh .L732
 6860 2466 3093 0000 		sts licznik_poprzednia_komenda.3483+1,r19
 6861 246a 2093 0000 		sts licznik_poprzednia_komenda.3483,r18
 6862               	.LVL524:
 6863               	.L733:
1431:main_sim900.h ****         licznik_poprzednia_komenda = 0;
1432:main_sim900.h ****         POMOC_DODAJ2('#', 'r');
1433:main_sim900.h ****         POMOC_DODAJ_HEX(aktualnie_wysylane_polecenie_SIM900 >> 8);
1434:main_sim900.h ****         POMOC_DODAJ_HEX(aktualnie_wysylane_polecenie_SIM900);
1435:main_sim900.h ****         if (aktualnie_wysylane_polecenie_SIM900 !=
1436:main_sim900.h ****             KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1) {
1437:main_sim900.h ****           if (aktualnie_wysylane_polecenie_SIM900 ==
1438:main_sim900.h ****                   KOMENDA_KOLEJKI_ODRZUC_ROZMOWE ||
1439:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
1440:main_sim900.h ****                   KOMENDA_KOLEJKI_PODAJ_PIN ||
1441:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
1442:main_sim900.h ****                   KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW ||
1443:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
1444:main_sim900.h ****                   KOMENDA_KOLEJKI_USTAW_WZMOCNIENIE_MIKROFONU ||
1445:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
1446:main_sim900.h ****                   KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS ||
1447:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
1448:main_sim900.h ****                    KOMENDA_KOLEJKI_SPRAWDZ_PIN &&
1449:main_sim900.h ****                aktualnie_wysylane_polecenie_SIM900 <=
1450:main_sim900.h ****                    KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ) ||
1451:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
1452:main_sim900.h ****                    KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
1453:main_sim900.h ****                aktualnie_wysylane_polecenie_SIM900 <=
1454:main_sim900.h ****                    KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) ||
1455:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
1456:main_sim900.h ****                    KOMENDA_KOLEJKI_USUN_SMSA_1 &&
1457:main_sim900.h ****                aktualnie_wysylane_polecenie_SIM900 <=
1458:main_sim900.h ****                    KOMENDA_KOLEJKI_USUN_SMSA_20)) {
1459:main_sim900.h ****             nastepne_wysylane_polecenie_SIM900 =
1460:main_sim900.h ****                 aktualnie_wysylane_polecenie_SIM900;
1461:main_sim900.h ****           } else
1462:main_sim900.h ****             nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
1463:main_sim900.h ****           wyzerowanie_danych_SIM900();
1464:main_sim900.h ****           wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1;
1465:main_sim900.h ****           wysylane_dane_RAM_SIM900[0] = '\0';
1466:main_sim900.h ****           wyslij_polecenie_RAM_SIM900();
1467:main_sim900.h ****         } else
1468:main_sim900.h ****           reset_modulu_SIM900();
1469:main_sim900.h ****       }
1470:main_sim900.h ****       licznik_odebranych_znakow = 0;
 6864               		.loc 2 1470 0
 6865 246e 1092 0000 		sts licznik_odebranych_znakow.3484+1,__zero_reg__
 6866 2472 1092 0000 		sts licznik_odebranych_znakow.3484,__zero_reg__
 6867               	.L737:
 6868               	.LBE613:
1471:main_sim900.h ****     } else if (aktualnie_wysylane_polecenie_SIM900 !=
1472:main_sim900.h ****                    KOMENDA_KOLEJKI_BRAK_KOMENDY &&
1473:main_sim900.h ****                trwa_rozmowa_przychodzaca_od_uzytkownika &&
1474:main_sim900.h ****                czy_jest_bezczynny_SIM900()) {
1475:main_sim900.h ****       {
1476:main_sim900.h ****         cli();
1477:main_sim900.h ****         const uint l = liczba_odebranych_znakow_SIM900;
1478:main_sim900.h ****         sei();
1479:main_sim900.h ****         if (licznik_odebranych_znakow < l)
1480:main_sim900.h ****           licznik_odebranych_znakow = l;
1481:main_sim900.h ****       }
1482:main_sim900.h ****       if (licznik_odebranych_znakow >=
1483:main_sim900.h ****           MIN_LICZBA_ODEBRANYCH_ZNAKOW_KONCZACYCH_ROZMOWE_W_TRAKCIE_PODSLUCHU) {
1484:main_sim900.h ****         if (++licznik_poprzednia_komenda >= 5 * 100) // 5 sek
1485:main_sim900.h ****         {
1486:main_sim900.h ****           licznik_poprzednia_komenda = 0;
1487:main_sim900.h ****           zakonczono_rozmowe_telefoniczna(
1488:main_sim900.h ****               powod_zakonczenia_rozmowy_zakonczenie);
1489:main_sim900.h ****           licznik_odebranych_znakow = 0;
1490:main_sim900.h ****           POMOC_DODAJ2('#', 'q');
1491:main_sim900.h ****           reset_modulu_SIM900();
1492:main_sim900.h ****         }
1493:main_sim900.h ****       }
1494:main_sim900.h ****     } else {
1495:main_sim900.h ****       licznik_poprzednia_komenda = 0;
1496:main_sim900.h ****       if (!trwa_rozmowa_przychodzaca_od_uzytkownika)
1497:main_sim900.h ****         licznik_odebranych_znakow = 0;
1498:main_sim900.h ****     }
1499:main_sim900.h **** 
1500:main_sim900.h ****     poprzednia_komenda = aktualnie_wysylane_polecenie_SIM900;
 6869               		.loc 2 1500 0
 6870 2476 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 6871 247a 8093 0000 		sts poprzednia_komenda.3482,r24
 6872               	/* epilogue start */
 6873               	.LBE612:
1501:main_sim900.h ****   }
1502:main_sim900.h **** }
 6874               		.loc 2 1502 0
 6875 247e 0895      		ret
 6876               	.L720:
1384:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_KOMENDA_SIM900);
 6877               		.loc 2 1384 0 discriminator 1
 6878 2480 0E94 0000 		call czy_jest_nowa_komenda_SIM900
 6879               	.LVL525:
 6880 2484 8111      		cpse r24,__zero_reg__
 6881 2486 00C0      		rjmp .L722
 6882 2488 00C0      		rjmp .L721
 6883               	.L725:
 6884               	.LVL526:
 6885               	.LBB616:
1400:main_sim900.h ****         komenda_SIM900 = ERROR_KOMENDA_SIM900;
 6886               		.loc 2 1400 0
 6887 248a 1092 0000 		sts licznik_bezpieczenstwa.3481+1,__zero_reg__
 6888 248e 1092 0000 		sts licznik_bezpieczenstwa.3481,__zero_reg__
1401:main_sim900.h ****         obsluga_wysylania_sms();
 6889               		.loc 2 1401 0
 6890 2492 84E0      		ldi r24,lo8(4)
 6891 2494 8093 0000 		sts komenda_SIM900,r24
1402:main_sim900.h ****       }
 6892               		.loc 2 1402 0
 6893 2498 0E94 0000 		call obsluga_wysylania_sms
 6894               	.LVL527:
 6895 249c 00C0      		rjmp .L726
 6896               	.LVL528:
 6897               	.L724:
1405:main_sim900.h ****   }
 6898               		.loc 2 1405 0
 6899 249e 1092 0000 		sts licznik_bezpieczenstwa.3481+1,__zero_reg__
 6900 24a2 1092 0000 		sts licznik_bezpieczenstwa.3481,__zero_reg__
 6901 24a6 00C0      		rjmp .L726
 6902               	.LVL529:
 6903               	.L732:
 6904               	.LBE616:
 6905               	.LBB617:
 6906               	.LBB614:
1431:main_sim900.h ****         POMOC_DODAJ2('#', 'r');
 6907               		.loc 2 1431 0
 6908 24a8 1092 0000 		sts licznik_poprzednia_komenda.3483+1,__zero_reg__
 6909 24ac 1092 0000 		sts licznik_poprzednia_komenda.3483,__zero_reg__
 6910               	.LVL530:
1435:main_sim900.h ****             KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1) {
 6911               		.loc 2 1435 0
 6912 24b0 8D3F      		cpi r24,lo8(-3)
 6913 24b2 01F0      		breq .L734
1437:main_sim900.h ****                   KOMENDA_KOLEJKI_ODRZUC_ROZMOWE ||
 6914               		.loc 2 1437 0
 6915 24b4 8739      		cpi r24,lo8(-105)
 6916 24b6 01F0      		breq .L735
1438:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
 6917               		.loc 2 1438 0
 6918 24b8 92E7      		ldi r25,lo8(114)
 6919 24ba 980F      		add r25,r24
 6920 24bc 9230      		cpi r25,lo8(2)
 6921 24be 00F0      		brlo .L735
1442:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
 6922               		.loc 2 1442 0
 6923 24c0 9CE6      		ldi r25,lo8(108)
 6924 24c2 980F      		add r25,r24
 6925 24c4 9230      		cpi r25,lo8(2)
 6926 24c6 00F0      		brlo .L735
1448:main_sim900.h ****                aktualnie_wysylane_polecenie_SIM900 <=
 6927               		.loc 2 1448 0
 6928 24c8 91E6      		ldi r25,lo8(97)
 6929 24ca 980F      		add r25,r24
1446:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
 6930               		.loc 2 1446 0
 6931 24cc 9A30      		cpi r25,lo8(10)
 6932 24ce 00F0      		brlo .L735
1450:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
 6933               		.loc 2 1450 0
 6934 24d0 96E5      		ldi r25,lo8(86)
 6935 24d2 980F      		add r25,r24
 6936 24d4 9832      		cpi r25,lo8(40)
 6937 24d6 00F0      		brlo .L735
1462:main_sim900.h ****           wyzerowanie_danych_SIM900();
 6938               		.loc 2 1462 0
 6939 24d8 1092 0000 		sts nastepne_wysylane_polecenie_SIM900,__zero_reg__
 6940               	.L736:
1463:main_sim900.h ****           wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1;
 6941               		.loc 2 1463 0
 6942 24dc 0E94 0000 		call wyzerowanie_danych_SIM900
 6943               	.LVL531:
1464:main_sim900.h ****           wysylane_dane_RAM_SIM900[0] = '\0';
 6944               		.loc 2 1464 0
 6945 24e0 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6946 24e4 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6947 24e8 8DEF      		ldi r24,lo8(-3)
 6948 24ea 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1465:main_sim900.h ****           wyslij_polecenie_RAM_SIM900();
 6949               		.loc 2 1465 0
 6950 24ee 1092 0000 		sts wysylany_blok_SIM900+2,__zero_reg__
1466:main_sim900.h ****         } else
 6951               		.loc 2 1466 0
 6952 24f2 0E94 0000 		call wyslij_polecenie_RAM_SIM900
 6953               	.LVL532:
 6954 24f6 00C0      		rjmp .L733
 6955               	.LVL533:
 6956               	.L735:
1459:main_sim900.h ****                 aktualnie_wysylane_polecenie_SIM900;
 6957               		.loc 2 1459 0
 6958 24f8 8093 0000 		sts nastepne_wysylane_polecenie_SIM900,r24
 6959 24fc 00C0      		rjmp .L736
 6960               	.L734:
1468:main_sim900.h ****       }
 6961               		.loc 2 1468 0
 6962 24fe 0E94 0000 		call reset_modulu_SIM900
 6963               	.LVL534:
 6964 2502 00C0      		rjmp .L733
 6965               	.LVL535:
 6966               	.L728:
 6967               	.LBE614:
1472:main_sim900.h ****                trwa_rozmowa_przychodzaca_od_uzytkownika &&
 6968               		.loc 2 1472 0
 6969 2504 9923      		tst r25
 6970 2506 01F0      		breq .L727
 6971               	.L729:
1474:main_sim900.h ****       {
 6972               		.loc 2 1474 0
 6973 2508 8091 0000 		lds r24,komenda_SIM900
1473:main_sim900.h ****                czy_jest_bezczynny_SIM900()) {
 6974               		.loc 2 1473 0
 6975 250c 8111      		cpse r24,__zero_reg__
 6976 250e 00C0      		rjmp .L727
 6977               	.LBB615:
1476:main_sim900.h ****         const uint l = liczba_odebranych_znakow_SIM900;
 6978               		.loc 2 1476 0
 6979               	/* #APP */
 6980               	 ;  1476 "main_sim900.h" 1
 6981 2510 F894      		cli
 6982               	 ;  0 "" 2
1477:main_sim900.h ****         sei();
 6983               		.loc 2 1477 0
 6984               	/* #NOAPP */
 6985 2512 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 6986 2516 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
 6987               	.LVL536:
1478:main_sim900.h ****         if (licznik_odebranych_znakow < l)
 6988               		.loc 2 1478 0
 6989               	/* #APP */
 6990               	 ;  1478 "main_sim900.h" 1
 6991 251a 7894      		sei
 6992               	 ;  0 "" 2
1479:main_sim900.h ****           licznik_odebranych_znakow = l;
 6993               		.loc 2 1479 0
 6994               	/* #NOAPP */
 6995 251c 2091 0000 		lds r18,licznik_odebranych_znakow.3484
 6996 2520 3091 0000 		lds r19,licznik_odebranych_znakow.3484+1
 6997 2524 2817      		cp r18,r24
 6998 2526 3907      		cpc r19,r25
 6999 2528 00F4      		brsh .L738
1480:main_sim900.h ****       }
 7000               		.loc 2 1480 0
 7001 252a 9093 0000 		sts licznik_odebranych_znakow.3484+1,r25
 7002 252e 8093 0000 		sts licznik_odebranych_znakow.3484,r24
 7003               	.L738:
 7004               	.LBE615:
1482:main_sim900.h ****           MIN_LICZBA_ODEBRANYCH_ZNAKOW_KONCZACYCH_ROZMOWE_W_TRAKCIE_PODSLUCHU) {
 7005               		.loc 2 1482 0
 7006 2532 8091 0000 		lds r24,licznik_odebranych_znakow.3484
 7007 2536 9091 0000 		lds r25,licznik_odebranych_znakow.3484+1
 7008               	.LVL537:
 7009 253a 0A97      		sbiw r24,10
 7010 253c 00F4      		brsh .+2
 7011 253e 00C0      		rjmp .L737
1484:main_sim900.h ****         {
 7012               		.loc 2 1484 0
 7013 2540 8091 0000 		lds r24,licznik_poprzednia_komenda.3483
 7014 2544 9091 0000 		lds r25,licznik_poprzednia_komenda.3483+1
 7015 2548 0196      		adiw r24,1
 7016 254a 843F      		cpi r24,-12
 7017 254c 21E0      		ldi r18,1
 7018 254e 9207      		cpc r25,r18
 7019 2550 00F4      		brsh .L740
 7020 2552 9093 0000 		sts licznik_poprzednia_komenda.3483+1,r25
 7021 2556 8093 0000 		sts licznik_poprzednia_komenda.3483,r24
 7022 255a 00C0      		rjmp .L737
 7023               	.L740:
1486:main_sim900.h ****           zakonczono_rozmowe_telefoniczna(
 7024               		.loc 2 1486 0
 7025 255c 1092 0000 		sts licznik_poprzednia_komenda.3483+1,__zero_reg__
 7026 2560 1092 0000 		sts licznik_poprzednia_komenda.3483,__zero_reg__
1487:main_sim900.h ****               powod_zakonczenia_rozmowy_zakonczenie);
 7027               		.loc 2 1487 0
 7028 2564 81E0      		ldi r24,lo8(1)
 7029 2566 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 7030               	.LVL538:
1489:main_sim900.h ****           POMOC_DODAJ2('#', 'q');
 7031               		.loc 2 1489 0
 7032 256a 1092 0000 		sts licznik_odebranych_znakow.3484+1,__zero_reg__
 7033 256e 1092 0000 		sts licznik_odebranych_znakow.3484,__zero_reg__
 7034               	.LVL539:
1491:main_sim900.h ****         }
 7035               		.loc 2 1491 0
 7036 2572 0E94 0000 		call reset_modulu_SIM900
 7037               	.LVL540:
 7038 2576 00C0      		rjmp .L737
 7039               	.LVL541:
 7040               	.L727:
1495:main_sim900.h ****       if (!trwa_rozmowa_przychodzaca_od_uzytkownika)
 7041               		.loc 2 1495 0
 7042 2578 1092 0000 		sts licznik_poprzednia_komenda.3483+1,__zero_reg__
 7043 257c 1092 0000 		sts licznik_poprzednia_komenda.3483,__zero_reg__
1496:main_sim900.h ****         licznik_odebranych_znakow = 0;
 7044               		.loc 2 1496 0
 7045 2580 9923      		tst r25
 7046 2582 01F4      		brne .+2
 7047 2584 00C0      		rjmp .L733
 7048 2586 00C0      		rjmp .L737
 7049               	.LBE617:
 7050               		.cfi_endproc
 7051               	.LFE56:
 7053               	.global	wykonanie_komend_powiadomien
 7055               	wykonanie_komend_powiadomien:
 7056               	.LFB60:
1353:main.c        ****   const komenda_typ aktualnie_wykonywana_komenda = komendy_kolejka[0];
 7057               		.loc 1 1353 0
 7058               		.cfi_startproc
 7059 2588 BF92      		push r11
 7060               	.LCFI79:
 7061               		.cfi_def_cfa_offset 3
 7062               		.cfi_offset 11, -2
 7063 258a CF92      		push r12
 7064               	.LCFI80:
 7065               		.cfi_def_cfa_offset 4
 7066               		.cfi_offset 12, -3
 7067 258c DF92      		push r13
 7068               	.LCFI81:
 7069               		.cfi_def_cfa_offset 5
 7070               		.cfi_offset 13, -4
 7071 258e EF92      		push r14
 7072               	.LCFI82:
 7073               		.cfi_def_cfa_offset 6
 7074               		.cfi_offset 14, -5
 7075 2590 FF92      		push r15
 7076               	.LCFI83:
 7077               		.cfi_def_cfa_offset 7
 7078               		.cfi_offset 15, -6
 7079 2592 0F93      		push r16
 7080               	.LCFI84:
 7081               		.cfi_def_cfa_offset 8
 7082               		.cfi_offset 16, -7
 7083 2594 1F93      		push r17
 7084               	.LCFI85:
 7085               		.cfi_def_cfa_offset 9
 7086               		.cfi_offset 17, -8
 7087 2596 CF93      		push r28
 7088               	.LCFI86:
 7089               		.cfi_def_cfa_offset 10
 7090               		.cfi_offset 28, -9
 7091 2598 DF93      		push r29
 7092               	.LCFI87:
 7093               		.cfi_def_cfa_offset 11
 7094               		.cfi_offset 29, -10
 7095               	/* prologue: function */
 7096               	/* frame size = 0 */
 7097               	/* stack size = 9 */
 7098               	.L__stack_usage = 9
1354:main.c        **** 
 7099               		.loc 1 1354 0
 7100 259a 8091 0000 		lds r24,komendy_kolejka
 7101               	.LVL542:
1361:main.c        **** 
 7102               		.loc 1 1361 0
 7103 259e 9091 0000 		lds r25,flaga_odczytywanie_smsa
 7104 25a2 9111      		cpse r25,__zero_reg__
 7105 25a4 00C0      		rjmp .L769
1357:main.c        ****       wykonywanie_rozmowy_telefonicznej ||
 7106               		.loc 1 1357 0
 7107 25a6 9091 0000 		lds r25,flaga_wysylanie_smsa
 7108 25aa 9111      		cpse r25,__zero_reg__
 7109 25ac 00C0      		rjmp .L769
1357:main.c        ****       wykonywanie_rozmowy_telefonicznej ||
 7110               		.loc 1 1357 0 is_stmt 0 discriminator 1
 7111 25ae 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 7112 25b2 9111      		cpse r25,__zero_reg__
 7113 25b4 00C0      		rjmp .L769
1358:main.c        ****       trwa_rozmowa_przychodzaca_od_uzytkownika ||
 7114               		.loc 1 1358 0 is_stmt 1
 7115 25b6 9091 0000 		lds r25,trwa_rozmowa_przychodzaca_od_uzytkownika
 7116 25ba 9111      		cpse r25,__zero_reg__
 7117 25bc 00C0      		rjmp .L769
1359:main.c        ****       aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
 7118               		.loc 1 1359 0
 7119 25be 9091 0000 		lds r25,aktualnie_wysylane_polecenie_SIM900
 7120 25c2 9111      		cpse r25,__zero_reg__
 7121 25c4 00C0      		rjmp .L769
1360:main.c        ****       opoznienie_SIM900_100MS || czekanie_na_odebranie_zachety;
 7122               		.loc 1 1360 0
 7123 25c6 9091 0000 		lds r25,opoznienie_SIM900_100MS
 7124 25ca 9111      		cpse r25,__zero_reg__
 7125 25cc 00C0      		rjmp .L769
1361:main.c        **** 
 7126               		.loc 1 1361 0 discriminator 2
 7127 25ce 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 7128 25d2 21E0      		ldi r18,lo8(1)
 7129 25d4 30E0      		ldi r19,0
 7130 25d6 9111      		cpse r25,__zero_reg__
 7131 25d8 00C0      		rjmp .L768
 7132 25da 30E0      		ldi r19,0
 7133 25dc 20E0      		ldi r18,0
 7134               	.L768:
 7135               	.LVL543:
1364:main.c        ****       czy_jest_bezczynny_SIM900();
 7136               		.loc 1 1364 0 discriminator 2
 7137 25de 232B      		or r18,r19
 7138 25e0 01F4      		brne .L769
 7139               	.LVL544:
1364:main.c        ****       czy_jest_bezczynny_SIM900();
 7140               		.loc 1 1364 0 is_stmt 0 discriminator 1
 7141 25e2 9091 C100 		lds r25,193
 7142 25e6 96FD      		sbrc r25,6
 7143 25e8 00C0      		rjmp .L769
1364:main.c        ****       czy_jest_bezczynny_SIM900();
 7144               		.loc 1 1364 0 discriminator 3
 7145 25ea 9091 0000 		lds r25,podlaczony_modul_gsm_SIM900
 7146 25ee 9923      		tst r25
 7147 25f0 01F0      		breq .L769
1365:main.c        **** 
 7148               		.loc 1 1365 0 is_stmt 1 discriminator 5
 7149 25f2 9091 0000 		lds r25,komenda_SIM900
1364:main.c        ****       czy_jest_bezczynny_SIM900();
 7150               		.loc 1 1364 0 discriminator 5
 7151 25f6 9923      		tst r25
 7152 25f8 01F4      		brne .+2
 7153 25fa 00C0      		rjmp .L770
 7154               	.LVL545:
 7155               	.L769:
1367:main.c        ****   case KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW: {
 7156               		.loc 1 1367 0
 7157 25fc 8938      		cpi r24,lo8(-119)
 7158 25fe 01F0      		breq .+2
 7159 2600 00C0      		rjmp .L805
 7160 2602 00C0      		rjmp .L771
 7161               	.LVL546:
 7162               	.L803:
 7163               	.LBB618:
1374:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
 7164               		.loc 1 1374 0
 7165 2604 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 7166 2608 8111      		cpse r24,__zero_reg__
 7167 260a 00C0      		rjmp .L771
1374:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
 7168               		.loc 1 1374 0 is_stmt 0 discriminator 2
 7169 260c 8091 0000 		lds r24,liczba_znakow_do_zapisu
 7170 2610 8111      		cpse r24,__zero_reg__
 7171 2612 00C0      		rjmp .L771
1374:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
 7172               		.loc 1 1374 0 discriminator 4
 7173 2614 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 7174 2618 8111      		cpse r24,__zero_reg__
 7175 261a 00C0      		rjmp .L771
1374:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
 7176               		.loc 1 1374 0 discriminator 6
 7177 261c F999      		sbic 0x1f,1
 7178 261e 00C0      		rjmp .L771
 7179               	.LVL547:
1376:main.c        ****     for (;;) {
 7180               		.loc 1 1376 0 is_stmt 1
 7181 2620 8AE2      		ldi r24,lo8(42)
 7182 2622 8093 0000 		sts tekst_wysylanego_smsa,r24
 7183 2626 00E0      		ldi r16,lo8(tekst_wysylanego_smsa+1)
 7184 2628 10E0      		ldi r17,hi8(tekst_wysylanego_smsa+1)
 7185               	.LVL548:
1378:main.c        ****               numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama)) {
 7186               		.loc 1 1378 0
 7187 262a 85E0      		ldi r24,lo8(5)
 7188 262c D82E      		mov r13,r24
1384:main.c        ****         *sms++ = '\n';
 7189               		.loc 1 1384 0
 7190 262e 93E2      		ldi r25,lo8(35)
 7191 2630 C92E      		mov r12,r25
1385:main.c        ****         ++numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama;
 7192               		.loc 1 1385 0
 7193 2632 2AE0      		ldi r18,lo8(10)
 7194 2634 B22E      		mov r11,r18
 7195               	.LVL549:
 7196               	.L773:
1378:main.c        ****               numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama)) {
 7197               		.loc 1 1378 0
 7198 2636 C091 0000 		lds r28,numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama
 7199 263a CD9D      		mul r28,r13
 7200 263c 7001      		movw r14,r0
 7201 263e 1124      		clr __zero_reg__
 7202 2640 88E0      		ldi r24,8
 7203 2642 E80E      		add r14,r24
 7204 2644 F11C      		adc r15,__zero_reg__
 7205 2646 C701      		movw r24,r14
 7206 2648 0E94 0000 		call eeprom_read_byte
 7207               	.LVL550:
 7208 264c 8F3F      		cpi r24,lo8(-1)
 7209 264e 01F0      		breq .L774
1380:main.c        ****             (void *)EEPROM_NUMER_TELEFONU_BRAMA(
 7210               		.loc 1 1380 0
 7211 2650 4FEF      		ldi r20,lo8(-1)
 7212 2652 B801      		movw r22,r16
 7213 2654 C701      		movw r24,r14
 7214 2656 0E94 0000 		call kopiuj_blok_eeprom_na_telefon
 7215               	.LVL551:
 7216 265a E801      		movw r28,r16
 7217 265c C80F      		add r28,r24
 7218 265e D11D      		adc r29,__zero_reg__
 7219               	.LVL552:
1384:main.c        ****         *sms++ = '\n';
 7220               		.loc 1 1384 0
 7221 2660 C882      		st Y,r12
1385:main.c        ****         ++numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama;
 7222               		.loc 1 1385 0
 7223 2662 8E01      		movw r16,r28
 7224 2664 0E5F      		subi r16,-2
 7225 2666 1F4F      		sbci r17,-1
 7226               	.LVL553:
 7227 2668 B982      		std Y+1,r11
1386:main.c        ****         if ((sms + MAX_LICZBA_ZNAKOW_TELEFON + 1 >=
 7228               		.loc 1 1386 0
 7229 266a 8091 0000 		lds r24,numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama
 7230 266e 8F5F      		subi r24,lo8(-(1))
 7231 2670 8093 0000 		sts numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama,r24
1387:main.c        ****              &tekst_wysylanego_smsa[MAX_LICZBA_ZNAKOW_SMS]) ||
 7232               		.loc 1 1387 0
 7233 2674 9E01      		movw r18,r28
 7234 2676 2D5E      		subi r18,-19
 7235 2678 3F4F      		sbci r19,-1
 7236 267a 2050      		subi r18,lo8(tekst_wysylanego_smsa+160)
 7237 267c 3040      		sbci r19,hi8(tekst_wysylanego_smsa+160)
 7238 267e 00F4      		brsh .L775
1388:main.c        ****             (numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama >=
 7239               		.loc 1 1388 0
 7240 2680 8F3F      		cpi r24,lo8(-1)
 7241 2682 01F4      		brne .L773
 7242               	.L776:
1394:main.c        ****           dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 7243               		.loc 1 1394 0
 7244 2684 1A82      		std Y+2,__zero_reg__
1395:main.c        ****           wysylanie_smsa_clipa = WYSYLANIE_SMSA_WYSYLANIE;
 7245               		.loc 1 1395 0
 7246 2686 83ED      		ldi r24,lo8(-45)
 7247 2688 0E94 0000 		call dodaj_komende
 7248               	.LVL554:
1396:main.c        ****           break;
 7249               		.loc 1 1396 0
 7250 268c 81E0      		ldi r24,lo8(1)
 7251 268e 8093 0000 		sts wysylanie_smsa_clipa,r24
 7252 2692 00C0      		rjmp .L806
 7253               	.L775:
1391:main.c        ****                MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER))
 7254               		.loc 1 1391 0
 7255 2694 8F3F      		cpi r24,lo8(-1)
 7256 2696 01F0      		breq .L776
1393:main.c        ****           *sms = '\0';
 7257               		.loc 1 1393 0
 7258 2698 89E8      		ldi r24,lo8(-119)
 7259 269a 0E94 0000 		call dodaj_komende
 7260               	.LVL555:
 7261 269e 00C0      		rjmp .L776
 7262               	.L774:
1400:main.c        ****             MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER) {
 7263               		.loc 1 1400 0
 7264 26a0 CF5F      		subi r28,lo8(-(1))
 7265 26a2 C093 0000 		sts numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama,r28
 7266 26a6 CF3F      		cpi r28,lo8(-1)
 7267 26a8 01F4      		brne .L773
1402:main.c        ****             *sms = '\0';
 7268               		.loc 1 1402 0
 7269 26aa E0E0      		ldi r30,hi8(tekst_wysylanego_smsa)
 7270 26ac 0030      		cpi r16,lo8(tekst_wysylanego_smsa)
 7271 26ae 1E07      		cpc r17,r30
 7272 26b0 01F0      		breq .L766
1403:main.c        ****             dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 7273               		.loc 1 1403 0
 7274 26b2 F801      		movw r30,r16
 7275 26b4 1082      		st Z,__zero_reg__
1404:main.c        ****             wysylanie_smsa_clipa = WYSYLANIE_SMSA_WYSYLANIE;
 7276               		.loc 1 1404 0
 7277 26b6 83ED      		ldi r24,lo8(-45)
 7278 26b8 0E94 0000 		call dodaj_komende
 7279               	.LVL556:
1405:main.c        ****           }
 7280               		.loc 1 1405 0
 7281 26bc 81E0      		ldi r24,lo8(1)
 7282 26be 8093 0000 		sts wysylanie_smsa_clipa,r24
 7283 26c2 00C0      		rjmp .L766
 7284               	.LVL557:
 7285               	.L778:
1369:main.c        ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 7286               		.loc 1 1369 0
 7287 26c4 8091 0000 		lds r24,wysylanie_smsa_clipa
 7288               	.LVL558:
 7289 26c8 8823      		tst r24
 7290 26ca 01F4      		brne .+2
 7291 26cc 00C0      		rjmp .L803
 7292               	.LVL559:
 7293               	.L771:
1371:main.c        ****       break;
 7294               		.loc 1 1371 0
 7295 26ce 89E8      		ldi r24,lo8(-119)
 7296 26d0 0E94 0000 		call dodaj_komende
 7297               	.LVL560:
 7298               	.L806:
 7299               	.LBE618:
1416:main.c        **** }
 7300               		.loc 1 1416 0
 7301 26d4 CFEF      		ldi r28,lo8(-1)
 7302               	.L766:
1417:main.c        **** 
 7303               		.loc 1 1417 0
 7304 26d6 8C2F      		mov r24,r28
 7305               	/* epilogue start */
 7306 26d8 DF91      		pop r29
 7307 26da CF91      		pop r28
 7308 26dc 1F91      		pop r17
 7309 26de 0F91      		pop r16
 7310 26e0 FF90      		pop r15
 7311 26e2 EF90      		pop r14
 7312 26e4 DF90      		pop r13
 7313 26e6 CF90      		pop r12
 7314 26e8 BF90      		pop r11
 7315 26ea 0895      		ret
 7316               	.LVL561:
 7317               	.L770:
1367:main.c        ****   case KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW: {
 7318               		.loc 1 1367 0
 7319 26ec 8938      		cpi r24,lo8(-119)
 7320 26ee 01F0      		breq .L778
 7321               	.LVL562:
 7322               	.L805:
1414:main.c        ****   }
 7323               		.loc 1 1414 0
 7324 26f0 C0E0      		ldi r28,0
 7325 26f2 00C0      		rjmp .L766
 7326               		.cfi_endproc
 7327               	.LFE60:
 7329               	.global	test_sms_clip_100ms
 7331               	test_sms_clip_100ms:
 7332               	.LFB62:
1431:main.c        ****   // static ulong licznik_sms;
 7333               		.loc 1 1431 0
 7334               		.cfi_startproc
 7335               	/* prologue: function */
 7336               	/* frame size = 0 */
 7337               	/* stack size = 0 */
 7338               	.L__stack_usage = 0
 7339               	/* epilogue start */
1450:main.c        **** 
 7340               		.loc 1 1450 0
 7341 26f4 0895      		ret
 7342               		.cfi_endproc
 7343               	.LFE62:
 7345               	.global	steruj_wejscia_wyjscia_100ms
 7347               	steruj_wejscia_wyjscia_100ms:
 7348               	.LFB63:
1452:main.c        ****   aktualizuj_stan_wyzwolenia_wejsc_100ms();
 7349               		.loc 1 1452 0
 7350               		.cfi_startproc
 7351               	/* prologue: function */
 7352               	/* frame size = 0 */
 7353               	/* stack size = 0 */
 7354               	.L__stack_usage = 0
1453:main.c        ****   steruj_wejsciem_reset_100ms();
 7355               		.loc 1 1453 0
 7356 26f6 0E94 0000 		call aktualizuj_stan_wyzwolenia_wejsc_100ms
 7357               	.LVL563:
1454:main.c        ****   steruj_wyjscia_100ms();
 7358               		.loc 1 1454 0
 7359 26fa 0E94 0000 		call steruj_wejsciem_reset_100ms
 7360               	.LVL564:
1455:main.c        **** }
 7361               		.loc 1 1455 0
 7362 26fe 0C94 0000 		jmp steruj_wyjscia_100ms
 7363               	.LVL565:
 7364               		.cfi_endproc
 7365               	.LFE63:
 7367               	.global	zapis_w_eeprom_stanu_wyjsc
 7369               	zapis_w_eeprom_stanu_wyjsc:
 7370               	.LFB64:
1458:main.c        ****   if (not czy_wolny_eeprom())
 7371               		.loc 1 1458 0
 7372               		.cfi_startproc
 7373 2702 CF93      		push r28
 7374               	.LCFI88:
 7375               		.cfi_def_cfa_offset 3
 7376               		.cfi_offset 28, -2
 7377 2704 DF93      		push r29
 7378               	.LCFI89:
 7379               		.cfi_def_cfa_offset 4
 7380               		.cfi_offset 29, -3
 7381 2706 1F92      		push __zero_reg__
 7382               	.LCFI90:
 7383               		.cfi_def_cfa_offset 5
 7384 2708 CDB7      		in r28,__SP_L__
 7385 270a DEB7      		in r29,__SP_H__
 7386               	.LCFI91:
 7387               		.cfi_def_cfa_register 28
 7388               	/* prologue: function */
 7389               	/* frame size = 1 */
 7390               	/* stack size = 3 */
 7391               	.L__stack_usage = 3
1459:main.c        ****     return;
 7392               		.loc 1 1459 0
 7393 270c 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 7394 2710 8111      		cpse r24,__zero_reg__
 7395 2712 00C0      		rjmp .L809
1459:main.c        ****     return;
 7396               		.loc 1 1459 0 is_stmt 0 discriminator 1
 7397 2714 8091 0000 		lds r24,liczba_znakow_do_zapisu
 7398 2718 8111      		cpse r24,__zero_reg__
 7399 271a 00C0      		rjmp .L809
1459:main.c        ****     return;
 7400               		.loc 1 1459 0 discriminator 2
 7401 271c 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 7402 2720 8111      		cpse r24,__zero_reg__
 7403 2722 00C0      		rjmp .L809
1459:main.c        ****     return;
 7404               		.loc 1 1459 0 discriminator 3
 7405 2724 F999      		sbic 0x1f,1
 7406 2726 00C0      		rjmp .L809
 7407               	.LBB621:
 7408               	.LBB622:
1461:main.c        ****   if ((stan_wyjscie[0] != 0) ^ (licznik_przelacznik_wyjscia[0] != 0))
 7409               		.loc 1 1461 0 is_stmt 1
 7410 2728 1982      		std Y+1,__zero_reg__
1462:main.c        ****     par |= BIT(0);
 7411               		.loc 1 1462 0
 7412 272a 91E0      		ldi r25,lo8(1)
 7413 272c 8091 0000 		lds r24,stan_wyjscie
 7414 2730 8111      		cpse r24,__zero_reg__
 7415 2732 00C0      		rjmp .L812
 7416 2734 90E0      		ldi r25,0
 7417               	.L812:
 7418 2736 81E0      		ldi r24,lo8(1)
 7419 2738 4091 0000 		lds r20,licznik_przelacznik_wyjscia
 7420 273c 5091 0000 		lds r21,licznik_przelacznik_wyjscia+1
 7421 2740 6091 0000 		lds r22,licznik_przelacznik_wyjscia+2
 7422 2744 7091 0000 		lds r23,licznik_przelacznik_wyjscia+3
 7423 2748 452B      		or r20,r21
 7424 274a 462B      		or r20,r22
 7425 274c 472B      		or r20,r23
 7426 274e 01F4      		brne .L813
 7427 2750 80E0      		ldi r24,0
 7428               	.L813:
 7429 2752 9817      		cp r25,r24
 7430 2754 01F0      		breq .L811
1463:main.c        ****   if (par != eeprom_read_byte((void *)EEPROM_USTAWIENIE_STANOW_WYJSC))
 7431               		.loc 1 1463 0
 7432 2756 81E0      		ldi r24,lo8(1)
 7433 2758 8983      		std Y+1,r24
 7434               	.L811:
1464:main.c        ****     zapisz_znaki_w_eeprom(&par, (uint)EEPROM_USTAWIENIE_STANOW_WYJSC, 1);
 7435               		.loc 1 1464 0
 7436 275a 85E0      		ldi r24,lo8(5)
 7437 275c 90E0      		ldi r25,0
 7438 275e 0E94 0000 		call eeprom_read_byte
 7439               	.LVL566:
 7440 2762 9981      		ldd r25,Y+1
 7441 2764 8917      		cp r24,r25
 7442 2766 01F0      		breq .L809
1465:main.c        **** }
 7443               		.loc 1 1465 0
 7444 2768 41E0      		ldi r20,lo8(1)
 7445 276a 65E0      		ldi r22,lo8(5)
 7446 276c 70E0      		ldi r23,0
 7447 276e CE01      		movw r24,r28
 7448 2770 0196      		adiw r24,1
 7449 2772 0E94 0000 		call zapisz_znaki_w_eeprom
 7450               	.LVL567:
 7451               	.L809:
 7452               	/* epilogue start */
 7453               	.LBE622:
 7454               	.LBE621:
1466:main.c        **** 
 7455               		.loc 1 1466 0
 7456 2776 0F90      		pop __tmp_reg__
 7457 2778 DF91      		pop r29
 7458 277a CF91      		pop r28
 7459 277c 0895      		ret
 7460               		.cfi_endproc
 7461               	.LFE64:
 7463               	.global	steruj_urzadzeniem_100MS
 7465               	steruj_urzadzeniem_100MS:
 7466               	.LFB65:
1481:main.c        ****   steruj_wejscia_wyjscia_100ms();
 7467               		.loc 1 1481 0
 7468               		.cfi_startproc
 7469               	/* prologue: function */
 7470               	/* frame size = 0 */
 7471               	/* stack size = 0 */
 7472               	.L__stack_usage = 0
1482:main.c        ****   steruj_SIM900_100MS();
 7473               		.loc 1 1482 0
 7474 277e 0E94 0000 		call steruj_wejscia_wyjscia_100ms
 7475               	.LVL568:
1483:main.c        ****   if (licznik_100ms_dioda_led) {
 7476               		.loc 1 1483 0
 7477 2782 0E94 0000 		call steruj_SIM900_100MS
 7478               	.LVL569:
1484:main.c        ****     if (--licznik_100ms_dioda_led == 0)
 7479               		.loc 1 1484 0
 7480 2786 8091 0000 		lds r24,licznik_100ms_dioda_led
 7481 278a 8823      		tst r24
 7482 278c 01F0      		breq .L816
1485:main.c        ****       ustaw_stan_led(FALSE);
 7483               		.loc 1 1485 0
 7484 278e 8150      		subi r24,lo8(-(-1))
 7485 2790 8093 0000 		sts licznik_100ms_dioda_led,r24
 7486 2794 8111      		cpse r24,__zero_reg__
 7487 2796 00C0      		rjmp .L817
1486:main.c        ****     else
 7488               		.loc 1 1486 0 discriminator 1
 7489 2798 409A      		sbi 0x8,0
 7490               	.L816:
1492:main.c        ****     --timer_report_user_100ms;
 7491               		.loc 1 1492 0
 7492 279a 8091 0000 		lds r24,timer_report_user_100ms
 7493 279e 9091 0000 		lds r25,timer_report_user_100ms+1
 7494 27a2 0097      		sbiw r24,0
 7495 27a4 01F0      		breq .L818
1493:main.c        ****     if (timer_report_user_100ms == 0) {
 7496               		.loc 1 1493 0
 7497 27a6 0197      		sbiw r24,1
 7498 27a8 9093 0000 		sts timer_report_user_100ms+1,r25
 7499 27ac 8093 0000 		sts timer_report_user_100ms,r24
1494:main.c        ****       // Okno czasowe minelo - resetuj licznik
 7500               		.loc 1 1494 0
 7501 27b0 892B      		or r24,r25
 7502 27b2 01F4      		brne .L819
 7503               	.L818:
1496:main.c        ****     }
 7504               		.loc 1 1496 0
 7505 27b4 1092 0000 		sts licznik_report_user,__zero_reg__
 7506               	.L819:
1506:main.c        ****   if (pierwsza_komenda != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 7507               		.loc 1 1506 0
 7508 27b8 8091 0000 		lds r24,komendy_kolejka
 7509               	.LVL570:
1507:main.c        ****     // Sprawdz czy pierwsza komenda to SMS - jesli tak i stoi zbyt dlugo,
 7510               		.loc 1 1507 0
 7511 27bc 8823      		tst r24
 7512 27be 01F4      		brne .+2
 7513 27c0 00C0      		rjmp .L820
1510:main.c        ****         pierwsza_komenda <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU) {
 7514               		.loc 1 1510 0
 7515 27c2 9DE2      		ldi r25,lo8(45)
 7516 27c4 980F      		add r25,r24
 7517 27c6 9230      		cpi r25,lo8(2)
 7518 27c8 00F0      		brlo .+2
 7519 27ca 00C0      		rjmp .L821
1513:main.c        ****         // Ta sama komenda SMS jest na poczatku kolejki - kolejka moze stac
 7520               		.loc 1 1513 0
 7521 27cc 9091 0000 		lds r25,ostatnia_pierwsza_komenda
 7522 27d0 9813      		cpse r25,r24
 7523 27d2 00C0      		rjmp .L821
1515:main.c        ****           ++licznik_kolejka_stoi_100ms;
 7524               		.loc 1 1515 0
 7525 27d4 8091 0000 		lds r24,licznik_kolejka_stoi_100ms
 7526 27d8 9091 0000 		lds r25,licznik_kolejka_stoi_100ms+1
 7527               	.LVL571:
 7528 27dc 8639      		cpi r24,-106
 7529 27de 9105      		cpc r25,__zero_reg__
 7530 27e0 00F0      		brlo .+2
 7531 27e2 00C0      		rjmp .L823
1516:main.c        ****         else {
 7532               		.loc 1 1516 0
 7533 27e4 0196      		adiw r24,1
 7534 27e6 9093 0000 		sts licznik_kolejka_stoi_100ms+1,r25
 7535 27ea 8093 0000 		sts licznik_kolejka_stoi_100ms,r24
 7536               	.LVL572:
 7537               	.L824:
1555:main.c        ****     if (licznik_watchdog_wysylanie_smsa_100ms < WATCHDOG_WYSYLANIA_SMS_100MS) {
 7538               		.loc 1 1555 0
 7539 27ee 8091 0000 		lds r24,flaga_wysylanie_smsa
 7540 27f2 8823      		tst r24
 7541 27f4 01F4      		brne .+2
 7542 27f6 00C0      		rjmp .L826
1556:main.c        ****       ++licznik_watchdog_wysylanie_smsa_100ms;
 7543               		.loc 1 1556 0
 7544 27f8 8091 0000 		lds r24,licznik_watchdog_wysylanie_smsa_100ms
 7545 27fc 9091 0000 		lds r25,licznik_watchdog_wysylanie_smsa_100ms+1
 7546 2800 8C32      		cpi r24,44
 7547 2802 21E0      		ldi r18,1
 7548 2804 9207      		cpc r25,r18
 7549 2806 00F0      		brlo .+2
 7550 2808 00C0      		rjmp .L827
1557:main.c        ****     } else {
 7551               		.loc 1 1557 0
 7552 280a 0196      		adiw r24,1
 7553 280c 9093 0000 		sts licznik_watchdog_wysylanie_smsa_100ms+1,r25
 7554 2810 8093 0000 		sts licznik_watchdog_wysylanie_smsa_100ms,r24
 7555               	.L828:
1579:main.c        ****     if (watchdog_sms_licznik_100ms < WATCHDOG_SMS_TIMEOUT_100MS)
 7556               		.loc 1 1579 0
 7557 2814 8091 0000 		lds r24,watchdog_sms_aktywny
 7558 2818 8823      		tst r24
 7559 281a 01F4      		brne .+2
 7560 281c 00C0      		rjmp .L830
1580:main.c        ****       ++watchdog_sms_licznik_100ms;
 7561               		.loc 1 1580 0
 7562 281e 8091 0000 		lds r24,watchdog_sms_licznik_100ms
 7563 2822 9091 0000 		lds r25,watchdog_sms_licznik_100ms+1
 7564 2826 8436      		cpi r24,100
 7565 2828 9105      		cpc r25,__zero_reg__
 7566 282a 00F0      		brlo .+2
 7567 282c 00C0      		rjmp .L831
1581:main.c        ****     else {
 7568               		.loc 1 1581 0
 7569 282e 8091 0000 		lds r24,watchdog_sms_licznik_100ms
 7570 2832 9091 0000 		lds r25,watchdog_sms_licznik_100ms+1
 7571 2836 0196      		adiw r24,1
 7572 2838 9093 0000 		sts watchdog_sms_licznik_100ms+1,r25
 7573 283c 8093 0000 		sts watchdog_sms_licznik_100ms,r24
 7574               	.L832:
1594:main.c        ****     ++stan_cyklu_blysku;
 7575               		.loc 1 1594 0
 7576 2840 8091 0000 		lds r24,liczba_blyskow_led
 7577 2844 8823      		tst r24
 7578 2846 01F4      		brne .+2
 7579 2848 00C0      		rjmp .L834
1595:main.c        ****     if (stan_cyklu_blysku >= 6) {
 7580               		.loc 1 1595 0
 7581 284a 9091 0000 		lds r25,stan_cyklu_blysku
 7582 284e 9F5F      		subi r25,lo8(-(1))
 7583 2850 9093 0000 		sts stan_cyklu_blysku,r25
1596:main.c        ****       stan_cyklu_blysku = 0;
 7584               		.loc 1 1596 0
 7585 2854 9630      		cpi r25,lo8(6)
 7586 2856 00F0      		brlo .L835
1597:main.c        ****       --liczba_blyskow_led;
 7587               		.loc 1 1597 0
 7588 2858 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
1598:main.c        ****     }
 7589               		.loc 1 1598 0
 7590 285c 8150      		subi r24,lo8(-(-1))
 7591 285e 8093 0000 		sts liczba_blyskow_led,r24
 7592               	.L835:
1600:main.c        ****     return;
 7593               		.loc 1 1600 0
 7594 2862 8091 0000 		lds r24,stan_cyklu_blysku
 7595 2866 8230      		cpi r24,lo8(2)
 7596 2868 00F4      		brsh .+2
 7597 286a 00C0      		rjmp .L836
1600:main.c        ****     return;
 7598               		.loc 1 1600 0 is_stmt 0 discriminator 1
 7599 286c 409A      		sbi 0x8,0
 7600 286e 0895      		ret
 7601               	.L817:
1488:main.c        ****   }
 7602               		.loc 1 1488 0 is_stmt 1 discriminator 2
 7603 2870 4098      		cbi 0x8,0
 7604 2872 00C0      		rjmp .L816
 7605               	.LVL573:
 7606               	.L823:
1520:main.c        ****                                        KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
 7607               		.loc 1 1520 0
 7608 2874 64ED      		ldi r22,lo8(-44)
 7609 2876 83ED      		ldi r24,lo8(-45)
 7610 2878 0E94 0000 		call filtruj_komendy_z_przedzialu
 7611               	.LVL574:
1522:main.c        ****             ++licznik_awaryjnych_resetow_kolejki;
 7612               		.loc 1 1522 0
 7613 287c 8091 0000 		lds r24,licznik_awaryjnych_resetow_kolejki
 7614 2880 9091 0000 		lds r25,licznik_awaryjnych_resetow_kolejki+1
 7615 2884 8F3F      		cpi r24,-1
 7616 2886 9807      		cpc r25,r24
 7617 2888 01F0      		breq .L825
1523:main.c        **** 
 7618               		.loc 1 1523 0
 7619 288a 0196      		adiw r24,1
 7620 288c 9093 0000 		sts licznik_awaryjnych_resetow_kolejki+1,r25
 7621 2890 8093 0000 		sts licznik_awaryjnych_resetow_kolejki,r24
 7622               	.L825:
1525:main.c        **** 
 7623               		.loc 1 1525 0
 7624 2894 82E9      		ldi r24,lo8(-110)
 7625 2896 0E94 0000 		call filtruj_i_dodaj_komende
 7626               	.LVL575:
1528:main.c        ****           timer_report_user_100ms = 0;
 7627               		.loc 1 1528 0
 7628 289a 1092 0000 		sts licznik_report_user,__zero_reg__
1529:main.c        **** 
 7629               		.loc 1 1529 0
 7630 289e 1092 0000 		sts timer_report_user_100ms+1,__zero_reg__
 7631 28a2 1092 0000 		sts timer_report_user_100ms,__zero_reg__
1532:main.c        ****           ostatnia_pierwsza_komenda = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 7632               		.loc 1 1532 0
 7633 28a6 1092 0000 		sts licznik_kolejka_stoi_100ms+1,__zero_reg__
 7634 28aa 1092 0000 		sts licznik_kolejka_stoi_100ms,__zero_reg__
1533:main.c        **** 
 7635               		.loc 1 1533 0
 7636 28ae 1092 0000 		sts ostatnia_pierwsza_komenda,__zero_reg__
1536:main.c        ****         }
 7637               		.loc 1 1536 0
 7638 28b2 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
 7639 28b6 00C0      		rjmp .L824
 7640               	.LVL576:
 7641               	.L821:
1545:main.c        ****       licznik_kolejka_stoi_100ms = 0;
 7642               		.loc 1 1545 0
 7643 28b8 8093 0000 		sts ostatnia_pierwsza_komenda,r24
 7644               	.L865:
1551:main.c        ****   }
 7645               		.loc 1 1551 0
 7646 28bc 1092 0000 		sts licznik_kolejka_stoi_100ms+1,__zero_reg__
 7647 28c0 1092 0000 		sts licznik_kolejka_stoi_100ms,__zero_reg__
 7648 28c4 00C0      		rjmp .L824
 7649               	.L820:
1550:main.c        ****     licznik_kolejka_stoi_100ms = 0;
 7650               		.loc 1 1550 0
 7651 28c6 1092 0000 		sts ostatnia_pierwsza_komenda,__zero_reg__
 7652 28ca 00C0      		rjmp .L865
 7653               	.LVL577:
 7654               	.L827:
1559:main.c        ****       // Awaryjne odblokowanie
 7655               		.loc 1 1559 0
 7656 28cc 1092 0000 		sts licznik_watchdog_wysylanie_smsa_100ms+1,__zero_reg__
 7657 28d0 1092 0000 		sts licznik_watchdog_wysylanie_smsa_100ms,__zero_reg__
1561:main.c        ****       flaga_wysylanie_smsa = 0;
 7658               		.loc 1 1561 0
 7659 28d4 0E94 0000 		call watchdog_sms_disarm
 7660               	.LVL578:
1562:main.c        ****       liczba_prob_wyslania_smsa = 0;
 7661               		.loc 1 1562 0
 7662 28d8 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
1563:main.c        ****       czekanie_na_odebranie_zachety = FALSE;
 7663               		.loc 1 1563 0
 7664 28dc 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
1564:main.c        ****       wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
 7665               		.loc 1 1564 0
 7666 28e0 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
1565:main.c        **** 
 7667               		.loc 1 1565 0
 7668 28e4 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
1567:main.c        ****         ++liczba_kolejnych_watchdogow_wysylania;
 7669               		.loc 1 1567 0
 7670 28e8 8091 0000 		lds r24,liczba_kolejnych_watchdogow_wysylania
 7671 28ec 8F3F      		cpi r24,lo8(-1)
 7672 28ee 01F0      		breq .L829
1568:main.c        ****       if (liczba_kolejnych_watchdogow_wysylania >= 3) {
 7673               		.loc 1 1568 0
 7674 28f0 8F5F      		subi r24,lo8(-(1))
 7675 28f2 8093 0000 		sts liczba_kolejnych_watchdogow_wysylania,r24
 7676               	.L829:
1569:main.c        ****         liczba_kolejnych_watchdogow_wysylania = 0;
 7677               		.loc 1 1569 0
 7678 28f6 8091 0000 		lds r24,liczba_kolejnych_watchdogow_wysylania
 7679 28fa 8330      		cpi r24,lo8(3)
 7680 28fc 00F4      		brsh .+2
 7681 28fe 00C0      		rjmp .L828
1570:main.c        ****         reset_modulu_SIM900();
 7682               		.loc 1 1570 0
 7683 2900 1092 0000 		sts liczba_kolejnych_watchdogow_wysylania,__zero_reg__
1571:main.c        ****       }
 7684               		.loc 1 1571 0
 7685 2904 0E94 0000 		call reset_modulu_SIM900
 7686               	.LVL579:
 7687 2908 00C0      		rjmp .L828
 7688               	.L826:
1575:main.c        ****     liczba_kolejnych_watchdogow_wysylania = 0;
 7689               		.loc 1 1575 0
 7690 290a 1092 0000 		sts licznik_watchdog_wysylanie_smsa_100ms+1,__zero_reg__
 7691 290e 1092 0000 		sts licznik_watchdog_wysylanie_smsa_100ms,__zero_reg__
1576:main.c        ****   }
 7692               		.loc 1 1576 0
 7693 2912 1092 0000 		sts liczba_kolejnych_watchdogow_wysylania,__zero_reg__
 7694 2916 00C0      		rjmp .L828
 7695               	.L831:
1583:main.c        ****       cli();
 7696               		.loc 1 1583 0
 7697 2918 8FEF      		ldi r24,lo8(-1)
 7698 291a 8093 0000 		sts watchdog_sms_trwa_reset,r24
1584:main.c        ****       wdt_enable(WDTO_15MS);
 7699               		.loc 1 1584 0
 7700               	/* #APP */
 7701               	 ;  1584 "main.c" 1
 7702 291e F894      		cli
 7703               	 ;  0 "" 2
 7704               	.LVL580:
 7705               	/* #NOAPP */
 7706               	.LBB623:
 7707               	.LBB624:
 7708               		.file 7 "/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h"
   1:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
   5:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
   8:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  11:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      distribution.
  15:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  16:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  20:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  32:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /* $Id$ */
  33:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  34:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /*
  35:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****  */
  37:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  38:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  41:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  44:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /** \file */
  45:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  48:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  57:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  61:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     the following:
  68:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  69:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     \code
  70:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  73:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  75:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     {
  80:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     }
  84:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     \endcode
  85:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  86:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** */
  91:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  92:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /**
  93:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** */
  98:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  99:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 101:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #ifndef __DOXYGEN__
 102:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 103:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined(WDP3)
 104:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 105:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else
 106:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 107:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif
 108:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 109:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 110:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 111:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 112:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 113:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else
 114:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 115:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif
 116:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 117:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined(WDTOE)
 118:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 119:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else
 120:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 121:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif
 122:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 123:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif	/* !__DOXYGEN__ */
 124:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 125:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 126:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /**
 127:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 128:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 129:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 130:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 131:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 132:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 133:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 134:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 135:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** */
 136:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 137:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 138:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 139:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 140:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined (WDT_CTRLA) && !defined(RAMPD)
 141:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 142:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 143:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** do { \
 144:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** uint8_t temp; \
 145:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 146:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"wdr"									"\n\t" \
 147:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]"		"\n\t" \
 148:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"				"\n\t" \
 149:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"sbr %[tmp], %[wdt_enable_timeout]"		"\n\t" \
 150:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"				"\n\t" \
 151:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"1:lds %[tmp], %[wdt_status_reg]"		"\n\t" \
 152:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"sbrc %[tmp], %[wdt_syncbusy_bit]"		"\n\t" \
 153:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"rjmp 1b"								"\n\t" \
 154:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	: [tmp]					"=r" (temp) \
 155:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	: [ccp_reg]				"I"  (_SFR_IO_ADDR(CCP)), \
 156:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [ioreg_cen_mask]		"r"  ((uint8_t)CCP_IOREG_gc), \
 157:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [wdt_reg]				"n"  (_SFR_MEM_ADDR(WDT_CTRLA)), \
 158:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [wdt_enable_timeout]	"M"  (timeout), \
 159:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [wdt_status_reg]		"n"  (_SFR_MEM_ADDR(WDT_STATUS)), \
 160:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [wdt_syncbusy_bit]	"I"  (WDT_SYNCBUSY_bm) \
 161:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ); \
 162:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** } while(0)
 163:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 164:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_disable() \
 165:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** do { \
 166:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** uint8_t temp; \
 167:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 168:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"wdr"								"\n\t" \
 169:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 170:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"			"\n\t" \
 171:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"cbr %[tmp], %[timeout_mask]"       "\n\t" \
 172:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"			"\n\t" \
 173:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [tmp]            "=r" (temp) \
 174:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [ccp_reg]        "I" (_SFR_IO_ADDR(CCP)),       \
 175:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ioreg_cen_mask] "r" ((uint8_t)CCP_IOREG_gc),   \
 176:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_reg]        "n" (_SFR_MEM_ADDR(WDT_CTRLA)),\
 177:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [timeout_mask]   "I" (WDT_PERIOD_gm) \
 178:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ); \
 179:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** } while(0)
 180:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 181:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else // defined (WDT_CTRLA) && !defined(RAMPD)
 182:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 183:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /*
 184:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 185:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 186:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    registers to the CCP register
 187:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ** At the same time,
 188:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 189:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 190:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 191:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 192:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 193:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    sync is finished).
 194:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** */
 195:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 196:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** do { \
 197:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** uint8_t temp; \
 198:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 199:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 200:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 201:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 202:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 203:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 204:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 205:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 206:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 207:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 208:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 209:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 210:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 211:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 212:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 213:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 214:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 215:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : "r0" \
 216:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ); \
 217:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** } while(0)
 218:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 219:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_disable() \
 220:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 221:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 222:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 223:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 224:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 225:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 226:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : \
 227:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 228:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 229:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 230:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 231:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 232:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : "r0" \
 233:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** );
 234:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 235:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif // defined (WDT_CTRLA) && !defined(RAMPD)
 236:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 237:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 238:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 239:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 240:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 241:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 242:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 243:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 244:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 245:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 246:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 247:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : /* no outputs */  \
 248:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 249:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 250:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 251:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 252:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 253:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : "r16" \
 254:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** )
 255:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 256:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_disable() \
 257:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** do { \
 258:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 259:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 260:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 261:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 262:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 263:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 264:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 265:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 266:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 267:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 268:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : /*no output */ \
 269:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 270:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 271:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 272:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 273:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 274:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : "r16" \
 275:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ); \
 276:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** }while(0)
 277:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 278:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #elif defined(CCP)
 279:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 280:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** static __inline__
 281:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 282:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 283:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** {
 284:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 285:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 286:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 287:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 288:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 289:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 290:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 291:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 292:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 293:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: /* no outputs */
 294:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 295:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 296:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 297:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 298:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 299:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: "r0"
 300:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			);
 301:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 302:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 303:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 304:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 305:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 306:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 307:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 308:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 309:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 310:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 311:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: /* no outputs */
 312:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 313:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 314:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 315:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 316:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 317:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: "r0"
 318:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			);
 319:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 320:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 321:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 322:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 323:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 324:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 325:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 326:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 327:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 328:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 329:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: /* no outputs */
 330:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 331:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 332:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 333:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 334:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 335:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: "r0"
 336:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			);
 337:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 338:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else
 339:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****  	{
 340:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 341:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 342:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 343:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 344:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 345:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 346:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 347:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: /* no outputs */
 348:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 349:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 350:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 351:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 352:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 353:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: "r0"
 354:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			);
 355:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 356:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** }
 357:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 358:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** static __inline__
 359:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 360:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** void wdt_disable (void)
 361:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** {
 362:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 363:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 364:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 365:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 366:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 367:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 368:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 369:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 370:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 371:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 372:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 373:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 374:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /*no output */
 375:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 376:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 377:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 378:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 379:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 380:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 381:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				);
 382:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 383:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 384:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 385:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 386:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 387:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 388:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 389:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 390:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 391:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 392:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 393:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 394:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 395:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /*no output */
 396:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 397:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 398:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 399:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 400:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 401:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 402:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				);
 403:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 404:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 405:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 406:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 407:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 408:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 409:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 410:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 411:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 412:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 413:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 414:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 415:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 416:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /*no output */
 417:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 418:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 419:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 420:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 421:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 422:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 423:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				);
 424:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 425:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else
 426:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 427:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 428:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 429:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 430:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 431:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 432:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 433:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 434:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 435:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 436:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 437:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /*no output */
 438:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 439:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 440:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 441:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 442:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 443:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 444:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				);
 445:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 446:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** }
 447:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 448:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else
 449:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 450:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** static __inline__
 451:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 452:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 453:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** {
 454:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 455:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 456:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 457:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 458:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 459:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 460:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 461:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 462:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 463:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /* no outputs */
 464:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 465:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 466:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 467:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 468:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 469:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		);
 470:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 471:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else
 472:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 473:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 7709               		.loc 7 473 0
 7710 2920 88E1      		ldi r24,lo8(24)
 7711 2922 98E0      		ldi r25,lo8(8)
 7712               	/* #APP */
 7713               	 ;  473 "/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h" 1
 7714 2924 0FB6      		in __tmp_reg__,__SREG__
 7715 2926 F894      		cli
 7716 2928 A895      		wdr
 7717 292a 8093 6000 		sts 96, r24
 7718 292e 0FBE      		out __SREG__,__tmp_reg__
 7719 2930 9093 6000 		sts 96, r25
 7720               	 	
 7721               	 ;  0 "" 2
 7722               	/* #NOAPP */
 7723               	.L833:
 7724 2934 00C0      		rjmp .L833
 7725               	.LVL581:
 7726               	.L830:
 7727               	.LBE624:
 7728               	.LBE623:
1589:main.c        ****     --watchdog_sms_safe_mode_100ms;
 7729               		.loc 1 1589 0
 7730 2936 8091 0000 		lds r24,watchdog_sms_safe_mode_100ms
 7731 293a 9091 0000 		lds r25,watchdog_sms_safe_mode_100ms+1
 7732 293e 892B      		or r24,r25
 7733 2940 01F4      		brne .+2
 7734 2942 00C0      		rjmp .L832
1590:main.c        ****   }
 7735               		.loc 1 1590 0
 7736 2944 8091 0000 		lds r24,watchdog_sms_safe_mode_100ms
 7737 2948 9091 0000 		lds r25,watchdog_sms_safe_mode_100ms+1
 7738 294c 0197      		sbiw r24,1
 7739 294e 9093 0000 		sts watchdog_sms_safe_mode_100ms+1,r25
 7740 2952 8093 0000 		sts watchdog_sms_safe_mode_100ms,r24
 7741 2956 00C0      		rjmp .L832
 7742               	.L836:
1600:main.c        ****     return;
 7743               		.loc 1 1600 0 discriminator 2
 7744 2958 4098      		cbi 0x8,0
 7745               	/* epilogue start */
1630:main.c        **** 
 7746               		.loc 1 1630 0 discriminator 2
 7747 295a 0895      		ret
 7748               	.L834:
1606:main.c        ****     // Nie zalogowany - dioda swiecei ciagle
 7749               		.loc 1 1606 0
 7750 295c 8091 0000 		lds r24,modul_zalogowany_w_sieci
 7751 2960 8111      		cpse r24,__zero_reg__
 7752 2962 00C0      		rjmp .L838
 7753               	.L843:
 7754               	.LBB625:
1623:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7755               		.loc 1 1623 0 discriminator 6
 7756 2964 4098      		cbi 0x8,0
 7757 2966 00C0      		rjmp .L839
 7758               	.L838:
 7759               	.LBE625:
1611:main.c        ****       // Mrugniecie (SMS, etc.)
 7760               		.loc 1 1611 0
 7761 2968 8091 0000 		lds r24,licznik_100ms_dioda_led
 7762 296c 8111      		cpse r24,__zero_reg__
 7763 296e 00C0      		rjmp .L843
 7764               	.LBB626:
1617:main.c        ****         if (++licznik_dioda_led_poziom_sieci >= 50)
 7765               		.loc 1 1617 0
 7766 2970 8091 0000 		lds r24,poziom_sieci_gsm
 7767 2974 8031      		cpi r24,lo8(16)
 7768 2976 00F4      		brsh .L841
1618:main.c        ****           licznik_dioda_led_poziom_sieci = 1;
 7769               		.loc 1 1618 0
 7770 2978 8091 0000 		lds r24,licznik_dioda_led_poziom_sieci.3736
 7771 297c 8F5F      		subi r24,lo8(-(1))
 7772 297e 8093 0000 		sts licznik_dioda_led_poziom_sieci.3736,r24
 7773 2982 8233      		cpi r24,lo8(50)
 7774 2984 00F0      		brlo .L842
1619:main.c        ****       } else
 7775               		.loc 1 1619 0
 7776 2986 81E0      		ldi r24,lo8(1)
 7777 2988 8093 0000 		sts licznik_dioda_led_poziom_sieci.3736,r24
 7778               	.L842:
1623:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7779               		.loc 1 1623 0
 7780 298c 8091 0000 		lds r24,licznik_dioda_led_poziom_sieci.3736
 7781 2990 8832      		cpi r24,lo8(40)
 7782 2992 01F0      		breq .L843
1623:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7783               		.loc 1 1623 0 is_stmt 0 discriminator 1
 7784 2994 8B32      		cpi r24,lo8(43)
 7785 2996 01F0      		breq .L843
1623:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7786               		.loc 1 1623 0 discriminator 3
 7787 2998 8E52      		subi r24,lo8(-(-46))
 7788 299a 8430      		cpi r24,lo8(4)
 7789 299c 00F0      		brlo .L843
1623:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7790               		.loc 1 1623 0 discriminator 5
 7791 299e 409A      		sbi 0x8,0
 7792               	.L839:
 7793               	.LBE626:
1629:main.c        **** }
 7794               		.loc 1 1629 0 is_stmt 1
 7795 29a0 0C94 0000 		jmp zapis_w_eeprom_stanu_wyjsc
 7796               	.LVL582:
 7797               	.L841:
 7798               	.LBB627:
1621:main.c        **** 
 7799               		.loc 1 1621 0
 7800 29a4 1092 0000 		sts licznik_dioda_led_poziom_sieci.3736,__zero_reg__
 7801 29a8 00C0      		rjmp .L842
 7802               	.LBE627:
 7803               		.cfi_endproc
 7804               	.LFE65:
 7806               	.global	steruj_urzadzeniem_10MS
 7808               	steruj_urzadzeniem_10MS:
 7809               	.LFB66:
1632:main.c        ****   steruj_wejscia_10ms();
 7810               		.loc 1 1632 0
 7811               		.cfi_startproc
 7812               	/* prologue: function */
 7813               	/* frame size = 0 */
 7814               	/* stack size = 0 */
 7815               	.L__stack_usage = 0
1633:main.c        ****   steruj_SIM900_10MS();
 7816               		.loc 1 1633 0
 7817 29aa 0E94 0000 		call steruj_wejscia_10ms
 7818               	.LVL583:
1634:main.c        ****   zapisz_bajt_w_EEPROM();
 7819               		.loc 1 1634 0
 7820 29ae 0E94 0000 		call steruj_SIM900_10MS
 7821               	.LVL584:
1635:main.c        ****   // test_dioda_wyjscia();
 7822               		.loc 1 1635 0
 7823 29b2 0C94 0000 		jmp zapisz_bajt_w_EEPROM
 7824               	.LVL585:
 7825               		.cfi_endproc
 7826               	.LFE66:
 7828               	.global	wolne_zdarzenie_timer
 7830               	wolne_zdarzenie_timer:
 7831               	.LFB67:
1640:main.c        ****   WYKONAJ_CLI_SEI(WYLACZ_PRZERWANIE_TIMER());
 7832               		.loc 1 1640 0
 7833               		.cfi_startproc
 7834               	/* prologue: function */
 7835               	/* frame size = 0 */
 7836               	/* stack size = 0 */
 7837               	.L__stack_usage = 0
1641:main.c        ****   if (!CZY_WYKONAC_ZDARZENIE_TIMER()) {
 7838               		.loc 1 1641 0
 7839               	/* #APP */
 7840               	 ;  1641 "main.c" 1
 7841 29b6 F894      		cli
 7842               	 ;  0 "" 2
 7843               	/* #NOAPP */
 7844 29b8 8091 6E00 		lds r24,110
 7845 29bc 8D7F      		andi r24,lo8(-3)
 7846 29be 8093 6E00 		sts 110,r24
 7847               	/* #APP */
 7848               	 ;  1641 "main.c" 1
 7849 29c2 7894      		sei
 7850               	 ;  0 "" 2
 7851               	 ;  1641 "main.c" 1
 7852 29c4 0000      		nop
 7853               	 ;  0 "" 2
1642:main.c        ****     WYKONAJ_CLI_SEI(WLACZ_PRZERWANIE_TIMER());
 7854               		.loc 1 1642 0
 7855               	/* #NOAPP */
 7856 29c6 8091 0000 		lds r24,wykonaj_zdarzenie_timer
 7857 29ca 8111      		cpse r24,__zero_reg__
 7858 29cc 00C0      		rjmp .L868
1643:main.c        ****     return;
 7859               		.loc 1 1643 0
 7860               	/* #APP */
 7861               	 ;  1643 "main.c" 1
 7862 29ce F894      		cli
 7863               	 ;  0 "" 2
 7864               	/* #NOAPP */
 7865 29d0 8091 6E00 		lds r24,110
 7866 29d4 8260      		ori r24,lo8(2)
 7867 29d6 8093 6E00 		sts 110,r24
 7868               	/* #APP */
 7869               	 ;  1643 "main.c" 1
 7870 29da 7894      		sei
 7871               	 ;  0 "" 2
 7872               	 ;  1643 "main.c" 1
 7873 29dc 0000      		nop
 7874               	 ;  0 "" 2
1644:main.c        ****   }
 7875               		.loc 1 1644 0
 7876               	/* #NOAPP */
 7877 29de 0895      		ret
 7878               	.L868:
1646:main.c        ****   if (wykonac_watki_10MS) {
 7879               		.loc 1 1646 0
 7880 29e0 1092 0000 		sts wykonaj_zdarzenie_timer,__zero_reg__
1647:main.c        ****     wykonac_watki = WYKONAJ_WATKI_10MS;
 7881               		.loc 1 1647 0
 7882 29e4 8091 0000 		lds r24,wykonac_watki_10MS
 7883 29e8 8823      		tst r24
 7884 29ea 01F0      		breq .L870
1648:main.c        ****     wykonac_watki_10MS = FALSE;
 7885               		.loc 1 1648 0
 7886 29ec 81E0      		ldi r24,lo8(1)
 7887 29ee 8093 0000 		sts wykonac_watki,r24
1649:main.c        ****   }
 7888               		.loc 1 1649 0
 7889 29f2 1092 0000 		sts wykonac_watki_10MS,__zero_reg__
 7890               	.L870:
1651:main.c        ****   if (CZY_WYKONAC_WATKI_10MS()) {
 7891               		.loc 1 1651 0
 7892               	/* #APP */
 7893               	 ;  1651 "main.c" 1
 7894 29f6 F894      		cli
 7895               	 ;  0 "" 2
 7896               	/* #NOAPP */
 7897 29f8 8091 6E00 		lds r24,110
 7898 29fc 8260      		ori r24,lo8(2)
 7899 29fe 8093 6E00 		sts 110,r24
 7900               	/* #APP */
 7901               	 ;  1651 "main.c" 1
 7902 2a02 7894      		sei
 7903               	 ;  0 "" 2
 7904               	 ;  1651 "main.c" 1
 7905 2a04 0000      		nop
 7906               	 ;  0 "" 2
1652:main.c        ****     static uchar licznik_wybuc_watki_100MS = 0;
 7907               		.loc 1 1652 0
 7908               	/* #NOAPP */
 7909 2a06 8091 0000 		lds r24,wykonac_watki
 7910 2a0a 80FF      		sbrs r24,0
 7911 2a0c 00C0      		rjmp .L867
 7912               	.LBB631:
1655:main.c        ****       licznik_wybuc_watki_100MS = 0;
 7913               		.loc 1 1655 0
 7914 2a0e 8091 0000 		lds r24,licznik_wybuc_watki_100MS.3743
 7915 2a12 8F5F      		subi r24,lo8(-(1))
 7916 2a14 8A30      		cpi r24,lo8(10)
 7917 2a16 01F0      		breq .L871
 7918 2a18 8093 0000 		sts licznik_wybuc_watki_100MS.3743,r24
 7919               	.L872:
1659:main.c        ****     cli();
 7920               		.loc 1 1659 0
 7921               	/* #APP */
 7922               	 ;  1659 "main.c" 1
 7923 2a1c 0000      		nop
 7924               	 ;  0 "" 2
1660:main.c        ****     if (CZY_ODBIERANIE_DANYCH_SIM900()) {
 7925               		.loc 1 1660 0
 7926               	 ;  1660 "main.c" 1
 7927 2a1e F894      		cli
 7928               	 ;  0 "" 2
1661:main.c        ****       WYLACZ_PRZERWANIE_ODBIORU_DANYCH_SIM900();
 7929               		.loc 1 1661 0
 7930               	/* #NOAPP */
 7931 2a20 00B6      		in __tmp_reg__,0x30
 7932 2a22 01FE      		sbrs __tmp_reg__,1
 7933 2a24 00C0      		rjmp .L873
1662:main.c        ****       sei();
 7934               		.loc 1 1662 0
 7935 2a26 8091 C100 		lds r24,193
 7936 2a2a 8F77      		andi r24,lo8(127)
 7937 2a2c 8093 C100 		sts 193,r24
1663:main.c        ****       if (liczba_odebranych_znakow_SIM900 != 0 &&
 7938               		.loc 1 1663 0
 7939               	/* #APP */
 7940               	 ;  1663 "main.c" 1
 7941 2a30 7894      		sei
 7942               	 ;  0 "" 2
1664:main.c        ****           ++licznik_opoznienie_oczekiwania_na_bajt_SIM900 >
 7943               		.loc 1 1664 0
 7944               	/* #NOAPP */
 7945 2a32 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 7946 2a36 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
 7947 2a3a 892B      		or r24,r25
 7948 2a3c 01F0      		breq .L874
1665:main.c        ****               MAX_OPOZNIENIE_OCZEKIWANIA_NA_BAJT_SIM900_500_MS) {
 7949               		.loc 1 1665 0
 7950 2a3e 8091 0000 		lds r24,licznik_opoznienie_oczekiwania_na_bajt_SIM900
 7951 2a42 8F5F      		subi r24,lo8(-(1))
1664:main.c        ****           ++licznik_opoznienie_oczekiwania_na_bajt_SIM900 >
 7952               		.loc 1 1664 0
 7953 2a44 8093 0000 		sts licznik_opoznienie_oczekiwania_na_bajt_SIM900,r24
 7954 2a48 8333      		cpi r24,lo8(51)
 7955 2a4a 00F0      		brlo .L874
1667:main.c        ****       } else {
 7956               		.loc 1 1667 0
 7957 2a4c 459A      		sbi 0x8,5
 7958 2a4e 8091 C100 		lds r24,193
 7959 2a52 8F77      		andi r24,lo8(127)
 7960 2a54 8093 C100 		sts 193,r24
 7961 2a58 80B7      		in r24,0x30
 7962 2a5a 8D7F      		andi r24,lo8(-3)
 7963 2a5c 80BF      		out 0x30,r24
 7964 2a5e 1092 0000 		sts poczatek_polecenia_SIM900+1,__zero_reg__
 7965 2a62 1092 0000 		sts poczatek_polecenia_SIM900,__zero_reg__
 7966 2a66 1092 0000 		sts zakonczenie_polecenia_SIM900+1,__zero_reg__
 7967 2a6a 1092 0000 		sts zakonczenie_polecenia_SIM900,__zero_reg__
 7968 2a6e 1092 0000 		sts czy_jest_nowe_polecenie_SIM900,__zero_reg__
 7969               	.L873:
1672:main.c        ****   }
 7970               		.loc 1 1672 0
 7971               	/* #APP */
 7972               	 ;  1672 "main.c" 1
 7973 2a72 7894      		sei
 7974               	 ;  0 "" 2
 7975               	/* #NOAPP */
 7976               	.L867:
 7977               	/* epilogue start */
 7978               	.LBE631:
1674:main.c        **** 
 7979               		.loc 1 1674 0
 7980 2a74 0895      		ret
 7981               	.L871:
 7982               	.LBB632:
1656:main.c        ****       wykonac_watki = WYKONAJ_WATKI_100MS | WYKONAJ_WATKI_10MS;
 7983               		.loc 1 1656 0
 7984 2a76 1092 0000 		sts licznik_wybuc_watki_100MS.3743,__zero_reg__
1657:main.c        ****     }
 7985               		.loc 1 1657 0
 7986 2a7a 83E0      		ldi r24,lo8(3)
 7987 2a7c 8093 0000 		sts wykonac_watki,r24
 7988 2a80 00C0      		rjmp .L872
 7989               	.L874:
1669:main.c        ****       }
 7990               		.loc 1 1669 0
 7991               	/* #APP */
 7992               	 ;  1669 "main.c" 1
 7993 2a82 F894      		cli
 7994               	 ;  0 "" 2
 7995               	/* #NOAPP */
 7996 2a84 8091 C100 		lds r24,193
 7997 2a88 8068      		ori r24,lo8(-128)
 7998 2a8a 8093 C100 		sts 193,r24
 7999               	/* #APP */
 8000               	 ;  1669 "main.c" 1
 8001 2a8e 7894      		sei
 8002               	 ;  0 "" 2
 8003               	 ;  1669 "main.c" 1
 8004 2a90 0000      		nop
 8005               	 ;  0 "" 2
 8006               	/* #NOAPP */
 8007 2a92 00C0      		rjmp .L873
 8008               	.LBE632:
 8009               		.cfi_endproc
 8010               	.LFE67:
 8012               	.global	ustaw_parametry_dla_bezpieczenstwa
 8014               	ustaw_parametry_dla_bezpieczenstwa:
 8015               	.LFB68:
1676:main.c        ****   wdt_reset();
 8016               		.loc 1 1676 0
 8017               		.cfi_startproc
 8018               	/* prologue: function */
 8019               	/* frame size = 0 */
 8020               	/* stack size = 0 */
 8021               	.L__stack_usage = 0
1677:main.c        ****   ustaw_parametry_dla_bezpieczenstwa_rejestry();
 8022               		.loc 1 1677 0
 8023               	/* #APP */
 8024               	 ;  1677 "main.c" 1
 8025 2a94 A895      		wdr
 8026               	 ;  0 "" 2
1678:main.c        ****   set_sleep_mode(SLEEP_MODE_IDLE);
 8027               		.loc 1 1678 0
 8028               	/* #NOAPP */
 8029 2a96 82E0      		ldi r24,lo8(2)
 8030 2a98 84BD      		out 0x24,r24
 8031 2a9a 83E0      		ldi r24,lo8(3)
 8032 2a9c 85BD      		out 0x25,r24
 8033 2a9e 8FE3      		ldi r24,lo8(63)
 8034 2aa0 87BD      		out 0x27,r24
 8035 2aa2 EEE6      		ldi r30,lo8(110)
 8036 2aa4 F0E0      		ldi r31,0
 8037 2aa6 8081      		ld r24,Z
 8038 2aa8 8260      		ori r24,lo8(2)
 8039 2aaa 8083      		st Z,r24
1679:main.c        **** }
 8040               		.loc 1 1679 0
 8041 2aac 83B7      		in r24,0x33
 8042 2aae 817F      		andi r24,lo8(-15)
 8043 2ab0 83BF      		out 0x33,r24
 8044               	/* epilogue start */
1680:main.c        **** 
 8045               		.loc 1 1680 0
 8046 2ab2 0895      		ret
 8047               		.cfi_endproc
 8048               	.LFE68:
 8050               	.global	inicjalizuj_parametry_modulu
 8052               	inicjalizuj_parametry_modulu:
 8053               	.LFB69:
1682:main.c        ****   memcpy_E(kod_modulu, ADRES_EEPROM_KOD_DOSTEPU, LICZBA_BAJTOW_KODU_DOSTEPU);
 8054               		.loc 1 1682 0
 8055               		.cfi_startproc
 8056 2ab4 CF93      		push r28
 8057               	.LCFI92:
 8058               		.cfi_def_cfa_offset 3
 8059               		.cfi_offset 28, -2
 8060 2ab6 DF93      		push r29
 8061               	.LCFI93:
 8062               		.cfi_def_cfa_offset 4
 8063               		.cfi_offset 29, -3
 8064               	/* prologue: function */
 8065               	/* frame size = 0 */
 8066               	/* stack size = 2 */
 8067               	.L__stack_usage = 2
1683:main.c        **** 
 8068               		.loc 1 1683 0
 8069 2ab8 44E0      		ldi r20,lo8(4)
 8070 2aba 50E0      		ldi r21,0
 8071 2abc 61E0      		ldi r22,lo8(1)
 8072 2abe 70E0      		ldi r23,0
 8073 2ac0 80E0      		ldi r24,lo8(kod_modulu)
 8074 2ac2 90E0      		ldi r25,hi8(kod_modulu)
 8075 2ac4 0E94 0000 		call eeprom_read_block
 8076               	.LVL586:
1686:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8077               		.loc 1 1686 0
 8078 2ac8 8091 0000 		lds r24,kod_modulu
 8079 2acc 8150      		subi r24,lo8(-(-1))
 8080 2ace 8E3F      		cpi r24,lo8(-2)
 8081 2ad0 00F0      		brlo .L889
1687:main.c        ****     kod_modulu[1] = bufor_eeprom[1] = 'B';
 8082               		.loc 1 1687 0
 8083 2ad2 81E4      		ldi r24,lo8(65)
 8084 2ad4 8093 0000 		sts bufor_eeprom,r24
 8085 2ad8 8093 0000 		sts kod_modulu,r24
1688:main.c        ****     kod_modulu[2] = bufor_eeprom[2] = 'C';
 8086               		.loc 1 1688 0
 8087 2adc 82E4      		ldi r24,lo8(66)
 8088 2ade 8093 0000 		sts bufor_eeprom+1,r24
 8089 2ae2 8093 0000 		sts kod_modulu+1,r24
1689:main.c        ****     kod_modulu[3] = bufor_eeprom[3] = 'D';
 8090               		.loc 1 1689 0
 8091 2ae6 83E4      		ldi r24,lo8(67)
 8092 2ae8 8093 0000 		sts bufor_eeprom+2,r24
 8093 2aec 8093 0000 		sts kod_modulu+2,r24
1690:main.c        ****     // Zapisz do EEPROM natychmiast (BLOCKING)
 8094               		.loc 1 1690 0
 8095 2af0 84E4      		ldi r24,lo8(68)
 8096 2af2 8093 0000 		sts bufor_eeprom+3,r24
 8097 2af6 8093 0000 		sts kod_modulu+3,r24
 8098               	.L890:
1692:main.c        ****       ;
 8099               		.loc 1 1692 0 discriminator 1
 8100 2afa F999      		sbic 0x1f,1
 8101 2afc 00C0      		rjmp .L890
1694:main.c        ****                         LICZBA_BAJTOW_KODU_DOSTEPU);
 8102               		.loc 1 1694 0
 8103 2afe 44E0      		ldi r20,lo8(4)
 8104 2b00 50E0      		ldi r21,0
 8105 2b02 61E0      		ldi r22,lo8(1)
 8106 2b04 70E0      		ldi r23,0
 8107 2b06 80E0      		ldi r24,lo8(kod_modulu)
 8108 2b08 90E0      		ldi r25,hi8(kod_modulu)
 8109 2b0a 0E94 0000 		call eeprom_update_block
 8110               	.LVL587:
 8111               	.L889:
1700:main.c        ****   if (tryb_pracy == 0xFF) {
 8112               		.loc 1 1700 0
 8113 2b0e 8EEF      		ldi r24,lo8(-2)
 8114 2b10 9FE0      		ldi r25,lo8(15)
 8115 2b12 0E94 0000 		call eeprom_read_byte
 8116               	.LVL588:
1701:main.c        ****     tryb_pracy = 1; // Domyślnie Publiczny
 8117               		.loc 1 1701 0
 8118 2b16 8F3F      		cpi r24,lo8(-1)
 8119 2b18 01F4      		brne .+2
 8120 2b1a 00C0      		rjmp .L891
1700:main.c        ****   if (tryb_pracy == 0xFF) {
 8121               		.loc 1 1700 0
 8122 2b1c 8093 0000 		sts tryb_pracy,r24
 8123               	.L892:
1709:main.c        ****   if (tryb_clip == 0xFF) {
 8124               		.loc 1 1709 0
 8125 2b20 8FEF      		ldi r24,lo8(-1)
 8126 2b22 9FE0      		ldi r25,lo8(15)
 8127 2b24 0E94 0000 		call eeprom_read_byte
 8128               	.LVL589:
1710:main.c        ****     tryb_clip = 1; // Domyślnie CLIP (1)
 8129               		.loc 1 1710 0
 8130 2b28 8F3F      		cpi r24,lo8(-1)
 8131 2b2a 01F4      		brne .+2
 8132 2b2c 00C0      		rjmp .L894
1709:main.c        ****   if (tryb_clip == 0xFF) {
 8133               		.loc 1 1709 0
 8134 2b2e 8093 0000 		sts tryb_clip,r24
 8135               	.L895:
1718:main.c        ****   czas_start_m = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_START_M);
 8136               		.loc 1 1718 0
 8137 2b32 8AEF      		ldi r24,lo8(-6)
 8138 2b34 9FE0      		ldi r25,lo8(15)
 8139 2b36 0E94 0000 		call eeprom_read_byte
 8140               	.LVL590:
 8141 2b3a 8093 0000 		sts czas_start_h,r24
1719:main.c        ****   czas_stop_h = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_STOP_H);
 8142               		.loc 1 1719 0
 8143 2b3e 8BEF      		ldi r24,lo8(-5)
 8144 2b40 9FE0      		ldi r25,lo8(15)
 8145 2b42 0E94 0000 		call eeprom_read_byte
 8146               	.LVL591:
 8147 2b46 8093 0000 		sts czas_start_m,r24
1720:main.c        ****   czas_stop_m = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_STOP_M);
 8148               		.loc 1 1720 0
 8149 2b4a 8CEF      		ldi r24,lo8(-4)
 8150 2b4c 9FE0      		ldi r25,lo8(15)
 8151 2b4e 0E94 0000 		call eeprom_read_byte
 8152               	.LVL592:
 8153 2b52 8093 0000 		sts czas_stop_h,r24
1721:main.c        **** 
 8154               		.loc 1 1721 0
 8155 2b56 8DEF      		ldi r24,lo8(-3)
 8156 2b58 9FE0      		ldi r25,lo8(15)
 8157 2b5a 0E94 0000 		call eeprom_read_byte
 8158               	.LVL593:
 8159 2b5e 8093 0000 		sts czas_stop_m,r24
1724:main.c        ****   if (skryba_wlaczona == 0xFF)
 8160               		.loc 1 1724 0
 8161 2b62 89EF      		ldi r24,lo8(-7)
 8162 2b64 9FE0      		ldi r25,lo8(15)
 8163 2b66 0E94 0000 		call eeprom_read_byte
 8164               	.LVL594:
1725:main.c        ****     skryba_wlaczona = FALSE;
 8165               		.loc 1 1725 0
 8166 2b6a 8F3F      		cpi r24,lo8(-1)
 8167 2b6c 01F4      		brne .+2
 8168 2b6e 00C0      		rjmp .L897
1724:main.c        ****   if (skryba_wlaczona == 0xFF)
 8169               		.loc 1 1724 0
 8170 2b70 8093 0000 		sts skryba_wlaczona,r24
 8171               	.L898:
1729:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA_LIMIT_L);
 8172               		.loc 1 1729 0
 8173 2b74 85EF      		ldi r24,lo8(-11)
 8174 2b76 9FE0      		ldi r25,lo8(15)
 8175 2b78 0E94 0000 		call eeprom_read_byte
 8176               	.LVL595:
 8177 2b7c C82F      		mov r28,r24
 8178               	.LVL596:
1731:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA_LIMIT_H);
 8179               		.loc 1 1731 0
 8180 2b7e 86EF      		ldi r24,lo8(-10)
 8181 2b80 9FE0      		ldi r25,lo8(15)
 8182               	.LVL597:
 8183 2b82 0E94 0000 		call eeprom_read_byte
 8184               	.LVL598:
1733:main.c        ****     // Nie ustawiono - domyslnie 800
 8185               		.loc 1 1733 0
 8186 2b86 CF3F      		cpi r28,lo8(-1)
 8187 2b88 01F0      		breq .+2
 8188 2b8a 00C0      		rjmp .L899
1733:main.c        ****     // Nie ustawiono - domyslnie 800
 8189               		.loc 1 1733 0 is_stmt 0 discriminator 1
 8190 2b8c 8F3F      		cpi r24,lo8(-1)
 8191 2b8e 01F0      		breq .+2
 8192 2b90 00C0      		rjmp .L899
 8193               	.LVL599:
 8194               	.L901:
1735:main.c        ****   } else {
 8195               		.loc 1 1735 0 is_stmt 1
 8196 2b92 80E2      		ldi r24,lo8(32)
 8197 2b94 93E0      		ldi r25,lo8(3)
 8198 2b96 9093 0000 		sts skryba_limit+1,r25
 8199 2b9a 8093 0000 		sts skryba_limit,r24
 8200               	.L900:
1744:main.c        **** 
 8201               		.loc 1 1744 0
 8202 2b9e 81E0      		ldi r24,lo8(1)
 8203 2ba0 9091 0000 		lds r25,skryba_wlaczona
 8204 2ba4 9111      		cpse r25,__zero_reg__
 8205 2ba6 00C0      		rjmp .L902
 8206 2ba8 80E0      		ldi r24,0
 8207               	.L902:
 8208 2baa 6091 0000 		lds r22,skryba_limit
 8209 2bae 0E94 0000 		call zapisz_debug_do_eeprom
 8210               	.LVL600:
1748:main.c        ****       (czas_start_m > 59 && czas_start_m != 0xFF) ||
 8211               		.loc 1 1748 0
 8212 2bb2 8091 0000 		lds r24,czas_start_h
 8213 2bb6 8851      		subi r24,lo8(-(-24))
 8214 2bb8 873E      		cpi r24,lo8(-25)
 8215 2bba 00F0      		brlo .L921
1749:main.c        ****       (czas_stop_h > 23 && czas_stop_h != 0xFF) ||
 8216               		.loc 1 1749 0 discriminator 1
 8217 2bbc 8091 0000 		lds r24,czas_start_m
 8218 2bc0 8C53      		subi r24,lo8(-(-60))
1748:main.c        ****       (czas_start_m > 59 && czas_start_m != 0xFF) ||
 8219               		.loc 1 1748 0 discriminator 1
 8220 2bc2 833C      		cpi r24,lo8(-61)
 8221 2bc4 00F0      		brlo .L921
1750:main.c        ****       (czas_stop_m > 59 && czas_stop_m != 0xFF)) {
 8222               		.loc 1 1750 0
 8223 2bc6 8091 0000 		lds r24,czas_stop_h
 8224 2bca 8851      		subi r24,lo8(-(-24))
1749:main.c        ****       (czas_stop_h > 23 && czas_stop_h != 0xFF) ||
 8225               		.loc 1 1749 0
 8226 2bcc 873E      		cpi r24,lo8(-25)
 8227 2bce 00F0      		brlo .L921
1751:main.c        ****     // Zapisz wartosci wylaczajace (0xFF) - BLOCKING
 8228               		.loc 1 1751 0
 8229 2bd0 8091 0000 		lds r24,czas_stop_m
 8230 2bd4 8C53      		subi r24,lo8(-(-60))
1750:main.c        ****       (czas_stop_m > 59 && czas_stop_m != 0xFF)) {
 8231               		.loc 1 1750 0
 8232 2bd6 833C      		cpi r24,lo8(-61)
 8233 2bd8 00F4      		brsh .L904
 8234               	.L921:
1753:main.c        ****       ;
 8235               		.loc 1 1753 0 discriminator 1
 8236 2bda F999      		sbic 0x1f,1
 8237 2bdc 00C0      		rjmp .L921
1755:main.c        ****     while (!eeprom_is_ready())
 8238               		.loc 1 1755 0
 8239 2bde 6FEF      		ldi r22,lo8(-1)
 8240 2be0 8AEF      		ldi r24,lo8(-6)
 8241 2be2 9FE0      		ldi r25,lo8(15)
 8242 2be4 0E94 0000 		call eeprom_update_byte
 8243               	.LVL601:
 8244               	.L905:
1756:main.c        ****       ;
 8245               		.loc 1 1756 0 discriminator 1
 8246 2be8 F999      		sbic 0x1f,1
 8247 2bea 00C0      		rjmp .L905
1758:main.c        ****     while (!eeprom_is_ready())
 8248               		.loc 1 1758 0
 8249 2bec 6FEF      		ldi r22,lo8(-1)
 8250 2bee 8BEF      		ldi r24,lo8(-5)
 8251 2bf0 9FE0      		ldi r25,lo8(15)
 8252 2bf2 0E94 0000 		call eeprom_update_byte
 8253               	.LVL602:
 8254               	.L906:
1759:main.c        ****       ;
 8255               		.loc 1 1759 0 discriminator 1
 8256 2bf6 F999      		sbic 0x1f,1
 8257 2bf8 00C0      		rjmp .L906
1761:main.c        ****     while (!eeprom_is_ready())
 8258               		.loc 1 1761 0
 8259 2bfa 6FEF      		ldi r22,lo8(-1)
 8260 2bfc 8CEF      		ldi r24,lo8(-4)
 8261 2bfe 9FE0      		ldi r25,lo8(15)
 8262 2c00 0E94 0000 		call eeprom_update_byte
 8263               	.LVL603:
 8264               	.L907:
1762:main.c        ****       ;
 8265               		.loc 1 1762 0 discriminator 1
 8266 2c04 F999      		sbic 0x1f,1
 8267 2c06 00C0      		rjmp .L907
1764:main.c        **** 
 8268               		.loc 1 1764 0
 8269 2c08 6FEF      		ldi r22,lo8(-1)
 8270 2c0a 8DEF      		ldi r24,lo8(-3)
 8271 2c0c 9FE0      		ldi r25,lo8(15)
 8272 2c0e 0E94 0000 		call eeprom_update_byte
 8273               	.LVL604:
1766:main.c        ****     czas_start_m = 0xFF;
 8274               		.loc 1 1766 0
 8275 2c12 8FEF      		ldi r24,lo8(-1)
 8276 2c14 8093 0000 		sts czas_start_h,r24
1767:main.c        ****     czas_stop_h = 0xFF;
 8277               		.loc 1 1767 0
 8278 2c18 8093 0000 		sts czas_start_m,r24
1768:main.c        ****     czas_stop_m = 0xFF;
 8279               		.loc 1 1768 0
 8280 2c1c 8093 0000 		sts czas_stop_h,r24
1769:main.c        ****   }
 8281               		.loc 1 1769 0
 8282 2c20 8093 0000 		sts czas_stop_m,r24
 8283               	.L904:
1772:main.c        ****       FALSE; // Domyślnie odblokowane, zaktualizuje sie przy odczycie czasu
 8284               		.loc 1 1772 0
 8285 2c24 1092 0000 		sts blokada_sterowania_czasowa,__zero_reg__
1777:main.c        ****   if (blokada_systemu == 0xFF) {
 8286               		.loc 1 1777 0
 8287 2c28 87EF      		ldi r24,lo8(-9)
 8288 2c2a 9FE0      		ldi r25,lo8(15)
 8289 2c2c 0E94 0000 		call eeprom_read_byte
 8290               	.LVL605:
1778:main.c        ****     blokada_systemu = FALSE; // Domyślnie odblokowany
 8291               		.loc 1 1778 0
 8292 2c30 8F3F      		cpi r24,lo8(-1)
 8293 2c32 01F4      		brne .+2
 8294 2c34 00C0      		rjmp .L908
1776:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_BLOKADA_SYSTEMU);
 8295               		.loc 1 1776 0
 8296 2c36 8093 0000 		sts blokada_systemu,r24
 8297               	.L909:
1682:main.c        ****   memcpy_E(kod_modulu, ADRES_EEPROM_KOD_DOSTEPU, LICZBA_BAJTOW_KODU_DOSTEPU);
 8298               		.loc 1 1682 0
 8299 2c3a C0EF      		ldi r28,lo8(-16)
 8300 2c3c DFE0      		ldi r29,lo8(15)
 8301               	.LVL606:
 8302               	.L912:
 8303               	.LBB633:
1785:main.c        ****       while (!eeprom_is_ready())
 8304               		.loc 1 1785 0
 8305 2c3e CE01      		movw r24,r28
 8306 2c40 0E94 0000 		call eeprom_read_byte
 8307               	.LVL607:
 8308 2c44 8F3F      		cpi r24,lo8(-1)
 8309 2c46 01F4      		brne .L910
 8310               	.L911:
1786:main.c        ****         ;
 8311               		.loc 1 1786 0 discriminator 1
 8312 2c48 F999      		sbic 0x1f,1
 8313 2c4a 00C0      		rjmp .L911
1788:main.c        ****     }
 8314               		.loc 1 1788 0
 8315 2c4c 60E0      		ldi r22,0
 8316 2c4e CE01      		movw r24,r28
 8317 2c50 0E94 0000 		call eeprom_update_byte
 8318               	.LVL608:
 8319               	.L910:
1784:main.c        ****     if (eeprom_read_byte((const uint8_t *)addr) == 0xFF) {
 8320               		.loc 1 1784 0
 8321 2c54 2196      		adiw r28,1
 8322               	.LVL609:
1783:main.c        ****        addr <= ADRES_EEPROM_DEBUG_SKRYBA_5; ++addr) {
 8323               		.loc 1 1783 0
 8324 2c56 C53F      		cpi r28,-11
 8325 2c58 8FE0      		ldi r24,15
 8326 2c5a D807      		cpc r29,r24
 8327 2c5c 01F4      		brne .L912
 8328               	.LBE633:
 8329               	.LBB634:
1793:main.c        ****        addr <= ADRES_EEPROM_DEBUG_USER_7; ++addr) {
 8330               		.loc 1 1793 0
 8331 2c5e C6EE      		ldi r28,lo8(-26)
 8332 2c60 DFE0      		ldi r29,lo8(15)
 8333               	.LVL610:
 8334               	.L915:
1795:main.c        ****       while (!eeprom_is_ready())
 8335               		.loc 1 1795 0
 8336 2c62 CE01      		movw r24,r28
 8337 2c64 0E94 0000 		call eeprom_read_byte
 8338               	.LVL611:
 8339 2c68 8F3F      		cpi r24,lo8(-1)
 8340 2c6a 01F4      		brne .L913
 8341               	.L914:
1796:main.c        ****         ;
 8342               		.loc 1 1796 0 discriminator 1
 8343 2c6c F999      		sbic 0x1f,1
 8344 2c6e 00C0      		rjmp .L914
1798:main.c        ****     }
 8345               		.loc 1 1798 0
 8346 2c70 60E0      		ldi r22,0
 8347 2c72 CE01      		movw r24,r28
 8348 2c74 0E94 0000 		call eeprom_update_byte
 8349               	.LVL612:
 8350               	.L913:
1794:main.c        ****     if (eeprom_read_byte((const uint8_t *)addr) == 0xFF) {
 8351               		.loc 1 1794 0
 8352 2c78 2196      		adiw r28,1
 8353               	.LVL613:
1793:main.c        ****        addr <= ADRES_EEPROM_DEBUG_USER_7; ++addr) {
 8354               		.loc 1 1793 0
 8355 2c7a CD3E      		cpi r28,-19
 8356 2c7c 2FE0      		ldi r18,15
 8357 2c7e D207      		cpc r29,r18
 8358 2c80 01F4      		brne .L915
 8359               	.LBE634:
1804:main.c        ****   timer_report_user_100ms = 0;
 8360               		.loc 1 1804 0
 8361 2c82 1092 0000 		sts licznik_report_user,__zero_reg__
1805:main.c        **** 
 8362               		.loc 1 1805 0
 8363 2c86 1092 0000 		sts timer_report_user_100ms+1,__zero_reg__
 8364 2c8a 1092 0000 		sts timer_report_user_100ms,__zero_reg__
1808:main.c        **** 
 8365               		.loc 1 1808 0
 8366 2c8e 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
1812:main.c        ****     ++licznik_resetow;
 8367               		.loc 1 1812 0
 8368 2c92 8091 0000 		lds r24,licznik_resetow.3787
 8369 2c96 8F3F      		cpi r24,lo8(-1)
 8370 2c98 01F0      		breq .L917
1813:main.c        ****   while (!eeprom_is_ready())
 8371               		.loc 1 1813 0
 8372 2c9a 8F5F      		subi r24,lo8(-(1))
 8373 2c9c 8093 0000 		sts licznik_resetow.3787,r24
 8374               	.L917:
1814:main.c        ****     ;
 8375               		.loc 1 1814 0 discriminator 1
 8376 2ca0 F999      		sbic 0x1f,1
 8377 2ca2 00C0      		rjmp .L917
1816:main.c        ****   while (!eeprom_is_ready())
 8378               		.loc 1 1816 0
 8379 2ca4 6091 0000 		lds r22,licznik_resetow.3787
 8380 2ca8 8CED      		ldi r24,lo8(-36)
 8381 2caa 9FE0      		ldi r25,lo8(15)
 8382 2cac 0E94 0000 		call eeprom_update_byte
 8383               	.LVL614:
 8384               	.L918:
1817:main.c        ****     ;
 8385               		.loc 1 1817 0 discriminator 1
 8386 2cb0 F999      		sbic 0x1f,1
 8387 2cb2 00C0      		rjmp .L918
1819:main.c        **** }
 8388               		.loc 1 1819 0
 8389 2cb4 62E0      		ldi r22,lo8(2)
 8390 2cb6 80E0      		ldi r24,0
 8391               	/* epilogue start */
1820:main.c        **** 
 8392               		.loc 1 1820 0
 8393 2cb8 DF91      		pop r29
 8394 2cba CF91      		pop r28
 8395               	.LVL615:
1819:main.c        **** }
 8396               		.loc 1 1819 0
 8397 2cbc 0C94 0000 		jmp zapisz_debug_do_eeprom
 8398               	.LVL616:
 8399               	.L891:
1702:main.c        ****     while (!eeprom_is_ready())
 8400               		.loc 1 1702 0
 8401 2cc0 81E0      		ldi r24,lo8(1)
 8402 2cc2 8093 0000 		sts tryb_pracy,r24
 8403               	.L893:
1703:main.c        ****       ;
 8404               		.loc 1 1703 0 discriminator 1
 8405 2cc6 F999      		sbic 0x1f,1
 8406 2cc8 00C0      		rjmp .L893
1705:main.c        ****   }
 8407               		.loc 1 1705 0
 8408 2cca 61E0      		ldi r22,lo8(1)
 8409 2ccc 8EEF      		ldi r24,lo8(-2)
 8410 2cce 9FE0      		ldi r25,lo8(15)
 8411 2cd0 0E94 0000 		call eeprom_update_byte
 8412               	.LVL617:
 8413 2cd4 00C0      		rjmp .L892
 8414               	.L894:
1711:main.c        ****     while (!eeprom_is_ready())
 8415               		.loc 1 1711 0
 8416 2cd6 81E0      		ldi r24,lo8(1)
 8417 2cd8 8093 0000 		sts tryb_clip,r24
 8418               	.L896:
1712:main.c        ****       ;
 8419               		.loc 1 1712 0 discriminator 1
 8420 2cdc F999      		sbic 0x1f,1
 8421 2cde 00C0      		rjmp .L896
1714:main.c        ****   }
 8422               		.loc 1 1714 0
 8423 2ce0 61E0      		ldi r22,lo8(1)
 8424 2ce2 8FEF      		ldi r24,lo8(-1)
 8425 2ce4 9FE0      		ldi r25,lo8(15)
 8426 2ce6 0E94 0000 		call eeprom_update_byte
 8427               	.LVL618:
 8428 2cea 00C0      		rjmp .L895
 8429               	.L897:
1726:main.c        **** 
 8430               		.loc 1 1726 0
 8431 2cec 1092 0000 		sts skryba_wlaczona,__zero_reg__
 8432 2cf0 00C0      		rjmp .L898
 8433               	.LVL619:
 8434               	.L899:
1737:main.c        ****     // Walidacja zakresu
 8435               		.loc 1 1737 0
 8436 2cf2 982F      		mov r25,r24
 8437 2cf4 8C2F      		mov r24,r28
 8438               	.LVL620:
 8439 2cf6 9093 0000 		sts skryba_limit+1,r25
 8440 2cfa 8093 0000 		sts skryba_limit,r24
1739:main.c        ****       skryba_limit = 800;
 8441               		.loc 1 1739 0
 8442 2cfe 0197      		sbiw r24,1
 8443 2d00 8032      		cpi r24,32
 8444 2d02 9340      		sbci r25,3
 8445 2d04 00F0      		brlo .+2
 8446 2d06 00C0      		rjmp .L901
 8447 2d08 00C0      		rjmp .L900
 8448               	.LVL621:
 8449               	.L908:
1779:main.c        ****   }
 8450               		.loc 1 1779 0
 8451 2d0a 1092 0000 		sts blokada_systemu,__zero_reg__
 8452 2d0e 00C0      		rjmp .L909
 8453               		.cfi_endproc
 8454               	.LFE69:
 8456               		.section	.rodata.str1.1
 8457               	.LC7:
 8458 00a8 5375 7065 		.string	"Super User dodany na pozycji %u"
 8458      7220 5573 
 8458      6572 2064 
 8458      6F64 616E 
 8458      7920 6E61 
 8459               		.text
 8460               	.global	wykonanie_komend_ukladow
 8462               	wykonanie_komend_ukladow:
 8463               	.LFB59:
 864:main.c        ****   const komenda_typ aktualnie_wykonywana_komenda = komendy_kolejka[0];
 8464               		.loc 1 864 0
 8465               		.cfi_startproc
 8466 2d10 CF92      		push r12
 8467               	.LCFI94:
 8468               		.cfi_def_cfa_offset 3
 8469               		.cfi_offset 12, -2
 8470 2d12 DF92      		push r13
 8471               	.LCFI95:
 8472               		.cfi_def_cfa_offset 4
 8473               		.cfi_offset 13, -3
 8474 2d14 EF92      		push r14
 8475               	.LCFI96:
 8476               		.cfi_def_cfa_offset 5
 8477               		.cfi_offset 14, -4
 8478 2d16 FF92      		push r15
 8479               	.LCFI97:
 8480               		.cfi_def_cfa_offset 6
 8481               		.cfi_offset 15, -5
 8482 2d18 0F93      		push r16
 8483               	.LCFI98:
 8484               		.cfi_def_cfa_offset 7
 8485               		.cfi_offset 16, -6
 8486 2d1a 1F93      		push r17
 8487               	.LCFI99:
 8488               		.cfi_def_cfa_offset 8
 8489               		.cfi_offset 17, -7
 8490 2d1c CF93      		push r28
 8491               	.LCFI100:
 8492               		.cfi_def_cfa_offset 9
 8493               		.cfi_offset 28, -8
 8494 2d1e DF93      		push r29
 8495               	.LCFI101:
 8496               		.cfi_def_cfa_offset 10
 8497               		.cfi_offset 29, -9
 8498 2d20 CDB7      		in r28,__SP_L__
 8499 2d22 DEB7      		in r29,__SP_H__
 8500               	.LCFI102:
 8501               		.cfi_def_cfa_register 28
 8502 2d24 A597      		sbiw r28,37
 8503               	.LCFI103:
 8504               		.cfi_def_cfa_offset 47
 8505 2d26 0FB6      		in __tmp_reg__,__SREG__
 8506 2d28 F894      		cli
 8507 2d2a DEBF      		out __SP_H__,r29
 8508 2d2c 0FBE      		out __SREG__,__tmp_reg__
 8509 2d2e CDBF      		out __SP_L__,r28
 8510               	/* prologue: function */
 8511               	/* frame size = 37 */
 8512               	/* stack size = 45 */
 8513               	.L__stack_usage = 45
 865:main.c        **** 
 8514               		.loc 1 865 0
 8515 2d30 1091 0000 		lds r17,komendy_kolejka
 8516               	.LVL622:
 867:main.c        ****   case KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU: {
 8517               		.loc 1 867 0
 8518 2d34 1438      		cpi r17,lo8(-124)
 8519 2d36 01F4      		brne .+2
 8520 2d38 00C0      		rjmp .L938
 8521 2d3a 00F4      		brsh .L939
 8522 2d3c 1338      		cpi r17,lo8(-125)
 8523 2d3e 00F0      		brlo .+2
 8524 2d40 00C0      		rjmp .L940
 8525 2d42 1330      		cpi r17,lo8(3)
 8526 2d44 00F0      		brlo .+2
 8527 2d46 00C0      		rjmp .L941
 8528 2d48 1230      		cpi r17,lo8(2)
 8529 2d4a 01F0      		breq .L942
 8530               	.L1012:
1348:main.c        ****   }
 8531               		.loc 1 1348 0
 8532 2d4c 80E0      		ldi r24,0
 8533 2d4e 00C0      		rjmp .L936
 8534               	.L939:
 867:main.c        ****   case KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU: {
 8535               		.loc 1 867 0
 8536 2d50 1638      		cpi r17,lo8(-122)
 8537 2d52 01F4      		brne .+2
 8538 2d54 00C0      		rjmp .L943
 8539 2d56 00F4      		brsh .+2
 8540 2d58 00C0      		rjmp .L944
 8541 2d5a 1738      		cpi r17,lo8(-121)
 8542 2d5c 01F4      		brne .+2
 8543 2d5e 00C0      		rjmp .L945
 8544 2d60 1838      		cpi r17,lo8(-120)
 8545 2d62 01F4      		brne .L1012
1322:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8546               		.loc 1 1322 0
 8547 2d64 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8548 2d68 8111      		cpse r24,__zero_reg__
 8549 2d6a 00C0      		rjmp .L1008
1322:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8550               		.loc 1 1322 0 is_stmt 0 discriminator 2
 8551 2d6c 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8552 2d70 8111      		cpse r24,__zero_reg__
 8553 2d72 00C0      		rjmp .L1008
1322:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8554               		.loc 1 1322 0 discriminator 4
 8555 2d74 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 8556 2d78 8111      		cpse r24,__zero_reg__
 8557 2d7a 00C0      		rjmp .L1008
1322:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8558               		.loc 1 1322 0 discriminator 6
 8559 2d7c F99B      		sbis 0x1f,1
 8560 2d7e 00C0      		rjmp .L1009
 8561               	.L1008:
1322:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8562               		.loc 1 1322 0 discriminator 7
 8563 2d80 88E8      		ldi r24,lo8(-120)
 8564 2d82 00C0      		rjmp .L1049
 8565               	.L942:
 869:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8566               		.loc 1 869 0 is_stmt 1
 8567 2d84 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8568 2d88 8111      		cpse r24,__zero_reg__
 8569 2d8a 00C0      		rjmp .L947
 869:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8570               		.loc 1 869 0 is_stmt 0 discriminator 2
 8571 2d8c 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8572 2d90 8111      		cpse r24,__zero_reg__
 8573 2d92 00C0      		rjmp .L947
 869:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8574               		.loc 1 869 0 discriminator 4
 8575 2d94 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 8576 2d98 8111      		cpse r24,__zero_reg__
 8577 2d9a 00C0      		rjmp .L947
 869:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8578               		.loc 1 869 0 discriminator 6
 8579 2d9c F99B      		sbis 0x1f,1
 8580 2d9e 00C0      		rjmp .L948
 8581               	.L947:
 869:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8582               		.loc 1 869 0 discriminator 7
 8583 2da0 82E0      		ldi r24,lo8(2)
 8584               	.LVL623:
 8585               	.L1049:
1322:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8586               		.loc 1 1322 0 is_stmt 1 discriminator 7
 8587 2da2 0E94 0000 		call dodaj_komende
 8588               	.LVL624:
 8589 2da6 00C0      		rjmp .L1048
 8590               	.LVL625:
 8591               	.L948:
 870:main.c        ****     kod_modulu[1] = bufor_eeprom[1] = 'B';
 8592               		.loc 1 870 0
 8593 2da8 81E4      		ldi r24,lo8(65)
 8594 2daa 8093 0000 		sts bufor_eeprom,r24
 8595 2dae 8093 0000 		sts kod_modulu,r24
 871:main.c        ****     kod_modulu[2] = bufor_eeprom[2] = 'C';
 8596               		.loc 1 871 0
 8597 2db2 82E4      		ldi r24,lo8(66)
 8598 2db4 8093 0000 		sts bufor_eeprom+1,r24
 8599 2db8 8093 0000 		sts kod_modulu+1,r24
 872:main.c        ****     kod_modulu[3] = bufor_eeprom[3] = 'D';
 8600               		.loc 1 872 0
 8601 2dbc 83E4      		ldi r24,lo8(67)
 8602 2dbe 8093 0000 		sts bufor_eeprom+2,r24
 8603 2dc2 8093 0000 		sts kod_modulu+2,r24
 873:main.c        ****     zapisz_znaki_w_eeprom_bez_kopiowania(ADRES_EEPROM_KOD_DOSTEPU,
 8604               		.loc 1 873 0
 8605 2dc6 84E4      		ldi r24,lo8(68)
 8606 2dc8 8093 0000 		sts bufor_eeprom+3,r24
 8607 2dcc 8093 0000 		sts kod_modulu+3,r24
 874:main.c        ****                                          LICZBA_BAJTOW_KODU_DOSTEPU);
 8608               		.loc 1 874 0
 8609 2dd0 64E0      		ldi r22,lo8(4)
 8610 2dd2 81E0      		ldi r24,lo8(1)
 8611 2dd4 90E0      		ldi r25,0
 8612 2dd6 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 8613               	.LVL626:
 8614               	.L1051:
 8615               	.LBB659:
1025:main.c        ****     break;
 8616               		.loc 1 1025 0
 8617 2dda 83E3      		ldi r24,lo8(51)
 8618 2ddc 8093 0000 		sts licznik_100ms_dioda_led,r24
 8619               	.LVL627:
 8620               	.L1048:
 8621               	.LBE659:
1350:main.c        **** }
 8622               		.loc 1 1350 0
 8623 2de0 8FEF      		ldi r24,lo8(-1)
 8624               	.L936:
 8625               	/* epilogue start */
1351:main.c        **** 
 8626               		.loc 1 1351 0
 8627 2de2 A596      		adiw r28,37
 8628 2de4 0FB6      		in __tmp_reg__,__SREG__
 8629 2de6 F894      		cli
 8630 2de8 DEBF      		out __SP_H__,r29
 8631 2dea 0FBE      		out __SREG__,__tmp_reg__
 8632 2dec CDBF      		out __SP_L__,r28
 8633 2dee DF91      		pop r29
 8634 2df0 CF91      		pop r28
 8635 2df2 1F91      		pop r17
 8636 2df4 0F91      		pop r16
 8637 2df6 FF90      		pop r15
 8638 2df8 EF90      		pop r14
 8639 2dfa DF90      		pop r13
 8640 2dfc CF90      		pop r12
 8641 2dfe 0895      		ret
 8642               	.LVL628:
 8643               	.L941:
 8644               	.LBB660:
1007:main.c        ****     const uchar nr_bloku =
 8645               		.loc 1 1007 0
 8646 2e00 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8647 2e04 8111      		cpse r24,__zero_reg__
 8648 2e06 00C0      		rjmp .L949
1007:main.c        ****     const uchar nr_bloku =
 8649               		.loc 1 1007 0 is_stmt 0 discriminator 2
 8650 2e08 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8651 2e0c 8111      		cpse r24,__zero_reg__
 8652 2e0e 00C0      		rjmp .L949
1007:main.c        ****     const uchar nr_bloku =
 8653               		.loc 1 1007 0 discriminator 4
 8654 2e10 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 8655 2e14 8111      		cpse r24,__zero_reg__
 8656 2e16 00C0      		rjmp .L949
1007:main.c        ****     const uchar nr_bloku =
 8657               		.loc 1 1007 0 discriminator 6
 8658 2e18 F99B      		sbis 0x1f,1
 8659 2e1a 00C0      		rjmp .L950
 8660               	.L949:
1007:main.c        ****     const uchar nr_bloku =
 8661               		.loc 1 1007 0 discriminator 7
 8662 2e1c 812F      		mov r24,r17
 8663 2e1e 00C0      		rjmp .L1049
 8664               	.L950:
1008:main.c        ****         aktualnie_wykonywana_komenda - KOMENDA_KOLEJKI_RESET_USTAWIEN_0;
 8665               		.loc 1 1008 0 is_stmt 1
 8666 2e20 0DEF      		ldi r16,lo8(-3)
 8667 2e22 010F      		add r16,r17
 8668               	.LVL629:
1011:main.c        ****     if (nr_bloku == 0) {
 8669               		.loc 1 1011 0
 8670 2e24 40E2      		ldi r20,lo8(32)
 8671 2e26 50E0      		ldi r21,0
 8672 2e28 6FEF      		ldi r22,lo8(-1)
 8673 2e2a 70E0      		ldi r23,0
 8674 2e2c 80E0      		ldi r24,lo8(bufor_eeprom)
 8675 2e2e 90E0      		ldi r25,hi8(bufor_eeprom)
 8676 2e30 0E94 0000 		call memset
 8677               	.LVL630:
1012:main.c        ****       kod_modulu[0] = bufor_eeprom[1] = 'A';
 8678               		.loc 1 1012 0
 8679 2e34 0111      		cpse r16,__zero_reg__
 8680 2e36 00C0      		rjmp .L951
1013:main.c        ****       kod_modulu[1] = bufor_eeprom[2] = 'B';
 8681               		.loc 1 1013 0
 8682 2e38 81E4      		ldi r24,lo8(65)
 8683 2e3a 8093 0000 		sts bufor_eeprom+1,r24
 8684 2e3e 8093 0000 		sts kod_modulu,r24
1014:main.c        ****       kod_modulu[2] = bufor_eeprom[3] = 'C';
 8685               		.loc 1 1014 0
 8686 2e42 82E4      		ldi r24,lo8(66)
 8687 2e44 8093 0000 		sts bufor_eeprom+2,r24
 8688 2e48 8093 0000 		sts kod_modulu+1,r24
1015:main.c        ****       kod_modulu[3] = bufor_eeprom[4] = 'D';
 8689               		.loc 1 1015 0
 8690 2e4c 83E4      		ldi r24,lo8(67)
 8691 2e4e 8093 0000 		sts bufor_eeprom+3,r24
 8692 2e52 8093 0000 		sts kod_modulu+2,r24
1016:main.c        ****       bufor_eeprom[5] = 0;
 8693               		.loc 1 1016 0
 8694 2e56 84E4      		ldi r24,lo8(68)
 8695 2e58 8093 0000 		sts bufor_eeprom+4,r24
 8696 2e5c 8093 0000 		sts kod_modulu+3,r24
1017:main.c        ****       stan_wyjscie[0] = 0;
 8697               		.loc 1 1017 0
 8698 2e60 1092 0000 		sts bufor_eeprom+5,__zero_reg__
1018:main.c        ****       licznik_przelacznik_wyjscia[0] = 0;
 8699               		.loc 1 1018 0
 8700 2e64 1092 0000 		sts stan_wyjscie,__zero_reg__
1019:main.c        ****     }
 8701               		.loc 1 1019 0
 8702 2e68 1092 0000 		sts licznik_przelacznik_wyjscia,__zero_reg__
 8703 2e6c 1092 0000 		sts licznik_przelacznik_wyjscia+1,__zero_reg__
 8704 2e70 1092 0000 		sts licznik_przelacznik_wyjscia+2,__zero_reg__
 8705 2e74 1092 0000 		sts licznik_przelacznik_wyjscia+3,__zero_reg__
 8706               	.L951:
1021:main.c        ****         nr_bloku * LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE,
 8707               		.loc 1 1021 0
 8708 2e78 60E2      		ldi r22,lo8(32)
 8709 2e7a 20E2      		ldi r18,lo8(32)
 8710 2e7c 029F      		mul r16,r18
 8711 2e7e C001      		movw r24,r0
 8712 2e80 1124      		clr __zero_reg__
 8713 2e82 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 8714               	.LVL631:
1024:main.c        ****     zapal_diode_led(50);
 8715               		.loc 1 1024 0
 8716 2e86 81E0      		ldi r24,lo8(1)
 8717 2e88 810F      		add r24,r17
 8718 2e8a 0E94 0000 		call dodaj_komende
 8719               	.LVL632:
 8720 2e8e 00C0      		rjmp .L1051
 8721               	.LVL633:
 8722               	.L940:
 8723               	.LBE660:
 8724               	.LBB661:
1029:main.c        ****     uchar bledny_zapis = FALSE;
 8725               		.loc 1 1029 0
 8726 2e90 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8727 2e94 8111      		cpse r24,__zero_reg__
 8728 2e96 00C0      		rjmp .L952
1029:main.c        ****     uchar bledny_zapis = FALSE;
 8729               		.loc 1 1029 0 is_stmt 0 discriminator 2
 8730 2e98 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8731 2e9c 8111      		cpse r24,__zero_reg__
 8732 2e9e 00C0      		rjmp .L952
1029:main.c        ****     uchar bledny_zapis = FALSE;
 8733               		.loc 1 1029 0 discriminator 4
 8734 2ea0 F090 0000 		lds r15,czy_zajety_bufor_eeprom
 8735 2ea4 F110      		cpse r15,__zero_reg__
 8736 2ea6 00C0      		rjmp .L952
1029:main.c        ****     uchar bledny_zapis = FALSE;
 8737               		.loc 1 1029 0 discriminator 6
 8738 2ea8 F99B      		sbis 0x1f,1
 8739 2eaa 00C0      		rjmp .L1013
 8740               	.L952:
1029:main.c        ****     uchar bledny_zapis = FALSE;
 8741               		.loc 1 1029 0 discriminator 7
 8742 2eac 83E8      		ldi r24,lo8(-125)
 8743 2eae 00C0      		rjmp .L1049
 8744               	.L1013:
 8745               	.LBB662:
1034:main.c        ****       if (eeprom_read_byte((void *)i) !=
 8746               		.loc 1 1034 0 is_stmt 1
 8747 2eb0 10E0      		ldi r17,0
 8748               	.LVL634:
 8749 2eb2 00E0      		ldi r16,0
 8750               	.LVL635:
 8751               	.L953:
1035:main.c        ****           pgm_read_byte(tab_eeprom_fabryczny + i))
 8752               		.loc 1 1035 0
 8753 2eb4 C801      		movw r24,r16
 8754 2eb6 0E94 0000 		call eeprom_read_byte
 8755               	.LVL636:
 8756               	.LBB663:
1036:main.c        ****         bledny_zapis = TRUE;
 8757               		.loc 1 1036 0
 8758 2eba F801      		movw r30,r16
 8759 2ebc E050      		subi r30,lo8(-(tab_eeprom_fabryczny.3639))
 8760 2ebe F040      		sbci r31,hi8(-(tab_eeprom_fabryczny.3639))
 8761               	.LVL637:
 8762               	/* #APP */
 8763               	 ;  1036 "main.c" 1
 8764 2ec0 E491      		lpm r30, Z
 8765               		
 8766               	 ;  0 "" 2
 8767               	.LVL638:
 8768               	/* #NOAPP */
 8769               	.LBE663:
1035:main.c        ****           pgm_read_byte(tab_eeprom_fabryczny + i))
 8770               		.loc 1 1035 0
 8771 2ec2 8E17      		cp r24,r30
 8772 2ec4 01F0      		breq .L954
1037:main.c        ****     }
 8773               		.loc 1 1037 0
 8774 2ec6 FF24      		clr r15
 8775 2ec8 FA94      		dec r15
 8776               	.LVL639:
 8777               	.L954:
1034:main.c        ****       if (eeprom_read_byte((void *)i) !=
 8778               		.loc 1 1034 0 discriminator 2
 8779 2eca 0F5F      		subi r16,-1
 8780 2ecc 1F4F      		sbci r17,-1
 8781               	.LVL640:
 8782 2ece 0630      		cpi r16,6
 8783 2ed0 1105      		cpc r17,__zero_reg__
 8784 2ed2 01F4      		brne .L953
 8785               	.LBE662:
 8786               	.LBB664:
1039:main.c        ****          i < EEPROM_NUMER_TELEFONU_BRAMA_0 +
 8787               		.loc 1 1039 0
 8788 2ed4 08E0      		ldi r16,lo8(8)
 8789 2ed6 10E0      		ldi r17,0
 8790               	.LVL641:
 8791               	.L956:
1044:main.c        ****         bledny_zapis = TRUE;
 8792               		.loc 1 1044 0
 8793 2ed8 C801      		movw r24,r16
 8794 2eda 0E94 0000 		call eeprom_read_byte
 8795               	.LVL642:
 8796 2ede 8F3F      		cpi r24,lo8(-1)
 8797 2ee0 01F4      		brne .L955
1043:main.c        ****       if (eeprom_read_byte((void *)i) != 0xff) {
 8798               		.loc 1 1043 0
 8799 2ee2 0F5F      		subi r16,-1
 8800 2ee4 1F4F      		sbci r17,-1
 8801               	.LVL643:
1039:main.c        ****          i < EEPROM_NUMER_TELEFONU_BRAMA_0 +
 8802               		.loc 1 1039 0
 8803 2ee6 083A      		cpi r16,-88
 8804 2ee8 8FE0      		ldi r24,15
 8805 2eea 1807      		cpc r17,r24
 8806 2eec 01F4      		brne .L956
 8807               	.LBE664:
1049:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
 8808               		.loc 1 1049 0
 8809 2eee FF20      		tst r15
 8810 2ef0 01F0      		breq .L957
 8811               	.L955:
 8812               	.LVL644:
1050:main.c        ****       break;
 8813               		.loc 1 1050 0
 8814 2ef2 83E0      		ldi r24,lo8(3)
 8815 2ef4 00C0      		rjmp .L1049
 8816               	.LVL645:
 8817               	.L957:
1053:main.c        ****     ustaw_stan_led(FALSE); // Wylacz diode po zakonczeniu resetu
 8818               		.loc 1 1053 0
 8819 2ef6 0E94 0000 		call inicjalizuj_parametry_modulu
 8820               	.LVL646:
1054:main.c        ****     break;
 8821               		.loc 1 1054 0
 8822 2efa 409A      		sbi 0x8,0
 8823 2efc 00C0      		rjmp .L1048
 8824               	.LVL647:
 8825               	.L938:
 8826               	.LBE661:
 8827               	.LBB665:
1058:main.c        **** 
 8828               		.loc 1 1058 0
 8829 2efe 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8830 2f02 8111      		cpse r24,__zero_reg__
 8831 2f04 00C0      		rjmp .L958
1058:main.c        **** 
 8832               		.loc 1 1058 0 is_stmt 0 discriminator 2
 8833 2f06 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8834 2f0a 8111      		cpse r24,__zero_reg__
 8835 2f0c 00C0      		rjmp .L958
1058:main.c        **** 
 8836               		.loc 1 1058 0 discriminator 4
 8837 2f0e 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 8838 2f12 8111      		cpse r24,__zero_reg__
 8839 2f14 00C0      		rjmp .L958
1058:main.c        **** 
 8840               		.loc 1 1058 0 discriminator 6
 8841 2f16 F99B      		sbis 0x1f,1
 8842 2f18 00C0      		rjmp .L959
 8843               	.L958:
1058:main.c        **** 
 8844               		.loc 1 1058 0 discriminator 7
 8845 2f1a 84E8      		ldi r24,lo8(-124)
 8846 2f1c 00C0      		rjmp .L1049
 8847               	.L959:
1060:main.c        ****       // Poza dozwolonym czasem - ignoruj
 8848               		.loc 1 1060 0 is_stmt 1
 8849 2f1e D090 0000 		lds r13,blokada_sterowania_czasowa
 8850 2f22 D110      		cpse r13,__zero_reg__
 8851 2f24 00C0      		rjmp .L1048
1068:main.c        **** 
 8852               		.loc 1 1068 0
 8853 2f26 8E01      		movw r16,r28
 8854 2f28 0B5E      		subi r16,-21
 8855 2f2a 1F4F      		sbci r17,-1
 8856 2f2c 60E0      		ldi r22,lo8(numer_telefonu_ktory_dzwoni)
 8857 2f2e 70E0      		ldi r23,hi8(numer_telefonu_ktory_dzwoni)
 8858 2f30 C801      		movw r24,r16
 8859 2f32 0E94 0000 		call strcpy
 8860               	.LVL648:
1072:main.c        ****         &bufor_eeprom[0]);
 8861               		.loc 1 1072 0
 8862 2f36 F801      		movw r30,r16
 8863               		0:
 8864 2f38 0190      		ld __tmp_reg__,Z+
 8865 2f3a 0020      		tst __tmp_reg__
 8866 2f3c 01F4      		brne 0b
 8867 2f3e BF01      		movw r22,r30
 8868 2f40 6150      		subi r22,1
 8869 2f42 7109      		sbc r23,__zero_reg__
1071:main.c        ****         &numer_lokalny[0], &numer_lokalny[strlen((char *)numer_lokalny)],
 8870               		.loc 1 1071 0
 8871 2f44 40E0      		ldi r20,lo8(bufor_eeprom)
 8872 2f46 50E0      		ldi r21,hi8(bufor_eeprom)
 8873 2f48 C801      		movw r24,r16
 8874 2f4a 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 8875               	.LVL649:
1077:main.c        ****       // Tylko w trybie prywatnym sprawdzamy listę
 8876               		.loc 1 1077 0
 8877 2f4e 8091 0000 		lds r24,tryb_pracy
 8878 2f52 8130      		cpi r24,lo8(1)
 8879 2f54 01F0      		breq .L963
 8880 2f56 38E0      		ldi r19,lo8(8)
 8881 2f58 E32E      		mov r14,r19
 8882 2f5a F12C      		mov r15,__zero_reg__
 8883               	.L964:
 8884               	.LBB666:
1081:main.c        ****                 &bufor_eeprom[0],
 8885               		.loc 1 1081 0
 8886 2f5c B701      		movw r22,r14
 8887 2f5e 80E0      		ldi r24,lo8(bufor_eeprom)
 8888 2f60 90E0      		ldi r25,hi8(bufor_eeprom)
 8889 2f62 0E94 0000 		call porownaj_numer_telefonu_blok
 8890               	.LVL650:
 8891 2f66 8111      		cpse r24,__zero_reg__
 8892 2f68 00C0      		rjmp .L1015
 8893               	.LVL651:
 8894 2f6a F5E0      		ldi r31,5
 8895 2f6c EF0E      		add r14,r31
 8896 2f6e F11C      		adc r15,__zero_reg__
1079:main.c        ****            nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 8897               		.loc 1 1079 0
 8898 2f70 28EA      		ldi r18,-88
 8899 2f72 E216      		cp r14,r18
 8900 2f74 2FE0      		ldi r18,15
 8901 2f76 F206      		cpc r15,r18
 8902 2f78 01F4      		brne .L964
 8903               	.L963:
 8904               	.LVL652:
 8905               	.LBE666:
1092:main.c        ****       wyciagnij_ostatnie_cyfry(numer_lokalny, numer_skrocony, 9);
 8906               		.loc 1 1092 0
 8907 2f7a 8091 0000 		lds r24,skryba_wlaczona
 8908 2f7e 8823      		tst r24
 8909 2f80 01F0      		breq .L965
1092:main.c        ****       wyciagnij_ostatnie_cyfry(numer_lokalny, numer_skrocony, 9);
 8910               		.loc 1 1092 0 is_stmt 0 discriminator 1
 8911 2f82 DD20      		tst r13
 8912 2f84 01F4      		brne .+2
 8913 2f86 00C0      		rjmp .L966
 8914               	.L970:
 8915 2f88 DD24      		clr r13
 8916 2f8a DA94      		dec r13
 8917               	.LVL653:
 8918               	.L965:
1115:main.c        ****                          ADRES_EEPROM_DEBUG_SKRYBA_2); // DEBUG
 8919               		.loc 1 1115 0 is_stmt 1
 8920 2f8c 81E0      		ldi r24,lo8(1)
 8921 2f8e 9091 0000 		lds r25,skryba_wlaczona
 8922 2f92 9111      		cpse r25,__zero_reg__
 8923 2f94 00C0      		rjmp .L972
 8924 2f96 80E0      		ldi r24,0
 8925               	.L972:
 8926 2f98 61EF      		ldi r22,lo8(-15)
 8927 2f9a 7FE0      		ldi r23,lo8(15)
 8928 2f9c 0E94 0000 		call zapisz_znak_w_eeprom
 8929               	.LVL654:
1117:main.c        ****                          ADRES_EEPROM_DEBUG_SKRYBA_3); // DEBUG
 8930               		.loc 1 1117 0
 8931 2fa0 81E0      		ldi r24,lo8(1)
 8932 2fa2 D110      		cpse r13,__zero_reg__
 8933 2fa4 80E0      		ldi r24,0
 8934               	.L973:
 8935 2fa6 62EF      		ldi r22,lo8(-14)
 8936 2fa8 7FE0      		ldi r23,lo8(15)
 8937 2faa 0E94 0000 		call zapisz_znak_w_eeprom
 8938               	.LVL655:
1120:main.c        ****       uchar len_full = strlen((char *)numer_lokalny);
 8939               		.loc 1 1120 0
 8940 2fae 8091 0000 		lds r24,skryba_wlaczona
 8941 2fb2 8823      		tst r24
 8942 2fb4 01F0      		breq .L975
1120:main.c        ****       uchar len_full = strlen((char *)numer_lokalny);
 8943               		.loc 1 1120 0 is_stmt 0 discriminator 1
 8944 2fb6 D110      		cpse r13,__zero_reg__
 8945 2fb8 00C0      		rjmp .L975
 8946               	.LBB667:
1121:main.c        **** 
 8947               		.loc 1 1121 0 is_stmt 1
 8948 2fba F801      		movw r30,r16
 8949               		0:
 8950 2fbc 0190      		ld __tmp_reg__,Z+
 8951 2fbe 0020      		tst __tmp_reg__
 8952 2fc0 01F4      		brne 0b
 8953 2fc2 3197      		sbiw r30,1
 8954 2fc4 CF01      		movw r24,r30
 8955 2fc6 801B      		sub r24,r16
 8956 2fc8 910B      		sbc r25,r17
 8957 2fca 182F      		mov r17,r24
 8958               	.LVL656:
1124:main.c        **** 
 8959               		.loc 1 1124 0
 8960 2fcc 64EF      		ldi r22,lo8(-12)
 8961 2fce 7FE0      		ldi r23,lo8(15)
 8962 2fd0 0E94 0000 		call zapisz_znak_w_eeprom
 8963               	.LVL657:
1126:main.c        ****         // Skopiuj skrócony numer do numer_telefonu_skryba
 8964               		.loc 1 1126 0
 8965 2fd4 1330      		cpi r17,lo8(3)
 8966 2fd6 00F0      		brlo .L975
1128:main.c        **** 
 8967               		.loc 1 1128 0
 8968 2fd8 BE01      		movw r22,r28
 8969 2fda 6F5F      		subi r22,-1
 8970 2fdc 7F4F      		sbci r23,-1
 8971 2fde 80E0      		ldi r24,lo8(numer_telefonu_skryba)
 8972 2fe0 90E0      		ldi r25,hi8(numer_telefonu_skryba)
 8973 2fe2 0E94 0000 		call strcpy
 8974               	.LVL658:
1131:main.c        ****           zapisz_znak_w_eeprom(
 8975               		.loc 1 1131 0
 8976 2fe6 80E0      		ldi r24,lo8(numer_telefonu_skryba)
 8977 2fe8 90E0      		ldi r25,hi8(numer_telefonu_skryba)
 8978 2fea FC01      		movw r30,r24
 8979               		0:
 8980 2fec 0190      		ld __tmp_reg__,Z+
 8981 2fee 0020      		tst __tmp_reg__
 8982 2ff0 01F4      		brne 0b
 8983 2ff2 CF01      		movw r24,r30
 8984 2ff4 8050      		subi r24,lo8(numer_telefonu_skryba+1)
 8985 2ff6 9040      		sbci r25,hi8(numer_telefonu_skryba+1)
 8986 2ff8 0397      		sbiw r24,3
 8987 2ffa 00F0      		brlo .L975
1132:main.c        ****               1, ADRES_EEPROM_DEBUG_SKRYBA_4); // DEBUG: komenda dodana
 8988               		.loc 1 1132 0
 8989 2ffc 63EF      		ldi r22,lo8(-13)
 8990 2ffe 7FE0      		ldi r23,lo8(15)
 8991 3000 81E0      		ldi r24,lo8(1)
 8992 3002 0E94 0000 		call zapisz_znak_w_eeprom
 8993               	.LVL659:
1136:main.c        ****         }
 8994               		.loc 1 1136 0
 8995 3006 86E8      		ldi r24,lo8(-122)
 8996 3008 0E94 0000 		call dodaj_komende
 8997               	.LVL660:
 8998               	.L975:
 8999               	.LBE667:
1142:main.c        ****       if (tryb_pracy == 1) {
 9000               		.loc 1 1142 0
 9001 300c 8091 0000 		lds r24,tryb_clip
 9002 3010 8823      		tst r24
 9003 3012 01F4      		brne .+2
 9004 3014 00C0      		rjmp .L1048
1143:main.c        ****         // Tryb publiczny - otwórz dla każdego
 9005               		.loc 1 1143 0
 9006 3016 8091 0000 		lds r24,tryb_pracy
 9007 301a 8130      		cpi r24,lo8(1)
 9008 301c 01F0      		breq .+2
 9009 301e 00C0      		rjmp .L978
 9010               	.L979:
1145:main.c        ****       } else if (znaleziono) {
 9011               		.loc 1 1145 0
 9012 3020 0E94 0000 		call ustaw_wyjscie_clip
 9013               	.LVL661:
 9014 3024 00C0      		rjmp .L1048
 9015               	.LVL662:
 9016               	.L1015:
 9017               	.LBB668:
1084:main.c        ****           break;
 9018               		.loc 1 1084 0
 9019 3026 DD24      		clr r13
 9020 3028 DA94      		dec r13
 9021 302a 00C0      		rjmp .L963
 9022               	.LVL663:
 9023               	.L966:
 9024               	.LBE668:
 9025               	.LBB669:
 9026               	.LBB670:
 831:main.c        **** 
 9027               		.loc 1 831 0
 9028 302c F801      		movw r30,r16
 9029               		0:
 9030 302e 0190      		ld __tmp_reg__,Z+
 9031 3030 0020      		tst __tmp_reg__
 9032 3032 01F4      		brne 0b
 9033 3034 3197      		sbiw r30,1
 9034 3036 E01B      		sub r30,r16
 9035 3038 F10B      		sbc r31,r17
 9036               	.LVL664:
 9037 303a CE01      		movw r24,r28
 9038 303c 0196      		adiw r24,1
 9039 303e 7C01      		movw r14,r24
 833:main.c        ****     // Take last max_digits
 9040               		.loc 1 833 0
 9041 3040 EA30      		cpi r30,lo8(10)
 9042 3042 00F0      		brlo .L967
 835:main.c        ****   } else {
 9043               		.loc 1 835 0
 9044 3044 E950      		subi r30,9
 9045 3046 FF0B      		sbc r31,r31
 9046               	.LVL665:
 9047 3048 B801      		movw r22,r16
 9048 304a 6E0F      		add r22,r30
 9049 304c 7F1F      		adc r23,r31
 9050               	.L1046:
 838:main.c        ****   }
 9051               		.loc 1 838 0
 9052 304e 0E94 0000 		call strcpy
 9053               	.LVL666:
 9054               	.LBE670:
 9055               	.LBE669:
1097:main.c        ****           &bufor_eeprom[0]);
 9056               		.loc 1 1097 0
 9057 3052 F701      		movw r30,r14
 9058               		0:
 9059 3054 0190      		ld __tmp_reg__,Z+
 9060 3056 0020      		tst __tmp_reg__
 9061 3058 01F4      		brne 0b
 9062 305a BF01      		movw r22,r30
 9063 305c 6150      		subi r22,1
 9064 305e 7109      		sbc r23,__zero_reg__
1096:main.c        ****           &numer_skrocony[0], &numer_skrocony[strlen((char *)numer_skrocony)],
 9065               		.loc 1 1096 0
 9066 3060 40E0      		ldi r20,lo8(bufor_eeprom)
 9067 3062 50E0      		ldi r21,hi8(bufor_eeprom)
 9068 3064 C701      		movw r24,r14
 9069 3066 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9070               	.LVL667:
1100:main.c        ****         for (uint nr_uzyt_clip = 0;
 9071               		.loc 1 1100 0
 9072 306a 8091 0000 		lds r24,tryb_pracy
 9073 306e 8130      		cpi r24,lo8(1)
 9074 3070 01F4      		brne .+2
 9075 3072 00C0      		rjmp .L965
 9076 3074 28E0      		ldi r18,lo8(8)
 9077 3076 E22E      		mov r14,r18
 9078 3078 F12C      		mov r15,__zero_reg__
 9079               	.L969:
 9080               	.LBB672:
1104:main.c        ****                   &bufor_eeprom[0],
 9081               		.loc 1 1104 0
 9082 307a B701      		movw r22,r14
 9083 307c 80E0      		ldi r24,lo8(bufor_eeprom)
 9084 307e 90E0      		ldi r25,hi8(bufor_eeprom)
 9085 3080 0E94 0000 		call porownaj_numer_telefonu_blok
 9086               	.LVL668:
 9087 3084 8111      		cpse r24,__zero_reg__
 9088 3086 00C0      		rjmp .L970
 9089               	.LVL669:
 9090 3088 F5E0      		ldi r31,5
 9091 308a EF0E      		add r14,r31
 9092 308c F11C      		adc r15,__zero_reg__
1101:main.c        ****              nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 9093               		.loc 1 1101 0
 9094 308e 28EA      		ldi r18,-88
 9095 3090 E216      		cp r14,r18
 9096 3092 2FE0      		ldi r18,15
 9097 3094 F206      		cpc r15,r18
 9098 3096 01F4      		brne .L969
 9099 3098 00C0      		rjmp .L965
 9100               	.LVL670:
 9101               	.L967:
 9102               	.LBE672:
 9103               	.LBB673:
 9104               	.LBB671:
 838:main.c        ****   }
 9105               		.loc 1 838 0
 9106 309a B801      		movw r22,r16
 9107 309c 00C0      		rjmp .L1046
 9108               	.LVL671:
 9109               	.L978:
 9110               	.LBE671:
 9111               	.LBE673:
1146:main.c        ****         // Tryb prywatny - otwórz tylko dla znalezionych
 9112               		.loc 1 1146 0
 9113 309e DD20      		tst r13
 9114 30a0 01F4      		brne .+2
 9115 30a2 00C0      		rjmp .L1048
 9116 30a4 00C0      		rjmp .L979
 9117               	.LVL672:
 9118               	.L944:
 9119               	.LBE665:
 9120               	.LBB674:
1156:main.c        **** 
 9121               		.loc 1 1156 0
 9122 30a6 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 9123 30aa 8111      		cpse r24,__zero_reg__
 9124 30ac 00C0      		rjmp .L980
1156:main.c        **** 
 9125               		.loc 1 1156 0 is_stmt 0 discriminator 2
 9126 30ae 8091 0000 		lds r24,liczba_znakow_do_zapisu
 9127 30b2 8111      		cpse r24,__zero_reg__
 9128 30b4 00C0      		rjmp .L980
1156:main.c        **** 
 9129               		.loc 1 1156 0 discriminator 4
 9130 30b6 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 9131 30ba 8111      		cpse r24,__zero_reg__
 9132 30bc 00C0      		rjmp .L980
1156:main.c        **** 
 9133               		.loc 1 1156 0 discriminator 6
 9134 30be F99B      		sbis 0x1f,1
 9135 30c0 00C0      		rjmp .L981
 9136               	.L980:
1156:main.c        **** 
 9137               		.loc 1 1156 0 discriminator 7
 9138 30c2 85E8      		ldi r24,lo8(-123)
 9139 30c4 00C0      		rjmp .L1049
 9140               	.L981:
1159:main.c        ****       return TRUE; // Duplicate found, abort
 9141               		.loc 1 1159 0 is_stmt 1
 9142 30c6 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 9143 30c8 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 9144 30ca 0E94 0000 		call czy_numer_istnieje
 9145               	.LVL673:
 9146 30ce 8111      		cpse r24,__zero_reg__
 9147 30d0 00C0      		rjmp .L1048
1168:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
 9148               		.loc 1 1168 0
 9149 30d2 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 9150 30d4 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 9151 30d6 FB01      		movw r30,r22
 9152               		0:
 9153 30d8 0190      		ld __tmp_reg__,Z+
 9154 30da 0020      		tst __tmp_reg__
 9155 30dc 01F4      		brne 0b
 9156 30de BF01      		movw r22,r30
 9157 30e0 6150      		subi r22,1
 9158 30e2 7109      		sbc r23,__zero_reg__
1166:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
 9159               		.loc 1 1166 0
 9160 30e4 40E0      		ldi r20,lo8(bufor_eeprom)
 9161 30e6 50E0      		ldi r21,hi8(bufor_eeprom)
 9162 30e8 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 9163 30ea 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 9164 30ec 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9165               	.LVL674:
1175:main.c        ****     for (uint nr_uzyt_clip = 0; nr_uzyt_clip < max_pozycja; ++nr_uzyt_clip) {
 9166               		.loc 1 1175 0
 9167 30f0 E090 0000 		lds r14,skryba_limit
 9168 30f4 F090 0000 		lds r15,skryba_limit+1
 9169 30f8 FCE1      		ldi r31,28
 9170 30fa EF16      		cp r14,r31
 9171 30fc F3E0      		ldi r31,3
 9172 30fe FF06      		cpc r15,r31
 9173 3100 00F0      		brlo .L983
 9174 3102 9BE1      		ldi r25,lo8(27)
 9175 3104 E92E      		mov r14,r25
 9176 3106 93E0      		ldi r25,lo8(3)
 9177 3108 F92E      		mov r15,r25
 9178               	.L983:
 9179               	.LVL675:
 9180               	.LBB675:
1176:main.c        ****       if (not czy_aktywny_numer_telefonu_brama(nr_uzyt_clip)) {
 9181               		.loc 1 1176 0
 9182 310a 08E0      		ldi r16,lo8(8)
 9183 310c 10E0      		ldi r17,0
 9184 310e D12C      		mov r13,__zero_reg__
 9185 3110 C12C      		mov r12,__zero_reg__
 9186               	.LVL676:
 9187               	.L984:
1176:main.c        ****       if (not czy_aktywny_numer_telefonu_brama(nr_uzyt_clip)) {
 9188               		.loc 1 1176 0 is_stmt 0 discriminator 1
 9189 3112 CE14      		cp r12,r14
 9190 3114 DF04      		cpc r13,r15
 9191 3116 01F4      		brne .+2
 9192 3118 00C0      		rjmp .L1048
1177:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
 9193               		.loc 1 1177 0 is_stmt 1
 9194 311a C801      		movw r24,r16
 9195 311c 0E94 0000 		call eeprom_read_byte
 9196               	.LVL677:
 9197 3120 9801      		movw r18,r16
 9198 3122 2B5F      		subi r18,-5
 9199 3124 3F4F      		sbci r19,-1
 9200 3126 8F3F      		cpi r24,lo8(-1)
 9201 3128 01F4      		brne .L985
1178:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
 9202               		.loc 1 1178 0
 9203 312a 65E0      		ldi r22,lo8(5)
 9204 312c C801      		movw r24,r16
 9205 312e 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 9206               	.LVL678:
 9207               	.LBE675:
1187:main.c        ****       // Policz aktywnych uzytkownikow
 9208               		.loc 1 1187 0
 9209 3132 8091 0000 		lds r24,skryba_wlaczona
 9210 3136 08E0      		ldi r16,lo8(8)
 9211 3138 10E0      		ldi r17,0
 9212               	.LBB676:
1189:main.c        ****       for (uint i = 0; i < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++i) {
 9213               		.loc 1 1189 0
 9214 313a F12C      		mov r15,__zero_reg__
 9215 313c E12C      		mov r14,__zero_reg__
 9216               	.LVL679:
 9217               	.LBE676:
1187:main.c        ****       // Policz aktywnych uzytkownikow
 9218               		.loc 1 1187 0
 9219 313e 8823      		tst r24
 9220 3140 01F4      		brne .+2
 9221 3142 00C0      		rjmp .L1048
 9222               	.L986:
 9223               	.LVL680:
 9224               	.LBB678:
 9225               	.LBB677:
1191:main.c        ****           ++aktywne_numery;
 9226               		.loc 1 1191 0
 9227 3144 C801      		movw r24,r16
 9228 3146 0E94 0000 		call eeprom_read_byte
 9229               	.LVL681:
 9230 314a 8F3F      		cpi r24,lo8(-1)
 9231 314c 01F0      		breq .L989
1192:main.c        ****         }
 9232               		.loc 1 1192 0
 9233 314e 9FEF      		ldi r25,-1
 9234 3150 E91A      		sub r14,r25
 9235 3152 F90A      		sbc r15,r25
 9236               	.LVL682:
 9237               	.L989:
 9238 3154 0B5F      		subi r16,-5
 9239 3156 1F4F      		sbci r17,-1
1190:main.c        ****         if (czy_aktywny_numer_telefonu_brama(i)) {
 9240               		.loc 1 1190 0 discriminator 2
 9241 3158 083A      		cpi r16,-88
 9242 315a EFE0      		ldi r30,15
 9243 315c 1E07      		cpc r17,r30
 9244 315e 01F4      		brne .L986
 9245               	.LVL683:
 9246               	.L1053:
 9247               	.LBE677:
 9248               	.LBE678:
 9249               	.LBE674:
 9250               	.LBB680:
 9251               	.LBB681:
1253:main.c        ****         skryba_wlaczona = FALSE;
 9252               		.loc 1 1253 0
 9253 3160 8091 0000 		lds r24,skryba_limit
 9254 3164 9091 0000 		lds r25,skryba_limit+1
 9255 3168 E816      		cp r14,r24
 9256 316a F906      		cpc r15,r25
 9257 316c 00F4      		brsh .+2
 9258 316e 00C0      		rjmp .L1048
1254:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_SKRYBA);
 9259               		.loc 1 1254 0
 9260 3170 1092 0000 		sts skryba_wlaczona,__zero_reg__
1255:main.c        **** 
 9261               		.loc 1 1255 0
 9262 3174 69EF      		ldi r22,lo8(-7)
 9263 3176 7FE0      		ldi r23,lo8(15)
 9264 3178 80E0      		ldi r24,0
 9265 317a 0E94 0000 		call zapisz_znak_w_eeprom
 9266               	.LVL684:
1257:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_TRYB_PRACY);
 9267               		.loc 1 1257 0
 9268 317e 1092 0000 		sts tryb_pracy,__zero_reg__
1258:main.c        ****       }
 9269               		.loc 1 1258 0
 9270 3182 6EEF      		ldi r22,lo8(-2)
 9271 3184 7FE0      		ldi r23,lo8(15)
 9272 3186 80E0      		ldi r24,0
 9273 3188 0E94 0000 		call zapisz_znak_w_eeprom
 9274               	.LVL685:
 9275 318c 00C0      		rjmp .L1048
 9276               	.LVL686:
 9277               	.L985:
 9278               	.LBE681:
 9279               	.LBE680:
 9280               	.LBB687:
 9281               	.LBB679:
1176:main.c        ****       if (not czy_aktywny_numer_telefonu_brama(nr_uzyt_clip)) {
 9282               		.loc 1 1176 0 discriminator 2
 9283 318e 8FEF      		ldi r24,-1
 9284 3190 C81A      		sub r12,r24
 9285 3192 D80A      		sbc r13,r24
 9286               	.LVL687:
 9287 3194 8901      		movw r16,r18
 9288 3196 00C0      		rjmp .L984
 9289               	.LVL688:
 9290               	.L943:
 9291               	.LBE679:
 9292               	.LBE687:
 9293               	.LBB688:
1208:main.c        **** 
 9294               		.loc 1 1208 0
 9295 3198 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 9296 319c 8111      		cpse r24,__zero_reg__
 9297 319e 00C0      		rjmp .L990
1208:main.c        **** 
 9298               		.loc 1 1208 0 is_stmt 0 discriminator 2
 9299 31a0 8091 0000 		lds r24,liczba_znakow_do_zapisu
 9300 31a4 8111      		cpse r24,__zero_reg__
 9301 31a6 00C0      		rjmp .L990
1208:main.c        **** 
 9302               		.loc 1 1208 0 discriminator 4
 9303 31a8 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 9304 31ac 8111      		cpse r24,__zero_reg__
 9305 31ae 00C0      		rjmp .L990
1208:main.c        **** 
 9306               		.loc 1 1208 0 discriminator 6
 9307 31b0 F99B      		sbis 0x1f,1
 9308 31b2 00C0      		rjmp .L991
 9309               	.L990:
1208:main.c        **** 
 9310               		.loc 1 1208 0 discriminator 7
 9311 31b4 86E8      		ldi r24,lo8(-122)
 9312 31b6 00C0      		rjmp .L1049
 9313               	.L991:
1216:main.c        ****         bufor_skryba);
 9314               		.loc 1 1216 0 is_stmt 1
 9315 31b8 60E0      		ldi r22,lo8(numer_telefonu_skryba)
 9316 31ba 70E0      		ldi r23,hi8(numer_telefonu_skryba)
 9317 31bc FB01      		movw r30,r22
 9318               		0:
 9319 31be 0190      		ld __tmp_reg__,Z+
 9320 31c0 0020      		tst __tmp_reg__
 9321 31c2 01F4      		brne 0b
 9322 31c4 BF01      		movw r22,r30
 9323 31c6 6150      		subi r22,1
 9324 31c8 7109      		sbc r23,__zero_reg__
1214:main.c        ****         &numer_telefonu_skryba[0],
 9325               		.loc 1 1214 0
 9326 31ca AE01      		movw r20,r28
 9327 31cc 4F5F      		subi r20,-1
 9328 31ce 5F4F      		sbci r21,-1
 9329 31d0 80E0      		ldi r24,lo8(numer_telefonu_skryba)
 9330 31d2 90E0      		ldi r25,hi8(numer_telefonu_skryba)
 9331 31d4 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9332               	.LVL689:
1222:main.c        ****       return TRUE; // Duplicate found, abort
 9333               		.loc 1 1222 0
 9334 31d8 80E0      		ldi r24,lo8(numer_telefonu_skryba)
 9335 31da 90E0      		ldi r25,hi8(numer_telefonu_skryba)
 9336 31dc 0E94 0000 		call czy_numer_istnieje
 9337               	.LVL690:
 9338 31e0 8111      		cpse r24,__zero_reg__
 9339 31e2 00C0      		rjmp .L1048
1227:main.c        **** 
 9340               		.loc 1 1227 0
 9341 31e4 85E0      		ldi r24,lo8(5)
 9342 31e6 FE01      		movw r30,r28
 9343 31e8 3196      		adiw r30,1
 9344 31ea A0E0      		ldi r26,lo8(bufor_eeprom)
 9345 31ec B0E0      		ldi r27,hi8(bufor_eeprom)
 9346               		0:
 9347 31ee 0190      		ld r0,Z+
 9348 31f0 0D92      		st X+,r0
 9349 31f2 8A95      		dec r24
 9350 31f4 01F4      		brne 0b
 9351               	.LVL691:
 9352 31f6 08E0      		ldi r16,lo8(8)
 9353 31f8 10E0      		ldi r17,0
 9354               	.LVL692:
 9355               	.L996:
 9356               	.LBB683:
1232:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
 9357               		.loc 1 1232 0
 9358 31fa C801      		movw r24,r16
 9359 31fc 0E94 0000 		call eeprom_read_byte
 9360               	.LVL693:
 9361 3200 8F3F      		cpi r24,lo8(-1)
 9362 3202 01F4      		brne .L994
1233:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
 9363               		.loc 1 1233 0
 9364 3204 65E0      		ldi r22,lo8(5)
 9365 3206 C801      		movw r24,r16
 9366 3208 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 9367               	.LVL694:
 9368               	.LBE683:
1243:main.c        ****       // Policz aktywnych uzytkownikow
 9369               		.loc 1 1243 0
 9370 320c 8091 0000 		lds r24,skryba_wlaczona
 9371 3210 08E0      		ldi r16,lo8(8)
 9372 3212 10E0      		ldi r17,0
 9373               	.LBB684:
1245:main.c        ****       for (uint i = 0; i < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++i) {
 9374               		.loc 1 1245 0
 9375 3214 F12C      		mov r15,__zero_reg__
 9376 3216 E12C      		mov r14,__zero_reg__
 9377               	.LBE684:
1243:main.c        ****       // Policz aktywnych uzytkownikow
 9378               		.loc 1 1243 0
 9379 3218 8823      		tst r24
 9380 321a 01F4      		brne .+2
 9381 321c 00C0      		rjmp .L1048
 9382               	.L995:
 9383               	.LVL695:
 9384               	.LBB685:
 9385               	.LBB682:
1247:main.c        ****           ++aktywne_numery;
 9386               		.loc 1 1247 0
 9387 321e C801      		movw r24,r16
 9388 3220 0E94 0000 		call eeprom_read_byte
 9389               	.LVL696:
 9390 3224 8F3F      		cpi r24,lo8(-1)
 9391 3226 01F0      		breq .L998
1248:main.c        ****         }
 9392               		.loc 1 1248 0
 9393 3228 2FEF      		ldi r18,-1
 9394 322a E21A      		sub r14,r18
 9395 322c F20A      		sbc r15,r18
 9396               	.LVL697:
 9397               	.L998:
 9398 322e 0B5F      		subi r16,-5
 9399 3230 1F4F      		sbci r17,-1
1246:main.c        ****         if (czy_aktywny_numer_telefonu_brama(i)) {
 9400               		.loc 1 1246 0 discriminator 2
 9401 3232 083A      		cpi r16,-88
 9402 3234 8FE0      		ldi r24,15
 9403 3236 1807      		cpc r17,r24
 9404 3238 01F4      		brne .L995
 9405 323a 00C0      		rjmp .L1053
 9406               	.LVL698:
 9407               	.L994:
 9408 323c 0B5F      		subi r16,-5
 9409 323e 1F4F      		sbci r17,-1
 9410               	.LBE682:
 9411               	.LBE685:
 9412               	.LBB686:
1230:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 9413               		.loc 1 1230 0
 9414 3240 083A      		cpi r16,-88
 9415 3242 FFE0      		ldi r31,15
 9416 3244 1F07      		cpc r17,r31
 9417 3246 01F4      		brne .L996
 9418 3248 00C0      		rjmp .L1048
 9419               	.LVL699:
 9420               	.L945:
 9421               	.LBE686:
 9422               	.LBE688:
 9423               	.LBB689:
1264:main.c        **** 
 9424               		.loc 1 1264 0
 9425 324a 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 9426 324e 8111      		cpse r24,__zero_reg__
 9427 3250 00C0      		rjmp .L999
1264:main.c        **** 
 9428               		.loc 1 1264 0 is_stmt 0 discriminator 2
 9429 3252 8091 0000 		lds r24,liczba_znakow_do_zapisu
 9430 3256 8111      		cpse r24,__zero_reg__
 9431 3258 00C0      		rjmp .L999
1264:main.c        **** 
 9432               		.loc 1 1264 0 discriminator 4
 9433 325a 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 9434 325e 8111      		cpse r24,__zero_reg__
 9435 3260 00C0      		rjmp .L999
1264:main.c        **** 
 9436               		.loc 1 1264 0 discriminator 6
 9437 3262 F99B      		sbis 0x1f,1
 9438 3264 00C0      		rjmp .L1000
 9439               	.L999:
1264:main.c        **** 
 9440               		.loc 1 1264 0 discriminator 7
 9441 3266 87E8      		ldi r24,lo8(-121)
 9442 3268 00C0      		rjmp .L1049
 9443               	.L1000:
1272:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
 9444               		.loc 1 1272 0 is_stmt 1
 9445 326a 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 9446 326c 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 9447 326e FB01      		movw r30,r22
 9448               		0:
 9449 3270 0190      		ld __tmp_reg__,Z+
 9450 3272 0020      		tst __tmp_reg__
 9451 3274 01F4      		brne 0b
 9452 3276 BF01      		movw r22,r30
 9453 3278 6150      		subi r22,1
 9454 327a 7109      		sbc r23,__zero_reg__
1270:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
 9455               		.loc 1 1270 0
 9456 327c AE01      		movw r20,r28
 9457 327e 4F5F      		subi r20,-1
 9458 3280 5F4F      		sbci r21,-1
 9459 3282 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 9460 3284 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 9461 3286 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9462               	.LVL700:
1279:main.c        ****       // Numer juz istnieje - wyslij komunikat
 9463               		.loc 1 1279 0
 9464 328a 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 9465 328c 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 9466 328e 0E94 0000 		call czy_numer_istnieje
 9467               	.LVL701:
 9468 3292 D82E      		mov r13,r24
 9469 3294 8823      		tst r24
 9470 3296 01F0      		breq .L1001
1281:main.c        ****              (char *)numer_telefonu_odebranego_smsa);
 9471               		.loc 1 1281 0
 9472 3298 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 9473 329a 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 9474 329c 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 9475 329e 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 9476 32a0 0E94 0000 		call strcpy
 9477               	.LVL702:
1283:main.c        ****                PSTR("Numer juz istnieje w systemie"));
 9478               		.loc 1 1283 0
 9479 32a4 60E0      		ldi r22,lo8(__c.3690)
 9480 32a6 70E0      		ldi r23,hi8(__c.3690)
 9481               	.LVL703:
 9482               	.L1047:
1314:main.c        ****                PSTR("Brak wolnych pozycji Super User (795-800)"));
 9483               		.loc 1 1314 0
 9484 32a8 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 9485 32aa 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 9486 32ac 0E94 0000 		call strcpy_P
 9487               	.LVL704:
 9488 32b0 00C0      		rjmp .L1007
 9489               	.LVL705:
 9490               	.L1001:
1290:main.c        **** 
 9491               		.loc 1 1290 0
 9492 32b2 85E0      		ldi r24,lo8(5)
 9493 32b4 FE01      		movw r30,r28
 9494 32b6 3196      		adiw r30,1
 9495 32b8 A0E0      		ldi r26,lo8(bufor_eeprom)
 9496 32ba B0E0      		ldi r27,hi8(bufor_eeprom)
 9497               		0:
 9498 32bc 0190      		ld r0,Z+
 9499 32be 0D92      		st X+,r0
 9500 32c0 8A95      		dec r24
 9501 32c2 01F4      		brne 0b
 9502               	.LVL706:
 9503 32c4 8AE8      		ldi r24,lo8(-118)
 9504 32c6 E82E      		mov r14,r24
 9505 32c8 8FE0      		ldi r24,lo8(15)
 9506 32ca F82E      		mov r15,r24
 9507               	.LBB690:
1295:main.c        ****          ++nr_uzyt) {
 9508               		.loc 1 1295 0
 9509 32cc 0AE1      		ldi r16,lo8(26)
 9510 32ce 13E0      		ldi r17,lo8(3)
 9511               	.LVL707:
 9512               	.L1005:
1297:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
 9513               		.loc 1 1297 0
 9514 32d0 C701      		movw r24,r14
 9515 32d2 0E94 0000 		call eeprom_read_byte
 9516               	.LVL708:
 9517 32d6 0F5F      		subi r16,-1
 9518 32d8 1F4F      		sbci r17,-1
 9519               	.LVL709:
 9520 32da 8F3F      		cpi r24,lo8(-1)
 9521 32dc 01F4      		brne .L1003
1298:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt),
 9522               		.loc 1 1298 0
 9523 32de 65E0      		ldi r22,lo8(5)
 9524 32e0 C701      		movw r24,r14
 9525 32e2 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 9526               	.LVL710:
1301:main.c        ****         pozycja_dodana = nr_uzyt + 1; // User-facing (1-indexed)
 9527               		.loc 1 1301 0
 9528 32e6 DD24      		clr r13
 9529 32e8 DA94      		dec r13
 9530               	.LVL711:
 9531               	.L1004:
 9532               	.LBE690:
1308:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 9533               		.loc 1 1308 0
 9534 32ea 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 9535 32ec 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 9536 32ee 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 9537 32f0 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 9538 32f2 0E94 0000 		call strcpy
 9539               	.LVL712:
1310:main.c        ****       sprintf((char *)tekst_wysylanego_smsa, "Super User dodany na pozycji %u",
 9540               		.loc 1 1310 0
 9541 32f6 DD20      		tst r13
 9542 32f8 01F0      		breq .L1006
1311:main.c        ****               pozycja_dodana);
 9543               		.loc 1 1311 0
 9544 32fa 1F93      		push r17
 9545 32fc 0F93      		push r16
 9546 32fe 80E0      		ldi r24,lo8(.LC7)
 9547 3300 90E0      		ldi r25,hi8(.LC7)
 9548 3302 9F93      		push r25
 9549 3304 8F93      		push r24
 9550 3306 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 9551 3308 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 9552 330a 9F93      		push r25
 9553 330c 8F93      		push r24
 9554 330e 0E94 0000 		call sprintf
 9555               	.LVL713:
 9556 3312 0F90      		pop __tmp_reg__
 9557 3314 0F90      		pop __tmp_reg__
 9558 3316 0F90      		pop __tmp_reg__
 9559 3318 0F90      		pop __tmp_reg__
 9560 331a 0F90      		pop __tmp_reg__
 9561 331c 0F90      		pop __tmp_reg__
 9562               	.L1007:
1317:main.c        **** 
 9563               		.loc 1 1317 0
 9564 331e 83ED      		ldi r24,lo8(-45)
 9565 3320 00C0      		rjmp .L1049
 9566               	.LVL714:
 9567               	.L1003:
 9568 3322 F5E0      		ldi r31,5
 9569 3324 EF0E      		add r14,r31
 9570 3326 F11C      		adc r15,__zero_reg__
 9571               	.LBB691:
1295:main.c        ****          ++nr_uzyt) {
 9572               		.loc 1 1295 0
 9573 3328 0032      		cpi r16,32
 9574 332a 23E0      		ldi r18,3
 9575 332c 1207      		cpc r17,r18
 9576 332e 01F4      		brne .L1005
 9577               	.LVL715:
 9578               	.LBE691:
1294:main.c        ****     for (uint nr_uzyt = 794; nr_uzyt < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 9579               		.loc 1 1294 0
 9580 3330 10E0      		ldi r17,0
 9581               	.LVL716:
 9582 3332 00E0      		ldi r16,0
 9583 3334 00C0      		rjmp .L1004
 9584               	.LVL717:
 9585               	.L1006:
1314:main.c        ****                PSTR("Brak wolnych pozycji Super User (795-800)"));
 9586               		.loc 1 1314 0
 9587 3336 60E0      		ldi r22,lo8(__c.3698)
 9588 3338 70E0      		ldi r23,hi8(__c.3698)
 9589 333a 00C0      		rjmp .L1047
 9590               	.LVL718:
 9591               	.L1009:
 9592               	.LBE689:
1324:main.c        ****                                          numer_telefonu_do_ktorego_dzwonic)],
 9593               		.loc 1 1324 0
 9594 333c 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 9595 333e 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 9596 3340 FB01      		movw r30,r22
 9597               		0:
 9598 3342 0190      		ld __tmp_reg__,Z+
 9599 3344 0020      		tst __tmp_reg__
 9600 3346 01F4      		brne 0b
 9601 3348 BF01      		movw r22,r30
 9602 334a 6150      		subi r22,1
 9603 334c 7109      		sbc r23,__zero_reg__
1323:main.c        ****                                      &numer_telefonu_do_ktorego_dzwonic[strlen(
 9604               		.loc 1 1323 0
 9605 334e 40E0      		ldi r20,lo8(bufor_eeprom)
 9606 3350 50E0      		ldi r21,hi8(bufor_eeprom)
 9607 3352 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 9608 3354 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 9609 3356 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9610               	.LVL719:
 9611 335a 08E0      		ldi r16,lo8(8)
 9612 335c 10E0      		ldi r17,0
 9613               	.LVL720:
 9614               	.L1011:
 9615               	.LBB692:
1331:main.c        ****               &bufor_eeprom[0], // 1 porwnanie zajmuje ~10us, czyli 170 numerw ~
 9616               		.loc 1 1331 0
 9617 335e B801      		movw r22,r16
 9618 3360 80E0      		ldi r24,lo8(bufor_eeprom)
 9619 3362 90E0      		ldi r25,hi8(bufor_eeprom)
 9620 3364 0E94 0000 		call porownaj_numer_telefonu_blok
 9621               	.LVL721:
 9622 3368 8823      		tst r24
 9623 336a 01F0      		breq .L1010
1335:main.c        ****         konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 9624               		.loc 1 1335 0
 9625 336c 1092 0000 		sts numer_telefonu_do_ktorego_dzwonic,__zero_reg__
1336:main.c        ****                                          &numer_telefonu_do_ktorego_dzwonic[1],
 9626               		.loc 1 1336 0
 9627 3370 40E0      		ldi r20,lo8(bufor_eeprom)
 9628 3372 50E0      		ldi r21,hi8(bufor_eeprom)
 9629 3374 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic+1)
 9630 3376 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic+1)
 9631 3378 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 9632 337a 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 9633 337c 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9634               	.LVL722:
1339:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
 9635               		.loc 1 1339 0
 9636 3380 65E0      		ldi r22,lo8(5)
 9637 3382 C801      		movw r24,r16
 9638 3384 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 9639               	.LVL723:
 9640 3388 00C0      		rjmp .L1048
 9641               	.L1010:
 9642 338a 0B5F      		subi r16,-5
 9643 338c 1F4F      		sbci r17,-1
1329:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 9644               		.loc 1 1329 0
 9645 338e 083A      		cpi r16,-88
 9646 3390 FFE0      		ldi r31,15
 9647 3392 1F07      		cpc r17,r31
 9648 3394 01F4      		brne .L1011
 9649 3396 00C0      		rjmp .L1048
 9650               	.LBE692:
 9651               		.cfi_endproc
 9652               	.LFE59:
 9654               	.global	wykonanie_komend
 9656               	wykonanie_komend:
 9657               	.LFB61:
1419:main.c        ****   if (wykonanie_komend_SIM900())
 9658               		.loc 1 1419 0
 9659               		.cfi_startproc
 9660               	/* prologue: function */
 9661               	/* frame size = 0 */
 9662               	/* stack size = 0 */
 9663               	.L__stack_usage = 0
1420:main.c        ****     ;
 9664               		.loc 1 1420 0
 9665 3398 0E94 0000 		call wykonanie_komend_SIM900
 9666               	.LVL724:
 9667 339c 8111      		cpse r24,__zero_reg__
 9668 339e 00C0      		rjmp .L1056
1422:main.c        ****     ;
 9669               		.loc 1 1422 0
 9670 33a0 0E94 0000 		call wykonanie_komend_ukladow
 9671               	.LVL725:
 9672 33a4 8111      		cpse r24,__zero_reg__
 9673 33a6 00C0      		rjmp .L1056
1424:main.c        ****     ;
 9674               		.loc 1 1424 0
 9675 33a8 0E94 0000 		call wykonanie_komend_powiadomien
 9676               	.LVL726:
 9677               	.L1056:
1428:main.c        **** }
 9678               		.loc 1 1428 0
 9679 33ac 0C94 0000 		jmp usun_komende
 9680               	.LVL727:
 9681               		.cfi_endproc
 9682               	.LFE61:
 9684               		.section	.text.startup,"ax",@progbits
 9685               	.global	main
 9687               	main:
 9688               	.LFB71:
1827:main.c        **** 
1828:main.c        **** #include "test_debug.h"
1829:main.c        **** 
1830:main.c        **** int main(void) {
 9689               		.loc 1 1830 0
 9690               		.cfi_startproc
 9691               	/* prologue: function */
 9692               	/* frame size = 0 */
 9693               	/* stack size = 0 */
 9694               	.L__stack_usage = 0
 9695               	.LVL728:
 9696               	.LBB693:
 9697               	.LBB694:
 9698               		.loc 7 473 0
 9699 0000 88E1      		ldi r24,lo8(24)
 9700 0002 9BE0      		ldi r25,lo8(11)
 9701               	/* #APP */
 9702               	 ;  473 "/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h" 1
 9703 0004 0FB6      		in __tmp_reg__,__SREG__
 9704 0006 F894      		cli
 9705 0008 A895      		wdr
 9706 000a 8093 6000 		sts 96, r24
 9707 000e 0FBE      		out __SREG__,__tmp_reg__
 9708 0010 9093 6000 		sts 96, r25
 9709               	 	
 9710               	 ;  0 "" 2
 9711               	.LVL729:
 9712               	/* #NOAPP */
 9713               	.LBE694:
 9714               	.LBE693:
1831:main.c        ****   // POMOC_DODAJ2('*', 'u');
1832:main.c        ****   { // inicjalizacja
1833:main.c        **** #ifndef DEBUG
1834:main.c        ****     wdt_enable(WDTO_120MS);
1835:main.c        ****     opoznienie_startowe();
 9715               		.loc 1 1835 0
 9716 0014 0E94 0000 		call opoznienie_startowe
 9717               	.LVL730:
1836:main.c        ****     opoznienie_startowe();
 9718               		.loc 1 1836 0
 9719 0018 0E94 0000 		call opoznienie_startowe
 9720               	.LVL731:
1837:main.c        ****     opoznienie_startowe();
 9721               		.loc 1 1837 0
 9722 001c 0E94 0000 		call opoznienie_startowe
 9723               	.LVL732:
1838:main.c        ****     opoznienie_startowe();
 9724               		.loc 1 1838 0
 9725 0020 0E94 0000 		call opoznienie_startowe
 9726               	.LVL733:
1839:main.c        **** #endif
1840:main.c        ****     inicjalizacja_portow();
 9727               		.loc 1 1840 0
 9728 0024 81E0      		ldi r24,lo8(1)
 9729 0026 87B9      		out 0x7,r24
 9730 0028 88B9      		out 0x8,r24
 9731 002a 80E2      		ldi r24,lo8(32)
 9732 002c 8AB9      		out 0xa,r24
1841:main.c        ****     inicjalizuj_parametry_modulu();
 9733               		.loc 1 1841 0
 9734 002e 0E94 0000 		call inicjalizuj_parametry_modulu
 9735               	.LVL734:
1842:main.c        ****     inicjalizacja_SIM900();
 9736               		.loc 1 1842 0
 9737 0032 0E94 0000 		call inicjalizacja_SIM900
 9738               	.LVL735:
1843:main.c        **** #ifdef DEBUG
1844:main.c        ****     debug_main();
1845:main.c        **** #endif
1846:main.c        ****     ustaw_parametry_dla_bezpieczenstwa();
 9739               		.loc 1 1846 0
 9740 0036 0E94 0000 		call ustaw_parametry_dla_bezpieczenstwa
 9741               	.LVL736:
1847:main.c        ****   }
1848:main.c        **** 
1849:main.c        ****   sei();
 9742               		.loc 1 1849 0
 9743               	/* #APP */
 9744               	 ;  1849 "main.c" 1
 9745 003a 7894      		sei
 9746               	 ;  0 "" 2
 9747               	/* #NOAPP */
 9748               	.L1063:
1850:main.c        **** 
1851:main.c        ****   for (;;) {
1852:main.c        ****     // wykonanie watkw moe trwa maksymalnie 10 ms
1853:main.c        ****     if (CZY_WYKONAC_WATKI_10MS())
 9749               		.loc 1 1853 0
 9750 003c 8091 0000 		lds r24,wykonac_watki
 9751 0040 80FD      		sbrc r24,0
1854:main.c        ****       ustaw_parametry_dla_bezpieczenstwa();
 9752               		.loc 1 1854 0
 9753 0042 0E94 0000 		call ustaw_parametry_dla_bezpieczenstwa
 9754               	.LVL737:
 9755               	.L1059:
1855:main.c        ****     if (CZY_WYKONAC_WATKI_100MS()) {
 9756               		.loc 1 1855 0
 9757 0046 8091 0000 		lds r24,wykonac_watki
 9758 004a 81FD      		sbrc r24,1
1856:main.c        ****       steruj_urzadzeniem_100MS();
 9759               		.loc 1 1856 0
 9760 004c 0E94 0000 		call steruj_urzadzeniem_100MS
 9761               	.LVL738:
 9762               	.L1060:
1857:main.c        **** #ifdef TEST_PCB
1858:main.c        ****       testPCB();
1859:main.c        **** #endif
1860:main.c        ****     }
1861:main.c        ****     if (CZY_WYKONAC_WATKI_10MS()) {
 9763               		.loc 1 1861 0
 9764 0050 8091 0000 		lds r24,wykonac_watki
 9765 0054 80FF      		sbrs r24,0
 9766 0056 00C0      		rjmp .L1061
1862:main.c        ****       steruj_urzadzeniem_10MS();
 9767               		.loc 1 1862 0
 9768 0058 0E94 0000 		call steruj_urzadzeniem_10MS
 9769               	.LVL739:
1863:main.c        ****       wykonanie_komend();
 9770               		.loc 1 1863 0
 9771 005c 0E94 0000 		call wykonanie_komend
 9772               	.LVL740:
1864:main.c        **** 
1865:main.c        ****       RESETUJ_WYKONANIE_WATKOW();
 9773               		.loc 1 1865 0
 9774 0060 1092 0000 		sts wykonac_watki,__zero_reg__
 9775               	.L1061:
1866:main.c        ****     }
1867:main.c        **** 
1868:main.c        ****     { // tryb SLEEP
1869:main.c        ****       cli();
 9776               		.loc 1 1869 0
 9777               	/* #APP */
 9778               	 ;  1869 "main.c" 1
 9779 0064 F894      		cli
 9780               	 ;  0 "" 2
1870:main.c        ****       if (!wykonaj_zdarzenie_timer) {
 9781               		.loc 1 1870 0
 9782               	/* #NOAPP */
 9783 0066 8091 0000 		lds r24,wykonaj_zdarzenie_timer
 9784 006a 8111      		cpse r24,__zero_reg__
 9785 006c 00C0      		rjmp .L1062
1871:main.c        ****         sleep_enable();
 9786               		.loc 1 1871 0
 9787 006e 83B7      		in r24,0x33
 9788 0070 8160      		ori r24,lo8(1)
 9789 0072 83BF      		out 0x33,r24
1872:main.c        ****         sei();
 9790               		.loc 1 1872 0
 9791               	/* #APP */
 9792               	 ;  1872 "main.c" 1
 9793 0074 7894      		sei
 9794               	 ;  0 "" 2
1873:main.c        ****         sleep_cpu();
 9795               		.loc 1 1873 0
 9796               	 ;  1873 "main.c" 1
 9797 0076 8895      		sleep
 9798               		
 9799               	 ;  0 "" 2
1874:main.c        ****         cli();
 9800               		.loc 1 1874 0
 9801               	 ;  1874 "main.c" 1
 9802 0078 F894      		cli
 9803               	 ;  0 "" 2
1875:main.c        ****         sleep_disable();
 9804               		.loc 1 1875 0
 9805               	/* #NOAPP */
 9806 007a 83B7      		in r24,0x33
 9807 007c 8E7F      		andi r24,lo8(-2)
 9808 007e 83BF      		out 0x33,r24
 9809               	.L1062:
1876:main.c        ****       }
1877:main.c        ****       sei();
 9810               		.loc 1 1877 0
 9811               	/* #APP */
 9812               	 ;  1877 "main.c" 1
 9813 0080 7894      		sei
 9814               	 ;  0 "" 2
1878:main.c        ****       wolne_zdarzenie_timer();
 9815               		.loc 1 1878 0
 9816               	/* #NOAPP */
 9817 0082 0E94 0000 		call wolne_zdarzenie_timer
 9818               	.LVL741:
1853:main.c        ****       ustaw_parametry_dla_bezpieczenstwa();
 9819               		.loc 1 1853 0
 9820 0086 00C0      		rjmp .L1063
 9821               		.cfi_endproc
 9822               	.LFE71:
 9824               		.local	licznik_resetow.3787
 9825               		.comm	licznik_resetow.3787,1,1
 9826               		.local	licznik_wybuc_watki_100MS.3743
 9827               		.comm	licznik_wybuc_watki_100MS.3743,1,1
 9828               		.local	licznik_dioda_led_poziom_sieci.3736
 9829               		.comm	licznik_dioda_led_poziom_sieci.3736,1,1
 9830               		.section	.progmem.data,"a",@progbits
 9833               	__c.3698:
 9834 0000 4272 616B 		.string	"Brak wolnych pozycji Super User (795-800)"
 9834      2077 6F6C 
 9834      6E79 6368 
 9834      2070 6F7A 
 9834      7963 6A69 
 9837               	__c.3690:
 9838 002a 4E75 6D65 		.string	"Numer juz istnieje w systemie"
 9838      7220 6A75 
 9838      7A20 6973 
 9838      746E 6965 
 9838      6A65 2077 
 9841               	tab_eeprom_fabryczny.3639:
 9842 0048 FF        		.byte	-1
 9843 0049 41        		.byte	65
 9844 004a 42        		.byte	66
 9845 004b 43        		.byte	67
 9846 004c 44        		.byte	68
 9847 004d 00        		.byte	0
 9848               		.local	licznik_odebranych_znakow.3484
 9849               		.comm	licznik_odebranych_znakow.3484,2,1
 9850               		.local	licznik_poprzednia_komenda.3483
 9851               		.comm	licznik_poprzednia_komenda.3483,2,1
 9852               		.local	poprzednia_komenda.3482
 9853               		.comm	poprzednia_komenda.3482,1,1
 9854               		.local	licznik_bezpieczenstwa.3481
 9855               		.comm	licznik_bezpieczenstwa.3481,2,1
 9856               		.local	licznik_cyklu_8_sek.3477
 9857               		.comm	licznik_cyklu_8_sek.3477,1,1
 9860               	nastepna_komenda.3468:
 9861 004e 00        		.byte	0
 9862 004f 00        		.byte	0
 9863 0050 A2        		.byte	-94
 9864 0051 A3        		.byte	-93
 9865 0052 A4        		.byte	-92
 9866 0053 A6        		.byte	-90
 9867 0054 A7        		.byte	-89
 9868 0055 A8        		.byte	-88
 9869 0056 A9        		.byte	-87
 9870 0057 94        		.byte	-108
 9873               	instrukcje.3467:
 9874 0058 2B63 7069 		.string	"+cpin?"
 9874      6E3F 00
 9875 005f 0000 0000 		.zero	7
 9875      0000 00
 9876 0066 2B63 6E6D 		.string	"+cnmi=2,1,2,1"
 9876      693D 322C 
 9876      312C 322C 
 9876      3100 
 9877 0074 2B6D 6F72 		.string	"+moring=1"
 9877      696E 673D 
 9877      3100 
 9878 007e 0000 0000 		.zero	4
 9879 0082 2B63 6C69 		.string	"+clip=1"
 9879      703D 3100 
 9880 008a 0000 0000 		.zero	6
 9880      0000 
 9881 0090 2B64 6465 		.string	"+ddet=1,10,1"
 9881      743D 312C 
 9881      3130 2C31 
 9881      00
 9882 009d 00        		.zero	1
 9883 009e 2B63 616C 		.string	"+calm=1"
 9883      6D3D 3100 
 9884 00a6 0000 0000 		.zero	6
 9884      0000 
 9885 00ac 2B63 7273 		.string	"+crsl=1"
 9885      6C3D 3100 
 9886 00b4 0000 0000 		.zero	6
 9886      0000 
 9887 00ba 2B63 7573 		.string	"+cusd=1"
 9887      643D 3100 
 9888 00c2 0000 0000 		.zero	6
 9888      0000 
 9889 00c8 2B63 7062 		.string	"+cpbw=26,\"1\""
 9889      773D 3236 
 9889      2C22 3122 
 9889      00
 9890 00d5 00        		.zero	1
 9891 00d6 2B63 6C74 		.string	"+clts=0"
 9891      733D 3000 
 9892 00de 0000 0000 		.zero	6
 9892      0000 
 9895               	instrukcja.3453:
 9896 00e4 2B63 6D69 		.string	"+cmic=0,15"
 9896      633D 302C 
 9896      3135 00
 9899               	instrukcja_usun_wszystkie_smsy.3450:
 9900 00ef 2B63 6D67 		.string	"+cmgda=6"
 9900      6461 3D36 
 9900      00
 9901               		.local	drugi_raz.3449
 9902               		.comm	drugi_raz.3449,1,1
 9905               	instrukcja_podaj_pin.3447:
 9906 00f8 2B63 7069 		.string	"+cpin=\"1976\""
 9906      6E3D 2231 
 9906      3937 3622 
 9906      00
 9909               	instrukcja_at.3444:
 9910 0105 2B69 6663 		.string	"+ifc=2,2"
 9910      3D32 2C32 
 9910      00
 9913               	instrukcja_ustawienie_pamieci.3441:
 9914 010e 2B63 706D 		.string	"+cpms=\"SM\",\"SM\",\"SM\""
 9914      733D 2253 
 9914      4D22 2C22 
 9914      534D 222C 
 9914      2253 4D22 
 9917               	instrukcja_ustawienie_pamieci.3439:
 9918 0123 2B63 6473 		.string	"+cdscb"
 9918      6362 00
 9921               	instrukcja_cclk.3437:
 9922 012a 2B63 636C 		.string	"+cclk?"
 9922      6B3F 00
 9925               	instrukcja_sprawdz_operatora.3435:
 9926 0131 2B63 6F70 		.string	"+cops?"
 9926      733F 00
 9929               	instrukcja_odczyt_ksiazki.3433:
 9930 0138 2B63 7062 		.string	"+cpbr=26"
 9930      723D 3236 
 9930      00
 9933               	instrukcja_creg.3431:
 9934 0141 2B63 7265 		.string	"+creg?"
 9934      673F 00
 9937               	instrukcja_poziom_sieci.3429:
 9938 0148 2B63 7371 		.string	"+csq"
 9938      00
 9941               	instrukcja_vts.3425:
 9942 014d 2B76 7473 		.string	"+vts=1"
 9942      3D31 00
 9945               	instrukcja_odbierz_rozmowe.3423:
 9946 0154 6100      		.string	"a"
 9949               	instrukcja_odrzuc_rozmowe.3421:
 9950 0156 6800      		.string	"h"
 9953               	__c.3418:
 9954 0158 2B43 4D54 		.string	"+CMTI:"
 9954      493A 00
 9957               	instrukcja_usun_smsa.3414:
 9958 015f 2B63 6D67 		.string	"+cmgd="
 9958      643D 00
 9961               	instrukcja_odczytaj_smsa.3381:
 9962 0166 2B63 6D67 		.string	"+cmgr="
 9962      723D 00
 9965               	instrukcja_wyslij_smsa.3349:
 9966 016d 2B63 6D67 		.string	"+cmgs="
 9966      733D 00
 9969               	__c.3329:
 9970 0174 2B43 4D54 		.string	"+CMTI:"
 9970      493A 00
 9973               	__c.3322:
 9974 017b 2B44 544D 		.string	"+DTMF:"
 9974      463A 00
 9977               	__c.3317:
 9978 0182 2B43 4C49 		.string	"+CLIP:"
 9978      503A 00
 9981               	__c.3304:
 9982 0189 3E00      		.string	">"
 9985               	__c.3275:
 9986 018b 2B43 4D47 		.string	"+CMGR:"
 9986      523A 00
 9989               	polecenie_operator.3246:
 9990 0192 2B43 4F50 		.string	"+COPS:"
 9990      533A 00
 9993               	urc.3241:
 9994 0199 2B43 5245 		.string	"+CREG:"
 9994      473A 00
 9997               	urc.3238:
 9998 01a0 2B43 5351 		.string	"+CSQ:"
 9998      3A00 
 9999               		.local	nr_zapytania_o_pin.3232
 10000               		.comm	nr_zapytania_o_pin.3232,1,1
 10003               	polecenie_pin_ready.3231:
 10004 01a6 2B43 5049 		.string	"+CPIN: READY"
 10004      4E3A 2052 
 10004      4541 4459 
 10004      00
 10007               	polecenie_zegar.3220:
 10008 01b3 2B43 434C 		.string	"+CCLK:"
 10008      4B3A 00
 10009               		.local	licznik_reset.3166
 10010               		.comm	licznik_reset.3166,1,1
 10013               	__c.3146:
 10014 01ba 313D 5243 		.string	"1=RCV 2=BSY 3=CNT 4=QSM 5=QAL 6=FND 7=ADD"
 10014      5620 323D 
 10014      4253 5920 
 10014      333D 434E 
 10014      5420 343D 
 10017               	__c.3144:
 10018 01e4 2055 373D 		.string	" U7="
 10018      00
 10021               	__c.3142:
 10022 01e9 2055 363D 		.string	" U6="
 10022      00
 10025               	__c.3140:
 10026 01ee 2055 353D 		.string	" U5="
 10026      00
 10029               	__c.3138:
 10030 01f3 5534 3D00 		.string	"U4="
 10033               	__c.3136:
 10034 01f7 2055 333D 		.string	" U3="
 10034      00
 10037               	__c.3134:
 10038 01fc 2055 323D 		.string	" U2="
 10038      00
 10041               	__c.3132:
 10042 0201 5531 3D00 		.string	"U1="
 10045               	__c.3130:
 10046 0205 534B 5259 		.string	"SKRYBA:"
 10046      4241 3A00 
 10049               	__c.3127:
 10050 020d 4445 4255 		.string	"DEBUG\n"
 10050      470A 00
 10053               	tekst_demo.3053:
 10054 0214 7777 772E 		.string	"www.sonfy.pl"
 10054      736F 6E66 
 10054      792E 706C 
 10054      00
 10057               	__c.3051:
 10058 0221 536B 7279 		.string	"Skryba: Wylaczona"
 10058      6261 3A20 
 10058      5779 6C61 
 10058      637A 6F6E 
 10058      6100 
 10061               	__c.3049:
 10062 0233 536B 7279 		.string	"Skryba: Wlaczona"
 10062      6261 3A20 
 10062      576C 6163 
 10062      7A6F 6E61 
 10062      00
 10065               	__c.3047:
 10066 0244 4861 726D 		.string	"Harmonogram: Wylaczony"
 10066      6F6E 6F67 
 10066      7261 6D3A 
 10066      2057 796C 
 10066      6163 7A6F 
 10069               	__c.3045:
 10070 025b 2044 544D 		.string	" DTMF"
 10070      4600 
 10073               	__c.3043:
 10074 0261 2043 4C49 		.string	" CLIP"
 10074      5000 
 10077               	__c.3041:
 10078 0267 5472 7962 		.string	"Tryb: Publiczny"
 10078      3A20 5075 
 10078      626C 6963 
 10078      7A6E 7900 
 10081               	__c.3039:
 10082 0277 5472 7962 		.string	"Tryb: Prywatny"
 10082      3A20 5072 
 10082      7977 6174 
 10082      6E79 00
 10085               	__c.3037:
 10086 0286 5374 6174 		.string	"Status: Aktywny"
 10086      7573 3A20 
 10086      416B 7479 
 10086      776E 7900 
 10089               	__c.3035:
 10090 0296 5374 6174 		.string	"Status: Zablokowany"
 10090      7573 3A20 
 10090      5A61 626C 
 10090      6F6B 6F77 
 10090      616E 7900 
 10093               	tekst_gsm.3021:
 10094 02aa 557A 7974 		.string	"Uzytkownicy "
 10094      6B6F 776E 
 10094      6963 7920 
 10094      00
 10097               	tekst_gsm.3010:
 10098 02b7 557A 7974 		.string	"Uzytkownicy "
 10098      6B6F 776E 
 10098      6963 7920 
 10098      00
 10101               	text_sygnal.3006:
 10102 02c4 5379 676E 		.string	"Sygnal GSM "
 10102      616C 2047 
 10102      534D 2000 
 10105               	__c.3004:
 10106 02d0 437A 6173 		.string	"Czas: "
 10106      3A20 00
 10109               	tekst_gsm.3002:
 10110 02d7 4143 3830 		.string	"AC800-DTM-TS"
 10110      302D 4454 
 10110      4D2D 5453 
 10110      00
 10111               		.local	stan.2971
 10112               		.comm	stan.2971,1,1
 10113               		.local	opoznienie_1s.2970
 10114               		.comm	opoznienie_1s.2970,1,1
 10115               	.global	wysylanie_smsa_clipa
 10116               		.section .bss
 10119               	wysylanie_smsa_clipa:
 10120 0000 00        		.zero	1
 10121               		.comm	ptr_start_pdu_z_wiadomoscia,2,1
 10122               	.global	wysylanie_echa_przez_pdu
 10125               	wysylanie_echa_przez_pdu:
 10126 0001 00        		.zero	1
 10127               		.local	liczba_kolejnych_watchdogow_wysylania
 10128               		.comm	liczba_kolejnych_watchdogow_wysylania,1,1
 10129               		.local	licznik_watchdog_wysylanie_smsa_100ms
 10130               		.comm	licznik_watchdog_wysylanie_smsa_100ms,2,1
 10131               		.local	licznik_awaryjnych_resetow_kolejki
 10132               		.comm	licznik_awaryjnych_resetow_kolejki,2,1
 10133               		.local	licznik_usunietych_sms_przez_limit
 10134               		.comm	licznik_usunietych_sms_przez_limit,2,1
 10135               		.local	licznik_kolejka_stoi_100ms
 10136               		.comm	licznik_kolejka_stoi_100ms,2,1
 10137               		.local	ostatnia_pierwsza_komenda
 10138               		.comm	ostatnia_pierwsza_komenda,1,1
 10139               		.local	timer_report_user_100ms
 10140               		.comm	timer_report_user_100ms,2,1
 10141               		.local	licznik_report_user
 10142               		.comm	licznik_report_user,1,1
 10143               		.comm	numer_telefonu_skryba,20,1
 10144               		.comm	numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama,1,1
 10145               		.comm	nie_wysylaj_echa_z_powodu_nietypowego_smsa,1,1
 10146               		.comm	kod_modulu,4,1
 10147               	.global	tryb_pracy
 10148               		.data
 10151               	tryb_pracy:
 10152 0000 01        		.byte	1
 10153               	.global	blokada_systemu
 10154               		.section .bss
 10157               	blokada_systemu:
 10158 0002 00        		.zero	1
 10159               	.global	opoznienie_wysylania_clipow_100MS
 10162               	opoznienie_wysylania_clipow_100MS:
 10163 0003 0000      		.zero	2
 10164               	.global	licznik_reset_urzadzenia
 10167               	licznik_reset_urzadzenia:
 10168 0005 00        		.zero	1
 10169               	.global	licznik_reset_modulu_SIM900
 10172               	licznik_reset_modulu_SIM900:
 10173 0006 00        		.zero	1
 10174               	.global	modul_zalogowany_w_sieci
 10177               	modul_zalogowany_w_sieci:
 10178 0007 00        		.zero	1
 10179               	.global	licznik_wybudz_watki_10MS
 10182               	licznik_wybudz_watki_10MS:
 10183 0008 00        		.zero	1
 10184               	.global	wykonac_watki
 10187               	wykonac_watki:
 10188 0009 00        		.zero	1
 10189               	.global	wykonac_watki_10MS
 10192               	wykonac_watki_10MS:
 10193 000a 00        		.zero	1
 10194               	.global	wykonaj_zdarzenie_timer
 10197               	wykonaj_zdarzenie_timer:
 10198 000b 00        		.zero	1
 10199               	.global	stan_cyklu_blysku
 10202               	stan_cyklu_blysku:
 10203 000c 00        		.zero	1
 10204               	.global	liczba_blyskow_led
 10207               	liczba_blyskow_led:
 10208 000d 00        		.zero	1
 10209               		.comm	licznik_100ms_dioda_led,1,1
 10210               	.global	g_czas_systemowy_100ms
 10213               	g_czas_systemowy_100ms:
 10214 000e 0000 0000 		.zero	4
 10215               	.global	licznik_timeout_rozmowy_100ms
 10218               	licznik_timeout_rozmowy_100ms:
 10219 0012 0000      		.zero	2
 10220               	.global	tryb_clip
 10221               		.data
 10224               	tryb_clip:
 10225 0001 FF        		.byte	-1
 10226               	.global	skryba_limit
 10229               	skryba_limit:
 10230 0002 1B03      		.word	795
 10231               	.global	skryba_wlaczona
 10232               		.section .bss
 10235               	skryba_wlaczona:
 10236 0014 00        		.zero	1
 10237               		.comm	stan_wyjscie,1,1
 10238               	.global	sms_pomijaj_aktualizacje_czasu
 10241               	sms_pomijaj_aktualizacje_czasu:
 10242 0015 00        		.zero	1
 10243               	.global	sms_timestamp_sekunda
 10246               	sms_timestamp_sekunda:
 10247 0016 00        		.zero	1
 10248               	.global	sms_timestamp_minuta
 10251               	sms_timestamp_minuta:
 10252 0017 00        		.zero	1
 10253               	.global	sms_timestamp_godzina
 10256               	sms_timestamp_godzina:
 10257 0018 00        		.zero	1
 10258               	.global	watchdog_sms_safe_mode_100ms
 10261               	watchdog_sms_safe_mode_100ms:
 10262 0019 0000      		.zero	2
 10263               	.global	watchdog_sms_trwa_reset
 10266               	watchdog_sms_trwa_reset:
 10267 001b 00        		.zero	1
 10268               	.global	watchdog_sms_licznik_100ms
 10271               	watchdog_sms_licznik_100ms:
 10272 001c 0000      		.zero	2
 10273               	.global	watchdog_sms_aktywny
 10276               	watchdog_sms_aktywny:
 10277 001e 00        		.zero	1
 10278               		.comm	opoznienie_zatrzymaj_odpytywanie_urzadzenia,1,1
 10279               	.global	blokada_clip
 10282               	blokada_clip:
 10283 001f 00        		.zero	1
 10284               	.global	max_oczekiwanie_na_odpowiedz_at
 10287               	max_oczekiwanie_na_odpowiedz_at:
 10288 0020 00        		.zero	1
 10289               		.comm	licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow,1,1
 10290               	.global	licznik_bezpieczenstwa_opoznienie_wysylania_sms
 10293               	licznik_bezpieczenstwa_opoznienie_wysylania_sms:
 10294 0021 0000      		.zero	2
 10295               	.global	licznik_ogolny_blad_zalogowania
 10298               	licznik_ogolny_blad_zalogowania:
 10299 0023 0000      		.zero	2
 10300               	.global	licznik_blad_zalogowania_u_operatora
 10303               	licznik_blad_zalogowania_u_operatora:
 10304 0025 00        		.zero	1
 10305               	.global	licznik_blad_stanu_karty_SIM
 10308               	licznik_blad_stanu_karty_SIM:
 10309 0026 00        		.zero	1
 10310               	.global	licznik_awaria_brak_zasiegu
 10313               	licznik_awaria_brak_zasiegu:
 10314 0027 0000      		.zero	2
 10315               	.global	liczba_smsow_ech_do_wyslania
 10318               	liczba_smsow_ech_do_wyslania:
 10319 0029 00        		.zero	1
 10320               	.global	ustaw_maksymalny_czas_dzwonienia
 10323               	ustaw_maksymalny_czas_dzwonienia:
 10324 002a 00        		.zero	1
 10325               	.global	maksymalny_czas_dzwonienia
 10328               	maksymalny_czas_dzwonienia:
 10329 002b 00        		.zero	1
 10330               		.comm	numer_telefonu_do_ktorego_dzwonic,33,1
 10331               		.comm	numer_telefonu_ktory_dzwoni,17,1
 10332               	.global	liczba_prob_wyslania_smsa
 10335               	liczba_prob_wyslania_smsa:
 10336 002c 00        		.zero	1
 10337               	.global	flaga_wysylanie_smsa
 10340               	flaga_wysylanie_smsa:
 10341 002d 00        		.zero	1
 10342               		.comm	numer_telefonu_wysylanego_smsa,33,1
 10343               	.global	flaga_odczytywanie_smsa
 10346               	flaga_odczytywanie_smsa:
 10347 002e 00        		.zero	1
 10348               		.comm	numer_telefonu_odebranego_smsa,17,1
 10349               	.global	dlugosc_pdu
 10352               	dlugosc_pdu:
 10353 002f 00        		.zero	1
 10354               		.comm	bufor_pdu,200,1
 10355               	.global	licznik_bezpieczenstwa_wykonywana_rozmowa
 10358               	licznik_bezpieczenstwa_wykonywana_rozmowa:
 10359 0030 0000      		.zero	2
 10360               	.global	trwa_rozmowa_przychodzaca_od_uzytkownika
 10363               	trwa_rozmowa_przychodzaca_od_uzytkownika:
 10364 0032 00        		.zero	1
 10365               	.global	max_oczekiwanie_na_odpowiedz
 10366               		.data
 10369               	max_oczekiwanie_na_odpowiedz:
 10370 0004 03        		.byte	3
 10371               		.comm	liczba_wykonanych_komend_identycznego_polecenia,1,1
 10372               	.global	nastepne_wysylane_polecenie_SIM900
 10373               		.section .bss
 10376               	nastepne_wysylane_polecenie_SIM900:
 10377 0033 00        		.zero	1
 10378               	.global	licznik_wysylane_polecenie_SIM900
 10381               	licznik_wysylane_polecenie_SIM900:
 10382 0034 0000      		.zero	2
 10383               	.global	aktualnie_wysylane_polecenie_SIM900
 10386               	aktualnie_wysylane_polecenie_SIM900:
 10387 0036 00        		.zero	1
 10388               		.comm	nazwa_operatora,11,1
 10389               	.global	oproznij_bufor_SIM900_po_bledzie
 10392               	oproznij_bufor_SIM900_po_bledzie:
 10393 0037 00        		.zero	1
 10394               	.global	opoznienie_SIM900_100MS
 10397               	opoznienie_SIM900_100MS:
 10398 0038 00        		.zero	1
 10399               		.text
 10400               	.Letext0:
 10401               		.file 8 "narzedzia.h"
 10402               		.file 9 "/usr/local/avr8-gnu-toolchain/avr/include/stdint.h"
 10403               		.file 10 "/usr/local/avr8-gnu-toolchain/lib/gcc/avr/7.3.0/include/stddef.h"
 10404               		.file 11 "/usr/local/avr8-gnu-toolchain/avr/include/stdio.h"
 10405               		.file 12 "enumkomendy.h"
 10406               		.file 13 "data_sim900.h"
 10407               		.file 14 "pamiec_ram.h"
 10408               		.file 15 "interpretacjaSMS.h"
 10409               		.file 16 "komendy.h"
 10410               		.file 17 "poleceniagsm.h"
 10411               		.file 18 "sim900.h"
 10412               		.file 19 "zapiseeprom.h"
 10413               		.file 20 "bufpomoc.h"
 10414               		.file 21 "/usr/local/avr8-gnu-toolchain/avr/include/avr/eeprom.h"
 10415               		.file 22 "konfiguracja.h"
 10416               		.file 23 "/usr/local/avr8-gnu-toolchain/avr/include/string.h"
 10417               		.file 24 "/usr/local/avr8-gnu-toolchain/avr/include/avr/pgmspace.h"
 10418               		.file 25 "pdu.h"
 10419               		.file 26 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:4      *ABS*:000000000000003f __SREG__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:5      *ABS*:000000000000003b __RAMPZ__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:6      *ABS*:0000000000000000 __tmp_reg__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:7      *ABS*:0000000000000001 __zero_reg__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:12     .text:0000000000000000 watchdog_sms_disarm
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10276  .bss:000000000000001e watchdog_sms_aktywny
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10271  .bss:000000000000001c watchdog_sms_licznik_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:33     .text:000000000000000e czy_numer_istnieje
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:100    .text:000000000000004e usun_zablokowany_sms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10386  .bss:0000000000000036 aktualnie_wysylane_polecenie_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:128    .text:0000000000000062 zareaguj_na_usuniety_sms_z_powodu_limitu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10132  .bss:000000000000004e licznik_usunietych_sms_przez_limit
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10207  .bss:000000000000000d liczba_blyskow_led
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10202  .bss:000000000000000c stan_cyklu_blysku
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:166    .text:000000000000008e polozenie_polecenia_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:187    .text:0000000000000098 opoznienie_startowe
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:252    .text:00000000000000d8 zapisz_debug_do_eeprom
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10140  .bss:0000000000000055 licznik_report_user
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10138  .bss:0000000000000053 timer_report_user_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10340  .bss:000000000000002d flaga_wysylanie_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:368    .text:000000000000015c test_dioda_wyjscia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10112  .bss:0000000000000048 opoznienie_1s.2970
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10010  .bss:0000000000000047 stan.2971
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:411    .text:000000000000018a test_wejscie
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:443    .text:000000000000019a __vector_16
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10182  .bss:0000000000000008 licznik_wybudz_watki_10MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10192  .bss:000000000000000a wykonac_watki_10MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10197  .bss:000000000000000b wykonaj_zdarzenie_timer
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:658    .text:000000000000029c generuj_raport_sieci
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10109  .progmem.data:00000000000002d7 tekst_gsm.3002
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10105  .progmem.data:00000000000002d0 __c.3004
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10101  .progmem.data:00000000000002c4 text_sygnal.3006
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10177  .bss:0000000000000007 modul_zalogowany_w_sieci
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:840    .text:0000000000000364 generuj_raport_uzytkownikow_1
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10097  .progmem.data:00000000000002b7 tekst_gsm.3010
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:1026   .text:0000000000000416 generuj_raport_uzytkownikow
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10093  .progmem.data:00000000000002aa tekst_gsm.3021
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:1202   .text:00000000000004b8 generuj_raport_stanu_urzadzenia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10157  .bss:0000000000000002 blokada_systemu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10089  .progmem.data:0000000000000296 __c.3035
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10085  .progmem.data:0000000000000286 __c.3037
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10151  .data:0000000000000000 tryb_pracy
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10081  .progmem.data:0000000000000277 __c.3039
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10077  .progmem.data:0000000000000267 __c.3041
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10224  .data:0000000000000001 tryb_clip
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10073  .progmem.data:0000000000000261 __c.3043
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10069  .progmem.data:000000000000025b __c.3045
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10065  .progmem.data:0000000000000244 __c.3047
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10235  .bss:0000000000000014 skryba_wlaczona
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10061  .progmem.data:0000000000000233 __c.3049
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10057  .progmem.data:0000000000000221 __c.3051
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10053  .progmem.data:0000000000000214 tekst_demo.3053
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:1456   .text:0000000000000634 czy_numer_jest_super_userem
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:1550   .text:0000000000000694 ustaw_wyjscie_clip
                            *COM*:0000000000000001 stan_wyjscie
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:1592   .text:00000000000006b4 wykonanie_polecenia_sms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10241  .bss:0000000000000015 sms_pomijaj_aktualizacje_czasu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10246  .bss:0000000000000016 sms_timestamp_sekunda
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10251  .bss:0000000000000017 sms_timestamp_minuta
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10256  .bss:0000000000000018 sms_timestamp_godzina
                            *COM*:0000000000000011 numer_telefonu_odebranego_smsa
                            *COM*:0000000000000021 numer_telefonu_wysylanego_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10049  .progmem.data:000000000000020d __c.3127
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10045  .progmem.data:0000000000000205 __c.3130
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10041  .progmem.data:0000000000000201 __c.3132
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10037  .progmem.data:00000000000001fc __c.3134
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10033  .progmem.data:00000000000001f7 __c.3136
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10029  .progmem.data:00000000000001f3 __c.3138
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10025  .progmem.data:00000000000001ee __c.3140
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10021  .progmem.data:00000000000001e9 __c.3142
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10017  .progmem.data:00000000000001e4 __c.3144
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10013  .progmem.data:00000000000001ba __c.3146
                            *COM*:0000000000000021 numer_telefonu_do_ktorego_dzwonic
                            *COM*:0000000000000001 numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:2591   .text:0000000000000c30 steruj_wejsciem_reset_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10000  .bss:0000000000000046 licznik_reset.3166
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:2662   .text:0000000000000c78 sprawdz_przychodzaca_rozmowe
                            *COM*:0000000000000011 numer_telefonu_ktory_dzwoni
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:2799   .text:0000000000000d1c zakonczono_rozmowe_telefoniczna
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10397  .bss:0000000000000038 opoznienie_SIM900_100MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10358  .bss:0000000000000030 licznik_bezpieczenstwa_wykonywana_rozmowa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10323  .bss:000000000000002a ustaw_maksymalny_czas_dzwonienia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10328  .bss:000000000000002b maksymalny_czas_dzwonienia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10282  .bss:000000000000001f blokada_clip
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:2829   .text:0000000000000d38 zakonczono_wysylanie_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10119  .bss:0000000000000000 wysylanie_smsa_clipa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:2852   .text:0000000000000d44 problem_z_wyslaniem_powiadomienia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10381  .bss:0000000000000034 licznik_wysylane_polecenie_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:2884   .text:0000000000000d6c wyzerowanie_danych_SIM900
                            *COM*:0000000000000001 licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10363  .bss:0000000000000032 trwa_rozmowa_przychodzaca_od_uzytkownika
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10346  .bss:000000000000002e flaga_odczytywanie_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:2923   .text:0000000000000d9a reset_modulu_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10308  .bss:0000000000000026 licznik_blad_stanu_karty_SIM
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10303  .bss:0000000000000025 licznik_blad_zalogowania_u_operatora
                            *COM*:000000000000000b nazwa_operatora
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10298  .bss:0000000000000023 licznik_ogolny_blad_zalogowania
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10376  .bss:0000000000000033 nastepne_wysylane_polecenie_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:2987   .text:0000000000000df4 obsluga_wysylania_sms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10335  .bss:000000000000002c liczba_prob_wyslania_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:3199   .text:0000000000000efe odpowiedz_na_polecenie
                            *COM*:0000000000000001 liczba_wykonanych_komend_identycznego_polecenia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9993   .progmem.data:0000000000000199 urc.3241
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9981   .progmem.data:0000000000000189 __c.3304
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10287  .bss:0000000000000020 max_oczekiwanie_na_odpowiedz_at
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10007  .progmem.data:00000000000001b3 polecenie_zegar.3220
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10003  .progmem.data:00000000000001a6 polecenie_pin_ready.3231
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9902   .bss:0000000000000045 nr_zapytania_o_pin.3232
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9997   .progmem.data:00000000000001a0 urc.3238
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9989   .progmem.data:0000000000000192 polecenie_operator.3246
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10218  .bss:0000000000000012 licznik_timeout_rozmowy_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9985   .progmem.data:000000000000018b __c.3275
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10352  .bss:000000000000002f dlugosc_pdu
                            *COM*:00000000000000c8 bufor_pdu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:4354   .text:000000000000157a obsluga_komendy_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10392  .bss:0000000000000037 oproznij_bufor_SIM900_po_bledzie
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9977   .progmem.data:0000000000000182 __c.3317
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9973   .progmem.data:000000000000017b __c.3322
                            *COM*:0000000000000001 licznik_100ms_dioda_led
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9969   .progmem.data:0000000000000174 __c.3329
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:4830   .text:0000000000001820 wyslanie_polecenia_ROM
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:4873   .text:0000000000001848 wyslij_sms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9965   .progmem.data:000000000000016d instrukcja_wyslij_smsa.3349
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10369  .data:0000000000000004 max_oczekiwanie_na_odpowiedz
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:5049   .text:0000000000001942 wykonanie_komend_SIM900
                            *COM*:0000000000000001 opoznienie_zatrzymaj_odpytywanie_urzadzenia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9860   .progmem.data:000000000000004e nastepna_komenda.3468
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9873   .progmem.data:0000000000000058 instrukcje.3467
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9961   .progmem.data:0000000000000166 instrukcja_odczytaj_smsa.3381
                            *COM*:0000000000000001 nie_wysylaj_echa_z_powodu_nietypowego_smsa
                            *COM*:0000000000000002 ptr_start_pdu_z_wiadomoscia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9957   .progmem.data:000000000000015f instrukcja_usun_smsa.3414
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9953   .progmem.data:0000000000000158 __c.3418
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9949   .progmem.data:0000000000000156 instrukcja_odrzuc_rozmowe.3421
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9945   .progmem.data:0000000000000154 instrukcja_odbierz_rozmowe.3423
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9941   .progmem.data:000000000000014d instrukcja_vts.3425
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9937   .progmem.data:0000000000000148 instrukcja_poziom_sieci.3429
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9933   .progmem.data:0000000000000141 instrukcja_creg.3431
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9929   .progmem.data:0000000000000138 instrukcja_odczyt_ksiazki.3433
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9925   .progmem.data:0000000000000131 instrukcja_sprawdz_operatora.3435
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9921   .progmem.data:000000000000012a instrukcja_cclk.3437
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9917   .progmem.data:0000000000000123 instrukcja_ustawienie_pamieci.3439
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9913   .progmem.data:000000000000010e instrukcja_ustawienie_pamieci.3441
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9909   .progmem.data:0000000000000105 instrukcja_at.3444
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9905   .progmem.data:00000000000000f8 instrukcja_podaj_pin.3447
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9857   .bss:0000000000000044 drugi_raz.3449
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9899   .progmem.data:00000000000000ef instrukcja_usun_wszystkie_smsy.3450
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9895   .progmem.data:00000000000000e4 instrukcja.3453
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:6453   .text:00000000000021f0 steruj_SIM900_100MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10162  .bss:0000000000000003 opoznienie_wysylania_clipow_100MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9855   .bss:0000000000000043 licznik_cyklu_8_sek.3477
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10313  .bss:0000000000000027 licznik_awaria_brak_zasiegu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10172  .bss:0000000000000006 licznik_reset_modulu_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:6752   .text:00000000000023c8 steruj_SIM900_10MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9853   .bss:0000000000000041 licznik_bezpieczenstwa.3481
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9851   .bss:0000000000000040 poprzednia_komenda.3482
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9849   .bss:000000000000003e licznik_poprzednia_komenda.3483
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9829   .bss:000000000000003c licznik_odebranych_znakow.3484
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:7055   .text:0000000000002588 wykonanie_komend_powiadomien
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:7331   .text:00000000000026f4 test_sms_clip_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:7347   .text:00000000000026f6 steruj_wejscia_wyjscia_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:7369   .text:0000000000002702 zapis_w_eeprom_stanu_wyjsc
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:7465   .text:000000000000277e steruj_urzadzeniem_100MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10136  .bss:0000000000000052 ostatnia_pierwsza_komenda
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10134  .bss:0000000000000050 licznik_kolejka_stoi_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10128  .bss:000000000000004a licznik_watchdog_wysylanie_smsa_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10130  .bss:000000000000004c licznik_awaryjnych_resetow_kolejki
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10114  .bss:0000000000000049 liczba_kolejnych_watchdogow_wysylania
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10266  .bss:000000000000001b watchdog_sms_trwa_reset
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10261  .bss:0000000000000019 watchdog_sms_safe_mode_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9827   .bss:000000000000003b licznik_dioda_led_poziom_sieci.3736
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:7808   .text:00000000000029aa steruj_urzadzeniem_10MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:7830   .text:00000000000029b6 wolne_zdarzenie_timer
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10187  .bss:0000000000000009 wykonac_watki
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9825   .bss:000000000000003a licznik_wybuc_watki_100MS.3743
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:8014   .text:0000000000002a94 ustaw_parametry_dla_bezpieczenstwa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:8052   .text:0000000000002ab4 inicjalizuj_parametry_modulu
                            *COM*:0000000000000004 kod_modulu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10229  .data:0000000000000002 skryba_limit
                             .bss:0000000000000039 licznik_resetow.3787
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:8462   .text:0000000000002d10 wykonanie_komend_ukladow
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9841   .progmem.data:0000000000000048 tab_eeprom_fabryczny.3639
                            *COM*:0000000000000014 numer_telefonu_skryba
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9837   .progmem.data:000000000000002a __c.3690
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9833   .progmem.data:0000000000000000 __c.3698
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9656   .text:0000000000003398 wykonanie_komend
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:9687   .text.startup:0000000000000000 main
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10125  .bss:0000000000000001 wysylanie_echa_przez_pdu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10167  .bss:0000000000000005 licznik_reset_urzadzenia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10213  .bss:000000000000000e g_czas_systemowy_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10293  .bss:0000000000000021 licznik_bezpieczenstwa_opoznienie_wysylania_sms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccmBCxii.s:10318  .bss:0000000000000029 liczba_smsow_ech_do_wyslania

UNDEFINED SYMBOLS
bufor_eeprom
konwertuj_telefon_na_blok_eeprom
porownaj_numer_telefonu_blok
filtruj_i_dodaj_komende
odebrany_blok_SIM900
strstr_P
bufor_pomoc_liczba_znakow_do_zapisu
liczba_znakow_do_zapisu
czy_zajety_bufor_eeprom
komendy_kolejka
zapisz_znaki_w_eeprom
licznik_wejscie
komenda_SIM900
liczba_odebranych_znakow_SIM900
licznik_opoznienie_oczekiwania_na_bajt_SIM900
sprawdzaj_wejscie_CTS_SIM900
podlaczony_modul_gsm_SIM900
nr_wyslanego_znaku_SIM900
wysylany_blok_SIM900
memcpy_P
strcpy_P
rtc_czas
strcat
poziom_sieci_gsm
__divmodhi4
__utoa_ncheck
eeprom_read_byte
tekst_wysylanego_smsa
czas_start_h
czas_stop_m
czas_stop_h
czas_start_m
sprintf
licznik_przelacznik_wyjscia
interpretuj_wiadomosc_sms
bufor_ustaw_czas
dodaj_komende
blokada_sterowania_czasowa
__tablejump2__
strcpy
czy_sa_komendy_z_przedzialu
stan_logiczny_na_wejsciu
wykonywanie_rozmowy_telefonicznej
czekanie_na_odebranie_zachety
liczba_komend_w_kolejce_SIM900
flaga_odebrany_znak_zachety
licznik_100ms_procedura_inicjalizacyjna_SIM900
podlaczona_karta_SIM_SIM900
filtruj_komendy_z_przedzialu
numer_bledu_cms
numer_bledu_cme
strtol
strchr
bledny_PIN
strncmp_P
memcpy
konwertuj_blok_dwa_znaki_na_znak_pdu
liczba_wysylanych_znakow_SIM900
memcmp
strtoul
wyslij_polecenie_ROM_SIM900
konwertuj_blok_eeprom_na_telefon
zapisz_naglowek_pdu
ascii_to_pdu_blok
wyslij_polecenie_RAM_SIM900
pobierz_numer_telefonu_nadawcy_z_PDU
konwertuj_pdu_na_blok_wysylany
wyslij_znaki_SIM900
pobierz_date_z_PDU
pobierz_czas_z_PDU
pdu_to_ascii
procedura_inicjalizacyjna_SIM900_100MS
czy_jest_nowa_komenda_SIM900
kopiuj_blok_eeprom_na_telefon
aktualizuj_stan_wyzwolenia_wejsc_100ms
steruj_wyjscia_100ms
steruj_wejscia_10ms
zapisz_bajt_w_EEPROM
poczatek_polecenia_SIM900
zakonczenie_polecenia_SIM900
czy_jest_nowe_polecenie_SIM900
eeprom_read_block
eeprom_update_block
eeprom_update_byte
zapisz_znaki_w_eeprom_bez_kopiowania
memset
zapisz_znak_w_eeprom
usun_komende
inicjalizacja_SIM900
__do_copy_data
__do_clear_bss
