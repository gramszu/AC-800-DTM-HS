   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	watchdog_sms_disarm:
  13               	.LFB34:
  14               		.file 1 "main.c"
   1:main.c        **** 
   2:main.c        **** #ifndef INCLUDE
   3:main.c        **** #include "narzedzia.h"
   4:main.c        **** #include <avr/eeprom.h>
   5:main.c        **** #include <avr/interrupt.h>
   6:main.c        **** #include <avr/io.h>
   7:main.c        **** #include <avr/pgmspace.h>
   8:main.c        **** #include <avr/sleep.h>
   9:main.c        **** #include <avr/wdt.h>
  10:main.c        **** #include <ctype.h>
  11:main.c        **** #include <stdio.h>
  12:main.c        **** #include <stdlib.h>
  13:main.c        **** #include <string.h>
  14:main.c        **** #include <util/crc16.h>
  15:main.c        **** #include <util/delay.h>
  16:main.c        **** 
  17:main.c        **** #ifndef TEST_ATMEGA128
  18:main.c        **** #include "pin_ATmega328.h"
  19:main.c        **** #else
  20:main.c        **** #include "pin_ATmega128.h"
  21:main.c        **** #endif
  22:main.c        **** #include "bufpomoc.h"
  23:main.c        **** #include "data_sim900.h"
  24:main.c        **** #include "interpretacjaSMS.h"
  25:main.c        **** #include "komendy.h"
  26:main.c        **** #include "konfiguracja.h"
  27:main.c        **** #include "pdu.h"
  28:main.c        **** #include "sim900.h"
  29:main.c        **** #include "wewy.h"
  30:main.c        **** #include "zapiseeprom.h"
  31:main.c        **** 
  32:main.c        **** #include "test_pcb.h"
  33:main.c        **** 
  34:main.c        **** #endif
  35:main.c        **** 
  36:main.c        **** // static const char nazwa_urzadzenia[12 + 1] PROGMEM = "BRAMA";
  37:main.c        **** 
  38:main.c        **** uchar skryba_wlaczona = FALSE;
  39:main.c        **** uint skryba_limit = 795; // Domyslny limit uzytkownikow dla Skryby (795 max,
  40:main.c        ****                          // pozycje 796-800 dla Super Userow)
  41:main.c        **** uchar tryb_clip = TRUE;
  42:main.c        **** uint licznik_timeout_rozmowy_100ms = 0;
  43:main.c        **** 
  44:main.c        **** volatile uint32_t g_czas_systemowy_100ms = 0;
  45:main.c        **** 
  46:main.c        **** #define INFORMACJA_W_RAPORCIE "www.sonfy.pl"
  47:main.c        **** 
  48:main.c        **** uchar licznik_100ms_dioda_led;
  49:main.c        **** uchar liczba_blyskow_led = 0;
  50:main.c        **** uchar stan_cyklu_blysku =
  51:main.c        ****     0; // 0-5: 0-1=ON (200ms), 2-5=OFF (400ms), 1 blysk=600ms
  52:main.c        **** 
  53:main.c        **** #define zapal_diode_led(czas_100ms) (licznik_100ms_dioda_led = (czas_100ms) + 1)
  54:main.c        **** #define zapal_diode_led_blyski(liczba)                                         \
  55:main.c        ****   (liczba_blyskow_led = (liczba), stan_cyklu_blysku = 0)
  56:main.c        **** // #define zapal_diode_led(czas_100ms)
  57:main.c        **** 
  58:main.c        **** volatile uchar wykonaj_zdarzenie_timer = FALSE;
  59:main.c        **** #define CZY_WYKONAC_ZDARZENIE_TIMER() wykonaj_zdarzenie_timer
  60:main.c        **** 
  61:main.c        **** #define WYKONAJ_WATKI_BRAK 0
  62:main.c        **** #define WYKONAJ_WATKI_10MS BIT(0)
  63:main.c        **** #define WYKONAJ_WATKI_100MS BIT(1)
  64:main.c        **** volatile uchar wykonac_watki_10MS = FALSE;
  65:main.c        **** uchar wykonac_watki = WYKONAJ_WATKI_BRAK;
  66:main.c        **** #define CZY_WYKONAC_WATKI_10MS() (wykonac_watki & WYKONAJ_WATKI_10MS)
  67:main.c        **** #define CZY_WYKONAC_WATKI_100MS() (wykonac_watki & WYKONAJ_WATKI_100MS)
  68:main.c        **** #define RESETUJ_WYKONANIE_WATKOW() (wykonac_watki = 0)
  69:main.c        **** 
  70:main.c        **** volatile uchar licznik_wybudz_watki_10MS = 0;
  71:main.c        **** #define OPOZNIENIE_TIMERA_0 18
  72:main.c        **** #define czy_pozostal_czas(procent)                                             \
  73:main.c        ****   (licznik_wybudz_watki_10MS < (100 - (procent)) * OPOZNIENIE_TIMERA_0 / 100)
  74:main.c        **** 
  75:main.c        **** przerwanie_timer() {
  76:main.c        ****   if (++licznik_wybudz_watki_10MS >= OPOZNIENIE_TIMERA_0) {
  77:main.c        ****     licznik_wybudz_watki_10MS = 0;
  78:main.c        ****     wykonac_watki_10MS = TRUE;
  79:main.c        ****   }
  80:main.c        **** 
  81:main.c        ****   if (STATUS_WLACZONY_SIM900()) {
  82:main.c        ****     if (!CZY_ODBIERANIE_DANYCH_SIM900() && czy_jest_bezczynny_SIM900()) {
  83:main.c        ****       ustaw_odbior_SIM900();
  84:main.c        ****     }
  85:main.c        ****     if (CZY_HANDSHAKING_CTS_ZEZWALA_NA_TRANSMISJE_SIM900()) {
  86:main.c        ****       cli();
  87:main.c        ****       if (CZY_WYSYLANIE_DANYCH_SIM900()) {
  88:main.c        ****         WYLACZ_PRZERWANIE_WYSYLANIA_DANYCH_SIM900();
  89:main.c        ****         sei();
  90:main.c        ****         uchar p = sprawdzaj_wejscie_CTS_SIM900;
  91:main.c        ****         if (p && (podlaczony_modul_gsm_SIM900 ||
  92:main.c        ****                   aktualnie_wysylane_polecenie_SIM900 ==
  93:main.c        ****                       KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT)) {
  94:main.c        ****           p = FALSE;
  95:main.c        ****           sprawdzaj_wejscie_CTS_SIM900 = p;
  96:main.c        ****           WSTAW_ZNAK_DO_BUFORA_SIM900();
  97:main.c        ****         }
  98:main.c        ****         cli();
  99:main.c        ****         WLACZ_PRZERWANIE_WYSYLANIA_DANYCH_SIM900();
 100:main.c        ****       }
 101:main.c        ****       sei();
 102:main.c        ****     }
 103:main.c        ****   } else {
 104:main.c        ****     zakoncz_przesylanie_SIM900();
 105:main.c        ****   }
 106:main.c        **** 
 107:main.c        ****   wykonaj_zdarzenie_timer =
 108:main.c        ****       TRUE; // uruchamia zdarzenie_timer, ktra korzysta z pozostaych zmiennych
 109:main.c        **** }
 110:main.c        **** 
 111:main.c        **** uchar modul_zalogowany_w_sieci = FALSE;
 112:main.c        **** 
 113:main.c        **** uchar licznik_reset_modulu_SIM900 = 0;
 114:main.c        **** #define START_LICZNIK_RESET_MODULU_SIM900 30
 115:main.c        **** 
 116:main.c        **** uchar licznik_reset_urzadzenia = 0;
 117:main.c        **** #define LICZNIK_RESET_URZADZENIA_RESET_SIM900 200
 118:main.c        **** #define START_LICZNIK_RESET_URZADZENIA 220
 119:main.c        **** 
 120:main.c        **** uint opoznienie_wysylania_clipow_100MS = 0;
 121:main.c        **** 
 122:main.c        **** void generuj_raport_sieci(uchar **buf_sms) {
 123:main.c        ****   static const char tekst_gsm[] PROGMEM = "AC800-DTM-TS";
 124:main.c        ****   uchar *ptr = *buf_sms;
 125:main.c        **** 
 126:main.c        ****   memcpy_R(ptr, tekst_gsm);
 127:main.c        ****   ptr += sizeof tekst_gsm - 1;
 128:main.c        ****   *ptr++ = '\n';
 129:main.c        **** 
 130:main.c        ****   strcpy_P((char *)ptr, PSTR("Czas: "));
 131:main.c        ****   ptr += strlen((char *)ptr);
 132:main.c        ****   strcat((char *)ptr, rtc_czas);
 133:main.c        ****   ptr += strlen((char *)ptr);
 134:main.c        ****   *ptr++ = '\n';
 135:main.c        **** 
 136:main.c        ****   static const char text_sygnal[] PROGMEM = "Sygnal GSM ";
 137:main.c        ****   memcpy_R(ptr, text_sygnal);
 138:main.c        ****   ptr += sizeof text_sygnal - 1;
 139:main.c        **** 
 140:main.c        ****   if (poziom_sieci_gsm <= 31 && modul_zalogowany_w_sieci) {
 141:main.c        ****     utoa(poziom_sieci_gsm * 100 / 31, ptr, 10);
 142:main.c        ****     ptr += strlen(ptr);
 143:main.c        ****     *ptr++ = '%';
 144:main.c        ****   } else {
 145:main.c        ****     *ptr++ = '-';
 146:main.c        ****     *ptr++ = '-';
 147:main.c        ****     *ptr++ = '-';
 148:main.c        ****   }
 149:main.c        ****   *ptr = 0;
 150:main.c        ****   *buf_sms = ptr;
 151:main.c        **** }
 152:main.c        **** 
 153:main.c        **** void generuj_raport_uzytkownikow_1(uchar **buf_sms) {
 154:main.c        ****   static const char tekst_gsm[] PROGMEM = "Uzytkownicy ";
 155:main.c        ****   uchar *ptr = *buf_sms;
 156:main.c        **** 
 157:main.c        ****   memcpy_R(ptr, tekst_gsm);
 158:main.c        ****   ptr += sizeof tekst_gsm - 1;
 159:main.c        ****   uint aktywne_numery = 0;
 160:main.c        ****   uint wolne_numery = 0;
 161:main.c        ****   // for (uchar nr_uzyt_clip = 0; nr_uzyt_clip <
 162:main.c        ****   // MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip)
 163:main.c        ****   for (uint nr_uzyt_clip = 0; nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 164:main.c        ****        ++nr_uzyt_clip) {
 165:main.c        ****     if (czy_aktywny_numer_telefonu_brama(nr_uzyt_clip))
 166:main.c        ****       ++aktywne_numery;
 167:main.c        ****     else
 168:main.c        ****       ++wolne_numery;
 169:main.c        ****   }
 170:main.c        **** 
 171:main.c        ****   utoa(aktywne_numery, ptr, 10);
 172:main.c        ****   ptr += strlen(ptr);
 173:main.c        ****   *ptr++ = '/';
 174:main.c        ****   utoa(wolne_numery, ptr, 10);
 175:main.c        ****   ptr += strlen(ptr);
 176:main.c        ****   *buf_sms = ptr;
 177:main.c        **** }
 178:main.c        **** 
 179:main.c        **** void generuj_raport_uzytkownikow(uchar **buf_sms) {
 180:main.c        ****   static const char tekst_gsm[] PROGMEM = "Uzytkownicy ";
 181:main.c        ****   uchar *ptr = *buf_sms;
 182:main.c        **** 
 183:main.c        ****   memcpy_R(ptr, tekst_gsm);
 184:main.c        ****   ptr += sizeof tekst_gsm - 1;
 185:main.c        ****   uchar aktywne_numery = 0;
 186:main.c        ****   uchar wolne_numery = 0;
 187:main.c        ****   for (uint nr_uzyt_clip = 0; nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 188:main.c        ****        ++nr_uzyt_clip) {
 189:main.c        ****     if (czy_aktywny_numer_telefonu_brama(nr_uzyt_clip))
 190:main.c        ****       ++aktywne_numery;
 191:main.c        ****     else
 192:main.c        ****       ++wolne_numery;
 193:main.c        ****   }
 194:main.c        ****   utoa(aktywne_numery, ptr, 10);
 195:main.c        ****   ptr += strlen(ptr);
 196:main.c        ****   *ptr++ = '/';
 197:main.c        ****   utoa(wolne_numery, ptr, 10);
 198:main.c        ****   ptr += strlen(ptr);
 199:main.c        ****   *buf_sms = ptr;
 200:main.c        **** }
 201:main.c        **** 
 202:main.c        **** uchar blokada_systemu = FALSE; // Nowa zmienna globalna
 203:main.c        **** uchar tryb_pracy = 1;          // 0=Prywatny, 1=Publiczny (domyślnie Publiczny)
 204:main.c        **** 
 205:main.c        **** void generuj_raport_stanu_urzadzenia(void) {
 206:main.c        ****   uchar *sms = (char *)tekst_wysylanego_smsa;
 207:main.c        ****   *sms++ = '*';
 208:main.c        ****   *sms++ = '\n';
 209:main.c        ****   generuj_raport_sieci(&sms);
 210:main.c        ****   *sms++ = '\n';
 211:main.c        ****   generuj_raport_uzytkownikow_1(&sms);
 212:main.c        ****   *sms++ = '\n';
 213:main.c        **** 
 214:main.c        ****   // Status sterownika (START/STOP)
 215:main.c        ****   if (blokada_systemu) {
 216:main.c        ****     strcpy_P((char *)sms, PSTR("Status: Zablokowany"));
 217:main.c        ****   } else {
 218:main.c        ****     strcpy_P((char *)sms, PSTR("Status: Aktywny"));
 219:main.c        ****   }
 220:main.c        ****   sms += strlen((char *)sms);
 221:main.c        ****   *sms++ = '\n';
 222:main.c        **** 
 223:main.c        ****   // Tryb pracy (OPEN/CLOSE)
 224:main.c        ****   if (tryb_pracy == 0) {
 225:main.c        ****     strcpy_P((char *)sms, PSTR("Tryb: Prywatny"));
 226:main.c        ****   } else {
 227:main.c        ****     strcpy_P((char *)sms, PSTR("Tryb: Publiczny"));
 228:main.c        ****   }
 229:main.c        ****   sms += strlen((char *)sms);
 230:main.c        **** 
 231:main.c        ****   if (tryb_clip) {
 232:main.c        ****     strcpy_P((char *)sms, PSTR(" CLIP"));
 233:main.c        ****   } else {
 234:main.c        ****     strcpy_P((char *)sms, PSTR(" DTMF"));
 235:main.c        ****   }
 236:main.c        ****   sms += strlen((char *)sms);
 237:main.c        ****   *sms++ = '\n';
 238:main.c        **** 
 239:main.c        ****   if (czas_start_h == 0xFF) {
 240:main.c        ****     strcpy_P((char *)sms, PSTR("Harmonogram: Wylaczony"));
 241:main.c        ****   } else {
 242:main.c        ****     sprintf((char *)sms, "Harmonogram: %02d:%02d %02d:%02d", (int)czas_start_h,
 243:main.c        ****             (int)czas_start_m, (int)czas_stop_h, (int)czas_stop_m);
 244:main.c        ****   }
 245:main.c        ****   sms += strlen((char *)sms);
 246:main.c        ****   *sms++ = '\n';
 247:main.c        **** 
 248:main.c        ****   // Skryba status (ON/OFF) - bez wyświetlania limitu
 249:main.c        ****   if (skryba_wlaczona) {
 250:main.c        ****     strcpy_P((char *)sms, PSTR("Skryba: Wlaczona"));
 251:main.c        ****   } else {
 252:main.c        ****     strcpy_P((char *)sms, PSTR("Skryba: Wylaczona"));
 253:main.c        ****   }
 254:main.c        ****   sms += strlen((char *)sms);
 255:main.c        ****   *sms++ = '\n';
 256:main.c        **** 
 257:main.c        ****   static const char tekst_demo[] PROGMEM = INFORMACJA_W_RAPORCIE;
 258:main.c        ****   strcpy_P((char *)sms, tekst_demo);
 259:main.c        **** }
 260:main.c        **** 
 261:main.c        **** // Helper function: sprawdz czy numer jest Super Userem (pozycje 795-800)
 262:main.c        **** uchar czy_numer_jest_super_userem(const uchar *numer_telefonu) {
 263:main.c        ****   // Konwertuj numer do formatu EEPROM
 264:main.c        ****   uchar temp_buf[LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM];
 265:main.c        ****   konwertuj_telefon_na_blok_eeprom(
 266:main.c        ****       (uchar *)numer_telefonu,
 267:main.c        ****       (uchar *)numer_telefonu + strlen((char *)numer_telefonu), temp_buf);
 268:main.c        **** 
 269:main.c        ****   // Sprawdz pozycje 794-799 (user-facing 795-800)
 270:main.c        ****   for (uint nr_uzyt = 794; nr_uzyt < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 271:main.c        ****        ++nr_uzyt) {
 272:main.c        ****     if (porownaj_numer_telefonu_blok(
 273:main.c        ****             temp_buf, (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt))) {
 274:main.c        ****       return TRUE; // Znaleziono w pozycjach super userow
 275:main.c        ****     }
 276:main.c        ****   }
 277:main.c        ****   return FALSE;
 278:main.c        **** }
 279:main.c        **** 
 280:main.c        **** void ustaw_wyjscie_clip(void) {
 281:main.c        ****   stan_wyjscie[0] = TRUE;
 282:main.c        ****   licznik_przelacznik_wyjscia[0] = 2 * 10ul; // 2 sekundy
 283:main.c        **** }
 284:main.c        **** 
 285:main.c        **** uchar kod_modulu[LICZBA_BAJTOW_KODU_DOSTEPU];
 286:main.c        **** 
 287:main.c        **** uchar nie_wysylaj_echa_z_powodu_nietypowego_smsa;
 288:main.c        **** 
 289:main.c        **** uchar numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama;
 290:main.c        **** uchar numer_telefonu_skryba[20];
 291:main.c        **** 
 292:main.c        **** // Blokada komend REPORT/USER - maksymalnie 8 w ciągu 30 sekund
 293:main.c        **** static uchar licznik_report_user = 0;
 294:main.c        **** static uint timer_report_user_100ms = 0;
 295:main.c        **** #define MAX_LICZBA_KOMEND_REPORT_USER_W_OKNIE 8
 296:main.c        **** #define OKNO_CZASOWE_REPORT_USER_100MS (30 * 10) // 30 sekund
 297:main.c        **** 
 298:main.c        **** // Mechanizm wykrywania zablokowanej kolejki i czyszczenia
 299:main.c        **** static komenda_typ ostatnia_pierwsza_komenda = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 300:main.c        **** static uint licznik_kolejka_stoi_100ms = 0;
 301:main.c        **** #define MAX_CZAS_KOLEJKA_STOI_100MS                                            \
 302:main.c        ****   (15 * 10) // 15 sekund - jesli kolejka stoi tyle czasu, wyczysc
 303:main.c        **** 
 304:main.c        **** static uint licznik_usunietych_sms_przez_limit = 0;
 305:main.c        **** static uint licznik_awaryjnych_resetow_kolejki = 0;
 306:main.c        **** 
 307:main.c        **** #define WATCHDOG_WYSYLANIA_SMS_100MS (30 * 10) // 30 sekund
 308:main.c        **** static uint licznik_watchdog_wysylanie_smsa_100ms = 0;
 309:main.c        **** static uchar liczba_kolejnych_watchdogow_wysylania = 0;
 310:main.c        **** #define WATCHDOG_SMS_TIMEOUT_100MS (10 * 10) // 10 sekund
 311:main.c        **** #define WATCHDOG_SMS_SAFE_MODE_100MS                                           \
 312:main.c        ****   (5 * 10) // 5 sekund po resecie - nie przyjmuj SMS
 313:main.c        **** 
 314:main.c        **** static inline void watchdog_sms_arm(void) {
 315:main.c        ****   watchdog_sms_aktywny = TRUE;
 316:main.c        ****   watchdog_sms_licznik_100ms = 0;
 317:main.c        **** }
 318:main.c        **** 
 319:main.c        **** static inline void watchdog_sms_disarm(void) {
  15               		.loc 1 319 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 320:main.c        ****   watchdog_sms_aktywny = FALSE;
  21               		.loc 1 320 0
  22 0000 1092 0000 		sts watchdog_sms_aktywny,__zero_reg__
 321:main.c        ****   watchdog_sms_licznik_100ms = 0;
  23               		.loc 1 321 0
  24 0004 1092 0000 		sts watchdog_sms_licznik_100ms+1,__zero_reg__
  25 0008 1092 0000 		sts watchdog_sms_licznik_100ms,__zero_reg__
  26               	/* epilogue start */
 322:main.c        **** }
  27               		.loc 1 322 0
  28 000c 0895      		ret
  29               		.cfi_endproc
  30               	.LFE34:
  33               	czy_numer_istnieje:
  34               	.LFB58:
 323:main.c        **** 
 324:main.c        **** static inline void sygnalizuj_pelny_system(void) {
 325:main.c        ****   // 10 szybkich blyskow informuje, ze kolejka/limit SMS jest zapelniony
 326:main.c        ****   zapal_diode_led_blyski(10);
 327:main.c        **** }
 328:main.c        **** 
 329:main.c        **** // Funkcja usuwania zablokowanego SMS z modulu SIM900
 330:main.c        **** static void usun_zablokowany_sms(void) {
 331:main.c        ****   // Usun SMS z modulu SIM900 (numer jest w aktualnie_wysylane_polecenie_SIM900)
 332:main.c        ****   // Sprawdzamy czy to byla komenda odczytu SMS
 333:main.c        ****   if (aktualnie_wysylane_polecenie_SIM900 >= KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 334:main.c        ****       aktualnie_wysylane_polecenie_SIM900 <= KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 335:main.c        ****     const uchar nr_smsa =
 336:main.c        ****         aktualnie_wysylane_polecenie_SIM900 - KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1;
 337:main.c        ****     // Uzywamy filtruj_i_dodaj_komende zamiast dodaj_komende
 338:main.c        ****     filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_USUN_SMSA_1 + nr_smsa);
 339:main.c        ****   } else {
 340:main.c        ****     // Fallback: Usun wszystkie
 341:main.c        ****     filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 342:main.c        ****   }
 343:main.c        **** }
 344:main.c        **** 
 345:main.c        **** static void zareaguj_na_usuniety_sms_z_powodu_limitu(void) {
 346:main.c        ****   if (licznik_usunietych_sms_przez_limit < 0xFFFF)
 347:main.c        ****     ++licznik_usunietych_sms_przez_limit;
 348:main.c        ****   sygnalizuj_pelny_system();
 349:main.c        ****   watchdog_sms_disarm();
 350:main.c        ****   // Uzywamy filtruj_i_dodaj
 351:main.c        ****   filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 352:main.c        **** }
 353:main.c        **** 
 354:main.c        **** // Funkcja zapisu znacznikow debugowania do EEPROM
 355:main.c        **** static void zapisz_debug_do_eeprom(uchar komenda, uchar akcja) {
 356:main.c        ****   if (!czy_wolny_eeprom())
 357:main.c        ****     return;
 358:main.c        **** 
 359:main.c        ****   uchar buf[8];
 360:main.c        ****   buf[0] = licznik_report_user;
 361:main.c        ****   buf[1] = (uchar)(timer_report_user_100ms & 0xFF);
 362:main.c        ****   buf[2] = (uchar)((timer_report_user_100ms >> 8) & 0xFF);
 363:main.c        ****   buf[3] = (uchar)flaga_wysylanie_smsa;
 364:main.c        **** 
 365:main.c        ****   uchar liczba_sms_w_kolejce = 0;
 366:main.c        ****   for (uchar i = 0; i < LICZBA_KOMEND; ++i) {
 367:main.c        ****     if (komendy_kolejka[i] >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
 368:main.c        ****         komendy_kolejka[i] <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
 369:main.c        ****       ++liczba_sms_w_kolejce;
 370:main.c        ****   }
 371:main.c        ****   buf[4] = liczba_sms_w_kolejce;
 372:main.c        ****   buf[5] = komenda;
 373:main.c        ****   buf[6] = akcja;
 374:main.c        **** 
 375:main.c        ****   zapisz_znaki_w_eeprom(buf, EEPROM_DEBUG_START, 7);
 376:main.c        **** }
 377:main.c        **** 
 378:main.c        **** void wykonanie_polecenia_sms(void) {
 379:main.c        ****   tekst_odebranego_smsa[MAX_LICZBA_ZNAKOW_SMS] = 0; // (1) dla pewnoci
 380:main.c        ****   watchdog_sms_arm();
 381:main.c        ****   const uchar komenda = interpretuj_wiadomosc_sms(tekst_odebranego_smsa);
 382:main.c        **** 
 383:main.c        ****   // Aktualizacja czasu z timestampu SMS (PRZED wykonaniem komendy!)
 384:main.c        ****   // KAŻDY SMS (nawet bez kodu ABCD) synchronizuje RTC, z wyłączeniem SET
 385:main.c        ****   extern uchar sms_timestamp_godzina;
 386:main.c        ****   extern uchar sms_timestamp_minuta;
 387:main.c        ****   extern uchar sms_timestamp_sekunda;
 388:main.c        ****   extern uchar sms_pomijaj_aktualizacje_czasu;
 389:main.c        **** 
 390:main.c        ****   if (!sms_pomijaj_aktualizacje_czasu) {
 391:main.c        ****     // Aktualizuj rtc_czas z timestampu SMS (z sekundami z PDU)
 392:main.c        ****     sprintf(rtc_czas, "%02d:%02d:%02d", sms_timestamp_godzina,
 393:main.c        ****             sms_timestamp_minuta, sms_timestamp_sekunda);
 394:main.c        **** 
 395:main.c        ****     // Zaktualizuj RTC w SIM900 (hardware)
 396:main.c        ****     extern char bufor_ustaw_czas[32];
 397:main.c        ****     sprintf(bufor_ustaw_czas, "+CCLK=\"24/01/01,%02d:%02d:%02d+04\"",
 398:main.c        ****             sms_timestamp_godzina, sms_timestamp_minuta, sms_timestamp_sekunda);
 399:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_USTAW_ZEGAR_SIM900);
 400:main.c        **** 
 401:main.c        ****     // Aktualizuj blokadę czasową
 402:main.c        ****     if (czas_start_h != 0xFF) {
 403:main.c        ****       int curr_time = sms_timestamp_godzina * 60 + sms_timestamp_minuta;
 404:main.c        ****       int start_time = czas_start_h * 60 + czas_start_m;
 405:main.c        ****       int stop_time = czas_stop_h * 60 + czas_stop_m;
 406:main.c        **** 
 407:main.c        ****       if (start_time <= stop_time) {
 408:main.c        ****         // Normalny przedział (np. 08:00 - 16:00)
 409:main.c        ****         blokada_sterowania_czasowa =
 410:main.c        ****             !(curr_time >= start_time && curr_time <= stop_time);
 411:main.c        ****       } else {
 412:main.c        ****         // Przejście przez północ (np. 22:00 - 06:00)
 413:main.c        ****         blokada_sterowania_czasowa =
 414:main.c        ****             !(curr_time >= start_time || curr_time <= stop_time);
 415:main.c        ****       }
 416:main.c        ****     } else {
 417:main.c        ****       blokada_sterowania_czasowa = FALSE;
 418:main.c        ****     }
 419:main.c        ****   }
 420:main.c        **** 
 421:main.c        ****   // Resetuj flagę pomijania dla następnego SMS
 422:main.c        ****   sms_pomijaj_aktualizacje_czasu = FALSE;
 423:main.c        **** 
 424:main.c        ****   // --- BLOKADA SYSTEMU (START/STOP) ---
 425:main.c        ****   if (blokada_systemu) {
 426:main.c        ****     // Gdy zablokowany, akceptuj tylko START i REPORT
 427:main.c        ****     if (komenda != INTERPRETACJA_SMS_POPRAWNY && // START/STOP zwracaja POPRAWNY
 428:main.c        ****         komenda != INTERPRETACJA_SMS_RAPORT) {
 429:main.c        ****       // Sprawdz czy to byla komenda START (ktora wlasnie odblokowala system)
 430:main.c        ****       // Jesli system nadal jest zablokowany (czyli to nie byl START), to
 431:main.c        ****       // ignoruj
 432:main.c        ****       if (eeprom_read_byte((const uint8_t *)ADRES_EEPROM_BLOKADA_SYSTEMU) ==
 433:main.c        ****           1) {
 434:main.c        ****         zapisz_debug_do_eeprom(1, 2); // Debug: Odrzucono przez blokade
 435:main.c        ****         usun_zablokowany_sms();
 436:main.c        ****         return;
 437:main.c        ****       }
 438:main.c        ****     }
 439:main.c        ****   }
 440:main.c        **** 
 441:main.c        ****   // --- WARSTWA 1: Limit czasowy (Rate Limiting) - V7 style ---
 442:main.c        ****   if (komenda == INTERPRETACJA_SMS_RAPORT ||
 443:main.c        ****       komenda == INTERPRETACJA_SMS_USER) {
 444:main.c        ****     if (licznik_report_user >= MAX_LICZBA_KOMEND_REPORT_USER_W_OKNIE) {
 445:main.c        ****       zapisz_debug_do_eeprom(1, 1);
 446:main.c        ****       usun_zablokowany_sms();
 447:main.c        ****       zareaguj_na_usuniety_sms_z_powodu_limitu();
 448:main.c        ****       watchdog_sms_disarm();
 449:main.c        ****       return;
 450:main.c        ****     }
 451:main.c        ****   }
 452:main.c        **** 
 453:main.c        ****   // --- WARSTWA 2: Sprawdzenie zajętości modemu (Busy Check) ---
 454:main.c        ****   if (flaga_wysylanie_smsa) {
 455:main.c        ****     // Same number check
 456:main.c        ****     if (strcmp((char *)numer_telefonu_odebranego_smsa,
 457:main.c        ****                (char *)numer_telefonu_wysylanego_smsa) == 0) {
 458:main.c        ****       zapisz_debug_do_eeprom(1, 1);
 459:main.c        ****       usun_zablokowany_sms();
 460:main.c        ****       zareaguj_na_usuniety_sms_z_powodu_limitu();
 461:main.c        ****       watchdog_sms_disarm();
 462:main.c        ****       return;
 463:main.c        ****     }
 464:main.c        ****     // Different number but busy
 465:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 466:main.c        ****     usun_zablokowany_sms();
 467:main.c        ****     zareaguj_na_usuniety_sms_z_powodu_limitu();
 468:main.c        ****     watchdog_sms_disarm();
 469:main.c        ****     return;
 470:main.c        ****   }
 471:main.c        **** 
 472:main.c        ****   // --- WARSTWA 3 i 4: Ochrona kolejki ---
 473:main.c        ****   uchar liczba_sms_w_kolejce = 0;
 474:main.c        ****   uchar liczba_wszystkich_komend = 0;
 475:main.c        ****   for (uchar i = 0; i < LICZBA_KOMEND; ++i) {
 476:main.c        ****     if (komendy_kolejka[i] != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 477:main.c        ****       ++liczba_wszystkich_komend;
 478:main.c        ****       if (komendy_kolejka[i] >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
 479:main.c        ****           komendy_kolejka[i] <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
 480:main.c        ****         ++liczba_sms_w_kolejce;
 481:main.c        ****     }
 482:main.c        ****   }
 483:main.c        **** 
 484:main.c        ****   if (liczba_wszystkich_komend >= 35) {
 485:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 486:main.c        ****     usun_zablokowany_sms();
 487:main.c        ****     zareaguj_na_usuniety_sms_z_powodu_limitu();
 488:main.c        ****     watchdog_sms_disarm();
 489:main.c        ****     return;
 490:main.c        ****   }
 491:main.c        **** 
 492:main.c        ****   if (liczba_sms_w_kolejce >= 6) {
 493:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 494:main.c        ****     usun_zablokowany_sms();
 495:main.c        ****     zareaguj_na_usuniety_sms_z_powodu_limitu();
 496:main.c        ****     watchdog_sms_disarm();
 497:main.c        ****     return;
 498:main.c        ****   }
 499:main.c        **** 
 500:main.c        ****   switch (komenda) {
 501:main.c        ****   case INTERPRETACJA_SMS_POPRAWNY:
 502:main.c        ****     zapal_diode_led_blyski(2); // Odbior poprawnej komendy - 2 blyski
 503:main.c        ****     break;
 504:main.c        ****   case INTERPRETACJA_SMS_BRAK_KODU: {
 505:main.c        ****     zapal_diode_led_blyski(1); // Odbior zwyklego SMS (bez kodu) - 1 blysk
 506:main.c        ****     zapisz_debug_do_eeprom(0, 3);
 507:main.c        ****     break;
 508:main.c        ****   }
 509:main.c        ****   case INTERPRETACJA_SMS_RAPORT: {
 510:main.c        ****     ++licznik_report_user;
 511:main.c        ****     timer_report_user_100ms = OKNO_CZASOWE_REPORT_USER_100MS;
 512:main.c        **** 
 513:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 514:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 515:main.c        ****     generuj_raport_stanu_urzadzenia();
 516:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 517:main.c        ****     zapal_diode_led_blyski(2); // Komenda REPORT - 2 blyski
 518:main.c        ****     zapisz_debug_do_eeprom(1, 0);
 519:main.c        ****     break;
 520:main.c        ****   }
 521:main.c        ****   case INTERPRETACJA_SMS_DEBUG: {
 522:main.c        ****     // DEBUG - wyślij flagi debug dla SKRYBA i USER
 523:main.c        ****     strcpy_P((char *)tekst_wysylanego_smsa, PSTR("DEBUG\n"));
 524:main.c        ****     uchar *sms = tekst_wysylanego_smsa + strlen((char *)tekst_wysylanego_smsa);
 525:main.c        **** 
 526:main.c        ****     // SKRYBA DEBUG
 527:main.c        ****     strcpy_P((char *)sms, PSTR("SKRYBA:"));
 528:main.c        ****     sms += strlen((char *)sms);
 529:main.c        ****     *sms++ =
 530:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_2);
 531:main.c        ****     *sms++ =
 532:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_3);
 533:main.c        ****     *sms++ =
 534:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_4);
 535:main.c        ****     *sms++ =
 536:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_5);
 537:main.c        ****     *sms++ = '\n';
 538:main.c        **** 
 539:main.c        ****     // USER DEBUG - wyświetl jako liczby dziesiętne
 540:main.c        ****     strcpy_P((char *)sms, PSTR("U1="));
 541:main.c        ****     sms += strlen((char *)sms);
 542:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_1), sms, 10);
 543:main.c        ****     sms += strlen((char *)sms);
 544:main.c        **** 
 545:main.c        ****     strcpy_P((char *)sms, PSTR(" U2="));
 546:main.c        ****     sms += strlen((char *)sms);
 547:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_2), sms, 10);
 548:main.c        ****     sms += strlen((char *)sms);
 549:main.c        **** 
 550:main.c        ****     strcpy_P((char *)sms, PSTR(" U3="));
 551:main.c        ****     sms += strlen((char *)sms);
 552:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_3), sms, 10);
 553:main.c        ****     sms += strlen((char *)sms);
 554:main.c        ****     *sms++ = '\n';
 555:main.c        **** 
 556:main.c        ****     strcpy_P((char *)sms, PSTR("U4="));
 557:main.c        ****     sms += strlen((char *)sms);
 558:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_4), sms, 10);
 559:main.c        ****     sms += strlen((char *)sms);
 560:main.c        **** 
 561:main.c        ****     strcpy_P((char *)sms, PSTR(" U5="));
 562:main.c        ****     sms += strlen((char *)sms);
 563:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_5), sms, 10);
 564:main.c        ****     sms += strlen((char *)sms);
 565:main.c        **** 
 566:main.c        ****     strcpy_P((char *)sms, PSTR(" U6="));
 567:main.c        ****     sms += strlen((char *)sms);
 568:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_6), sms, 10);
 569:main.c        ****     sms += strlen((char *)sms);
 570:main.c        **** 
 571:main.c        ****     strcpy_P((char *)sms, PSTR(" U7="));
 572:main.c        ****     sms += strlen((char *)sms);
 573:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_7), sms, 10);
 574:main.c        ****     sms += strlen((char *)sms);
 575:main.c        ****     *sms++ = '\n';
 576:main.c        **** 
 577:main.c        ****     strcpy_P((char *)sms, PSTR("1=RCV 2=BSY 3=CNT 4=QSM 5=QAL 6=FND 7=ADD"));
 578:main.c        **** 
 579:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 580:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 581:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 582:main.c        ****     zapal_diode_led_blyski(2);
 583:main.c        ****     break;
 584:main.c        ****   }
 585:main.c        ****   case INTERPRETACJA_SMS_USER: {
 586:main.c        ****     ++licznik_report_user;
 587:main.c        ****     timer_report_user_100ms = OKNO_CZASOWE_REPORT_USER_100MS;
 588:main.c        **** 
 589:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 590:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 591:main.c        **** 
 592:main.c        ****     // Uzyj lokalnego bufora aby uniknac konfliktow z EEPROM
 593:main.c        ****     uchar temp_buf[LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM];
 594:main.c        **** 
 595:main.c        ****     // Konwertuj numer na format EEPROM
 596:main.c        ****     konwertuj_telefon_na_blok_eeprom(
 597:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
 598:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[strlen(
 599:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
 600:main.c        ****         temp_buf);
 601:main.c        **** 
 602:main.c        ****     // Sprawdz czy numer jest na liscie
 603:main.c        ****     uchar znaleziono = FALSE;
 604:main.c        ****     for (uint nr_uzyt_clip = 0;
 605:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 606:main.c        ****       if (porownaj_numer_telefonu_blok(
 607:main.c        ****               temp_buf, (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
 608:main.c        ****         znaleziono = TRUE;
 609:main.c        ****         break;
 610:main.c        ****       }
 611:main.c        ****     }
 612:main.c        **** 
 613:main.c        ****     // Przygotuj odpowiedz - pokaz FAKTYCZNY numer z EEPROM (max 9 cyfr)
 614:main.c        ****     // zamiast numeru wpisanego w komendzie (ktory moze miec prefiks +48)
 615:main.c        ****     uchar numer_z_eeprom[MAX_LICZBA_ZNAKOW_TELEFON + 1];
 616:main.c        ****     konwertuj_blok_eeprom_na_telefon(temp_buf, numer_z_eeprom,
 617:main.c        ****                                      MAX_LICZBA_ZNAKOW_TELEFON + 1);
 618:main.c        **** 
 619:main.c        ****     strcpy((char *)tekst_wysylanego_smsa, (char *)numer_z_eeprom);
 620:main.c        ****     strcat((char *)tekst_wysylanego_smsa, ": ");
 621:main.c        ****     if (znaleziono) {
 622:main.c        ****       strcat((char *)tekst_wysylanego_smsa, "OK");
 623:main.c        ****     } else {
 624:main.c        ****       strcat((char *)tekst_wysylanego_smsa, "Brak takiego numeru w systemie");
 625:main.c        ****     }
 626:main.c        **** 
 627:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 628:main.c        **** 
 629:main.c        ****     zapal_diode_led_blyski(2); // Komenda USER - 2 blyski
 630:main.c        **** 
 631:main.c        ****     // Zapisz debug tylko na koncu (bezpiecznie)
 632:main.c        ****     // U1=1 (USER), U6=znaleziono
 633:main.c        ****     if (czy_wolny_eeprom()) {
 634:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 635:main.c        ****       // Ale poniewaz zapisz_znak_w_eeprom uzywa przerwan, nie mozemy wolac go
 636:main.c        ****       // od razu drugi raz Mozemy zapisac skondensowana informacje lub uzyc
 637:main.c        ****       // bufora Dla bezpieczenstwa zapiszmy tylko jeden bajt statusu Bit 0:
 638:main.c        ****       // znaleziono, Bit 1: USER wykonany zapisz_znak_w_eeprom(znaleziono |
 639:main.c        ****       // 0x02, ADRES_EEPROM_DEBUG_USER_6);
 640:main.c        ****     }
 641:main.c        ****     zapisz_debug_do_eeprom(2, znaleziono); // 2 = USER
 642:main.c        ****     break;
 643:main.c        ****   }
 644:main.c        ****   case INTERPRETACJA_SMS_USER_BEZ_NUMERU: {
 645:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 646:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 647:main.c        ****     strcpy((char *)tekst_wysylanego_smsa,
 648:main.c        ****            "Wpisz numer jaki sprawdzasz, np: USER 793557357");
 649:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 650:main.c        ****     zapal_diode_led_blyski(2);
 651:main.c        ****     break;
 652:main.c        ****   }
 653:main.c        ****   case INTERPRETACJA_SMS_USER_LIST: {
 654:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 655:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 656:main.c        ****     numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama = 0;
 657:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW);
 658:main.c        ****     zapal_diode_led_blyski(2);
 659:main.c        ****     break;
 660:main.c        ****   }
 661:main.c        ****   case INTERPRETACJA_SMS_RESET_WSZYSTKICH_USTAWIEN: {
 662:main.c        ****     if (not czy_sa_komendy_z_przedzialu(
 663:main.c        ****             KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 664:main.c        ****             KOMENDA_KOLEJKI_RESET_USTAWIEN_INICJALIZACJA)) {
 665:main.c        ****       zapal_diode_led_blyski(25);
 666:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
 667:main.c        ****     }
 668:main.c        ****     break;
 669:main.c        ****   }
 670:main.c        ****   default:
 671:main.c        ****     break;
 672:main.c        ****   }
 673:main.c        **** 
 674:main.c        ****   watchdog_sms_disarm();
 675:main.c        **** }
 676:main.c        **** 
 677:main.c        **** void steruj_wejsciem_reset_100ms(void) {
 678:main.c        ****   static uchar licznik_reset;
 679:main.c        ****   if (CZY_AKTUALNY_STAN_LOGICZNY_ON(0)) {
 680:main.c        ****     if (licznik_reset < 20 * 10)
 681:main.c        ****       ++licznik_reset;
 682:main.c        ****   } else {
 683:main.c        ****     if (licznik_reset >= 20 * 10) {
 684:main.c        ****       if (not czy_sa_komendy_z_przedzialu(
 685:main.c        ****               KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 686:main.c        ****               KOMENDA_KOLEJKI_RESET_USTAWIEN_INICJALIZACJA))
 687:main.c        ****         dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
 688:main.c        ****     } else if (licznik_reset >= 5 * 10) {
 689:main.c        ****       if (not czy_sa_komendy_z_przedzialu(
 690:main.c        ****               KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 691:main.c        ****               KOMENDA_KOLEJKI_RESET_USTAWIEN_INICJALIZACJA))
 692:main.c        ****         dodaj_komende(KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU);
 693:main.c        ****     }
 694:main.c        ****     licznik_reset = 0;
 695:main.c        ****   }
 696:main.c        **** }
 697:main.c        **** 
 698:main.c        **** uchar sprawdz_przychodzaca_rozmowe(void) // wysya TRUE, gdy naley odebra
 699:main.c        **** {
 700:main.c        ****   // Super User: pozycje 795-800 omijaja wszystkie blokady
 701:main.c        ****   uchar jest_super_user =
 702:main.c        ****       czy_numer_jest_super_userem(numer_telefonu_ktory_dzwoni);
 703:main.c        **** 
 704:main.c        ****   if (blokada_systemu && !jest_super_user) {
 705:main.c        ****     return FALSE; // Ignoruj rozmowy gdy system zablokowany (chyba ze super
 706:main.c        ****                   // user)
 707:main.c        ****   }
 708:main.c        **** 
 709:main.c        ****   if (blokada_sterowania_czasowa && !jest_super_user) {
 710:main.c        ****     return FALSE; // Ignoruj rozmowy gdy blokada czasowa (chyba ze super user)
 711:main.c        ****   }
 712:main.c        **** 
 713:main.c        ****   // W trybie DTMF:
 714:main.c        ****   if (!tryb_clip) {
 715:main.c        ****     if (numer_telefonu_ktory_dzwoni[0] != 0)
 716:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA);
 717:main.c        **** 
 718:main.c        ****     // Publiczny: odbierz wszystkie
 719:main.c        ****     if (tryb_pracy == 1)
 720:main.c        ****       return TRUE;
 721:main.c        **** 
 722:main.c        ****     // Prywatny: sprawdź autoryzację SYNCHRONICZNIE
 723:main.c        ****     // Konwertuj numer na format EEPROM
 724:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_ktory_dzwoni[0],
 725:main.c        ****                                      &numer_telefonu_ktory_dzwoni[strlen(
 726:main.c        ****                                          (char *)numer_telefonu_ktory_dzwoni)],
 727:main.c        ****                                      &bufor_eeprom[0]);
 728:main.c        **** 
 729:main.c        ****     // Sprawdź listę autoryzowanych numerów
 730:main.c        ****     for (uint nr_uzyt = 0; nr_uzyt < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 731:main.c        ****          ++nr_uzyt) {
 732:main.c        ****       if (porownaj_numer_telefonu_blok(
 733:main.c        ****               &bufor_eeprom[0], (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt))) {
 734:main.c        ****         return TRUE; // Numer autoryzowany - odbierz
 735:main.c        ****       }
 736:main.c        ****     }
 737:main.c        ****     return FALSE; // Numer nieautoryzowany - odrzuć
 738:main.c        ****   }
 739:main.c        **** 
 740:main.c        ****   // W trybie CLIP:
 741:main.c        ****   if (numer_telefonu_ktory_dzwoni[0] != 0)
 742:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA);
 743:main.c        **** 
 744:main.c        ****   // Publiczny: włącz wyjście dla wszystkich
 745:main.c        ****   if (tryb_pracy == 1)
 746:main.c        ****     return TRUE;
 747:main.c        **** 
 748:main.c        ****   // Prywatny: sprawdź autoryzację
 749:main.c        ****   return FALSE; // Autoryzacja przez SPRAWDZ_UZYTKOWNIKOW_BRAMA
 750:main.c        **** }
 751:main.c        **** 
 752:main.c        **** uchar wysylanie_echa_przez_pdu = FALSE;
 753:main.c        **** 
 754:main.c        **** uchar *ptr_start_pdu_z_wiadomoscia; // pierwszy znak
 755:main.c        **** 
 756:main.c        **** #define WYSYLANIE_SMSA_CLIPA_BRAK 0
 757:main.c        **** #define WYSYLANIE_SMSA_WYSYLANIE 1
 758:main.c        **** #define WYSYLANIE_SMSA_POWTARZANIE 2
 759:main.c        **** #define WYSYLANIE_CLIPA_WYSYLANIE 4
 760:main.c        **** #define WYSYLANIE_CLIPA_KONCZENIE 5
 761:main.c        **** 
 762:main.c        **** uchar wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
 763:main.c        **** 
 764:main.c        **** enum PowodZakonczeniaRozmowyTelefonicznej {
 765:main.c        ****   powod_zakonczenia_rozmowy_odrzucenie,
 766:main.c        ****   powod_zakonczenia_rozmowy_zakonczenie,
 767:main.c        ****   powod_zakonczenia_rozmowy_przekroczony_czas,
 768:main.c        ****   powod_zakonczenia_rozmowy_otrzymana_wiadomosc
 769:main.c        **** };
 770:main.c        **** 
 771:main.c        **** void zakonczono_rozmowe_telefoniczna(
 772:main.c        ****     const enum PowodZakonczeniaRozmowyTelefonicznej powod) {
 773:main.c        ****   POMOC_DODAJ2('#', 'a');
 774:main.c        ****   opoznienie_SIM900_100MS = 60; // byo 60
 775:main.c        ****   licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 776:main.c        ****   ustaw_maksymalny_czas_dzwonienia = 0;
 777:main.c        ****   maksymalny_czas_dzwonienia = 0;
 778:main.c        ****   blokada_clip = FALSE;
 779:main.c        **** }
 780:main.c        **** 
 781:main.c        **** enum PowodZakonczeniaWysylaniaSMS {
 782:main.c        ****   zakonczenie_wysylania_sms_ok,
 783:main.c        ****   zakonczenie_wysylania_sms_blad_powtarzanie,
 784:main.c        ****   zakonczenie_wysylania_sms_blad_zakonczenie,
 785:main.c        ****   zakonczenie_wysylania_sms_blad_powtorz_sms,
 786:main.c        **** };
 787:main.c        **** 
 788:main.c        **** void zakonczono_wysylanie_smsa(const enum PowodZakonczeniaWysylaniaSMS powod) {
 789:main.c        ****   POMOC_DODAJ2('#', 'A');
 790:main.c        ****   opoznienie_SIM900_100MS = 60;
 791:main.c        **** 
 792:main.c        ****   wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
 793:main.c        **** }
 794:main.c        **** 
 795:main.c        **** void problem_z_wyslaniem_powiadomienia(void) {
 796:main.c        ****   wykonywanie_rozmowy_telefonicznej = FALSE;
 797:main.c        ****   licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 798:main.c        ****   wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 799:main.c        ****   czekanie_na_odebranie_zachety = FALSE;
 800:main.c        ****   opoznienie_SIM900_100MS = 60;
 801:main.c        ****   flaga_wysylanie_smsa = 0;
 802:main.c        **** }
 803:main.c        **** 
 804:main.c        **** #define JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ()                             \
 805:main.c        ****   if (!czy_mozna_wysylac_dane_do_SIM900) {                                     \
 806:main.c        ****     dodaj_komende(wykonywana_komenda);                                         \
 807:main.c        ****     break;                                                                     \
 808:main.c        ****   }                                                                            \
 809:main.c        ****   wysylane_polecenie_SIM900 = wykonywana_komenda;
 810:main.c        **** 
 811:main.c        **** #define POWTORZ_JESLI(WAR)                                                     \
 812:main.c        ****   {                                                                            \
 813:main.c        ****     if (WAR) {                                                                 \
 814:main.c        ****       dodaj_komende(wykonywana_komenda);                                       \
 815:main.c        ****       break;                                                                   \
 816:main.c        ****     }                                                                          \
 817:main.c        ****   }
 818:main.c        **** 
 819:main.c        **** #define JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ() POWTORZ_JESLI(!czy_wolny_eeprom())
 820:main.c        **** 
 821:main.c        **** #define JESLI_SIM900_ZAJETY_WYKONAJ_POZNIEJ() POWTORZ_JESLI(czy_gsm_zajety)
 822:main.c        **** 
 823:main.c        **** #include "main_sim900.h"
 824:main.c        **** 
 825:main.c        **** #define aktualnie_wykonywana_komenda wykonywana_komenda
 826:main.c        **** 
 827:main.c        **** void inicjalizuj_parametry_modulu(void);
 828:main.c        **** 
 829:main.c        **** #define MAX_LICZBA_KOMEND_DLA_ALARMOW (LICZBA_KOMEND / 4)
 830:main.c        **** 
 831:main.c        **** // Funkcja pomocnicza: Wyciąga ostatnie N cyfr z numeru telefonu
 832:main.c        **** // max_digits: maksimum cyfr (9)
 833:main.c        **** static void wyciagnij_ostatnie_cyfry(const uchar *numer_pelny,
 834:main.c        ****                                      uchar *numer_skrocony, uchar max_digits) {
 835:main.c        ****   uchar len = strlen((char *)numer_pelny);
 836:main.c        **** 
 837:main.c        ****   if (len > max_digits) {
 838:main.c        ****     // Take last max_digits
 839:main.c        ****     strcpy((char *)numer_skrocony, (char *)numer_pelny + (len - max_digits));
 840:main.c        ****   } else {
 841:main.c        ****     // Take all
 842:main.c        ****     strcpy((char *)numer_skrocony, (char *)numer_pelny);
 843:main.c        ****   }
 844:main.c        **** }
 845:main.c        **** 
 846:main.c        **** // Helper function to check if a number exists in EEPROM
 847:main.c        **** // Uses bufor_eeprom as temporary storage for comparison
 848:main.c        **** static uchar czy_numer_istnieje(const uchar *numer_telefonu) {
  35               		.loc 1 848 0
  36               		.cfi_startproc
  37               	.LVL0:
  38 000e CF93      		push r28
  39               	.LCFI0:
  40               		.cfi_def_cfa_offset 3
  41               		.cfi_offset 28, -2
  42 0010 DF93      		push r29
  43               	.LCFI1:
  44               		.cfi_def_cfa_offset 4
  45               		.cfi_offset 29, -3
  46               	/* prologue: function */
  47               	/* frame size = 0 */
  48               	/* stack size = 2 */
  49               	.L__stack_usage = 2
 849:main.c        ****   // Convert number to EEPROM block format
 850:main.c        ****   // We use a local buffer to avoid corrupting global buffers if possible,
 851:main.c        ****   // but porownaj_numer_telefonu_blok expects a block.
 852:main.c        ****   // Let's use bufor_eeprom as it is standard for this operation in this
 853:main.c        ****   // codebase.
 854:main.c        ****   konwertuj_telefon_na_blok_eeprom(
 855:main.c        ****       numer_telefonu, numer_telefonu + strlen((char *)numer_telefonu),
  50               		.loc 1 855 0
  51 0012 FC01      		movw r30,r24
  52               		0:
  53 0014 0190      		ld __tmp_reg__,Z+
  54 0016 0020      		tst __tmp_reg__
  55 0018 01F4      		brne 0b
  56 001a BF01      		movw r22,r30
 854:main.c        ****       numer_telefonu, numer_telefonu + strlen((char *)numer_telefonu),
  57               		.loc 1 854 0
  58 001c 6150      		subi r22,1
  59 001e 7109      		sbc r23,__zero_reg__
  60 0020 40E0      		ldi r20,lo8(bufor_eeprom)
  61 0022 50E0      		ldi r21,hi8(bufor_eeprom)
  62 0024 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
  63               	.LVL1:
  64 0028 C8E0      		ldi r28,lo8(8)
  65 002a D0E0      		ldi r29,0
  66               	.LVL2:
  67               	.L4:
  68               	.LBB357:
 856:main.c        ****       bufor_eeprom);
 857:main.c        **** 
 858:main.c        ****   for (uint nr_uzyt_clip = 0; nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 859:main.c        ****        ++nr_uzyt_clip) {
 860:main.c        ****     if (porownaj_numer_telefonu_blok(
  69               		.loc 1 860 0
  70 002c BE01      		movw r22,r28
  71 002e 80E0      		ldi r24,lo8(bufor_eeprom)
  72 0030 90E0      		ldi r25,hi8(bufor_eeprom)
  73 0032 0E94 0000 		call porownaj_numer_telefonu_blok
  74               	.LVL3:
  75 0036 8111      		cpse r24,__zero_reg__
  76 0038 00C0      		rjmp .L5
  77 003a 2596      		adiw r28,5
 858:main.c        ****        ++nr_uzyt_clip) {
  78               		.loc 1 858 0
  79 003c C83A      		cpi r28,-88
  80 003e FFE0      		ldi r31,15
  81 0040 DF07      		cpc r29,r31
  82 0042 01F4      		brne .L4
  83               	.L2:
  84               	/* epilogue start */
  85               	.LBE357:
 861:main.c        ****             bufor_eeprom, (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
 862:main.c        ****       return TRUE;
 863:main.c        ****     }
 864:main.c        ****   }
 865:main.c        ****   return FALSE;
 866:main.c        **** }
  86               		.loc 1 866 0
  87 0044 DF91      		pop r29
  88 0046 CF91      		pop r28
  89 0048 0895      		ret
  90               	.L5:
  91               	.LBB358:
 862:main.c        ****     }
  92               		.loc 1 862 0
  93 004a 8FEF      		ldi r24,lo8(-1)
  94 004c 00C0      		rjmp .L2
  95               	.LBE358:
  96               		.cfi_endproc
  97               	.LFE58:
 100               	usun_zablokowany_sms:
 101               	.LFB36:
 330:main.c        ****   // Usun SMS z modulu SIM900 (numer jest w aktualnie_wysylane_polecenie_SIM900)
 102               		.loc 1 330 0
 103               		.cfi_startproc
 104               	/* prologue: function */
 105               	/* frame size = 0 */
 106               	/* stack size = 0 */
 107               	.L__stack_usage = 0
 333:main.c        ****       aktualnie_wysylane_polecenie_SIM900 <= KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 108               		.loc 1 333 0
 109 004e 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 110 0052 96E5      		ldi r25,lo8(86)
 111 0054 980F      		add r25,r24
 112               	.LBB359:
 338:main.c        ****   } else {
 113               		.loc 1 338 0
 114 0056 8C5E      		subi r24,lo8(-(20))
 115               	.LBE359:
 333:main.c        ****       aktualnie_wysylane_polecenie_SIM900 <= KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 116               		.loc 1 333 0
 117 0058 9431      		cpi r25,lo8(20)
 118 005a 00F0      		brlo .L9
 341:main.c        ****   }
 119               		.loc 1 341 0
 120 005c 82E9      		ldi r24,lo8(-110)
 121               	.L9:
 122 005e 0C94 0000 		jmp filtruj_i_dodaj_komende
 123               	.LVL4:
 124               		.cfi_endproc
 125               	.LFE36:
 128               	zareaguj_na_usuniety_sms_z_powodu_limitu:
 129               	.LFB37:
 345:main.c        ****   if (licznik_usunietych_sms_przez_limit < 0xFFFF)
 130               		.loc 1 345 0
 131               		.cfi_startproc
 132               	/* prologue: function */
 133               	/* frame size = 0 */
 134               	/* stack size = 0 */
 135               	.L__stack_usage = 0
 346:main.c        ****     ++licznik_usunietych_sms_przez_limit;
 136               		.loc 1 346 0
 137 0062 8091 0000 		lds r24,licznik_usunietych_sms_przez_limit
 138 0066 9091 0000 		lds r25,licznik_usunietych_sms_przez_limit+1
 139 006a 8F3F      		cpi r24,-1
 140 006c 9807      		cpc r25,r24
 141 006e 01F0      		breq .L11
 347:main.c        ****   sygnalizuj_pelny_system();
 142               		.loc 1 347 0
 143 0070 0196      		adiw r24,1
 144 0072 9093 0000 		sts licznik_usunietych_sms_przez_limit+1,r25
 145 0076 8093 0000 		sts licznik_usunietych_sms_przez_limit,r24
 146               	.L11:
 147               	.LBB362:
 148               	.LBB363:
 326:main.c        **** }
 149               		.loc 1 326 0
 150 007a 8AE0      		ldi r24,lo8(10)
 151 007c 8093 0000 		sts liczba_blyskow_led,r24
 152 0080 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 153               	.LBE363:
 154               	.LBE362:
 349:main.c        ****   // Uzywamy filtruj_i_dodaj
 155               		.loc 1 349 0
 156 0084 0E94 0000 		call watchdog_sms_disarm
 157               	.LVL5:
 351:main.c        **** }
 158               		.loc 1 351 0
 159 0088 82E9      		ldi r24,lo8(-110)
 160 008a 0C94 0000 		jmp filtruj_i_dodaj_komende
 161               	.LVL6:
 162               		.cfi_endproc
 163               	.LFE37:
 166               	polozenie_polecenia_SIM900:
 167               	.LFB48:
 168               		.file 2 "main_sim900.h"
   1:main_sim900.h **** 
   2:main_sim900.h **** #ifdef MAIN_SIM900_H
   3:main_sim900.h **** #error Dwa razy wlaczany plik
   4:main_sim900.h **** #endif
   5:main_sim900.h **** 
   6:main_sim900.h **** void wyzerowanie_danych_SIM900(void) {
   7:main_sim900.h ****   POMOC_DODAJ2('*', 't');
   8:main_sim900.h ****   problem_z_wyslaniem_powiadomienia();
   9:main_sim900.h ****   licznik_wysylane_polecenie_SIM900 = 0;
  10:main_sim900.h ****   aktualnie_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
  11:main_sim900.h ****   liczba_komend_w_kolejce_SIM900 = 0;
  12:main_sim900.h ****   licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow = 0;
  13:main_sim900.h ****   czekanie_na_odebranie_zachety = FALSE;
  14:main_sim900.h ****   flaga_odebrany_znak_zachety = FALSE;
  15:main_sim900.h ****   trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
  16:main_sim900.h ****   wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
  17:main_sim900.h ****   flaga_odczytywanie_smsa = FALSE;
  18:main_sim900.h **** }
  19:main_sim900.h **** 
  20:main_sim900.h **** void reset_modulu_SIM900(void) {
  21:main_sim900.h ****   wyzerowanie_danych_SIM900();
  22:main_sim900.h ****   POMOC_DODAJ2('*', 'm');
  23:main_sim900.h ****   HARDRESET_SIM900();
  24:main_sim900.h ****   podlaczony_modul_gsm_SIM900 = FALSE;
  25:main_sim900.h ****   podlaczona_karta_SIM_SIM900 = FALSE;
  26:main_sim900.h ****   licznik_blad_stanu_karty_SIM = 0;
  27:main_sim900.h ****   licznik_blad_zalogowania_u_operatora = 0;
  28:main_sim900.h ****   nazwa_operatora[0] = '\0';
  29:main_sim900.h ****   licznik_ogolny_blad_zalogowania = 0;
  30:main_sim900.h ****   blokada_clip = FALSE;
  31:main_sim900.h ****   nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
  32:main_sim900.h ****   poziom_sieci_gsm = POZIOM_SIECI_BLAD;
  33:main_sim900.h ****   filtruj_komendy_z_przedzialu(KOMENDA_KOLEJKI_USUN_SMSA_1,
  34:main_sim900.h ****                                KOMENDA_KOLEJKI_USUN_SMSA_20);
  35:main_sim900.h ****   filtruj_komendy_z_przedzialu(
  36:main_sim900.h ****       KOMENDA_KOLEJKI_KOMENDA_SIM900,
  37:main_sim900.h ****       KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE);
  38:main_sim900.h ****   filtruj_komendy_z_przedzialu(
  39:main_sim900.h ****       KOMENDA_KOLEJKI_SPRAWDZ_PIN,
  40:main_sim900.h ****       KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ);
  41:main_sim900.h ****   filtruj_komendy_z_przedzialu(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT,
  42:main_sim900.h ****                                KOMENDA_KOLEJKI_WYSLIJ_PDU);
  43:main_sim900.h ****   modul_zalogowany_w_sieci = FALSE;
  44:main_sim900.h **** }
  45:main_sim900.h **** 
  46:main_sim900.h **** static uchar czy_polecenie_SIM900(PGM_P polecenie, const uchar liczba_znakow) {
  47:main_sim900.h ****   return strncmp_P(odebrany_blok_SIM900 + 2, polecenie, liczba_znakow) == 0;
  48:main_sim900.h **** }
  49:main_sim900.h **** 
  50:main_sim900.h **** static uchar *polozenie_polecenia_SIM900(PGM_P polecenie) {
 169               		.loc 2 50 0
 170               		.cfi_startproc
 171               	.LVL7:
 172               	/* prologue: function */
 173               	/* frame size = 0 */
 174               	/* stack size = 0 */
 175               	.L__stack_usage = 0
  51:main_sim900.h ****   return strstr_P(odebrany_blok_SIM900, polecenie);
 176               		.loc 2 51 0
 177 008e BC01      		movw r22,r24
 178 0090 80E0      		ldi r24,lo8(odebrany_blok_SIM900)
 179 0092 90E0      		ldi r25,hi8(odebrany_blok_SIM900)
 180               	.LVL8:
 181 0094 0C94 0000 		jmp strstr_P
 182               	.LVL9:
 183               		.cfi_endproc
 184               	.LFE48:
 187               	opoznienie_startowe:
 188               	.LFB70:
 867:main.c        **** 
 868:main.c        **** uchar wykonanie_komend_ukladow(void) {
 869:main.c        ****   const komenda_typ aktualnie_wykonywana_komenda = komendy_kolejka[0];
 870:main.c        **** 
 871:main.c        ****   switch (aktualnie_wykonywana_komenda) {
 872:main.c        ****   case KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU: {
 873:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 874:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 875:main.c        ****     kod_modulu[1] = bufor_eeprom[1] = 'B';
 876:main.c        ****     kod_modulu[2] = bufor_eeprom[2] = 'C';
 877:main.c        ****     kod_modulu[3] = bufor_eeprom[3] = 'D';
 878:main.c        ****     zapisz_znaki_w_eeprom_bez_kopiowania(ADRES_EEPROM_KOD_DOSTEPU,
 879:main.c        ****                                          LICZBA_BAJTOW_KODU_DOSTEPU);
 880:main.c        ****     zapal_diode_led(50);
 881:main.c        ****     break;
 882:main.c        ****   }
 883:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_0:
 884:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_1:
 885:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_2:
 886:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_3:
 887:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_4:
 888:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_5:
 889:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_6:
 890:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_7:
 891:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_8:
 892:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_9:
 893:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_10:
 894:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_11:
 895:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_12:
 896:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_13:
 897:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_14:
 898:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_15:
 899:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_16:
 900:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_17:
 901:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_18:
 902:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_19:
 903:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_20:
 904:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_21:
 905:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_22:
 906:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_23:
 907:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_24:
 908:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_25:
 909:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_26:
 910:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_27:
 911:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_28:
 912:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_29:
 913:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_30:
 914:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_31:
 915:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_32:
 916:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_33:
 917:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_34:
 918:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_35:
 919:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_36:
 920:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_37:
 921:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_38:
 922:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_39:
 923:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_40:
 924:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_41:
 925:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_42:
 926:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_43:
 927:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_44:
 928:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_45:
 929:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_46:
 930:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_47:
 931:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_48:
 932:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_49:
 933:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_50:
 934:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_51:
 935:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_52:
 936:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_53:
 937:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_54:
 938:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_55:
 939:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_56:
 940:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_57:
 941:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_58:
 942:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_59:
 943:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_60:
 944:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_61:
 945:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_62:
 946:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_63:
 947:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_64:
 948:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_65:
 949:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_66:
 950:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_67:
 951:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_68:
 952:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_69:
 953:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_70:
 954:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_71:
 955:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_72:
 956:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_73:
 957:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_74:
 958:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_75:
 959:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_76:
 960:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_77:
 961:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_78:
 962:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_79:
 963:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_80:
 964:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_81:
 965:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_82:
 966:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_83:
 967:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_84:
 968:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_85:
 969:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_86:
 970:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_87:
 971:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_88:
 972:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_89:
 973:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_90:
 974:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_91:
 975:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_92:
 976:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_93:
 977:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_94:
 978:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_95:
 979:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_96:
 980:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_97:
 981:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_98:
 982:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_99:
 983:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_100:
 984:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_101:
 985:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_102:
 986:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_103:
 987:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_104:
 988:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_105:
 989:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_106:
 990:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_107:
 991:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_108:
 992:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_109:
 993:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_110:
 994:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_111:
 995:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_112:
 996:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_113:
 997:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_114:
 998:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_115:
 999:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_116:
1000:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_117:
1001:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_118:
1002:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_119:
1003:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_120:
1004:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_121:
1005:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_122:
1006:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_123:
1007:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_124:
1008:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_125:
1009:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_126:
1010:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_127: {
1011:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1012:main.c        ****     const uchar nr_bloku =
1013:main.c        ****         aktualnie_wykonywana_komenda - KOMENDA_KOLEJKI_RESET_USTAWIEN_0;
1014:main.c        **** #define LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE 32
1015:main.c        ****     memset(bufor_eeprom, 0xff, LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE);
1016:main.c        ****     if (nr_bloku == 0) {
1017:main.c        ****       kod_modulu[0] = bufor_eeprom[1] = 'A';
1018:main.c        ****       kod_modulu[1] = bufor_eeprom[2] = 'B';
1019:main.c        ****       kod_modulu[2] = bufor_eeprom[3] = 'C';
1020:main.c        ****       kod_modulu[3] = bufor_eeprom[4] = 'D';
1021:main.c        ****       bufor_eeprom[5] = 0;
1022:main.c        ****       stan_wyjscie[0] = 0;
1023:main.c        ****       licznik_przelacznik_wyjscia[0] = 0;
1024:main.c        ****     }
1025:main.c        ****     zapisz_znaki_w_eeprom_bez_kopiowania(
1026:main.c        ****         nr_bloku * LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE,
1027:main.c        ****         LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE);
1028:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0 + nr_bloku + 1);
1029:main.c        ****     zapal_diode_led(50);
1030:main.c        ****     break;
1031:main.c        ****   }
1032:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_INICJALIZACJA: {
1033:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1034:main.c        ****     uchar bledny_zapis = FALSE;
1035:main.c        ****     static const uchar tab_eeprom_fabryczny[6] PROGMEM = {
1036:main.c        ****         0xff, 'A', 'B', 'C', 'D', 0x00,
1037:main.c        ****     };
1038:main.c        ****     for (uint i = 0; i < 6; ++i) {
1039:main.c        ****       if (eeprom_read_byte((void *)i) !=
1040:main.c        ****           pgm_read_byte(tab_eeprom_fabryczny + i))
1041:main.c        ****         bledny_zapis = TRUE;
1042:main.c        ****     }
1043:main.c        ****     for (uint i = EEPROM_NUMER_TELEFONU_BRAMA_0;
1044:main.c        ****          i < EEPROM_NUMER_TELEFONU_BRAMA_0 +
1045:main.c        ****                  MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA *
1046:main.c        ****                      LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM;
1047:main.c        ****          ++i) {
1048:main.c        ****       if (eeprom_read_byte((void *)i) != 0xff) {
1049:main.c        ****         bledny_zapis = TRUE;
1050:main.c        ****         break;
1051:main.c        ****       }
1052:main.c        ****     }
1053:main.c        ****     if (bledny_zapis) {
1054:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
1055:main.c        ****       break;
1056:main.c        ****     }
1057:main.c        ****     inicjalizuj_parametry_modulu();
1058:main.c        ****     ustaw_stan_led(FALSE); // Wylacz diode po zakonczeniu resetu
1059:main.c        ****     break;
1060:main.c        ****   }
1061:main.c        ****   case KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA: {
1062:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1063:main.c        **** 
1064:main.c        ****     if (blokada_sterowania_czasowa) {
1065:main.c        ****       // Poza dozwolonym czasem - ignoruj
1066:main.c        ****       break;
1067:main.c        ****     }
1068:main.c        **** 
1069:main.c        ****     // Make a local copy of the phone number to prevent corruption
1070:main.c        ****     // if the global buffer changes during processing (e.g. new CLIP)
1071:main.c        ****     uchar numer_lokalny[MAX_LICZBA_ZNAKOW_TELEFON + 1];
1072:main.c        ****     strcpy((char *)numer_lokalny, (char *)numer_telefonu_ktory_dzwoni);
1073:main.c        **** 
1074:main.c        ****     // Konwertuj numer dla późniejszego użycia
1075:main.c        ****     konwertuj_telefon_na_blok_eeprom(
1076:main.c        ****         &numer_lokalny[0], &numer_lokalny[strlen((char *)numer_lokalny)],
1077:main.c        ****         &bufor_eeprom[0]);
1078:main.c        **** 
1079:main.c        ****     // Sprawdź czy numer jest na liście (PEŁNY NUMER)
1080:main.c        ****     uchar znaleziono = FALSE;
1081:main.c        ****     if (tryb_pracy != 1) {
1082:main.c        ****       // Tylko w trybie prywatnym sprawdzamy listę
1083:main.c        ****       for (uint nr_uzyt_clip = 0;
1084:main.c        ****            nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
1085:main.c        ****         if (porownaj_numer_telefonu_blok(
1086:main.c        ****                 &bufor_eeprom[0],
1087:main.c        ****                 (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
1088:main.c        ****           znaleziono = TRUE;
1089:main.c        ****           break;
1090:main.c        ****         }
1091:main.c        ****       }
1092:main.c        ****     }
1093:main.c        **** 
1094:main.c        ****     // SKRYBA: Jeśli nie znaleziono pełnego, sprawdź skrócony (ostatnie 9 cyfr)
1095:main.c        ****     uchar numer_skrocony[20]; // Increased buffer size
1096:main.c        ****     if (skryba_wlaczona && !znaleziono) {
1097:main.c        ****       wyciagnij_ostatnie_cyfry(numer_lokalny, numer_skrocony, 9);
1098:main.c        **** 
1099:main.c        ****       // Konwertuj skrócony numer do bufor_eeprom dla porównania
1100:main.c        ****       konwertuj_telefon_na_blok_eeprom(
1101:main.c        ****           &numer_skrocony[0], &numer_skrocony[strlen((char *)numer_skrocony)],
1102:main.c        ****           &bufor_eeprom[0]);
1103:main.c        **** 
1104:main.c        ****       if (tryb_pracy != 1) {
1105:main.c        ****         for (uint nr_uzyt_clip = 0;
1106:main.c        ****              nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
1107:main.c        ****              ++nr_uzyt_clip) {
1108:main.c        ****           if (porownaj_numer_telefonu_blok(
1109:main.c        ****                   &bufor_eeprom[0],
1110:main.c        ****                   (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
1111:main.c        ****             znaleziono = TRUE;
1112:main.c        ****             break;
1113:main.c        ****           }
1114:main.c        ****         }
1115:main.c        ****       }
1116:main.c        ****     }
1117:main.c        **** 
1118:main.c        ****     // SKRYBA: Auto-save numer jesli wlaczona i nie znaleziono
1119:main.c        ****     zapisz_znak_w_eeprom(skryba_wlaczona ? 1 : 0,
1120:main.c        ****                          ADRES_EEPROM_DEBUG_SKRYBA_2); // DEBUG
1121:main.c        ****     zapisz_znak_w_eeprom(znaleziono ? 0 : 1,
1122:main.c        ****                          ADRES_EEPROM_DEBUG_SKRYBA_3); // DEBUG
1123:main.c        **** 
1124:main.c        ****     if (skryba_wlaczona && !znaleziono) {
1125:main.c        ****       uchar len_full = strlen((char *)numer_lokalny);
1126:main.c        **** 
1127:main.c        ****       // DEBUG: Zapisz dlugosc numeru
1128:main.c        ****       zapisz_znak_w_eeprom(len_full, ADRES_EEPROM_DEBUG_SKRYBA_5);
1129:main.c        **** 
1130:main.c        ****       if (len_full >= 3) {
1131:main.c        ****         // Skopiuj skrócony numer do numer_telefonu_skryba
1132:main.c        ****         strcpy((char *)numer_telefonu_skryba, (char *)numer_skrocony);
1133:main.c        **** 
1134:main.c        ****         // Extra check: ensure extracted number is also >= 3 chars
1135:main.c        ****         if (strlen((char *)numer_telefonu_skryba) >= 3) {
1136:main.c        ****           zapisz_znak_w_eeprom(
1137:main.c        ****               1, ADRES_EEPROM_DEBUG_SKRYBA_4); // DEBUG: komenda dodana
1138:main.c        **** 
1139:main.c        ****           // Dodaj komende dodania uzytkownika Skryba
1140:main.c        ****           dodaj_komende(KOMENDA_KOLEJKI_DODAJ_UZYTKOWNIKA_SKRYBA);
1141:main.c        ****         }
1142:main.c        ****       }
1143:main.c        ****     }
1144:main.c        **** 
1145:main.c        ****     // Teraz sprawdź tryb i otwórz bramę (TYLKO W TRYBIE CLIP!)
1146:main.c        ****     if (tryb_clip) {
1147:main.c        ****       if (tryb_pracy == 1) {
1148:main.c        ****         // Tryb publiczny - otwórz dla każdego
1149:main.c        ****         ustaw_wyjscie_clip();
1150:main.c        ****       } else if (znaleziono) {
1151:main.c        ****         // Tryb prywatny - otwórz tylko dla znalezionych
1152:main.c        ****         ustaw_wyjscie_clip();
1153:main.c        ****       }
1154:main.c        ****     }
1155:main.c        ****     // W trybie DTMF NIE włączamy wyjścia - czekamy na klawisz '1'
1156:main.c        **** 
1157:main.c        ****     break;
1158:main.c        ****   }
1159:main.c        ****   case KOMENDA_KOLEJKI_DODAJ_UZYTKOWNIKA_BRAMA: {
1160:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1161:main.c        **** 
1162:main.c        ****     // Check for duplicates using the helper function
1163:main.c        ****     if (czy_numer_istnieje(numer_telefonu_do_ktorego_dzwonic)) {
1164:main.c        ****       return TRUE; // Duplicate found, abort
1165:main.c        ****     }
1166:main.c        **** 
1167:main.c        ****     // Re-convert because czy_numer_istnieje uses bufor_eeprom which might be
1168:main.c        ****     // modified (though in this implementation it sets it correctly for writing
1169:main.c        ****     // too) But to be safe and consistent with original logic:
1170:main.c        ****     konwertuj_telefon_na_blok_eeprom(
1171:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
1172:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[strlen(
1173:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
1174:main.c        ****         &bufor_eeprom[0]);
1175:main.c        **** 
1176:main.c        ****     uchar dodano = FALSE;
1177:main.c        ****     // Skryba: dodawaj tylko do pozycji 0-794 (user-facing 1-795)
1178:main.c        ****     // Pozycje 795-800 (indeksy 794-799) sa zarezerwowane dla Super Userow
1179:main.c        ****     uint max_pozycja = (skryba_limit < 795) ? skryba_limit : 795;
1180:main.c        ****     for (uint nr_uzyt_clip = 0; nr_uzyt_clip < max_pozycja; ++nr_uzyt_clip) {
1181:main.c        ****       if (not czy_aktywny_numer_telefonu_brama(nr_uzyt_clip)) {
1182:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
1183:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
1184:main.c        ****             LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1185:main.c        ****         dodano = TRUE;
1186:main.c        ****         break;
1187:main.c        ****       }
1188:main.c        ****     }
1189:main.c        **** 
1190:main.c        ****     // Jesli dodano numer i Skryba jest wlaczona, sprawdz czy osiagnieto limit
1191:main.c        ****     if (dodano && skryba_wlaczona) {
1192:main.c        ****       // Policz aktywnych uzytkownikow
1193:main.c        ****       uint aktywne_numery = 0;
1194:main.c        ****       for (uint i = 0; i < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++i) {
1195:main.c        ****         if (czy_aktywny_numer_telefonu_brama(i)) {
1196:main.c        ****           ++aktywne_numery;
1197:main.c        ****         }
1198:main.c        ****       }
1199:main.c        **** 
1200:main.c        ****       // Jesli osiagnieto limit, wylacz Skrybe
1201:main.c        ****       if (aktywne_numery >= skryba_limit) {
1202:main.c        ****         skryba_wlaczona = FALSE;
1203:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_SKRYBA);
1204:main.c        **** 
1205:main.c        ****         tryb_pracy = 0; // Prywatny
1206:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_TRYB_PRACY);
1207:main.c        ****       }
1208:main.c        ****     }
1209:main.c        ****     break;
1210:main.c        ****   }
1211:main.c        ****   case KOMENDA_KOLEJKI_DODAJ_UZYTKOWNIKA_SKRYBA: {
1212:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1213:main.c        **** 
1214:main.c        ****     // Use a LOCAL buffer for Skryba to avoid corruption by czy_numer_istnieje
1215:main.c        ****     uchar bufor_skryba[LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM];
1216:main.c        **** 
1217:main.c        ****     // Convert Skryba number to EEPROM format FIRST, before duplicate check
1218:main.c        ****     konwertuj_telefon_na_blok_eeprom(
1219:main.c        ****         &numer_telefonu_skryba[0],
1220:main.c        ****         &numer_telefonu_skryba[strlen((char *)numer_telefonu_skryba)],
1221:main.c        ****         bufor_skryba);
1222:main.c        **** 
1223:main.c        ****     // Check for duplicates using the helper function
1224:main.c        ****     // (This will use bufor_eeprom internally, but we have our number safe in
1225:main.c        ****     // bufor_skryba)
1226:main.c        ****     if (czy_numer_istnieje(numer_telefonu_skryba)) {
1227:main.c        ****       return TRUE; // Duplicate found, abort
1228:main.c        ****     }
1229:main.c        **** 
1230:main.c        ****     // Copy our safe buffer to bufor_eeprom for writing
1231:main.c        ****     memcpy(bufor_eeprom, bufor_skryba, LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1232:main.c        **** 
1233:main.c        ****     uchar dodano = FALSE;
1234:main.c        ****     for (uint nr_uzyt_clip = 0;
1235:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
1236:main.c        ****       if (not czy_aktywny_numer_telefonu_brama(nr_uzyt_clip)) {
1237:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
1238:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
1239:main.c        ****             LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1240:main.c        **** 
1241:main.c        ****         dodano = TRUE;
1242:main.c        ****         break;
1243:main.c        ****       }
1244:main.c        ****     }
1245:main.c        **** 
1246:main.c        ****     // Jesli dodano numer i Skryba jest wlaczona, sprawdz czy osiagnieto limit
1247:main.c        ****     if (dodano && skryba_wlaczona) {
1248:main.c        ****       // Policz aktywnych uzytkownikow
1249:main.c        ****       uint aktywne_numery = 0;
1250:main.c        ****       for (uint i = 0; i < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++i) {
1251:main.c        ****         if (czy_aktywny_numer_telefonu_brama(i)) {
1252:main.c        ****           ++aktywne_numery;
1253:main.c        ****         }
1254:main.c        ****       }
1255:main.c        **** 
1256:main.c        ****       // Jesli osiagnieto limit, wylacz Skrybe
1257:main.c        ****       if (aktywne_numery >= skryba_limit) {
1258:main.c        ****         skryba_wlaczona = FALSE;
1259:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_SKRYBA);
1260:main.c        **** 
1261:main.c        ****         tryb_pracy = 0; // Prywatny
1262:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_TRYB_PRACY);
1263:main.c        ****       }
1264:main.c        ****     }
1265:main.c        ****     break;
1266:main.c        ****   }
1267:main.c        ****   case KOMENDA_KOLEJKI_DODAJ_SUPER_USERA: {
1268:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1269:main.c        **** 
1270:main.c        ****     // Use a LOCAL buffer to avoid corruption by czy_numer_istnieje
1271:main.c        ****     uchar bufor_super[LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM];
1272:main.c        **** 
1273:main.c        ****     // Convert number to EEPROM format FIRST, before duplicate check
1274:main.c        ****     konwertuj_telefon_na_blok_eeprom(
1275:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
1276:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[strlen(
1277:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
1278:main.c        ****         bufor_super);
1279:main.c        **** 
1280:main.c        ****     // Check for duplicates using the helper function
1281:main.c        ****     // (This will use bufor_eeprom internally, but we have our number safe in
1282:main.c        ****     // bufor_super)
1283:main.c        ****     if (czy_numer_istnieje(numer_telefonu_do_ktorego_dzwonic)) {
1284:main.c        ****       // Numer juz istnieje - wyslij komunikat
1285:main.c        ****       strcpy((char *)numer_telefonu_wysylanego_smsa,
1286:main.c        ****              (char *)numer_telefonu_odebranego_smsa);
1287:main.c        ****       strcpy_P((char *)tekst_wysylanego_smsa,
1288:main.c        ****                PSTR("Numer juz istnieje w systemie"));
1289:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
1290:main.c        ****       return TRUE;
1291:main.c        ****     }
1292:main.c        **** 
1293:main.c        ****     // Copy our safe buffer to bufor_eeprom for writing
1294:main.c        ****     memcpy(bufor_eeprom, bufor_super, LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1295:main.c        **** 
1296:main.c        ****     // Szukaj pierwszej wolnej pozycji w zakresie 794-799 (user-facing 795-800)
1297:main.c        ****     uchar dodano = FALSE;
1298:main.c        ****     uint pozycja_dodana = 0;
1299:main.c        ****     for (uint nr_uzyt = 794; nr_uzyt < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
1300:main.c        ****          ++nr_uzyt) {
1301:main.c        ****       if (not czy_aktywny_numer_telefonu_brama(nr_uzyt)) {
1302:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
1303:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt),
1304:main.c        ****             LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1305:main.c        ****         dodano = TRUE;
1306:main.c        ****         pozycja_dodana = nr_uzyt + 1; // User-facing (1-indexed)
1307:main.c        ****         break;
1308:main.c        ****       }
1309:main.c        ****     }
1310:main.c        **** 
1311:main.c        ****     // Wyslij odpowiedz
1312:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
1313:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
1314:main.c        ****     if (dodano) {
1315:main.c        ****       sprintf((char *)tekst_wysylanego_smsa, "Super User dodany na pozycji %u",
1316:main.c        ****               pozycja_dodana);
1317:main.c        ****     } else {
1318:main.c        ****       strcpy_P((char *)tekst_wysylanego_smsa,
1319:main.c        ****                PSTR("Brak wolnych pozycji Super User (795-800)"));
1320:main.c        ****     }
1321:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
1322:main.c        **** 
1323:main.c        ****     return TRUE;
1324:main.c        ****   }
1325:main.c        ****   case KOMENDA_KOLEJKI_USUN_UZYTKOWNIKA_BRAMA: {
1326:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1327:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
1328:main.c        ****                                      &numer_telefonu_do_ktorego_dzwonic[strlen(
1329:main.c        ****                                          numer_telefonu_do_ktorego_dzwonic)],
1330:main.c        ****                                      &bufor_eeprom[0]);
1331:main.c        ****     // for (uchar nr_uzyt_clip = 0; nr_uzyt_clip <
1332:main.c        ****     // MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip)
1333:main.c        ****     for (uint nr_uzyt_clip = 0;
1334:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
1335:main.c        ****       if (porownaj_numer_telefonu_blok(
1336:main.c        ****               &bufor_eeprom[0], // 1 porwnanie zajmuje ~10us, czyli 170 numerw ~
1337:main.c        ****                                 // 2ms
1338:main.c        ****               (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
1339:main.c        ****         numer_telefonu_do_ktorego_dzwonic[0] = '\0';
1340:main.c        ****         konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
1341:main.c        ****                                          &numer_telefonu_do_ktorego_dzwonic[1],
1342:main.c        ****                                          &bufor_eeprom[0]);
1343:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
1344:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
1345:main.c        ****             LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1346:main.c        ****         break;
1347:main.c        ****       }
1348:main.c        ****     }
1349:main.c        ****     break;
1350:main.c        ****   }
1351:main.c        ****   default:
1352:main.c        ****     return FALSE;
1353:main.c        ****   }
1354:main.c        ****   return TRUE;
1355:main.c        **** }
1356:main.c        **** 
1357:main.c        **** uchar wykonanie_komend_powiadomien(void) {
1358:main.c        ****   const komenda_typ aktualnie_wykonywana_komenda = komendy_kolejka[0];
1359:main.c        **** 
1360:main.c        ****   const uchar czy_gsm_zajety =
1361:main.c        ****       flaga_odczytywanie_smsa || flaga_wysylanie_smsa ||
1362:main.c        ****       wykonywanie_rozmowy_telefonicznej ||
1363:main.c        ****       trwa_rozmowa_przychodzaca_od_uzytkownika ||
1364:main.c        ****       aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
1365:main.c        ****       opoznienie_SIM900_100MS || czekanie_na_odebranie_zachety;
1366:main.c        **** 
1367:main.c        ****   const uchar czy_mozna_wysylac_dane_do_SIM900 =
1368:main.c        ****       !czy_gsm_zajety && CZY_MOZNA_WYSYLAC_DANE_SIM900() &&
1369:main.c        ****       czy_jest_bezczynny_SIM900();
1370:main.c        **** 
1371:main.c        ****   switch (aktualnie_wykonywana_komenda) {
1372:main.c        ****   case KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW: {
1373:main.c        ****     if (not czy_mozna_wysylac_dane_do_SIM900 ||
1374:main.c        ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1375:main.c        ****       dodaj_komende(aktualnie_wykonywana_komenda);
1376:main.c        ****       break;
1377:main.c        ****     }
1378:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1379:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
1380:main.c        ****     *sms++ = '*';
1381:main.c        ****     for (;;) {
1382:main.c        ****       if (czy_aktywny_numer_telefonu_brama(
1383:main.c        ****               numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama)) {
1384:main.c        ****         sms += kopiuj_blok_eeprom_na_telefon(
1385:main.c        ****             (void *)EEPROM_NUMER_TELEFONU_BRAMA(
1386:main.c        ****                 numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama),
1387:main.c        ****             sms, MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER);
1388:main.c        ****         *sms++ = '#';
1389:main.c        ****         *sms++ = '\n';
1390:main.c        ****         ++numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama;
1391:main.c        ****         if ((sms + MAX_LICZBA_ZNAKOW_TELEFON + 1 >=
1392:main.c        ****              &tekst_wysylanego_smsa[MAX_LICZBA_ZNAKOW_SMS]) ||
1393:main.c        ****             (numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama >=
1394:main.c        ****              MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER)) {
1395:main.c        ****           if ((numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama <
1396:main.c        ****                MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER))
1397:main.c        ****             dodaj_komende(aktualnie_wykonywana_komenda);
1398:main.c        ****           *sms = '\0';
1399:main.c        ****           dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
1400:main.c        ****           wysylanie_smsa_clipa = WYSYLANIE_SMSA_WYSYLANIE;
1401:main.c        ****           break;
1402:main.c        ****         }
1403:main.c        ****       } else {
1404:main.c        ****         if (++numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama >=
1405:main.c        ****             MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER) {
1406:main.c        ****           if (sms != &tekst_wysylanego_smsa[0]) {
1407:main.c        ****             *sms = '\0';
1408:main.c        ****             dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
1409:main.c        ****             wysylanie_smsa_clipa = WYSYLANIE_SMSA_WYSYLANIE;
1410:main.c        ****           }
1411:main.c        ****           break;
1412:main.c        ****         }
1413:main.c        ****       }
1414:main.c        ****     }
1415:main.c        ****     break;
1416:main.c        ****   }
1417:main.c        ****   default:
1418:main.c        ****     return FALSE;
1419:main.c        ****   }
1420:main.c        ****   return TRUE;
1421:main.c        **** }
1422:main.c        **** 
1423:main.c        **** void wykonanie_komend(void) {
1424:main.c        ****   if (wykonanie_komend_SIM900())
1425:main.c        ****     ;
1426:main.c        ****   else if (wykonanie_komend_ukladow())
1427:main.c        ****     ;
1428:main.c        ****   else if (wykonanie_komend_powiadomien())
1429:main.c        ****     ;
1430:main.c        ****   else
1431:main.c        ****     ;
1432:main.c        ****   usun_komende();
1433:main.c        **** }
1434:main.c        **** 
1435:main.c        **** void test_sms_clip_100ms(void) {
1436:main.c        ****   // static ulong licznik_sms;
1437:main.c        ****   // if ( ++licznik_sms > 60 * 10 )
1438:main.c        ****   //{
1439:main.c        ****   //	licznik_sms = 0;
1440:main.c        **** 
1441:main.c        ****   // tekst_wysylanego_smsa[0] = 'A';
1442:main.c        ****   // tekst_wysylanego_smsa[1] = 'B';
1443:main.c        ****   // tekst_wysylanego_smsa[2] = 'C';
1444:main.c        ****   // tekst_wysylanego_smsa[3] = 'D';
1445:main.c        ****   // tekst_wysylanego_smsa[4] = 0;
1446:main.c        ****   // static const char tel[] PROGMEM = "731314727";
1447:main.c        ****   ////static const char tel[] PROGMEM = "505691117";
1448:main.c        ****   // memcpy_R(numer_telefonu_wysylanego_smsa, tel);
1449:main.c        ****   // dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
1450:main.c        **** 
1451:main.c        ****   // memcpy_R(numer_telefonu_do_ktorego_dzwonic, tel);
1452:main.c        ****   // dodaj_komende(KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE);
1453:main.c        ****   //}
1454:main.c        **** }
1455:main.c        **** 
1456:main.c        **** void steruj_wejscia_wyjscia_100ms(void) {
1457:main.c        ****   aktualizuj_stan_wyzwolenia_wejsc_100ms();
1458:main.c        ****   steruj_wejsciem_reset_100ms();
1459:main.c        ****   steruj_wyjscia_100ms();
1460:main.c        **** }
1461:main.c        **** 
1462:main.c        **** void zapis_w_eeprom_stanu_wyjsc(void) {
1463:main.c        ****   if (not czy_wolny_eeprom())
1464:main.c        ****     return;
1465:main.c        ****   uchar par = 0;
1466:main.c        ****   if ((stan_wyjscie[0] != 0) ^ (licznik_przelacznik_wyjscia[0] != 0))
1467:main.c        ****     par |= BIT(0);
1468:main.c        ****   if (par != eeprom_read_byte((void *)EEPROM_USTAWIENIE_STANOW_WYJSC))
1469:main.c        ****     zapisz_znaki_w_eeprom(&par, (uint)EEPROM_USTAWIENIE_STANOW_WYJSC, 1);
1470:main.c        **** }
1471:main.c        **** 
1472:main.c        **** // void test_clip_na_101(void)
1473:main.c        **** //{
1474:main.c        **** //	if ( not modul_zalogowany_w_sieci )
1475:main.c        **** //		return;
1476:main.c        **** //	static uint licznik_101;
1477:main.c        **** //	if ( ++licznik_101 < 2 * 60 * 10 )
1478:main.c        **** //		return;
1479:main.c        **** //	licznik_101 = 0;
1480:main.c        **** //	static const char doladowanie[] PROGMEM = "*101#";
1481:main.c        **** //	strcpy_P(numer_telefonu_do_ktorego_dzwonic, doladowanie);
1482:main.c        **** //	dodaj_komende(KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE);
1483:main.c        **** // }
1484:main.c        **** 
1485:main.c        **** void steruj_urzadzeniem_100MS(void) {
1486:main.c        ****   steruj_wejscia_wyjscia_100ms();
1487:main.c        ****   steruj_SIM900_100MS();
1488:main.c        ****   if (licznik_100ms_dioda_led) {
1489:main.c        ****     if (--licznik_100ms_dioda_led == 0)
1490:main.c        ****       ustaw_stan_led(FALSE);
1491:main.c        ****     else
1492:main.c        ****       ustaw_stan_led(TRUE);
1493:main.c        ****   }
1494:main.c        **** 
1495:main.c        ****   // Aktualizacja timera blokady komend REPORT/USER
1496:main.c        ****   if (timer_report_user_100ms > 0) {
1497:main.c        ****     --timer_report_user_100ms;
1498:main.c        ****     if (timer_report_user_100ms == 0) {
1499:main.c        ****       // Okno czasowe minelo - resetuj licznik
1500:main.c        ****       licznik_report_user = 0;
1501:main.c        ****     }
1502:main.c        ****   } else {
1503:main.c        ****     // Timer jest 0 - upewnij sie ze licznik tez jest 0 (ochrona przed
1504:main.c        ****     // bledami)
1505:main.c        ****     licznik_report_user = 0;
1506:main.c        ****   }
1507:main.c        **** 
1508:main.c        ****   // Mechanizm wykrywania zablokowanej kolejki i czyszczenia starych komend
1509:main.c        ****   // SMS
1510:main.c        ****   const komenda_typ pierwsza_komenda = komendy_kolejka[0];
1511:main.c        ****   if (pierwsza_komenda != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
1512:main.c        ****     // Sprawdz czy pierwsza komenda to SMS - jesli tak i stoi zbyt dlugo,
1513:main.c        ****     // wyczysc
1514:main.c        ****     if (pierwsza_komenda >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
1515:main.c        ****         pierwsza_komenda <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU) {
1516:main.c        ****       // To jest komenda SMS - sprawdz czy stoi zbyt dlugo
1517:main.c        ****       if (pierwsza_komenda == ostatnia_pierwsza_komenda) {
1518:main.c        ****         // Ta sama komenda SMS jest na poczatku kolejki - kolejka moze stac
1519:main.c        ****         if (licznik_kolejka_stoi_100ms < MAX_CZAS_KOLEJKA_STOI_100MS)
1520:main.c        ****           ++licznik_kolejka_stoi_100ms;
1521:main.c        ****         else {
1522:main.c        ****           // Komenda SMS stoi juz 30 sekund - wyczysc wszystkie komendy SMS i
1523:main.c        ****           // wznow dzialanie
1524:main.c        ****           filtruj_komendy_z_przedzialu(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT,
1525:main.c        ****                                        KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
1526:main.c        ****           if (licznik_awaryjnych_resetow_kolejki < 0xFFFF)
1527:main.c        ****             ++licznik_awaryjnych_resetow_kolejki;
1528:main.c        **** 
1529:main.c        ****           filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
1530:main.c        **** 
1531:main.c        ****           // Resetuj blokade komend REPORT/USER aby wznowic dzialanie
1532:main.c        ****           licznik_report_user = 0;
1533:main.c        ****           timer_report_user_100ms = 0;
1534:main.c        **** 
1535:main.c        ****           // Resetuj liczniki kolejki
1536:main.c        ****           licznik_kolejka_stoi_100ms = 0;
1537:main.c        ****           ostatnia_pierwsza_komenda = KOMENDA_KOLEJKI_BRAK_KOMENDY;
1538:main.c        **** 
1539:main.c        ****           // Resetuj flage wysylania SMS (na wypadek zablokowania)
1540:main.c        ****           flaga_wysylanie_smsa = 0;
1541:main.c        ****         }
1542:main.c        ****       } else {
1543:main.c        ****         // Pierwsza komenda SMS sie zmienila - kolejka dziala
1544:main.c        ****         ostatnia_pierwsza_komenda = pierwsza_komenda;
1545:main.c        ****         licznik_kolejka_stoi_100ms = 0;
1546:main.c        ****       }
1547:main.c        ****     } else {
1548:main.c        ****       // To nie jest komenda SMS - resetuj licznik (nie interesuje nas)
1549:main.c        ****       ostatnia_pierwsza_komenda = pierwsza_komenda;
1550:main.c        ****       licznik_kolejka_stoi_100ms = 0;
1551:main.c        ****     }
1552:main.c        ****   } else {
1553:main.c        ****     // Kolejka jest pusta
1554:main.c        ****     ostatnia_pierwsza_komenda = KOMENDA_KOLEJKI_BRAK_KOMENDY;
1555:main.c        ****     licznik_kolejka_stoi_100ms = 0;
1556:main.c        ****   }
1557:main.c        **** 
1558:main.c        ****   // Watchdog pilnujacy zakleszczonego wysylania SMS
1559:main.c        ****   if (flaga_wysylanie_smsa) {
1560:main.c        ****     if (licznik_watchdog_wysylanie_smsa_100ms < WATCHDOG_WYSYLANIA_SMS_100MS) {
1561:main.c        ****       ++licznik_watchdog_wysylanie_smsa_100ms;
1562:main.c        ****     } else {
1563:main.c        ****       licznik_watchdog_wysylanie_smsa_100ms = 0;
1564:main.c        ****       // Awaryjne odblokowanie
1565:main.c        ****       watchdog_sms_disarm();
1566:main.c        ****       flaga_wysylanie_smsa = 0;
1567:main.c        ****       liczba_prob_wyslania_smsa = 0;
1568:main.c        ****       czekanie_na_odebranie_zachety = FALSE;
1569:main.c        ****       wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
1570:main.c        **** 
1571:main.c        ****       if (liczba_kolejnych_watchdogow_wysylania < 255)
1572:main.c        ****         ++liczba_kolejnych_watchdogow_wysylania;
1573:main.c        ****       if (liczba_kolejnych_watchdogow_wysylania >= 3) {
1574:main.c        ****         liczba_kolejnych_watchdogow_wysylania = 0;
1575:main.c        ****         reset_modulu_SIM900();
1576:main.c        ****       }
1577:main.c        ****     }
1578:main.c        ****   } else {
1579:main.c        ****     licznik_watchdog_wysylanie_smsa_100ms = 0;
1580:main.c        ****     liczba_kolejnych_watchdogow_wysylania = 0;
1581:main.c        ****   }
1582:main.c        **** 
1583:main.c        ****   if (watchdog_sms_aktywny) {
1584:main.c        ****     if (watchdog_sms_licznik_100ms < WATCHDOG_SMS_TIMEOUT_100MS)
1585:main.c        ****       ++watchdog_sms_licznik_100ms;
1586:main.c        ****     else {
1587:main.c        ****       watchdog_sms_trwa_reset = TRUE;
1588:main.c        ****       cli();
1589:main.c        ****       wdt_enable(WDTO_15MS);
1590:main.c        ****       while (1)
1591:main.c        ****         ;
1592:main.c        ****     }
1593:main.c        ****   } else if (watchdog_sms_safe_mode_100ms) {
1594:main.c        ****     --watchdog_sms_safe_mode_100ms;
1595:main.c        ****   }
1596:main.c        **** 
1597:main.c        ****   // Obsluga szybkich blyskow LED
1598:main.c        ****   if (liczba_blyskow_led > 0) {
1599:main.c        ****     ++stan_cyklu_blysku;
1600:main.c        ****     if (stan_cyklu_blysku >= 6) {
1601:main.c        ****       stan_cyklu_blysku = 0;
1602:main.c        ****       --liczba_blyskow_led;
1603:main.c        ****     }
1604:main.c        ****     ustaw_stan_led(stan_cyklu_blysku < 2);
1605:main.c        ****     return;
1606:main.c        ****   }
1607:main.c        **** 
1608:main.c        ****   // LED: ON gdy nie zalogowany, OFF gdy zalogowany (z mruganiem przy dobrym
1609:main.c        ****   // sygnale)
1610:main.c        ****   if (!modul_zalogowany_w_sieci) {
1611:main.c        ****     // Nie zalogowany - dioda swiecei ciagle
1612:main.c        ****     ustaw_stan_led(TRUE);
1613:main.c        ****   } else {
1614:main.c        ****     // Zalogowany - dioda zgaszona lub mruga w zaleznosci od sygnalu
1615:main.c        ****     if (licznik_100ms_dioda_led) {
1616:main.c        ****       // Mrugniecie (SMS, etc.)
1617:main.c        ****       ustaw_stan_led(TRUE);
1618:main.c        ****     } else {
1619:main.c        ****       // Normalne dzialanie - mrugaj w zaleznosci od poziomu sygnalu
1620:main.c        ****       static uchar licznik_dioda_led_poziom_sieci;
1621:main.c        ****       if (poziom_sieci_gsm < 16) {
1622:main.c        ****         if (++licznik_dioda_led_poziom_sieci >= 50)
1623:main.c        ****           licznik_dioda_led_poziom_sieci = 1;
1624:main.c        ****       } else
1625:main.c        ****         licznik_dioda_led_poziom_sieci = 0;
1626:main.c        **** 
1627:main.c        ****       ustaw_stan_led(licznik_dioda_led_poziom_sieci == 40 ||
1628:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
1629:main.c        ****                      (licznik_dioda_led_poziom_sieci >= 46 &&
1630:main.c        ****                       licznik_dioda_led_poziom_sieci <= 49));
1631:main.c        ****     }
1632:main.c        ****   }
1633:main.c        ****   zapis_w_eeprom_stanu_wyjsc();
1634:main.c        **** }
1635:main.c        **** 
1636:main.c        **** void steruj_urzadzeniem_10MS(void) {
1637:main.c        ****   steruj_wejscia_10ms();
1638:main.c        ****   steruj_SIM900_10MS();
1639:main.c        ****   zapisz_bajt_w_EEPROM();
1640:main.c        ****   // test_dioda_wyjscia();
1641:main.c        ****   // test_wejscie();
1642:main.c        **** }
1643:main.c        **** 
1644:main.c        **** void wolne_zdarzenie_timer(void) {
1645:main.c        ****   WYKONAJ_CLI_SEI(WYLACZ_PRZERWANIE_TIMER());
1646:main.c        ****   if (!CZY_WYKONAC_ZDARZENIE_TIMER()) {
1647:main.c        ****     WYKONAJ_CLI_SEI(WLACZ_PRZERWANIE_TIMER());
1648:main.c        ****     return;
1649:main.c        ****   }
1650:main.c        ****   wykonaj_zdarzenie_timer = FALSE;
1651:main.c        ****   if (wykonac_watki_10MS) {
1652:main.c        ****     wykonac_watki = WYKONAJ_WATKI_10MS;
1653:main.c        ****     wykonac_watki_10MS = FALSE;
1654:main.c        ****   }
1655:main.c        ****   WYKONAJ_CLI_SEI(WLACZ_PRZERWANIE_TIMER());
1656:main.c        ****   if (CZY_WYKONAC_WATKI_10MS()) {
1657:main.c        ****     static uchar licznik_wybuc_watki_100MS = 0;
1658:main.c        **** #define OPOZNIENIE_100_MS 10
1659:main.c        ****     if (++licznik_wybuc_watki_100MS == OPOZNIENIE_100_MS) {
1660:main.c        ****       licznik_wybuc_watki_100MS = 0;
1661:main.c        ****       wykonac_watki = WYKONAJ_WATKI_100MS | WYKONAJ_WATKI_10MS;
1662:main.c        ****     }
1663:main.c        ****     NOP();
1664:main.c        ****     cli();
1665:main.c        ****     if (CZY_ODBIERANIE_DANYCH_SIM900()) {
1666:main.c        ****       WYLACZ_PRZERWANIE_ODBIORU_DANYCH_SIM900();
1667:main.c        ****       sei();
1668:main.c        ****       if (liczba_odebranych_znakow_SIM900 != 0 &&
1669:main.c        ****           ++licznik_opoznienie_oczekiwania_na_bajt_SIM900 >
1670:main.c        ****               MAX_OPOZNIENIE_OCZEKIWANIA_NA_BAJT_SIM900_500_MS) {
1671:main.c        ****         resetuj_odbior_SIM900_po_bledzie();
1672:main.c        ****       } else {
1673:main.c        ****         WYKONAJ_CLI_SEI(WLACZ_PRZERWANIE_ODBIORU_DANYCH_SIM900());
1674:main.c        ****       }
1675:main.c        ****     }
1676:main.c        ****     sei();
1677:main.c        ****   }
1678:main.c        **** }
1679:main.c        **** 
1680:main.c        **** void ustaw_parametry_dla_bezpieczenstwa(void) {
1681:main.c        ****   wdt_reset();
1682:main.c        ****   ustaw_parametry_dla_bezpieczenstwa_rejestry();
1683:main.c        ****   set_sleep_mode(SLEEP_MODE_IDLE);
1684:main.c        **** }
1685:main.c        **** 
1686:main.c        **** void inicjalizuj_parametry_modulu(void) {
1687:main.c        ****   memcpy_E(kod_modulu, ADRES_EEPROM_KOD_DOSTEPU, LICZBA_BAJTOW_KODU_DOSTEPU);
1688:main.c        **** 
1689:main.c        ****   // Auto-naprawa: Jeśli kod jest pusty (FF) lub zerowy, ustaw ABCD
1690:main.c        ****   if (kod_modulu[0] == 0xFF || kod_modulu[0] == 0x00) {
1691:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
1692:main.c        ****     kod_modulu[1] = bufor_eeprom[1] = 'B';
1693:main.c        ****     kod_modulu[2] = bufor_eeprom[2] = 'C';
1694:main.c        ****     kod_modulu[3] = bufor_eeprom[3] = 'D';
1695:main.c        ****     // Zapisz do EEPROM natychmiast (BLOCKING)
1696:main.c        ****     while (!eeprom_is_ready())
1697:main.c        ****       ;
1698:main.c        ****     eeprom_update_block(kod_modulu, (void *)ADRES_EEPROM_KOD_DOSTEPU,
1699:main.c        ****                         LICZBA_BAJTOW_KODU_DOSTEPU);
1700:main.c        ****   }
1701:main.c        **** 
1702:main.c        ****   // Auto-naprawa: Jeśli tryb pracy jest nieokreślony (0xFF), ustaw Publiczny
1703:main.c        ****   // (1)
1704:main.c        ****   tryb_pracy = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_TRYB_PRACY);
1705:main.c        ****   if (tryb_pracy == 0xFF) {
1706:main.c        ****     tryb_pracy = 1; // Domyślnie Publiczny
1707:main.c        ****     while (!eeprom_is_ready())
1708:main.c        ****       ;
1709:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_TRYB_PRACY, 1);
1710:main.c        ****   }
1711:main.c        **** 
1712:main.c        ****   // --- Inicjalizacja trybu CLIP/DTMF ---
1713:main.c        ****   tryb_clip = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_TRYB_CLIP_DTMF);
1714:main.c        ****   if (tryb_clip == 0xFF) {
1715:main.c        ****     tryb_clip = 1; // Domyślnie CLIP (1)
1716:main.c        ****     while (!eeprom_is_ready())
1717:main.c        ****       ;
1718:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_TRYB_CLIP_DTMF, 1);
1719:main.c        ****   }
1720:main.c        **** 
1721:main.c        ****   // Inicjalizacja parametrow czasowych
1722:main.c        ****   czas_start_h = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_START_H);
1723:main.c        ****   czas_start_m = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_START_M);
1724:main.c        ****   czas_stop_h = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_STOP_H);
1725:main.c        ****   czas_stop_m = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_STOP_M);
1726:main.c        **** 
1727:main.c        ****   // Inicjalizacja SKRYBA
1728:main.c        ****   skryba_wlaczona = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA);
1729:main.c        ****   if (skryba_wlaczona == 0xFF)
1730:main.c        ****     skryba_wlaczona = FALSE;
1731:main.c        **** 
1732:main.c        ****   // Odczyt limitu Skryby z EEPROM
1733:main.c        ****   uchar limit_l =
1734:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA_LIMIT_L);
1735:main.c        ****   uchar limit_h =
1736:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA_LIMIT_H);
1737:main.c        ****   if (limit_l == 0xFF && limit_h == 0xFF) {
1738:main.c        ****     // Nie ustawiono - domyslnie 800
1739:main.c        ****     skryba_limit = 800;
1740:main.c        ****   } else {
1741:main.c        ****     skryba_limit = limit_l | (limit_h << 8);
1742:main.c        ****     // Walidacja zakresu
1743:main.c        ****     if (skryba_limit < 1 || skryba_limit > MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA) {
1744:main.c        ****       skryba_limit = 800;
1745:main.c        ****     }
1746:main.c        ****   }
1747:main.c        ****   // Debug initialization
1748:main.c        ****   zapisz_debug_do_eeprom(skryba_wlaczona ? 1 : 0, (uchar)(skryba_limit & 0xFF));
1749:main.c        **** 
1750:main.c        ****   // Auto-naprawa Harmonogramu: Jeśli wartości są nieprawidłowe (ale nie
1751:main.c        ****   // 0xFF), ustaw na OFF
1752:main.c        ****   if ((czas_start_h > 23 && czas_start_h != 0xFF) ||
1753:main.c        ****       (czas_start_m > 59 && czas_start_m != 0xFF) ||
1754:main.c        ****       (czas_stop_h > 23 && czas_stop_h != 0xFF) ||
1755:main.c        ****       (czas_stop_m > 59 && czas_stop_m != 0xFF)) {
1756:main.c        ****     // Zapisz wartosci wylaczajace (0xFF) - BLOCKING
1757:main.c        ****     while (!eeprom_is_ready())
1758:main.c        ****       ;
1759:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_CZAS_START_H, 0xFF);
1760:main.c        ****     while (!eeprom_is_ready())
1761:main.c        ****       ;
1762:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_CZAS_START_M, 0xFF);
1763:main.c        ****     while (!eeprom_is_ready())
1764:main.c        ****       ;
1765:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_CZAS_STOP_H, 0xFF);
1766:main.c        ****     while (!eeprom_is_ready())
1767:main.c        ****       ;
1768:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_CZAS_STOP_M, 0xFF);
1769:main.c        **** 
1770:main.c        ****     czas_start_h = 0xFF;
1771:main.c        ****     czas_start_m = 0xFF;
1772:main.c        ****     czas_stop_h = 0xFF;
1773:main.c        ****     czas_stop_m = 0xFF;
1774:main.c        ****   }
1775:main.c        **** 
1776:main.c        ****   blokada_sterowania_czasowa =
1777:main.c        ****       FALSE; // Domyślnie odblokowane, zaktualizuje sie przy odczycie czasu
1778:main.c        **** 
1779:main.c        ****   // Inicjalizacja blokady systemu (START/STOP)
1780:main.c        ****   blokada_systemu =
1781:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_BLOKADA_SYSTEMU);
1782:main.c        ****   if (blokada_systemu == 0xFF) {
1783:main.c        ****     blokada_systemu = FALSE; // Domyślnie odblokowany
1784:main.c        ****   }
1785:main.c        **** 
1786:main.c        ****   // Inicjalizacja zmiennych debug SKRYBA (jesli 0xFF to wyczysc)
1787:main.c        ****   for (uint16_t addr = ADRES_EEPROM_DEBUG_SKRYBA_1;
1788:main.c        ****        addr <= ADRES_EEPROM_DEBUG_SKRYBA_5; ++addr) {
1789:main.c        ****     if (eeprom_read_byte((const uint8_t *)addr) == 0xFF) {
1790:main.c        ****       while (!eeprom_is_ready())
1791:main.c        ****         ;
1792:main.c        ****       eeprom_update_byte((uint8_t *)addr, 0);
1793:main.c        ****     }
1794:main.c        ****   }
1795:main.c        **** 
1796:main.c        ****   // Inicjalizacja zmiennych debug USER (jesli 0xFF to wyczysc)
1797:main.c        ****   for (uint16_t addr = ADRES_EEPROM_DEBUG_USER_1;
1798:main.c        ****        addr <= ADRES_EEPROM_DEBUG_USER_7; ++addr) {
1799:main.c        ****     if (eeprom_read_byte((const uint8_t *)addr) == 0xFF) {
1800:main.c        ****       while (!eeprom_is_ready())
1801:main.c        ****         ;
1802:main.c        ****       eeprom_update_byte((uint8_t *)addr, 0);
1803:main.c        ****     }
1804:main.c        ****   }
1805:main.c        **** 
1806:main.c        ****   // --- NOWE Z V7 (Ported) ---
1807:main.c        ****   // Reset blokady komend REPORT/USER po inicjalizacji/resecie
1808:main.c        ****   licznik_report_user = 0;
1809:main.c        ****   timer_report_user_100ms = 0;
1810:main.c        **** 
1811:main.c        ****   // Reset flagi wysylania SMS po resecie
1812:main.c        ****   flaga_wysylanie_smsa = 0;
1813:main.c        **** 
1814:main.c        ****   // Zwieksz licznik resetow i zapisz debug
1815:main.c        ****   static uchar licznik_resetow = 0;
1816:main.c        ****   if (licznik_resetow < 255)
1817:main.c        ****     ++licznik_resetow;
1818:main.c        ****   while (!eeprom_is_ready())
1819:main.c        ****     ;
1820:main.c        ****   eeprom_update_byte((void *)EEPROM_DEBUG_LICZNIK_RESETOW, licznik_resetow);
1821:main.c        ****   while (!eeprom_is_ready())
1822:main.c        ****     ;
1823:main.c        ****   zapisz_debug_do_eeprom(0, 2); // Reset (komenda=0 oznacza reset)
1824:main.c        **** }
1825:main.c        **** 
1826:main.c        **** static void opoznienie_startowe(void) {
 189               		.loc 1 1826 0
 190               		.cfi_startproc
 191               	/* prologue: function */
 192               	/* frame size = 0 */
 193               	/* stack size = 0 */
 194               	.L__stack_usage = 0
 195               	.LVL10:
 196               	.LBB364:
 197               	.LBB365:
 198               	.LBB366:
 199               		.file 3 "/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h"
   1:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
   6:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
   9:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  12:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      distribution.
  16:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  17:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  21:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  33:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  35:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  38:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #  endif
  42:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  44:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  48:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /** \file */
  49:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \code
  51:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \endcode
  55:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  56:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     used.
  60:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  61:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  70:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  79:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  83:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** */
  84:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  85:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif
  89:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  90:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  97:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 103:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     integer value.
 107:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****  */
 108:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif
 110:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 111:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif
 114:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 115:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif
 120:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 121:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /**
 122:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 124:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 126:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 129:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 131:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 137:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 142:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 147:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    respectively.
 151:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 152:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    \note
 153:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 154:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 164:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****  */
 165:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** void
 166:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** {
 168:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 176:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 179:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 182:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	#else
 183:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	#endif
 186:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 187:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 200               		.loc 3 187 0
 201 0098 8FEF      		ldi r24,lo8(-28673)
 202 009a 9FE8      		ldi r25,hi8(-28673)
 203 009c 0197      	1:	sbiw r24,1
 204 009e 01F4      		brne 1b
 205 00a0 00C0      		rjmp .
 206 00a2 0000      		nop
 207               	.LVL11:
 208 00a4 8FEF      		ldi r24,lo8(-28673)
 209 00a6 9FE8      		ldi r25,hi8(-28673)
 210 00a8 0197      	1:	sbiw r24,1
 211 00aa 01F4      		brne 1b
 212 00ac 00C0      		rjmp .
 213 00ae 0000      		nop
 214               	.LVL12:
 215 00b0 8FEF      		ldi r24,lo8(-28673)
 216 00b2 9FE8      		ldi r25,hi8(-28673)
 217 00b4 0197      	1:	sbiw r24,1
 218 00b6 01F4      		brne 1b
 219 00b8 00C0      		rjmp .
 220 00ba 0000      		nop
 221               	.LVL13:
 222 00bc 8FEF      		ldi r24,lo8(-28673)
 223 00be 9FE8      		ldi r25,hi8(-28673)
 224 00c0 0197      	1:	sbiw r24,1
 225 00c2 01F4      		brne 1b
 226 00c4 00C0      		rjmp .
 227 00c6 0000      		nop
 228               	.LVL14:
 229 00c8 8FEF      		ldi r24,lo8(-28673)
 230 00ca 9FE8      		ldi r25,hi8(-28673)
 231 00cc 0197      	1:	sbiw r24,1
 232 00ce 01F4      		brne 1b
 233 00d0 00C0      		rjmp .
 234 00d2 0000      		nop
 235               	.LVL15:
 236               	.LBE366:
 237               	.LBE365:
 238               	.LBE364:
1827:main.c        ****   for (uchar i = 0; i < 5; ++i)
1828:main.c        ****     _delay_ms(20);
1829:main.c        ****   wdt_reset();
 239               		.loc 1 1829 0
 240               	/* #APP */
 241               	 ;  1829 "main.c" 1
 242 00d4 A895      		wdr
 243               	 ;  0 "" 2
 244               	/* epilogue start */
1830:main.c        **** }
 245               		.loc 1 1830 0
 246               	/* #NOAPP */
 247 00d6 0895      		ret
 248               		.cfi_endproc
 249               	.LFE70:
 252               	zapisz_debug_do_eeprom:
 253               	.LFB38:
 355:main.c        ****   if (!czy_wolny_eeprom())
 254               		.loc 1 355 0
 255               		.cfi_startproc
 256               	.LVL16:
 257 00d8 CF93      		push r28
 258               	.LCFI2:
 259               		.cfi_def_cfa_offset 3
 260               		.cfi_offset 28, -2
 261 00da DF93      		push r29
 262               	.LCFI3:
 263               		.cfi_def_cfa_offset 4
 264               		.cfi_offset 29, -3
 265 00dc CDB7      		in r28,__SP_L__
 266 00de DEB7      		in r29,__SP_H__
 267               	.LCFI4:
 268               		.cfi_def_cfa_register 28
 269 00e0 2897      		sbiw r28,8
 270               	.LCFI5:
 271               		.cfi_def_cfa_offset 12
 272 00e2 0FB6      		in __tmp_reg__,__SREG__
 273 00e4 F894      		cli
 274 00e6 DEBF      		out __SP_H__,r29
 275 00e8 0FBE      		out __SREG__,__tmp_reg__
 276 00ea CDBF      		out __SP_L__,r28
 277               	/* prologue: function */
 278               	/* frame size = 8 */
 279               	/* stack size = 10 */
 280               	.L__stack_usage = 10
 356:main.c        ****     return;
 281               		.loc 1 356 0
 282 00ec 9091 0000 		lds r25,bufor_pomoc_liczba_znakow_do_zapisu
 283 00f0 9111      		cpse r25,__zero_reg__
 284 00f2 00C0      		rjmp .L17
 356:main.c        ****     return;
 285               		.loc 1 356 0 is_stmt 0 discriminator 1
 286 00f4 9091 0000 		lds r25,liczba_znakow_do_zapisu
 287 00f8 9111      		cpse r25,__zero_reg__
 288 00fa 00C0      		rjmp .L17
 356:main.c        ****     return;
 289               		.loc 1 356 0 discriminator 2
 290 00fc 9091 0000 		lds r25,czy_zajety_bufor_eeprom
 291 0100 9111      		cpse r25,__zero_reg__
 292 0102 00C0      		rjmp .L17
 356:main.c        ****     return;
 293               		.loc 1 356 0 discriminator 3
 294 0104 F999      		sbic 0x1f,1
 295 0106 00C0      		rjmp .L17
 296               	.LVL17:
 297               	.LBB370:
 298               	.LBB371:
 360:main.c        ****   buf[1] = (uchar)(timer_report_user_100ms & 0xFF);
 299               		.loc 1 360 0 is_stmt 1
 300 0108 2091 0000 		lds r18,licznik_report_user
 301 010c 2983      		std Y+1,r18
 361:main.c        ****   buf[2] = (uchar)((timer_report_user_100ms >> 8) & 0xFF);
 302               		.loc 1 361 0
 303 010e 3091 0000 		lds r19,timer_report_user_100ms
 304 0112 2091 0000 		lds r18,timer_report_user_100ms+1
 305 0116 3A83      		std Y+2,r19
 362:main.c        ****   buf[3] = (uchar)flaga_wysylanie_smsa;
 306               		.loc 1 362 0
 307 0118 2B83      		std Y+3,r18
 363:main.c        **** 
 308               		.loc 1 363 0
 309 011a 2091 0000 		lds r18,flaga_wysylanie_smsa
 310 011e 2C83      		std Y+4,r18
 311               	.LVL18:
 312 0120 E0E0      		ldi r30,lo8(komendy_kolejka)
 313 0122 F0E0      		ldi r31,hi8(komendy_kolejka)
 314               	.LVL19:
 315               	.L20:
 316               	.LBB372:
 367:main.c        ****         komendy_kolejka[i] <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
 317               		.loc 1 367 0
 318 0124 2191      		ld r18,Z+
 319               	.LVL20:
 320 0126 235D      		subi r18,lo8(-(45))
 321 0128 2230      		cpi r18,lo8(2)
 322 012a 00F4      		brsh .L19
 369:main.c        ****   }
 323               		.loc 1 369 0
 324 012c 9F5F      		subi r25,lo8(-(1))
 325               	.LVL21:
 326               	.L19:
 366:main.c        ****     if (komendy_kolejka[i] >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
 327               		.loc 1 366 0
 328 012e 20E0      		ldi r18,hi8(komendy_kolejka+30)
 329 0130 E030      		cpi r30,lo8(komendy_kolejka+30)
 330 0132 F207      		cpc r31,r18
 331 0134 01F4      		brne .L20
 332               	.LBE372:
 371:main.c        ****   buf[5] = komenda;
 333               		.loc 1 371 0
 334 0136 9D83      		std Y+5,r25
 372:main.c        ****   buf[6] = akcja;
 335               		.loc 1 372 0
 336 0138 8E83      		std Y+6,r24
 373:main.c        **** 
 337               		.loc 1 373 0
 338 013a 6F83      		std Y+7,r22
 375:main.c        **** }
 339               		.loc 1 375 0
 340 013c 47E0      		ldi r20,lo8(7)
 341 013e 62ED      		ldi r22,lo8(-46)
 342 0140 7FE0      		ldi r23,lo8(15)
 343               	.LVL22:
 344 0142 CE01      		movw r24,r28
 345               	.LVL23:
 346 0144 0196      		adiw r24,1
 347 0146 0E94 0000 		call zapisz_znaki_w_eeprom
 348               	.LVL24:
 349               	.L17:
 350               	/* epilogue start */
 351               	.LBE371:
 352               	.LBE370:
 376:main.c        **** 
 353               		.loc 1 376 0
 354 014a 2896      		adiw r28,8
 355 014c 0FB6      		in __tmp_reg__,__SREG__
 356 014e F894      		cli
 357 0150 DEBF      		out __SP_H__,r29
 358 0152 0FBE      		out __SREG__,__tmp_reg__
 359 0154 CDBF      		out __SP_L__,r28
 360 0156 DF91      		pop r29
 361 0158 CF91      		pop r28
 362 015a 0895      		ret
 363               		.cfi_endproc
 364               	.LFE38:
 366               	.global	test_dioda_wyjscia
 368               	test_dioda_wyjscia:
 369               	.LFB24:
 370               		.file 4 "test_pcb.h"
   1:test_pcb.h    **** void test_dioda_wyjscia(void)
   2:test_pcb.h    **** {
 371               		.loc 4 2 0
 372               		.cfi_startproc
 373               	/* prologue: function */
 374               	/* frame size = 0 */
 375               	/* stack size = 0 */
 376               	.L__stack_usage = 0
   3:test_pcb.h    **** 	static uchar opoznienie_1s;
   4:test_pcb.h    **** 	if ( ++opoznienie_1s < 100 )
 377               		.loc 4 4 0
 378 015c 8091 0000 		lds r24,opoznienie_1s.2970
 379 0160 8F5F      		subi r24,lo8(-(1))
 380 0162 8436      		cpi r24,lo8(100)
 381 0164 00F4      		brsh .L23
 382 0166 8093 0000 		sts opoznienie_1s.2970,r24
 383 016a 0895      		ret
 384               	.L23:
   5:test_pcb.h    **** 		return;
   6:test_pcb.h    **** 	opoznienie_1s = 0;
 385               		.loc 4 6 0
 386 016c 1092 0000 		sts opoznienie_1s.2970,__zero_reg__
   7:test_pcb.h    **** 	static uchar stan;
   8:test_pcb.h    **** 	stan = not stan;
 387               		.loc 4 8 0
 388 0170 8091 0000 		lds r24,stan.2971
 389 0174 91E0      		ldi r25,lo8(1)
 390 0176 8111      		cpse r24,__zero_reg__
 391 0178 90E0      		ldi r25,0
 392               	.L25:
 393 017a 9093 0000 		sts stan.2971,r25
   9:test_pcb.h    **** 	if ( stan )
 394               		.loc 4 9 0
 395 017e 8111      		cpse r24,__zero_reg__
 396 0180 00C0      		rjmp .L26
  10:test_pcb.h    **** 	{
  11:test_pcb.h    **** 		ustaw_stan_led(TRUE);
 397               		.loc 4 11 0 discriminator 2
 398 0182 4098      		cbi 0x8,0
 399 0184 0895      		ret
 400               	.L26:
  12:test_pcb.h    **** 	}
  13:test_pcb.h    **** 	else
  14:test_pcb.h    **** 	{
  15:test_pcb.h    **** 		ustaw_stan_led(FALSE);
 401               		.loc 4 15 0 discriminator 1
 402 0186 409A      		sbi 0x8,0
 403               	/* epilogue start */
  16:test_pcb.h    **** 	}
  17:test_pcb.h    **** }
 404               		.loc 4 17 0 discriminator 1
 405 0188 0895      		ret
 406               		.cfi_endproc
 407               	.LFE24:
 409               	.global	test_wejscie
 411               	test_wejscie:
 412               	.LFB25:
  18:test_pcb.h    **** 
  19:test_pcb.h    **** void test_wejscie(void)
  20:test_pcb.h    **** {
 413               		.loc 4 20 0
 414               		.cfi_startproc
 415               	/* prologue: function */
 416               	/* frame size = 0 */
 417               	/* stack size = 0 */
 418               	.L__stack_usage = 0
 419               	.LBB373:
 420               	.LBB374:
 421               		.file 5 "wewy.h"
   1:wewy.h        **** 
   2:wewy.h        **** #include <avr/io.h>
   3:wewy.h        **** #include "narzedzia.h"
   4:wewy.h        **** #include "konfiguracja_eeprom.h"
   5:wewy.h        **** 
   6:wewy.h        **** #define LICZBA_WEJSC	1
   7:wewy.h        **** extern uchar licznik_wejscie[LICZBA_WEJSC];
   8:wewy.h        **** 
   9:wewy.h        **** extern uchar parametry_wejscia[LICZBA_WEJSC];
  10:wewy.h        **** void kopiuj_parametry_we_wy_z_eeprom(void);
  11:wewy.h        **** 
  12:wewy.h        **** extern ulong czas_trwania_impulsu_na_wejsciu[LICZBA_WEJSC];
  13:wewy.h        **** extern ulong czas_trwania_impulsu_off_na_wejsciu[LICZBA_WEJSC];
  14:wewy.h        **** 
  15:wewy.h        **** #define STAN_LOGICZNY_NA_WEJSCIU_WYZWOLENIE	0x02
  16:wewy.h        **** #define STAN_LOGICZNY_NA_WEJSCIU_ON					0x01
  17:wewy.h        **** #define STAN_LOGICZNY_NA_WEJSCIU_OFF				0x00
  18:wewy.h        **** #define CZY_WYZWOLENIE_NA_WEJSCIU(NR_WEJ)	(stan_logiczny_na_wejsciu[NR_WEJ] & STAN_LOGICZNY_NA_WEJS
  19:wewy.h        **** #define CZY_AKTUALNY_STAN_LOGICZNY_ON(NR_WEJ)	(stan_logiczny_na_wejsciu[NR_WEJ] & STAN_LOGICZNY_NA_
  20:wewy.h        **** #define CZY_AKTUALNY_STAN_LOGICZNY_OFF(NR_WEJ)	(!CZY_AKTUALNY_STAN_LOGICZNY_ON(NR_WEJ))
  21:wewy.h        **** 
  22:wewy.h        **** extern uchar stan_logiczny_na_wejsciu[LICZBA_WEJSC];
  23:wewy.h        **** 
  24:wewy.h        **** void steruj_wejscia_10ms(void);
  25:wewy.h        **** void aktualizuj_stan_wyzwolenia_wejsc_100ms(void);
  26:wewy.h        **** void inicjalizuj_parametry_we_wy(void);
  27:wewy.h        **** 
  28:wewy.h        **** static uchar stan_wejscia(const uchar nr_wejscia) __attribute__((unused));
  29:wewy.h        **** 
  30:wewy.h        **** static uchar stan_wejscia(const uchar nr_wejscia)
  31:wewy.h        **** {
  32:wewy.h        **** 	return licznik_wejscie[nr_wejscia] & 0xf0;
 422               		.loc 5 32 0
 423 018a 8091 0000 		lds r24,licznik_wejscie
 424 018e 807F      		andi r24,lo8(-16)
 425               	.LBE374:
 426               	.LBE373:
  21:test_pcb.h    **** 	ustaw_stan_led(stan_wejscia(0));
 427               		.loc 4 21 0
 428 0190 01F4      		brne .L31
 429               		.loc 4 21 0 is_stmt 0 discriminator 1
 430 0192 409A      		sbi 0x8,0
 431 0194 0895      		ret
 432               	.L31:
 433               		.loc 4 21 0 discriminator 2
 434 0196 4098      		cbi 0x8,0
 435               	/* epilogue start */
  22:test_pcb.h    **** }
 436               		.loc 4 22 0 is_stmt 1 discriminator 2
 437 0198 0895      		ret
 438               		.cfi_endproc
 439               	.LFE25:
 441               	.global	__vector_16
 443               	__vector_16:
 444               	.LFB26:
  75:main.c        ****   if (++licznik_wybudz_watki_10MS >= OPOZNIENIE_TIMERA_0) {
 445               		.loc 1 75 0
 446               		.cfi_startproc
 447 019a 7894      		sei
 448 019c 1F92      		push r1
 449               	.LCFI6:
 450               		.cfi_def_cfa_offset 3
 451               		.cfi_offset 1, -2
 452 019e 0F92      		push r0
 453               	.LCFI7:
 454               		.cfi_def_cfa_offset 4
 455               		.cfi_offset 0, -3
 456 01a0 0FB6      		in r0,__SREG__
 457 01a2 0F92      		push r0
 458 01a4 1124      		clr __zero_reg__
 459 01a6 0BB6      		in r0,__RAMPZ__
 460 01a8 0F92      		push r0
 461 01aa 2F93      		push r18
 462               	.LCFI8:
 463               		.cfi_def_cfa_offset 5
 464               		.cfi_offset 18, -4
 465 01ac 8F93      		push r24
 466               	.LCFI9:
 467               		.cfi_def_cfa_offset 6
 468               		.cfi_offset 24, -5
 469 01ae 9F93      		push r25
 470               	.LCFI10:
 471               		.cfi_def_cfa_offset 7
 472               		.cfi_offset 25, -6
 473 01b0 EF93      		push r30
 474               	.LCFI11:
 475               		.cfi_def_cfa_offset 8
 476               		.cfi_offset 30, -7
 477 01b2 FF93      		push r31
 478               	.LCFI12:
 479               		.cfi_def_cfa_offset 9
 480               		.cfi_offset 31, -8
 481               	/* prologue: Interrupt */
 482               	/* frame size = 0 */
 483               	/* stack size = 9 */
 484               	.L__stack_usage = 9
  76:main.c        ****     licznik_wybudz_watki_10MS = 0;
 485               		.loc 1 76 0
 486 01b4 8091 0000 		lds r24,licznik_wybudz_watki_10MS
 487 01b8 8F5F      		subi r24,lo8(-(1))
 488 01ba 8093 0000 		sts licznik_wybudz_watki_10MS,r24
 489 01be 8231      		cpi r24,lo8(18)
 490 01c0 00F0      		brlo .L34
  77:main.c        ****     wykonac_watki_10MS = TRUE;
 491               		.loc 1 77 0
 492 01c2 1092 0000 		sts licznik_wybudz_watki_10MS,__zero_reg__
  78:main.c        ****   }
 493               		.loc 1 78 0
 494 01c6 8FEF      		ldi r24,lo8(-1)
 495 01c8 8093 0000 		sts wykonac_watki_10MS,r24
 496               	.L34:
  81:main.c        ****     if (!CZY_ODBIERANIE_DANYCH_SIM900() && czy_jest_bezczynny_SIM900()) {
 497               		.loc 1 81 0
 498 01cc 4F9B      		sbis 0x9,7
 499 01ce 00C0      		rjmp .L35
  82:main.c        ****       ustaw_odbior_SIM900();
 500               		.loc 1 82 0
 501 01d0 00B6      		in __tmp_reg__,0x30
 502 01d2 01FC      		sbrc __tmp_reg__,1
 503 01d4 00C0      		rjmp .L36
  82:main.c        ****       ustaw_odbior_SIM900();
 504               		.loc 1 82 0 is_stmt 0 discriminator 1
 505 01d6 8091 0000 		lds r24,komenda_SIM900
 506 01da 8111      		cpse r24,__zero_reg__
 507 01dc 00C0      		rjmp .L36
  83:main.c        ****     }
 508               		.loc 1 83 0 is_stmt 1
 509 01de 1092 0000 		sts liczba_odebranych_znakow_SIM900+1,__zero_reg__
 510 01e2 1092 0000 		sts liczba_odebranych_znakow_SIM900,__zero_reg__
 511 01e6 1092 0000 		sts licznik_opoznienie_oczekiwania_na_bajt_SIM900,__zero_reg__
 512 01ea 80B7      		in r24,0x30
 513 01ec 8260      		ori r24,lo8(2)
 514 01ee 80BF      		out 0x30,r24
 515               	/* #APP */
 516               	 ;  83 "main.c" 1
 517 01f0 F894      		cli
 518               	 ;  0 "" 2
 519               	/* #NOAPP */
 520 01f2 8091 C100 		lds r24,193
 521 01f6 8068      		ori r24,lo8(-128)
 522 01f8 8093 C100 		sts 193,r24
 523               	/* #APP */
 524               	 ;  83 "main.c" 1
 525 01fc 7894      		sei
 526               	 ;  0 "" 2
 527               	 ;  83 "main.c" 1
 528 01fe 0000      		nop
 529               	 ;  0 "" 2
 530               	/* #NOAPP */
 531 0200 4598      		cbi 0x8,5
 532               	.L36:
  85:main.c        ****       cli();
 533               		.loc 1 85 0
 534 0202 3499      		sbic 0x6,4
 535 0204 00C0      		rjmp .L37
  86:main.c        ****       if (CZY_WYSYLANIE_DANYCH_SIM900()) {
 536               		.loc 1 86 0
 537               	/* #APP */
 538               	 ;  86 "main.c" 1
 539 0206 F894      		cli
 540               	 ;  0 "" 2
  87:main.c        ****         WYLACZ_PRZERWANIE_WYSYLANIA_DANYCH_SIM900();
 541               		.loc 1 87 0
 542               	/* #NOAPP */
 543 0208 8091 C100 		lds r24,193
 544 020c 86FF      		sbrs r24,6
 545 020e 00C0      		rjmp .L38
 546               	.LBB375:
  88:main.c        ****         sei();
 547               		.loc 1 88 0
 548 0210 8091 C100 		lds r24,193
 549 0214 8F7B      		andi r24,lo8(-65)
 550 0216 8093 C100 		sts 193,r24
  89:main.c        ****         uchar p = sprawdzaj_wejscie_CTS_SIM900;
 551               		.loc 1 89 0
 552               	/* #APP */
 553               	 ;  89 "main.c" 1
 554 021a 7894      		sei
 555               	 ;  0 "" 2
  90:main.c        ****         if (p && (podlaczony_modul_gsm_SIM900 ||
 556               		.loc 1 90 0
 557               	/* #NOAPP */
 558 021c 8091 0000 		lds r24,sprawdzaj_wejscie_CTS_SIM900
 559               	.LVL25:
  91:main.c        ****                   aktualnie_wysylane_polecenie_SIM900 ==
 560               		.loc 1 91 0
 561 0220 8823      		tst r24
 562 0222 01F0      		breq .L39
  91:main.c        ****                   aktualnie_wysylane_polecenie_SIM900 ==
 563               		.loc 1 91 0 is_stmt 0 discriminator 1
 564 0224 8091 0000 		lds r24,podlaczony_modul_gsm_SIM900
 565               	.LVL26:
 566 0228 8111      		cpse r24,__zero_reg__
 567 022a 00C0      		rjmp .L40
  91:main.c        ****                   aktualnie_wysylane_polecenie_SIM900 ==
 568               		.loc 1 91 0 discriminator 2
 569 022c 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 570 0230 8C38      		cpi r24,lo8(-116)
 571 0232 01F4      		brne .L39
 572               	.L40:
 573               	.LVL27:
  95:main.c        ****           WSTAW_ZNAK_DO_BUFORA_SIM900();
 574               		.loc 1 95 0 is_stmt 1
 575 0234 1092 0000 		sts sprawdzaj_wejscie_CTS_SIM900,__zero_reg__
 576               	.LBB376:
  96:main.c        ****         }
 577               		.loc 1 96 0
 578 0238 8091 0000 		lds r24,nr_wyslanego_znaku_SIM900
 579 023c 9091 0000 		lds r25,nr_wyslanego_znaku_SIM900+1
 580               	.LVL28:
 581 0240 FC01      		movw r30,r24
 582 0242 E050      		subi r30,lo8(-(wysylany_blok_SIM900))
 583 0244 F040      		sbci r31,hi8(-(wysylany_blok_SIM900))
 584 0246 2081      		ld r18,Z
 585               	.LVL29:
 586 0248 0196      		adiw r24,1
 587               	.LVL30:
 588 024a 9093 0000 		sts nr_wyslanego_znaku_SIM900+1,r25
 589 024e 8093 0000 		sts nr_wyslanego_znaku_SIM900,r24
 590 0252 2093 C600 		sts 198,r18
 591               	.LVL31:
 592               	.L39:
 593               	.LBE376:
  98:main.c        ****         WLACZ_PRZERWANIE_WYSYLANIA_DANYCH_SIM900();
 594               		.loc 1 98 0
 595               	/* #APP */
 596               	 ;  98 "main.c" 1
 597 0256 F894      		cli
 598               	 ;  0 "" 2
  99:main.c        ****       }
 599               		.loc 1 99 0
 600               	/* #NOAPP */
 601 0258 8091 C100 		lds r24,193
 602 025c 8064      		ori r24,lo8(64)
 603 025e 8093 C100 		sts 193,r24
 604               	.L38:
 605               	.LBE375:
 101:main.c        ****     }
 606               		.loc 1 101 0
 607               	/* #APP */
 608               	 ;  101 "main.c" 1
 609 0262 7894      		sei
 610               	 ;  0 "" 2
 611               	/* #NOAPP */
 612               	.L37:
 107:main.c        ****       TRUE; // uruchamia zdarzenie_timer, ktra korzysta z pozostaych zmiennych
 613               		.loc 1 107 0
 614 0264 8FEF      		ldi r24,lo8(-1)
 615 0266 8093 0000 		sts wykonaj_zdarzenie_timer,r24
 616               	/* epilogue start */
 109:main.c        **** 
 617               		.loc 1 109 0
 618 026a FF91      		pop r31
 619 026c EF91      		pop r30
 620 026e 9F91      		pop r25
 621 0270 8F91      		pop r24
 622 0272 2F91      		pop r18
 623 0274 0F90      		pop r0
 624 0276 0BBE      		out __RAMPZ__,r0
 625 0278 0F90      		pop r0
 626 027a 0FBE      		out __SREG__,r0
 627 027c 0F90      		pop r0
 628 027e 1F90      		pop r1
 629 0280 1895      		reti
 630               	.L35:
 104:main.c        ****   }
 631               		.loc 1 104 0
 632 0282 459A      		sbi 0x8,5
 633               	/* #APP */
 634               	 ;  104 "main.c" 1
 635 0284 F894      		cli
 636               	 ;  0 "" 2
 637               	/* #NOAPP */
 638 0286 8091 C100 		lds r24,193
 639 028a 8F73      		andi r24,lo8(63)
 640 028c 8093 C100 		sts 193,r24
 641 0290 80B7      		in r24,0x30
 642 0292 8D7F      		andi r24,lo8(-3)
 643 0294 80BF      		out 0x30,r24
 644               	/* #APP */
 645               	 ;  104 "main.c" 1
 646 0296 7894      		sei
 647               	 ;  0 "" 2
 648               	 ;  104 "main.c" 1
 649 0298 0000      		nop
 650               	 ;  0 "" 2
 651               	/* #NOAPP */
 652 029a 00C0      		rjmp .L37
 653               		.cfi_endproc
 654               	.LFE26:
 656               	.global	generuj_raport_sieci
 658               	generuj_raport_sieci:
 659               	.LFB27:
 122:main.c        ****   static const char tekst_gsm[] PROGMEM = "AC800-DTM-TS";
 660               		.loc 1 122 0
 661               		.cfi_startproc
 662               	.LVL32:
 663 029c DF92      		push r13
 664               	.LCFI13:
 665               		.cfi_def_cfa_offset 3
 666               		.cfi_offset 13, -2
 667 029e EF92      		push r14
 668               	.LCFI14:
 669               		.cfi_def_cfa_offset 4
 670               		.cfi_offset 14, -3
 671 02a0 FF92      		push r15
 672               	.LCFI15:
 673               		.cfi_def_cfa_offset 5
 674               		.cfi_offset 15, -4
 675 02a2 0F93      		push r16
 676               	.LCFI16:
 677               		.cfi_def_cfa_offset 6
 678               		.cfi_offset 16, -5
 679 02a4 1F93      		push r17
 680               	.LCFI17:
 681               		.cfi_def_cfa_offset 7
 682               		.cfi_offset 17, -6
 683 02a6 CF93      		push r28
 684               	.LCFI18:
 685               		.cfi_def_cfa_offset 8
 686               		.cfi_offset 28, -7
 687 02a8 DF93      		push r29
 688               	.LCFI19:
 689               		.cfi_def_cfa_offset 9
 690               		.cfi_offset 29, -8
 691               	/* prologue: function */
 692               	/* frame size = 0 */
 693               	/* stack size = 7 */
 694               	.L__stack_usage = 7
 695 02aa 8C01      		movw r16,r24
 124:main.c        **** 
 696               		.loc 1 124 0
 697 02ac DC01      		movw r26,r24
 698 02ae ED90      		ld r14,X+
 699 02b0 FC90      		ld r15,X
 700               	.LVL33:
 126:main.c        ****   ptr += sizeof tekst_gsm - 1;
 701               		.loc 1 126 0
 702 02b2 4CE0      		ldi r20,lo8(12)
 703 02b4 50E0      		ldi r21,0
 704 02b6 60E0      		ldi r22,lo8(tekst_gsm.3002)
 705 02b8 70E0      		ldi r23,hi8(tekst_gsm.3002)
 706 02ba C701      		movw r24,r14
 707               	.LVL34:
 708 02bc 0E94 0000 		call memcpy_P
 709               	.LVL35:
 128:main.c        **** 
 710               		.loc 1 128 0
 711 02c0 E701      		movw r28,r14
 712 02c2 2D96      		adiw r28,13
 713               	.LVL36:
 714 02c4 8AE0      		ldi r24,lo8(10)
 715 02c6 D82E      		mov r13,r24
 716 02c8 F701      		movw r30,r14
 717 02ca D486      		std Z+12,r13
 130:main.c        ****   ptr += strlen((char *)ptr);
 718               		.loc 1 130 0
 719 02cc 60E0      		ldi r22,lo8(__c.3004)
 720 02ce 70E0      		ldi r23,hi8(__c.3004)
 721 02d0 CE01      		movw r24,r28
 722 02d2 0E94 0000 		call strcpy_P
 723               	.LVL37:
 131:main.c        ****   strcat((char *)ptr, rtc_czas);
 724               		.loc 1 131 0
 725               		0:
 726 02d6 0990      		ld __tmp_reg__,Y+
 727 02d8 0020      		tst __tmp_reg__
 728 02da 01F4      		brne 0b
 729               	.LVL38:
 730 02dc 2197      		sbiw r28,1
 731               	.LVL39:
 132:main.c        ****   ptr += strlen((char *)ptr);
 732               		.loc 1 132 0
 733 02de 60E0      		ldi r22,lo8(rtc_czas)
 734 02e0 70E0      		ldi r23,hi8(rtc_czas)
 735 02e2 CE01      		movw r24,r28
 736 02e4 0E94 0000 		call strcat
 737               	.LVL40:
 133:main.c        ****   *ptr++ = '\n';
 738               		.loc 1 133 0
 739               		0:
 740 02e8 0990      		ld __tmp_reg__,Y+
 741 02ea 0020      		tst __tmp_reg__
 742 02ec 01F4      		brne 0b
 743               	.LVL41:
 744 02ee 2197      		sbiw r28,1
 745               	.LVL42:
 134:main.c        **** 
 746               		.loc 1 134 0
 747 02f0 DE01      		movw r26,r28
 748 02f2 DD92      		st X+,r13
 749               	.LVL43:
 750 02f4 CD01      		movw r24,r26
 137:main.c        ****   ptr += sizeof text_sygnal - 1;
 751               		.loc 1 137 0
 752 02f6 4BE0      		ldi r20,lo8(11)
 753 02f8 50E0      		ldi r21,0
 754 02fa 60E0      		ldi r22,lo8(text_sygnal.3006)
 755 02fc 70E0      		ldi r23,hi8(text_sygnal.3006)
 756 02fe 0E94 0000 		call memcpy_P
 757               	.LVL44:
 140:main.c        ****     utoa(poziom_sieci_gsm * 100 / 31, ptr, 10);
 758               		.loc 1 140 0
 759 0302 8091 0000 		lds r24,poziom_sieci_gsm
 760 0306 8032      		cpi r24,lo8(32)
 761 0308 00F4      		brsh .L48
 140:main.c        ****     utoa(poziom_sieci_gsm * 100 / 31, ptr, 10);
 762               		.loc 1 140 0 is_stmt 0 discriminator 1
 763 030a 9091 0000 		lds r25,modul_zalogowany_w_sieci
 764 030e 9923      		tst r25
 765 0310 01F0      		breq .L48
 138:main.c        **** 
 766               		.loc 1 138 0 is_stmt 1
 767 0312 2C96      		adiw r28,12
 768               	.LVL45:
 141:main.c        ****     ptr += strlen(ptr);
 769               		.loc 1 141 0
 770 0314 B4E6      		ldi r27,lo8(100)
 771 0316 8B9F      		mul r24,r27
 772 0318 C001      		movw r24,r0
 773 031a 1124      		clr __zero_reg__
 774               	.LVL46:
 775 031c 6FE1      		ldi r22,lo8(31)
 776 031e 70E0      		ldi r23,0
 777 0320 0E94 0000 		call __divmodhi4
 778 0324 CB01      		movw r24,r22
 779               	.LBB377:
 780               	.LBB378:
 781               		.file 6 "/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h"
   1:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Copyright (c) 2004,2007 Joerg Wunsch
   3:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
   4:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Portions of documentation Copyright (c) 1990, 1991, 1993, 1994
   5:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The Regents of the University of California.
   6:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
   7:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    All rights reserved.
   8:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
   9:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Redistribution and use in source and binary forms, with or without
  10:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    modification, are permitted provided that the following conditions are met:
  11:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  12:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    * Redistributions of source code must retain the above copyright
  13:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer.
  14:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  15:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    * Redistributions in binary form must reproduce the above copyright
  16:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer in
  17:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      the documentation and/or other materials provided with the
  18:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      distribution.
  19:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  20:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    * Neither the name of the copyright holders nor the names of
  21:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      contributors may be used to endorse or promote products derived
  22:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      from this software without specific prior written permission.
  23:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  24:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  28:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  34:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   POSSIBILITY OF SUCH DAMAGE.
  35:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  36:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   $Id$
  37:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
  38:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  39:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef _STDLIB_H_
  40:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define	_STDLIB_H_ 1
  41:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  42:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ASSEMBLER__
  43:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  44:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __DOXYGEN__
  45:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define __need_NULL
  46:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define __need_size_t
  47:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define __need_wchar_t
  48:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #include <stddef.h>
  49:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  50:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ptr_t
  51:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define __ptr_t void *
  52:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  53:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif	/* !__DOXYGEN__ */
  54:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  55:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifdef __cplusplus
  56:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern "C" {
  57:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  58:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  59:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** \file */
  60:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  61:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** \defgroup avr_stdlib <stdlib.h>: General utilities
  62:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \code #include <stdlib.h> \endcode
  63:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  64:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     This file declares some basic C macros and functions as
  65:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     defined by the ISO standard, plus some AVR-specific extensions.
  66:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
  67:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  68:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /*@{*/
  69:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** Result type for function div(). */
  70:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** typedef struct {
  71:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	int quot;                   /**< The Quotient. */
  72:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	int rem;                    /**< The Remainder. */
  73:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** } div_t;
  74:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  75:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** Result type for function ldiv(). */
  76:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** typedef struct {
  77:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	long quot;                  /**< The Quotient. */
  78:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	long rem;                   /**< The Remainder. */
  79:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** } ldiv_t;
  80:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  81:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** Comparision function type for qsort(), just for convenience. */
  82:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** typedef int (*__compar_fn_t)(const void *, const void *);
  83:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  84:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __DOXYGEN__
  85:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  86:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ATTR_CONST__
  87:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # define __ATTR_CONST__ __attribute__((__const__))
  88:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  89:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  90:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ATTR_MALLOC__
  91:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # define __ATTR_MALLOC__ __attribute__((__malloc__))
  92:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  93:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  94:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ATTR_NORETURN__
  95:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # define __ATTR_NORETURN__ __attribute__((__noreturn__))
  96:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  97:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  98:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ATTR_PURE__
  99:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # define __ATTR_PURE__ __attribute__((__pure__))
 100:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 101:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 102:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef	__ATTR_GNU_INLINE__
 103:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # ifdef  __GNUC_STDC_INLINE__
 104:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__   __attribute__((__gnu_inline__))
 105:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # else
 106:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__
 107:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # endif
 108:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 109:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 110:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 111:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 112:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** The abort() function causes abnormal program termination to occur.
 113:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     This realization disables interrupts and jumps to _exit() function
 114:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     with argument equal to 1. In the limited AVR environment, execution is
 115:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     effectively halted by entering an infinite loop. */
 116:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void abort(void) __ATTR_NORETURN__;
 117:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 118:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** The abs() function computes the absolute value of the integer \c i.
 119:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 120:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 121:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern int abs(int __i) __ATTR_CONST__;
 122:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 123:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define	abs(__i) __builtin_abs(__i)
 124:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 125:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 126:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** The labs() function computes the absolute value of the long integer
 127:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c i.
 128:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 129:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 130:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern long labs(long __i) __ATTR_CONST__;
 131:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 132:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define labs(__i) __builtin_labs(__i)
 133:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 134:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 135:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 136:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The bsearch() function searches an array of \c nmemb objects, the
 137:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      initial member of which is pointed to by \c base, for a member
 138:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      that matches the object pointed to by \c key.  The size of each
 139:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      member of the array is specified by \c size.
 140:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 141:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The contents of the array should be in ascending sorted order
 142:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      according to the comparison function referenced by \c compar.
 143:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The \c compar routine is expected to have two arguments which
 144:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      point to the key object and to an array member, in that order,
 145:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      and should return an integer less than, equal to, or greater than
 146:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      zero if the key object is found, respectively, to be less than,
 147:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      to match, or be greater than the array member.
 148:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 149:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The bsearch() function returns a pointer to a matching member of
 150:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      the array, or a null pointer if no match is found.  If two
 151:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      members compare as equal, which member is matched is unspecified.
 152:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 153:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void *bsearch(const void *__key, const void *__base, size_t __nmemb,
 154:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 		     size_t __size, int (*__compar)(const void *, const void *));
 155:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 156:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /* __divmodhi4 and __divmodsi4 from libgcc.a */
 157:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 158:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The div() function computes the value \c num/denom and returns
 159:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c div_t that
 160:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      contains two int members named \c quot and \c rem.
 161:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 162:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern div_t div(int __num, int __denom) __asm__("__divmodhi4") __ATTR_CONST__;
 163:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 164:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The ldiv() function computes the value \c num/denom and returns
 165:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c ldiv_t that
 166:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      contains two long integer members named \c quot and \c rem.
 167:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 168:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern ldiv_t ldiv(long __num, long __denom) __asm__("__divmodsi4") __ATTR_CONST__;
 169:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 170:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 171:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The qsort() function is a modified partition-exchange sort, or
 172:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      quicksort.
 173:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 174:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The qsort() function sorts an array of \c nmemb objects, the
 175:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      initial member of which is pointed to by \c base.  The size of
 176:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      each object is specified by \c size.  The contents of the array
 177:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      base are sorted in ascending order according to a comparison
 178:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      function pointed to by \c compar, which requires two arguments
 179:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      pointing to the objects being compared.
 180:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 181:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The comparison function must return an integer less than, equal
 182:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      to, or greater than zero if the first argument is considered to
 183:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      be respectively less than, equal to, or greater than the second.
 184:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 185:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void qsort(void *__base, size_t __nmemb, size_t __size,
 186:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 		  __compar_fn_t __compar);
 187:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 188:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 189:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The strtol() function converts the string in \c nptr to a long
 190:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     value.  The conversion is done according to the given base, which
 191:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     must be between 2 and 36 inclusive, or be the special value 0.
 192:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 193:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 194:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 195:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 196:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 197:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 198:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 199:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 200:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The remainder of the string is converted to a long value in the
 201:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     obvious manner, stopping at the first character which is not a
 202:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     valid digit in the given base.  (In bases above 10, the letter \c 'A'
 203:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     in either upper or lower case represents 10, \c 'B' represents 11,
 204:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     and so forth, with \c 'Z' representing 35.)
 205:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 206:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     If \c endptr is not NULL, strtol() stores the address of the first
 207:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 208:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     however, strtol() stores the original value of \c nptr in \c
 209:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 210:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     on return, the entire string was valid.)
 211:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 212:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The strtol() function returns the result of the conversion, unless
 213:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     the value would underflow or overflow.  If no conversion could be
 214:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     performed, 0 is returned.  If an overflow or underflow occurs, \c
 215:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE" and the function return value
 216:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     is clamped to \c LONG_MIN or \c LONG_MAX, respectively.
 217:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 218:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern long strtol(const char *__nptr, char **__endptr, int __base);
 219:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 220:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 221:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The strtoul() function converts the string in \c nptr to an
 222:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     unsigned long value.  The conversion is done according to the
 223:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     given base, which must be between 2 and 36 inclusive, or be the
 224:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     special value 0.
 225:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 226:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 227:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 228:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 229:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 230:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 231:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 232:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 233:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The remainder of the string is converted to an unsigned long value
 234:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     in the obvious manner, stopping at the first character which is
 235:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     not a valid digit in the given base.  (In bases above 10, the
 236:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     letter \c 'A' in either upper or lower case represents 10, \c 'B'
 237:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     represents 11, and so forth, with \c 'Z' representing 35.)
 238:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 239:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     If \c endptr is not NULL, strtoul() stores the address of the first
 240:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 241:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     however, strtoul() stores the original value of \c nptr in \c
 242:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 243:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     on return, the entire string was valid.)
 244:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 245:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The strtoul() function return either the result of the conversion
 246:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     or, if there was a leading minus sign, the negation of the result
 247:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     of the conversion, unless the original (non-negated) value would
 248:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     overflow; in the latter case, strtoul() returns ULONG_MAX, and \c
 249:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE".  If no conversion could 
 250:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     be performed, 0 is returned.
 251:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 252:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern unsigned long strtoul(const char *__nptr, char **__endptr, int __base);
 253:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 254:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 255:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The atol() function converts the initial portion of the string
 256:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     pointed to by \p s to long integer representation. In contrast to
 257:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 258:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****         \code strtol(s, (char **)NULL, 10); \endcode
 259:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 260:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 261:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 262:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     stack) and works more quickly.
 263:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 264:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern long atol(const char *__s) __ATTR_PURE__;
 265:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 266:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 267:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The atoi() function converts the initial portion of the string
 268:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     pointed to by \p s to integer representation. In contrast to
 269:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 270:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****         \code (int)strtol(s, (char **)NULL, 10); \endcode
 271:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 272:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 273:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 274:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     stack) and works more quickly.
 275:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 276:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern int atoi(const char *__s) __ATTR_PURE__;
 277:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 278:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 279:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The exit() function terminates the application.  Since there is no
 280:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    environment to return to, \c status is ignored, and code execution
 281:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    will eventually reach an infinite loop, thereby effectively halting
 282:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    all code processing.  Before entering the infinite loop, interrupts
 283:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    are globally disabled.
 284:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 285:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    In a C++ context, global destructors will be called before halting
 286:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    execution.
 287:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 288:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void exit(int __status) __ATTR_NORETURN__;
 289:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 290:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 291:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The malloc() function allocates \c size bytes of memory.
 292:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    If malloc() fails, a NULL pointer is returned.
 293:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 294:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Note that malloc() does \e not initialize the returned memory to
 295:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    zero bytes.
 296:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 297:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    See the chapter about \ref malloc "malloc() usage" for implementation
 298:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    details.
 299:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 300:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void *malloc(size_t __size) __ATTR_MALLOC__;
 301:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 302:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 303:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The free() function causes the allocated memory referenced by \c
 304:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    ptr to be made available for future allocations.  If \c ptr is
 305:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    NULL, no action occurs.
 306:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 307:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void free(void *__ptr);
 308:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 309:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 310:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 311:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 312:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern size_t __malloc_margin;
 313:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 314:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 315:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 316:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 317:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *__malloc_heap_start;
 318:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 319:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 320:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 321:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 322:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *__malloc_heap_end;
 323:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 324:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 325:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Allocate \c nele elements of \c size each.  Identical to calling
 326:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c malloc() using <tt>nele * size</tt> as argument, except the
 327:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    allocated memory will be cleared to zero.
 328:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 329:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void *calloc(size_t __nele, size_t __size) __ATTR_MALLOC__;
 330:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 331:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 332:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The realloc() function tries to change the size of the region
 333:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    allocated at \c ptr to the new \c size value.  It returns a
 334:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    pointer to the new region.  The returned pointer might be the
 335:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    same as the old pointer, or a pointer to a completely different
 336:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    region.
 337:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 338:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The contents of the returned region up to either the old or the new
 339:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    size value (whatever is less) will be identical to the contents of
 340:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    the old region, even in case a new region had to be allocated.
 341:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 342:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    It is acceptable to pass \c ptr as NULL, in which case realloc()
 343:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    will behave identical to malloc().
 344:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 345:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    If the new memory cannot be allocated, realloc() returns NULL, and
 346:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    the region at \c ptr will not be changed.
 347:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 348:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void *realloc(void *__ptr, size_t __size) __ATTR_MALLOC__;
 349:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 350:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern double strtod(const char *__nptr, char **__endptr);
 351:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 352:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** \ingroup avr_stdlib
 353:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \fn  double atof (const char *nptr)
 354:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 355:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The atof() function converts the initial portion of the string pointed
 356:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     to by \a nptr to double representation.
 357:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 358:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     It is equivalent to calling
 359:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	\code strtod(nptr, (char **)0); \endcode
 360:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  */
 361:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern double atof(const char *__nptr);
 362:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 363:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** Highest number that can be generated by rand(). */
 364:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define	RAND_MAX 0x7FFF
 365:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 366:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 367:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The rand() function computes a sequence of pseudo-random integers in the
 368:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      range of 0 to \c RAND_MAX (as defined by the header file <stdlib.h>).
 369:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 370:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The srand() function sets its argument \c seed as the seed for a new
 371:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      sequence of pseudo-random numbers to be returned by rand().  These
 372:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      sequences are repeatable by calling srand() with the same seed value.
 373:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 374:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      If no seed value is provided, the functions are automatically seeded with
 375:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      a value of 1.
 376:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 377:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      In compliance with the C standard, these functions operate on
 378:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      \c int arguments.  Since the underlying algorithm already uses
 379:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      32-bit calculations, this causes a loss of precision.  See
 380:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      \c random() for an alternate set of functions that retains full
 381:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      32-bit precision.
 382:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 383:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern int rand(void);
 384:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 385:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Pseudo-random number generator seeding; see rand().
 386:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 387:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void srand(unsigned int __seed);
 388:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 389:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 390:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Variant of rand() that stores the context in the user-supplied
 391:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    variable located at \c ctx instead of a static library variable
 392:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    so the function becomes re-entrant.
 393:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 394:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern int rand_r(unsigned long *__ctx);
 395:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /*@}*/
 396:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 397:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /*@{*/
 398:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** \name Non-standard (i.e. non-ISO C) functions.
 399:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  \ingroup avr_stdlib
 400:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 401:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 402:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \brief Convert an integer to a string.
 403:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 404:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The function itoa() converts the integer value from \c val into an
 405:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 406:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 407:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 408:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 409:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 410:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (int) + 1 characters, i.e. one
 411:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 412:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 413:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 414:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 415:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 416:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 417:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 418:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 419:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c 'a'.
 420:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     
 421:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     If radix is 10 and val is negative, a minus sign will be prepended.
 422:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 423:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The itoa() function returns the pointer passed as \c s.
 424:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 425:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 426:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *itoa(int val, char *s, int radix);
 427:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #else
 428:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 429:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** char *itoa (int __val, char *__s, int __radix)
 430:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** {
 431:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 432:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__itoa (int, char *, int);
 433:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __itoa (__val, __s, __radix);
 434:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 435:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	*__s = 0;
 436:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __s;
 437:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else {
 438:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__itoa_ncheck (int, char *, unsigned char);
 439:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __itoa_ncheck (__val, __s, __radix);
 440:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     }
 441:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** }
 442:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 443:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 444:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 445:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  \ingroup avr_stdlib
 446:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  
 447:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \brief Convert a long integer to a string.
 448:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 449:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The function ltoa() converts the long integer value from \c val into an
 450:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 451:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 452:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 453:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 454:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 455:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (long int) + 1 characters, i.e. one
 456:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 457:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 458:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 459:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 460:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 461:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 462:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 463:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 464:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c 'a'.
 465:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 466:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    If radix is 10 and val is negative, a minus sign will be prepended.
 467:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 468:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The ltoa() function returns the pointer passed as \c s.
 469:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 470:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 471:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *ltoa(long val, char *s, int radix);
 472:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #else
 473:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 474:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** char *ltoa (long __val, char *__s, int __radix)
 475:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** {
 476:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 477:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__ltoa (long, char *, int);
 478:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __ltoa (__val, __s, __radix);
 479:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 480:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	*__s = 0;
 481:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __s;
 482:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else {
 483:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__ltoa_ncheck (long, char *, unsigned char);
 484:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __ltoa_ncheck (__val, __s, __radix);
 485:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     }
 486:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** }
 487:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 488:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 489:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 490:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  \ingroup avr_stdlib
 491:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 492:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \brief Convert an unsigned integer to a string.
 493:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 494:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The function utoa() converts the unsigned integer value from \c val into an
 495:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 496:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 497:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 498:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 499:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 500:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (unsigned int) + 1 characters, i.e. one
 501:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 502:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 503:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 504:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 505:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 506:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 507:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 508:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 509:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c 'a'.
 510:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 511:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The utoa() function returns the pointer passed as \c s.
 512:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 513:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 514:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *utoa(unsigned int val, char *s, int radix);
 515:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #else
 516:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 517:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** char *utoa (unsigned int __val, char *__s, int __radix)
 518:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** {
 519:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 520:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__utoa (unsigned int, char *, int);
 521:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __utoa (__val, __s, __radix);
 522:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 523:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	*__s = 0;
 524:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __s;
 525:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else {
 526:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__utoa_ncheck (unsigned int, char *, unsigned char);
 527:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __utoa_ncheck (__val, __s, __radix);
 782               		.loc 6 527 0
 783 0326 4AE0      		ldi r20,lo8(10)
 784 0328 BE01      		movw r22,r28
 785 032a 0E94 0000 		call __utoa_ncheck
 786               	.LVL47:
 787               	.LBE378:
 788               	.LBE377:
 142:main.c        ****     *ptr++ = '%';
 789               		.loc 1 142 0
 790               		0:
 791 032e 0990      		ld __tmp_reg__,Y+
 792 0330 0020      		tst __tmp_reg__
 793 0332 01F4      		brne 0b
 794               	.LVL48:
 795 0334 2197      		sbiw r28,1
 796               	.LVL49:
 143:main.c        ****   } else {
 797               		.loc 1 143 0
 798 0336 FE01      		movw r30,r28
 799 0338 3196      		adiw r30,1
 800               	.LVL50:
 801 033a 85E2      		ldi r24,lo8(37)
 802 033c 8883      		st Y,r24
 803               	.L49:
 149:main.c        ****   *buf_sms = ptr;
 804               		.loc 1 149 0
 805 033e 1082      		st Z,__zero_reg__
 150:main.c        **** }
 806               		.loc 1 150 0
 807 0340 D801      		movw r26,r16
 808 0342 ED93      		st X+,r30
 809 0344 FC93      		st X,r31
 810               	/* epilogue start */
 151:main.c        **** 
 811               		.loc 1 151 0
 812 0346 DF91      		pop r29
 813 0348 CF91      		pop r28
 814 034a 1F91      		pop r17
 815 034c 0F91      		pop r16
 816               	.LVL51:
 817 034e FF90      		pop r15
 818 0350 EF90      		pop r14
 819 0352 DF90      		pop r13
 820 0354 0895      		ret
 821               	.LVL52:
 822               	.L48:
 145:main.c        ****     *ptr++ = '-';
 823               		.loc 1 145 0
 824 0356 8DE2      		ldi r24,lo8(45)
 825 0358 8C87      		std Y+12,r24
 826               	.LVL53:
 146:main.c        ****     *ptr++ = '-';
 827               		.loc 1 146 0
 828 035a 8D87      		std Y+13,r24
 147:main.c        ****   }
 829               		.loc 1 147 0
 830 035c FE01      		movw r30,r28
 831 035e 3F96      		adiw r30,15
 832               	.LVL54:
 833 0360 8E87      		std Y+14,r24
 834 0362 00C0      		rjmp .L49
 835               		.cfi_endproc
 836               	.LFE27:
 838               	.global	generuj_raport_uzytkownikow_1
 840               	generuj_raport_uzytkownikow_1:
 841               	.LFB28:
 153:main.c        ****   static const char tekst_gsm[] PROGMEM = "Uzytkownicy ";
 842               		.loc 1 153 0
 843               		.cfi_startproc
 844               	.LVL55:
 845 0364 AF92      		push r10
 846               	.LCFI20:
 847               		.cfi_def_cfa_offset 3
 848               		.cfi_offset 10, -2
 849 0366 BF92      		push r11
 850               	.LCFI21:
 851               		.cfi_def_cfa_offset 4
 852               		.cfi_offset 11, -3
 853 0368 CF92      		push r12
 854               	.LCFI22:
 855               		.cfi_def_cfa_offset 5
 856               		.cfi_offset 12, -4
 857 036a DF92      		push r13
 858               	.LCFI23:
 859               		.cfi_def_cfa_offset 6
 860               		.cfi_offset 13, -5
 861 036c EF92      		push r14
 862               	.LCFI24:
 863               		.cfi_def_cfa_offset 7
 864               		.cfi_offset 14, -6
 865 036e FF92      		push r15
 866               	.LCFI25:
 867               		.cfi_def_cfa_offset 8
 868               		.cfi_offset 15, -7
 869 0370 0F93      		push r16
 870               	.LCFI26:
 871               		.cfi_def_cfa_offset 9
 872               		.cfi_offset 16, -8
 873 0372 1F93      		push r17
 874               	.LCFI27:
 875               		.cfi_def_cfa_offset 10
 876               		.cfi_offset 17, -9
 877 0374 CF93      		push r28
 878               	.LCFI28:
 879               		.cfi_def_cfa_offset 11
 880               		.cfi_offset 28, -10
 881 0376 DF93      		push r29
 882               	.LCFI29:
 883               		.cfi_def_cfa_offset 12
 884               		.cfi_offset 29, -11
 885               	/* prologue: function */
 886               	/* frame size = 0 */
 887               	/* stack size = 10 */
 888               	.L__stack_usage = 10
 889 0378 8C01      		movw r16,r24
 155:main.c        **** 
 890               		.loc 1 155 0
 891 037a FC01      		movw r30,r24
 892 037c C081      		ld r28,Z
 893 037e D181      		ldd r29,Z+1
 894               	.LVL56:
 157:main.c        ****   ptr += sizeof tekst_gsm - 1;
 895               		.loc 1 157 0
 896 0380 4CE0      		ldi r20,lo8(12)
 897 0382 50E0      		ldi r21,0
 898 0384 60E0      		ldi r22,lo8(tekst_gsm.3010)
 899 0386 70E0      		ldi r23,hi8(tekst_gsm.3010)
 900 0388 CE01      		movw r24,r28
 901               	.LVL57:
 902 038a 0E94 0000 		call memcpy_P
 903               	.LVL58:
 158:main.c        ****   uint aktywne_numery = 0;
 904               		.loc 1 158 0
 905 038e 2C96      		adiw r28,12
 906               	.LVL59:
 907 0390 88E0      		ldi r24,lo8(8)
 908 0392 C82E      		mov r12,r24
 909 0394 D12C      		mov r13,__zero_reg__
 160:main.c        ****   // for (uchar nr_uzyt_clip = 0; nr_uzyt_clip <
 910               		.loc 1 160 0
 911 0396 F12C      		mov r15,__zero_reg__
 912 0398 E12C      		mov r14,__zero_reg__
 159:main.c        ****   uint wolne_numery = 0;
 913               		.loc 1 159 0
 914 039a B12C      		mov r11,__zero_reg__
 915 039c A12C      		mov r10,__zero_reg__
 916               	.LVL60:
 917               	.L56:
 918               	.LBB379:
 165:main.c        ****       ++aktywne_numery;
 919               		.loc 1 165 0
 920 039e C601      		movw r24,r12
 921 03a0 0E94 0000 		call eeprom_read_byte
 922               	.LVL61:
 923 03a4 8F3F      		cpi r24,lo8(-1)
 924 03a6 01F0      		breq .L54
 166:main.c        ****     else
 925               		.loc 1 166 0
 926 03a8 FFEF      		ldi r31,-1
 927 03aa AF1A      		sub r10,r31
 928 03ac BF0A      		sbc r11,r31
 929               	.LVL62:
 930               	.L55:
 931 03ae E5E0      		ldi r30,5
 932 03b0 CE0E      		add r12,r30
 933 03b2 D11C      		adc r13,__zero_reg__
 163:main.c        ****        ++nr_uzyt_clip) {
 934               		.loc 1 163 0
 935 03b4 F8EA      		ldi r31,-88
 936 03b6 CF16      		cp r12,r31
 937 03b8 FFE0      		ldi r31,15
 938 03ba DF06      		cpc r13,r31
 939 03bc 01F4      		brne .L56
 940               	.LVL63:
 941               	.LBE379:
 942               	.LBB380:
 943               	.LBB381:
 944               		.loc 6 527 0
 945 03be 4AE0      		ldi r20,lo8(10)
 946 03c0 BE01      		movw r22,r28
 947 03c2 C501      		movw r24,r10
 948 03c4 0E94 0000 		call __utoa_ncheck
 949               	.LVL64:
 950               	.LBE381:
 951               	.LBE380:
 172:main.c        ****   *ptr++ = '/';
 952               		.loc 1 172 0
 953               		0:
 954 03c8 0990      		ld __tmp_reg__,Y+
 955 03ca 0020      		tst __tmp_reg__
 956 03cc 01F4      		brne 0b
 957               	.LVL65:
 958 03ce 2197      		sbiw r28,1
 959               	.LVL66:
 173:main.c        ****   utoa(wolne_numery, ptr, 10);
 960               		.loc 1 173 0
 961 03d0 6E01      		movw r12,r28
 962 03d2 8FEF      		ldi r24,-1
 963 03d4 C81A      		sub r12,r24
 964 03d6 D80A      		sbc r13,r24
 965               	.LVL67:
 966 03d8 8FE2      		ldi r24,lo8(47)
 967 03da 8883      		st Y,r24
 968               	.LVL68:
 969               	.LBB382:
 970               	.LBB383:
 971               		.loc 6 527 0
 972 03dc 4AE0      		ldi r20,lo8(10)
 973 03de B601      		movw r22,r12
 974 03e0 C701      		movw r24,r14
 975 03e2 0E94 0000 		call __utoa_ncheck
 976               	.LVL69:
 977               	.LBE383:
 978               	.LBE382:
 175:main.c        ****   *buf_sms = ptr;
 979               		.loc 1 175 0
 980 03e6 F601      		movw r30,r12
 981               		0:
 982 03e8 0190      		ld __tmp_reg__,Z+
 983 03ea 0020      		tst __tmp_reg__
 984 03ec 01F4      		brne 0b
 985 03ee CF01      		movw r24,r30
 986               	.LVL70:
 987 03f0 0197      		sbiw r24,1
 988               	.LVL71:
 176:main.c        **** }
 989               		.loc 1 176 0
 990 03f2 F801      		movw r30,r16
 991               	.LVL72:
 992 03f4 9183      		std Z+1,r25
 993 03f6 8083      		st Z,r24
 994               	/* epilogue start */
 177:main.c        **** 
 995               		.loc 1 177 0
 996 03f8 DF91      		pop r29
 997 03fa CF91      		pop r28
 998 03fc 1F91      		pop r17
 999 03fe 0F91      		pop r16
 1000               	.LVL73:
 1001 0400 FF90      		pop r15
 1002 0402 EF90      		pop r14
 1003               	.LVL74:
 1004 0404 DF90      		pop r13
 1005 0406 CF90      		pop r12
 1006               	.LVL75:
 1007 0408 BF90      		pop r11
 1008 040a AF90      		pop r10
 1009               	.LVL76:
 1010 040c 0895      		ret
 1011               	.LVL77:
 1012               	.L54:
 1013               	.LBB384:
 168:main.c        ****   }
 1014               		.loc 1 168 0
 1015 040e 8FEF      		ldi r24,-1
 1016 0410 E81A      		sub r14,r24
 1017 0412 F80A      		sbc r15,r24
 1018               	.LVL78:
 1019 0414 00C0      		rjmp .L55
 1020               	.LBE384:
 1021               		.cfi_endproc
 1022               	.LFE28:
 1024               	.global	generuj_raport_uzytkownikow
 1026               	generuj_raport_uzytkownikow:
 1027               	.LFB29:
 179:main.c        ****   static const char tekst_gsm[] PROGMEM = "Uzytkownicy ";
 1028               		.loc 1 179 0
 1029               		.cfi_startproc
 1030               	.LVL79:
 1031 0416 CF92      		push r12
 1032               	.LCFI30:
 1033               		.cfi_def_cfa_offset 3
 1034               		.cfi_offset 12, -2
 1035 0418 DF92      		push r13
 1036               	.LCFI31:
 1037               		.cfi_def_cfa_offset 4
 1038               		.cfi_offset 13, -3
 1039 041a EF92      		push r14
 1040               	.LCFI32:
 1041               		.cfi_def_cfa_offset 5
 1042               		.cfi_offset 14, -4
 1043 041c FF92      		push r15
 1044               	.LCFI33:
 1045               		.cfi_def_cfa_offset 6
 1046               		.cfi_offset 15, -5
 1047 041e 0F93      		push r16
 1048               	.LCFI34:
 1049               		.cfi_def_cfa_offset 7
 1050               		.cfi_offset 16, -6
 1051 0420 1F93      		push r17
 1052               	.LCFI35:
 1053               		.cfi_def_cfa_offset 8
 1054               		.cfi_offset 17, -7
 1055 0422 CF93      		push r28
 1056               	.LCFI36:
 1057               		.cfi_def_cfa_offset 9
 1058               		.cfi_offset 28, -8
 1059 0424 DF93      		push r29
 1060               	.LCFI37:
 1061               		.cfi_def_cfa_offset 10
 1062               		.cfi_offset 29, -9
 1063               	/* prologue: function */
 1064               	/* frame size = 0 */
 1065               	/* stack size = 8 */
 1066               	.L__stack_usage = 8
 1067 0426 8C01      		movw r16,r24
 181:main.c        **** 
 1068               		.loc 1 181 0
 1069 0428 FC01      		movw r30,r24
 1070 042a C081      		ld r28,Z
 1071 042c D181      		ldd r29,Z+1
 1072               	.LVL80:
 183:main.c        ****   ptr += sizeof tekst_gsm - 1;
 1073               		.loc 1 183 0
 1074 042e 4CE0      		ldi r20,lo8(12)
 1075 0430 50E0      		ldi r21,0
 1076 0432 60E0      		ldi r22,lo8(tekst_gsm.3021)
 1077 0434 70E0      		ldi r23,hi8(tekst_gsm.3021)
 1078 0436 CE01      		movw r24,r28
 1079               	.LVL81:
 1080 0438 0E94 0000 		call memcpy_P
 1081               	.LVL82:
 184:main.c        ****   uchar aktywne_numery = 0;
 1082               		.loc 1 184 0
 1083 043c 2C96      		adiw r28,12
 1084               	.LVL83:
 1085 043e 88E0      		ldi r24,lo8(8)
 1086 0440 E82E      		mov r14,r24
 1087 0442 F12C      		mov r15,__zero_reg__
 186:main.c        ****   for (uint nr_uzyt_clip = 0; nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 1088               		.loc 1 186 0
 1089 0444 D12C      		mov r13,__zero_reg__
 185:main.c        ****   uchar wolne_numery = 0;
 1090               		.loc 1 185 0
 1091 0446 C12C      		mov r12,__zero_reg__
 1092               	.LVL84:
 1093               	.L61:
 1094               	.LBB385:
 189:main.c        ****       ++aktywne_numery;
 1095               		.loc 1 189 0
 1096 0448 C701      		movw r24,r14
 1097 044a 0E94 0000 		call eeprom_read_byte
 1098               	.LVL85:
 1099 044e 8F3F      		cpi r24,lo8(-1)
 1100 0450 01F0      		breq .L59
 190:main.c        ****     else
 1101               		.loc 1 190 0
 1102 0452 C394      		inc r12
 1103               	.LVL86:
 1104               	.L60:
 1105 0454 F5E0      		ldi r31,5
 1106 0456 EF0E      		add r14,r31
 1107 0458 F11C      		adc r15,__zero_reg__
 187:main.c        ****        ++nr_uzyt_clip) {
 1108               		.loc 1 187 0
 1109 045a 88EA      		ldi r24,-88
 1110 045c E816      		cp r14,r24
 1111 045e 8FE0      		ldi r24,15
 1112 0460 F806      		cpc r15,r24
 1113 0462 01F4      		brne .L61
 1114               	.LVL87:
 1115               	.LBE385:
 1116               	.LBB386:
 1117               	.LBB387:
 1118               		.loc 6 527 0
 1119 0464 4AE0      		ldi r20,lo8(10)
 1120 0466 BE01      		movw r22,r28
 1121 0468 8C2D      		mov r24,r12
 1122 046a 90E0      		ldi r25,0
 1123 046c 0E94 0000 		call __utoa_ncheck
 1124               	.LVL88:
 1125               	.LBE387:
 1126               	.LBE386:
 195:main.c        ****   *ptr++ = '/';
 1127               		.loc 1 195 0
 1128               		0:
 1129 0470 0990      		ld __tmp_reg__,Y+
 1130 0472 0020      		tst __tmp_reg__
 1131 0474 01F4      		brne 0b
 1132               	.LVL89:
 1133 0476 2197      		sbiw r28,1
 1134               	.LVL90:
 196:main.c        ****   utoa(wolne_numery, ptr, 10);
 1135               		.loc 1 196 0
 1136 0478 7E01      		movw r14,r28
 1137 047a EFEF      		ldi r30,-1
 1138 047c EE1A      		sub r14,r30
 1139 047e FE0A      		sbc r15,r30
 1140               	.LVL91:
 1141 0480 8FE2      		ldi r24,lo8(47)
 1142 0482 8883      		st Y,r24
 1143               	.LVL92:
 1144               	.LBB388:
 1145               	.LBB389:
 1146               		.loc 6 527 0
 1147 0484 4AE0      		ldi r20,lo8(10)
 1148 0486 B701      		movw r22,r14
 1149 0488 8D2D      		mov r24,r13
 1150 048a 90E0      		ldi r25,0
 1151 048c 0E94 0000 		call __utoa_ncheck
 1152               	.LVL93:
 1153               	.LBE389:
 1154               	.LBE388:
 198:main.c        ****   *buf_sms = ptr;
 1155               		.loc 1 198 0
 1156 0490 F701      		movw r30,r14
 1157               		0:
 1158 0492 0190      		ld __tmp_reg__,Z+
 1159 0494 0020      		tst __tmp_reg__
 1160 0496 01F4      		brne 0b
 1161 0498 CF01      		movw r24,r30
 1162               	.LVL94:
 1163 049a 0197      		sbiw r24,1
 1164               	.LVL95:
 199:main.c        **** }
 1165               		.loc 1 199 0
 1166 049c F801      		movw r30,r16
 1167               	.LVL96:
 1168 049e 9183      		std Z+1,r25
 1169 04a0 8083      		st Z,r24
 1170               	/* epilogue start */
 200:main.c        **** 
 1171               		.loc 1 200 0
 1172 04a2 DF91      		pop r29
 1173 04a4 CF91      		pop r28
 1174 04a6 1F91      		pop r17
 1175 04a8 0F91      		pop r16
 1176               	.LVL97:
 1177 04aa FF90      		pop r15
 1178 04ac EF90      		pop r14
 1179               	.LVL98:
 1180 04ae DF90      		pop r13
 1181               	.LVL99:
 1182 04b0 CF90      		pop r12
 1183               	.LVL100:
 1184 04b2 0895      		ret
 1185               	.LVL101:
 1186               	.L59:
 1187               	.LBB390:
 192:main.c        ****   }
 1188               		.loc 1 192 0
 1189 04b4 D394      		inc r13
 1190               	.LVL102:
 1191 04b6 00C0      		rjmp .L60
 1192               	.LBE390:
 1193               		.cfi_endproc
 1194               	.LFE29:
 1196               		.section	.rodata.str1.1,"aMS",@progbits,1
 1197               	.LC0:
 1198 0000 4861 726D 		.string	"Harmonogram: %02d:%02d %02d:%02d"
 1198      6F6E 6F67 
 1198      7261 6D3A 
 1198      2025 3032 
 1198      643A 2530 
 1199               		.text
 1200               	.global	generuj_raport_stanu_urzadzenia
 1202               	generuj_raport_stanu_urzadzenia:
 1203               	.LFB30:
 205:main.c        ****   uchar *sms = (char *)tekst_wysylanego_smsa;
 1204               		.loc 1 205 0
 1205               		.cfi_startproc
 1206 04b8 1F93      		push r17
 1207               	.LCFI38:
 1208               		.cfi_def_cfa_offset 3
 1209               		.cfi_offset 17, -2
 1210 04ba CF93      		push r28
 1211               	.LCFI39:
 1212               		.cfi_def_cfa_offset 4
 1213               		.cfi_offset 28, -3
 1214 04bc DF93      		push r29
 1215               	.LCFI40:
 1216               		.cfi_def_cfa_offset 5
 1217               		.cfi_offset 29, -4
 1218 04be 00D0      		rcall .
 1219               	.LCFI41:
 1220               		.cfi_def_cfa_offset 7
 1221 04c0 CDB7      		in r28,__SP_L__
 1222 04c2 DEB7      		in r29,__SP_H__
 1223               	.LCFI42:
 1224               		.cfi_def_cfa_register 28
 1225               	/* prologue: function */
 1226               	/* frame size = 2 */
 1227               	/* stack size = 5 */
 1228               	.L__stack_usage = 5
 207:main.c        ****   *sms++ = '\n';
 1229               		.loc 1 207 0
 1230 04c4 8AE2      		ldi r24,lo8(42)
 1231 04c6 8093 0000 		sts tekst_wysylanego_smsa,r24
 208:main.c        ****   generuj_raport_sieci(&sms);
 1232               		.loc 1 208 0
 1233 04ca 80E0      		ldi r24,lo8(tekst_wysylanego_smsa+2)
 1234 04cc 90E0      		ldi r25,hi8(tekst_wysylanego_smsa+2)
 1235 04ce 9A83      		std Y+2,r25
 1236 04d0 8983      		std Y+1,r24
 1237 04d2 1AE0      		ldi r17,lo8(10)
 1238 04d4 1093 0000 		sts tekst_wysylanego_smsa+1,r17
 209:main.c        ****   *sms++ = '\n';
 1239               		.loc 1 209 0
 1240 04d8 CE01      		movw r24,r28
 1241 04da 0196      		adiw r24,1
 1242 04dc 0E94 0000 		call generuj_raport_sieci
 1243               	.LVL103:
 210:main.c        ****   generuj_raport_uzytkownikow_1(&sms);
 1244               		.loc 1 210 0
 1245 04e0 E981      		ldd r30,Y+1
 1246 04e2 FA81      		ldd r31,Y+2
 1247 04e4 CF01      		movw r24,r30
 1248 04e6 0196      		adiw r24,1
 1249 04e8 9A83      		std Y+2,r25
 1250 04ea 8983      		std Y+1,r24
 1251 04ec 1083      		st Z,r17
 211:main.c        ****   *sms++ = '\n';
 1252               		.loc 1 211 0
 1253 04ee CE01      		movw r24,r28
 1254 04f0 0196      		adiw r24,1
 1255 04f2 0E94 0000 		call generuj_raport_uzytkownikow_1
 1256               	.LVL104:
 212:main.c        **** 
 1257               		.loc 1 212 0
 1258 04f6 E981      		ldd r30,Y+1
 1259 04f8 FA81      		ldd r31,Y+2
 1260 04fa CF01      		movw r24,r30
 1261 04fc 0196      		adiw r24,1
 1262 04fe 9A83      		std Y+2,r25
 1263 0500 8983      		std Y+1,r24
 1264 0502 1083      		st Z,r17
 215:main.c        ****     strcpy_P((char *)sms, PSTR("Status: Zablokowany"));
 1265               		.loc 1 215 0
 1266 0504 2091 0000 		lds r18,blokada_systemu
 1267 0508 8981      		ldd r24,Y+1
 1268 050a 9A81      		ldd r25,Y+2
 216:main.c        ****   } else {
 1269               		.loc 1 216 0
 1270 050c 60E0      		ldi r22,lo8(__c.3035)
 1271 050e 70E0      		ldi r23,hi8(__c.3035)
 215:main.c        ****     strcpy_P((char *)sms, PSTR("Status: Zablokowany"));
 1272               		.loc 1 215 0
 1273 0510 2111      		cpse r18,__zero_reg__
 1274 0512 00C0      		rjmp .L74
 218:main.c        ****   }
 1275               		.loc 1 218 0
 1276 0514 60E0      		ldi r22,lo8(__c.3037)
 1277 0516 70E0      		ldi r23,hi8(__c.3037)
 1278               	.L74:
 1279 0518 0E94 0000 		call strcpy_P
 1280               	.LVL105:
 220:main.c        ****   *sms++ = '\n';
 1281               		.loc 1 220 0
 1282 051c E981      		ldd r30,Y+1
 1283 051e FA81      		ldd r31,Y+2
 1284               		0:
 1285 0520 0190      		ld __tmp_reg__,Z+
 1286 0522 0020      		tst __tmp_reg__
 1287 0524 01F4      		brne 0b
 221:main.c        **** 
 1288               		.loc 1 221 0
 1289 0526 DF01      		movw r26,r30
 1290 0528 1197      		sbiw r26,1
 1291 052a FA83      		std Y+2,r31
 1292 052c E983      		std Y+1,r30
 1293 052e 8AE0      		ldi r24,lo8(10)
 1294 0530 8C93      		st X,r24
 224:main.c        ****     strcpy_P((char *)sms, PSTR("Tryb: Prywatny"));
 1295               		.loc 1 224 0
 1296 0532 2091 0000 		lds r18,tryb_pracy
 1297 0536 8981      		ldd r24,Y+1
 1298 0538 9A81      		ldd r25,Y+2
 225:main.c        ****   } else {
 1299               		.loc 1 225 0
 1300 053a 60E0      		ldi r22,lo8(__c.3039)
 1301 053c 70E0      		ldi r23,hi8(__c.3039)
 224:main.c        ****     strcpy_P((char *)sms, PSTR("Tryb: Prywatny"));
 1302               		.loc 1 224 0
 1303 053e 2223      		tst r18
 1304 0540 01F0      		breq .L75
 227:main.c        ****   }
 1305               		.loc 1 227 0
 1306 0542 60E0      		ldi r22,lo8(__c.3041)
 1307 0544 70E0      		ldi r23,hi8(__c.3041)
 1308               	.L75:
 1309 0546 0E94 0000 		call strcpy_P
 1310               	.LVL106:
 229:main.c        **** 
 1311               		.loc 1 229 0
 1312 054a 8981      		ldd r24,Y+1
 1313 054c 9A81      		ldd r25,Y+2
 1314 054e FC01      		movw r30,r24
 1315               		0:
 1316 0550 0190      		ld __tmp_reg__,Z+
 1317 0552 0020      		tst __tmp_reg__
 1318 0554 01F4      		brne 0b
 1319 0556 CF01      		movw r24,r30
 1320 0558 0197      		sbiw r24,1
 1321 055a 9A83      		std Y+2,r25
 1322 055c 8983      		std Y+1,r24
 231:main.c        ****     strcpy_P((char *)sms, PSTR(" CLIP"));
 1323               		.loc 1 231 0
 1324 055e 2091 0000 		lds r18,tryb_clip
 232:main.c        ****   } else {
 1325               		.loc 1 232 0
 1326 0562 60E0      		ldi r22,lo8(__c.3043)
 1327 0564 70E0      		ldi r23,hi8(__c.3043)
 231:main.c        ****     strcpy_P((char *)sms, PSTR(" CLIP"));
 1328               		.loc 1 231 0
 1329 0566 2111      		cpse r18,__zero_reg__
 1330 0568 00C0      		rjmp .L76
 234:main.c        ****   }
 1331               		.loc 1 234 0
 1332 056a 60E0      		ldi r22,lo8(__c.3045)
 1333 056c 70E0      		ldi r23,hi8(__c.3045)
 1334               	.L76:
 1335 056e 0E94 0000 		call strcpy_P
 1336               	.LVL107:
 236:main.c        ****   *sms++ = '\n';
 1337               		.loc 1 236 0
 1338 0572 E981      		ldd r30,Y+1
 1339 0574 FA81      		ldd r31,Y+2
 1340               		0:
 1341 0576 0190      		ld __tmp_reg__,Z+
 1342 0578 0020      		tst __tmp_reg__
 1343 057a 01F4      		brne 0b
 237:main.c        **** 
 1344               		.loc 1 237 0
 1345 057c DF01      		movw r26,r30
 1346 057e 1197      		sbiw r26,1
 1347 0580 FA83      		std Y+2,r31
 1348 0582 E983      		std Y+1,r30
 1349 0584 8AE0      		ldi r24,lo8(10)
 1350 0586 8C93      		st X,r24
 239:main.c        ****     strcpy_P((char *)sms, PSTR("Harmonogram: Wylaczony"));
 1351               		.loc 1 239 0
 1352 0588 8091 0000 		lds r24,czas_start_h
 1353 058c 8F3F      		cpi r24,lo8(-1)
 1354 058e 01F4      		brne .L70
 240:main.c        ****   } else {
 1355               		.loc 1 240 0
 1356 0590 60E0      		ldi r22,lo8(__c.3047)
 1357 0592 70E0      		ldi r23,hi8(__c.3047)
 1358 0594 8981      		ldd r24,Y+1
 1359 0596 9A81      		ldd r25,Y+2
 1360 0598 0E94 0000 		call strcpy_P
 1361               	.LVL108:
 1362               	.L71:
 245:main.c        ****   *sms++ = '\n';
 1363               		.loc 1 245 0
 1364 059c E981      		ldd r30,Y+1
 1365 059e FA81      		ldd r31,Y+2
 1366               		0:
 1367 05a0 0190      		ld __tmp_reg__,Z+
 1368 05a2 0020      		tst __tmp_reg__
 1369 05a4 01F4      		brne 0b
 246:main.c        **** 
 1370               		.loc 1 246 0
 1371 05a6 DF01      		movw r26,r30
 1372 05a8 1197      		sbiw r26,1
 1373 05aa FA83      		std Y+2,r31
 1374 05ac E983      		std Y+1,r30
 1375 05ae 8AE0      		ldi r24,lo8(10)
 1376 05b0 8C93      		st X,r24
 249:main.c        ****     strcpy_P((char *)sms, PSTR("Skryba: Wlaczona"));
 1377               		.loc 1 249 0
 1378 05b2 2091 0000 		lds r18,skryba_wlaczona
 1379 05b6 8981      		ldd r24,Y+1
 1380 05b8 9A81      		ldd r25,Y+2
 250:main.c        ****   } else {
 1381               		.loc 1 250 0
 1382 05ba 60E0      		ldi r22,lo8(__c.3049)
 1383 05bc 70E0      		ldi r23,hi8(__c.3049)
 249:main.c        ****     strcpy_P((char *)sms, PSTR("Skryba: Wlaczona"));
 1384               		.loc 1 249 0
 1385 05be 2111      		cpse r18,__zero_reg__
 1386 05c0 00C0      		rjmp .L77
 252:main.c        ****   }
 1387               		.loc 1 252 0
 1388 05c2 60E0      		ldi r22,lo8(__c.3051)
 1389 05c4 70E0      		ldi r23,hi8(__c.3051)
 1390               	.L77:
 1391 05c6 0E94 0000 		call strcpy_P
 1392               	.LVL109:
 254:main.c        ****   *sms++ = '\n';
 1393               		.loc 1 254 0
 1394 05ca E981      		ldd r30,Y+1
 1395 05cc FA81      		ldd r31,Y+2
 1396               		0:
 1397 05ce 0190      		ld __tmp_reg__,Z+
 1398 05d0 0020      		tst __tmp_reg__
 1399 05d2 01F4      		brne 0b
 255:main.c        **** 
 1400               		.loc 1 255 0
 1401 05d4 DF01      		movw r26,r30
 1402 05d6 1197      		sbiw r26,1
 1403 05d8 FA83      		std Y+2,r31
 1404 05da E983      		std Y+1,r30
 1405 05dc 8AE0      		ldi r24,lo8(10)
 1406 05de 8C93      		st X,r24
 258:main.c        **** }
 1407               		.loc 1 258 0
 1408 05e0 60E0      		ldi r22,lo8(tekst_demo.3053)
 1409 05e2 70E0      		ldi r23,hi8(tekst_demo.3053)
 1410 05e4 8981      		ldd r24,Y+1
 1411 05e6 9A81      		ldd r25,Y+2
 1412 05e8 0E94 0000 		call strcpy_P
 1413               	.LVL110:
 1414               	/* epilogue start */
 259:main.c        **** 
 1415               		.loc 1 259 0
 1416 05ec 0F90      		pop __tmp_reg__
 1417 05ee 0F90      		pop __tmp_reg__
 1418 05f0 DF91      		pop r29
 1419 05f2 CF91      		pop r28
 1420 05f4 1F91      		pop r17
 1421 05f6 0895      		ret
 1422               	.L70:
 242:main.c        ****             (int)czas_start_m, (int)czas_stop_h, (int)czas_stop_m);
 1423               		.loc 1 242 0
 1424 05f8 9091 0000 		lds r25,czas_stop_m
 1425 05fc 1F92      		push __zero_reg__
 1426 05fe 9F93      		push r25
 1427 0600 9091 0000 		lds r25,czas_stop_h
 1428 0604 1F92      		push __zero_reg__
 1429 0606 9F93      		push r25
 1430 0608 9091 0000 		lds r25,czas_start_m
 1431 060c 1F92      		push __zero_reg__
 1432 060e 9F93      		push r25
 1433 0610 1F92      		push __zero_reg__
 1434 0612 8F93      		push r24
 1435 0614 80E0      		ldi r24,lo8(.LC0)
 1436 0616 90E0      		ldi r25,hi8(.LC0)
 1437 0618 9F93      		push r25
 1438 061a 8F93      		push r24
 1439 061c 8A81      		ldd r24,Y+2
 1440 061e 8F93      		push r24
 1441 0620 8981      		ldd r24,Y+1
 1442 0622 8F93      		push r24
 1443 0624 0E94 0000 		call sprintf
 1444               	.LVL111:
 1445 0628 0FB6      		in __tmp_reg__,__SREG__
 1446 062a F894      		cli
 1447 062c DEBF      		out __SP_H__,r29
 1448 062e 0FBE      		out __SREG__,__tmp_reg__
 1449 0630 CDBF      		out __SP_L__,r28
 1450 0632 00C0      		rjmp .L71
 1451               		.cfi_endproc
 1452               	.LFE30:
 1454               	.global	czy_numer_jest_super_userem
 1456               	czy_numer_jest_super_userem:
 1457               	.LFB31:
 262:main.c        ****   // Konwertuj numer do formatu EEPROM
 1458               		.loc 1 262 0
 1459               		.cfi_startproc
 1460               	.LVL112:
 1461 0634 0F93      		push r16
 1462               	.LCFI43:
 1463               		.cfi_def_cfa_offset 3
 1464               		.cfi_offset 16, -2
 1465 0636 1F93      		push r17
 1466               	.LCFI44:
 1467               		.cfi_def_cfa_offset 4
 1468               		.cfi_offset 17, -3
 1469 0638 CF93      		push r28
 1470               	.LCFI45:
 1471               		.cfi_def_cfa_offset 5
 1472               		.cfi_offset 28, -4
 1473 063a DF93      		push r29
 1474               	.LCFI46:
 1475               		.cfi_def_cfa_offset 6
 1476               		.cfi_offset 29, -5
 1477 063c 00D0      		rcall .
 1478 063e 00D0      		rcall .
 1479 0640 1F92      		push __zero_reg__
 1480               	.LCFI47:
 1481               		.cfi_def_cfa_offset 11
 1482 0642 CDB7      		in r28,__SP_L__
 1483 0644 DEB7      		in r29,__SP_H__
 1484               	.LCFI48:
 1485               		.cfi_def_cfa_register 28
 1486               	/* prologue: function */
 1487               	/* frame size = 5 */
 1488               	/* stack size = 9 */
 1489               	.L__stack_usage = 9
 267:main.c        **** 
 1490               		.loc 1 267 0
 1491 0646 FC01      		movw r30,r24
 1492               		0:
 1493 0648 0190      		ld __tmp_reg__,Z+
 1494 064a 0020      		tst __tmp_reg__
 1495 064c 01F4      		brne 0b
 1496 064e BF01      		movw r22,r30
 265:main.c        ****       (uchar *)numer_telefonu,
 1497               		.loc 1 265 0
 1498 0650 6150      		subi r22,1
 1499 0652 7109      		sbc r23,__zero_reg__
 1500 0654 AE01      		movw r20,r28
 1501 0656 4F5F      		subi r20,-1
 1502 0658 5F4F      		sbci r21,-1
 1503 065a 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 1504               	.LVL113:
 1505 065e 0AE8      		ldi r16,lo8(-118)
 1506 0660 1FE0      		ldi r17,lo8(15)
 1507               	.LVL114:
 1508               	.L80:
 1509               	.LBB391:
 272:main.c        ****             temp_buf, (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt))) {
 1510               		.loc 1 272 0
 1511 0662 B801      		movw r22,r16
 1512 0664 CE01      		movw r24,r28
 1513 0666 0196      		adiw r24,1
 1514 0668 0E94 0000 		call porownaj_numer_telefonu_blok
 1515               	.LVL115:
 1516 066c 8111      		cpse r24,__zero_reg__
 1517 066e 00C0      		rjmp .L81
 1518 0670 0B5F      		subi r16,-5
 1519 0672 1F4F      		sbci r17,-1
 270:main.c        ****        ++nr_uzyt) {
 1520               		.loc 1 270 0
 1521 0674 083A      		cpi r16,-88
 1522 0676 FFE0      		ldi r31,15
 1523 0678 1F07      		cpc r17,r31
 1524 067a 01F4      		brne .L80
 1525               	.L78:
 1526               	/* epilogue start */
 1527               	.LBE391:
 278:main.c        **** 
 1528               		.loc 1 278 0
 1529 067c 0F90      		pop __tmp_reg__
 1530 067e 0F90      		pop __tmp_reg__
 1531 0680 0F90      		pop __tmp_reg__
 1532 0682 0F90      		pop __tmp_reg__
 1533 0684 0F90      		pop __tmp_reg__
 1534 0686 DF91      		pop r29
 1535 0688 CF91      		pop r28
 1536 068a 1F91      		pop r17
 1537 068c 0F91      		pop r16
 1538 068e 0895      		ret
 1539               	.L81:
 1540               	.LBB392:
 274:main.c        ****     }
 1541               		.loc 1 274 0
 1542 0690 8FEF      		ldi r24,lo8(-1)
 1543 0692 00C0      		rjmp .L78
 1544               	.LBE392:
 1545               		.cfi_endproc
 1546               	.LFE31:
 1548               	.global	ustaw_wyjscie_clip
 1550               	ustaw_wyjscie_clip:
 1551               	.LFB32:
 280:main.c        ****   stan_wyjscie[0] = TRUE;
 1552               		.loc 1 280 0
 1553               		.cfi_startproc
 1554               	/* prologue: function */
 1555               	/* frame size = 0 */
 1556               	/* stack size = 0 */
 1557               	.L__stack_usage = 0
 281:main.c        ****   licznik_przelacznik_wyjscia[0] = 2 * 10ul; // 2 sekundy
 1558               		.loc 1 281 0
 1559 0694 8FEF      		ldi r24,lo8(-1)
 1560 0696 8093 0000 		sts stan_wyjscie,r24
 282:main.c        **** }
 1561               		.loc 1 282 0
 1562 069a 84E1      		ldi r24,lo8(20)
 1563 069c 90E0      		ldi r25,0
 1564 069e A0E0      		ldi r26,0
 1565 06a0 B0E0      		ldi r27,0
 1566 06a2 8093 0000 		sts licznik_przelacznik_wyjscia,r24
 1567 06a6 9093 0000 		sts licznik_przelacznik_wyjscia+1,r25
 1568 06aa A093 0000 		sts licznik_przelacznik_wyjscia+2,r26
 1569 06ae B093 0000 		sts licznik_przelacznik_wyjscia+3,r27
 1570               	/* epilogue start */
 283:main.c        **** 
 1571               		.loc 1 283 0
 1572 06b2 0895      		ret
 1573               		.cfi_endproc
 1574               	.LFE32:
 1576               		.section	.rodata.str1.1
 1577               	.LC1:
 1578 0021 2530 3264 		.string	"%02d:%02d:%02d"
 1578      3A25 3032 
 1578      643A 2530 
 1578      3264 00
 1579               	.LC2:
 1580 0030 2B43 434C 		.string	"+CCLK=\"24/01/01,%02d:%02d:%02d+04\""
 1580      4B3D 2232 
 1580      342F 3031 
 1580      2F30 312C 
 1580      2530 3264 
 1581               	.LC3:
 1582 0053 3A20 00   		.string	": "
 1583               	.LC4:
 1584 0056 4F4B 00   		.string	"OK"
 1585               	.LC5:
 1586 0059 4272 616B 		.string	"Brak takiego numeru w systemie"
 1586      2074 616B 
 1586      6965 676F 
 1586      206E 756D 
 1586      6572 7520 
 1587               	.LC6:
 1588 0078 5770 6973 		.string	"Wpisz numer jaki sprawdzasz, np: USER 793557357"
 1588      7A20 6E75 
 1588      6D65 7220 
 1588      6A61 6B69 
 1588      2073 7072 
 1589               		.text
 1590               	.global	wykonanie_polecenia_sms
 1592               	wykonanie_polecenia_sms:
 1593               	.LFB39:
 378:main.c        ****   tekst_odebranego_smsa[MAX_LICZBA_ZNAKOW_SMS] = 0; // (1) dla pewnoci
 1594               		.loc 1 378 0
 1595               		.cfi_startproc
 1596 06b4 CF92      		push r12
 1597               	.LCFI49:
 1598               		.cfi_def_cfa_offset 3
 1599               		.cfi_offset 12, -2
 1600 06b6 DF92      		push r13
 1601               	.LCFI50:
 1602               		.cfi_def_cfa_offset 4
 1603               		.cfi_offset 13, -3
 1604 06b8 FF92      		push r15
 1605               	.LCFI51:
 1606               		.cfi_def_cfa_offset 5
 1607               		.cfi_offset 15, -4
 1608 06ba 0F93      		push r16
 1609               	.LCFI52:
 1610               		.cfi_def_cfa_offset 6
 1611               		.cfi_offset 16, -5
 1612 06bc 1F93      		push r17
 1613               	.LCFI53:
 1614               		.cfi_def_cfa_offset 7
 1615               		.cfi_offset 17, -6
 1616 06be CF93      		push r28
 1617               	.LCFI54:
 1618               		.cfi_def_cfa_offset 8
 1619               		.cfi_offset 28, -7
 1620 06c0 DF93      		push r29
 1621               	.LCFI55:
 1622               		.cfi_def_cfa_offset 9
 1623               		.cfi_offset 29, -8
 1624 06c2 CDB7      		in r28,__SP_L__
 1625 06c4 DEB7      		in r29,__SP_H__
 1626               	.LCFI56:
 1627               		.cfi_def_cfa_register 28
 1628 06c6 6697      		sbiw r28,22
 1629               	.LCFI57:
 1630               		.cfi_def_cfa_offset 31
 1631 06c8 0FB6      		in __tmp_reg__,__SREG__
 1632 06ca F894      		cli
 1633 06cc DEBF      		out __SP_H__,r29
 1634 06ce 0FBE      		out __SREG__,__tmp_reg__
 1635 06d0 CDBF      		out __SP_L__,r28
 1636               	/* prologue: function */
 1637               	/* frame size = 22 */
 1638               	/* stack size = 29 */
 1639               	.L__stack_usage = 29
 379:main.c        ****   watchdog_sms_arm();
 1640               		.loc 1 379 0
 1641 06d2 1092 0000 		sts wysylany_blok_SIM900+399,__zero_reg__
 1642               	.LBB432:
 1643               	.LBB433:
 315:main.c        ****   watchdog_sms_licznik_100ms = 0;
 1644               		.loc 1 315 0
 1645 06d6 8FEF      		ldi r24,lo8(-1)
 1646 06d8 8093 0000 		sts watchdog_sms_aktywny,r24
 316:main.c        **** }
 1647               		.loc 1 316 0
 1648 06dc 1092 0000 		sts watchdog_sms_licznik_100ms+1,__zero_reg__
 1649 06e0 1092 0000 		sts watchdog_sms_licznik_100ms,__zero_reg__
 1650               	.LBE433:
 1651               	.LBE432:
 381:main.c        **** 
 1652               		.loc 1 381 0
 1653 06e4 80E0      		ldi r24,lo8(wysylany_blok_SIM900+239)
 1654 06e6 90E0      		ldi r25,hi8(wysylany_blok_SIM900+239)
 1655 06e8 0E94 0000 		call interpretuj_wiadomosc_sms
 1656               	.LVL116:
 1657 06ec 182F      		mov r17,r24
 1658               	.LVL117:
 390:main.c        ****     // Aktualizuj rtc_czas z timestampu SMS (z sekundami z PDU)
 1659               		.loc 1 390 0
 1660 06ee 8091 0000 		lds r24,sms_pomijaj_aktualizacje_czasu
 1661 06f2 8111      		cpse r24,__zero_reg__
 1662 06f4 00C0      		rjmp .L85
 1663               	.LBB434:
 392:main.c        ****             sms_timestamp_minuta, sms_timestamp_sekunda);
 1664               		.loc 1 392 0
 1665 06f6 8091 0000 		lds r24,sms_timestamp_sekunda
 1666 06fa 1F92      		push __zero_reg__
 1667 06fc 8F93      		push r24
 1668 06fe 8091 0000 		lds r24,sms_timestamp_minuta
 1669 0702 1F92      		push __zero_reg__
 1670 0704 8F93      		push r24
 1671 0706 8091 0000 		lds r24,sms_timestamp_godzina
 1672 070a 1F92      		push __zero_reg__
 1673 070c 8F93      		push r24
 1674 070e 80E0      		ldi r24,lo8(.LC1)
 1675 0710 90E0      		ldi r25,hi8(.LC1)
 1676 0712 9F93      		push r25
 1677 0714 8F93      		push r24
 1678 0716 80E0      		ldi r24,lo8(rtc_czas)
 1679 0718 90E0      		ldi r25,hi8(rtc_czas)
 1680 071a 9F93      		push r25
 1681 071c 8F93      		push r24
 1682 071e 0E94 0000 		call sprintf
 1683               	.LVL118:
 397:main.c        ****             sms_timestamp_godzina, sms_timestamp_minuta, sms_timestamp_sekunda);
 1684               		.loc 1 397 0
 1685 0722 8091 0000 		lds r24,sms_timestamp_sekunda
 1686 0726 1F92      		push __zero_reg__
 1687 0728 8F93      		push r24
 1688 072a 8091 0000 		lds r24,sms_timestamp_minuta
 1689 072e 1F92      		push __zero_reg__
 1690 0730 8F93      		push r24
 1691 0732 8091 0000 		lds r24,sms_timestamp_godzina
 1692 0736 1F92      		push __zero_reg__
 1693 0738 8F93      		push r24
 1694 073a 80E0      		ldi r24,lo8(.LC2)
 1695 073c 90E0      		ldi r25,hi8(.LC2)
 1696 073e 9F93      		push r25
 1697 0740 8F93      		push r24
 1698 0742 80E0      		ldi r24,lo8(bufor_ustaw_czas)
 1699 0744 90E0      		ldi r25,hi8(bufor_ustaw_czas)
 1700 0746 9F93      		push r25
 1701 0748 8F93      		push r24
 1702 074a 0E94 0000 		call sprintf
 1703               	.LVL119:
 399:main.c        **** 
 1704               		.loc 1 399 0
 1705 074e 8EEF      		ldi r24,lo8(-2)
 1706 0750 0E94 0000 		call dodaj_komende
 1707               	.LVL120:
 402:main.c        ****       int curr_time = sms_timestamp_godzina * 60 + sms_timestamp_minuta;
 1708               		.loc 1 402 0
 1709 0754 2091 0000 		lds r18,czas_start_h
 1710 0758 0FB6      		in __tmp_reg__,__SREG__
 1711 075a F894      		cli
 1712 075c DEBF      		out __SP_H__,r29
 1713 075e 0FBE      		out __SREG__,__tmp_reg__
 1714 0760 CDBF      		out __SP_L__,r28
 1715 0762 2F3F      		cpi r18,lo8(-1)
 1716 0764 01F4      		brne .+2
 1717 0766 00C0      		rjmp .L86
 1718               	.LBB435:
 403:main.c        ****       int start_time = czas_start_h * 60 + czas_start_m;
 1719               		.loc 1 403 0
 1720 0768 3091 0000 		lds r19,sms_timestamp_godzina
 1721 076c 6CE3      		ldi r22,lo8(60)
 1722 076e 8091 0000 		lds r24,sms_timestamp_minuta
 1723 0772 90E0      		ldi r25,0
 1724 0774 369F      		mul r19,r22
 1725 0776 800D      		add r24,r0
 1726 0778 911D      		adc r25,r1
 1727 077a 1124      		clr __zero_reg__
 1728               	.LVL121:
 404:main.c        ****       int stop_time = czas_stop_h * 60 + czas_stop_m;
 1729               		.loc 1 404 0
 1730 077c 4091 0000 		lds r20,czas_start_m
 1731 0780 50E0      		ldi r21,0
 1732 0782 269F      		mul r18,r22
 1733 0784 400D      		add r20,r0
 1734 0786 511D      		adc r21,r1
 1735 0788 1124      		clr __zero_reg__
 1736               	.LVL122:
 405:main.c        **** 
 1737               		.loc 1 405 0
 1738 078a 7091 0000 		lds r23,czas_stop_h
 1739 078e 2091 0000 		lds r18,czas_stop_m
 1740 0792 30E0      		ldi r19,0
 1741 0794 769F      		mul r23,r22
 1742 0796 200D      		add r18,r0
 1743 0798 311D      		adc r19,r1
 1744 079a 1124      		clr __zero_reg__
 1745               	.LVL123:
 407:main.c        ****         // Normalny przedział (np. 08:00 - 16:00)
 1746               		.loc 1 407 0
 1747 079c 2417      		cp r18,r20
 1748 079e 3507      		cpc r19,r21
 1749 07a0 04F0      		brlt .L87
 410:main.c        ****       } else {
 1750               		.loc 1 410 0
 1751 07a2 8417      		cp r24,r20
 1752 07a4 9507      		cpc r25,r21
 1753 07a6 04F0      		brlt .L113
 410:main.c        ****       } else {
 1754               		.loc 1 410 0 is_stmt 0 discriminator 2
 1755 07a8 41E0      		ldi r20,lo8(1)
 1756               	.LVL124:
 1757 07aa 2817      		cp r18,r24
 1758 07ac 3907      		cpc r19,r25
 1759 07ae 04F0      		brlt .L88
 1760 07b0 40E0      		ldi r20,0
 1761               	.L88:
 409:main.c        ****             !(curr_time >= start_time && curr_time <= stop_time);
 1762               		.loc 1 409 0 is_stmt 1
 1763 07b2 4093 0000 		sts blokada_sterowania_czasowa,r20
 1764               	.LVL125:
 1765               	.L85:
 1766               	.LBE435:
 1767               	.LBE434:
 422:main.c        **** 
 1768               		.loc 1 422 0
 1769 07b6 1092 0000 		sts sms_pomijaj_aktualizacje_czasu,__zero_reg__
 425:main.c        ****     // Gdy zablokowany, akceptuj tylko START i REPORT
 1770               		.loc 1 425 0
 1771 07ba 8091 0000 		lds r24,blokada_systemu
 1772 07be 8823      		tst r24
 1773 07c0 01F0      		breq .L92
 427:main.c        ****         komenda != INTERPRETACJA_SMS_RAPORT) {
 1774               		.loc 1 427 0
 1775 07c2 8DEF      		ldi r24,lo8(-3)
 1776 07c4 810F      		add r24,r17
 1777 07c6 8230      		cpi r24,lo8(2)
 1778 07c8 00F0      		brlo .L92
 432:main.c        ****           1) {
 1779               		.loc 1 432 0
 1780 07ca 87EF      		ldi r24,lo8(-9)
 1781 07cc 9FE0      		ldi r25,lo8(15)
 1782 07ce 0E94 0000 		call eeprom_read_byte
 1783               	.LVL126:
 1784 07d2 8130      		cpi r24,lo8(1)
 1785 07d4 01F4      		brne .L92
 434:main.c        ****         usun_zablokowany_sms();
 1786               		.loc 1 434 0
 1787 07d6 62E0      		ldi r22,lo8(2)
 1788 07d8 0E94 0000 		call zapisz_debug_do_eeprom
 1789               	.LVL127:
 435:main.c        ****         return;
 1790               		.loc 1 435 0
 1791 07dc 0E94 0000 		call usun_zablokowany_sms
 1792               	.LVL128:
 1793               	.L84:
 1794               	/* epilogue start */
 675:main.c        **** 
 1795               		.loc 1 675 0
 1796 07e0 6696      		adiw r28,22
 1797 07e2 0FB6      		in __tmp_reg__,__SREG__
 1798 07e4 F894      		cli
 1799 07e6 DEBF      		out __SP_H__,r29
 1800 07e8 0FBE      		out __SREG__,__tmp_reg__
 1801 07ea CDBF      		out __SP_L__,r28
 1802 07ec DF91      		pop r29
 1803 07ee CF91      		pop r28
 1804 07f0 1F91      		pop r17
 1805 07f2 0F91      		pop r16
 1806 07f4 FF90      		pop r15
 1807 07f6 DF90      		pop r13
 1808 07f8 CF90      		pop r12
 1809 07fa 0895      		ret
 1810               	.LVL129:
 1811               	.L113:
 1812               	.LBB437:
 1813               	.LBB436:
 410:main.c        ****       } else {
 1814               		.loc 1 410 0
 1815 07fc 41E0      		ldi r20,lo8(1)
 1816               	.LVL130:
 1817 07fe 00C0      		rjmp .L88
 1818               	.LVL131:
 1819               	.L87:
 414:main.c        ****       }
 1820               		.loc 1 414 0
 1821 0800 8417      		cp r24,r20
 1822 0802 9507      		cpc r25,r21
 1823 0804 04F4      		brge .L114
 414:main.c        ****       }
 1824               		.loc 1 414 0 is_stmt 0 discriminator 1
 1825 0806 41E0      		ldi r20,lo8(1)
 1826               	.LVL132:
 1827 0808 2817      		cp r18,r24
 1828 080a 3907      		cpc r19,r25
 1829 080c 04F0      		brlt .L91
 1830 080e 40E0      		ldi r20,0
 1831               	.L91:
 1832 0810 842F      		mov r24,r20
 1833               	.LVL133:
 1834               	.L90:
 413:main.c        ****             !(curr_time >= start_time || curr_time <= stop_time);
 1835               		.loc 1 413 0 is_stmt 1
 1836 0812 8093 0000 		sts blokada_sterowania_czasowa,r24
 1837 0816 00C0      		rjmp .L85
 1838               	.LVL134:
 1839               	.L114:
 414:main.c        ****       }
 1840               		.loc 1 414 0
 1841 0818 80E0      		ldi r24,0
 1842               	.LVL135:
 1843 081a 00C0      		rjmp .L90
 1844               	.LVL136:
 1845               	.L86:
 1846               	.LBE436:
 417:main.c        ****     }
 1847               		.loc 1 417 0
 1848 081c 1092 0000 		sts blokada_sterowania_czasowa,__zero_reg__
 1849 0820 00C0      		rjmp .L85
 1850               	.L92:
 1851               	.LBE437:
 442:main.c        ****       komenda == INTERPRETACJA_SMS_USER) {
 1852               		.loc 1 442 0
 1853 0822 8CEF      		ldi r24,lo8(-4)
 1854 0824 810F      		add r24,r17
 1855 0826 8230      		cpi r24,lo8(2)
 1856 0828 00F4      		brsh .L94
 444:main.c        ****       zapisz_debug_do_eeprom(1, 1);
 1857               		.loc 1 444 0
 1858 082a 8091 0000 		lds r24,licznik_report_user
 1859 082e 8830      		cpi r24,lo8(8)
 1860 0830 00F0      		brlo .L94
 1861               	.L95:
 445:main.c        ****       usun_zablokowany_sms();
 1862               		.loc 1 445 0
 1863 0832 61E0      		ldi r22,lo8(1)
 1864 0834 81E0      		ldi r24,lo8(1)
 1865 0836 0E94 0000 		call zapisz_debug_do_eeprom
 1866               	.LVL137:
 446:main.c        ****       zareaguj_na_usuniety_sms_z_powodu_limitu();
 1867               		.loc 1 446 0
 1868 083a 0E94 0000 		call usun_zablokowany_sms
 1869               	.LVL138:
 447:main.c        ****       watchdog_sms_disarm();
 1870               		.loc 1 447 0
 1871 083e 0E94 0000 		call zareaguj_na_usuniety_sms_z_powodu_limitu
 1872               	.LVL139:
 1873               	.L98:
 674:main.c        **** }
 1874               		.loc 1 674 0
 1875 0842 0E94 0000 		call watchdog_sms_disarm
 1876               	.LVL140:
 1877 0846 00C0      		rjmp .L84
 1878               	.LVL141:
 1879               	.L94:
 454:main.c        ****     // Same number check
 1880               		.loc 1 454 0
 1881 0848 8091 0000 		lds r24,flaga_wysylanie_smsa
 1882 084c 8111      		cpse r24,__zero_reg__
 1883 084e 00C0      		rjmp .L95
 1884 0850 E0E0      		ldi r30,lo8(komendy_kolejka)
 1885 0852 F0E0      		ldi r31,hi8(komendy_kolejka)
 474:main.c        ****   for (uchar i = 0; i < LICZBA_KOMEND; ++i) {
 1886               		.loc 1 474 0
 1887 0854 20E0      		ldi r18,0
 473:main.c        ****   uchar liczba_wszystkich_komend = 0;
 1888               		.loc 1 473 0
 1889 0856 90E0      		ldi r25,0
 1890               	.L97:
 1891               	.LVL142:
 1892               	.LBB438:
 476:main.c        ****       ++liczba_wszystkich_komend;
 1893               		.loc 1 476 0
 1894 0858 8191      		ld r24,Z+
 1895               	.LVL143:
 1896 085a 8823      		tst r24
 1897 085c 01F0      		breq .L96
 477:main.c        ****       if (komendy_kolejka[i] >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
 1898               		.loc 1 477 0
 1899 085e 2F5F      		subi r18,lo8(-(1))
 1900               	.LVL144:
 478:main.c        ****           komendy_kolejka[i] <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
 1901               		.loc 1 478 0
 1902 0860 835D      		subi r24,lo8(-(45))
 1903 0862 8230      		cpi r24,lo8(2)
 1904 0864 00F4      		brsh .L96
 480:main.c        ****     }
 1905               		.loc 1 480 0
 1906 0866 9F5F      		subi r25,lo8(-(1))
 1907               	.LVL145:
 1908               	.L96:
 475:main.c        ****     if (komendy_kolejka[i] != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 1909               		.loc 1 475 0 discriminator 2
 1910 0868 80E0      		ldi r24,hi8(komendy_kolejka+30)
 1911 086a E030      		cpi r30,lo8(komendy_kolejka+30)
 1912 086c F807      		cpc r31,r24
 1913 086e 01F4      		brne .L97
 1914               	.LBE438:
 484:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 1915               		.loc 1 484 0
 1916 0870 2332      		cpi r18,lo8(35)
 1917 0872 00F4      		brsh .L95
 492:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 1918               		.loc 1 492 0
 1919 0874 9630      		cpi r25,lo8(6)
 1920 0876 00F4      		brsh .L95
 500:main.c        ****   case INTERPRETACJA_SMS_POPRAWNY:
 1921               		.loc 1 500 0
 1922 0878 1C30      		cpi r17,lo8(12)
 1923 087a 00F4      		brsh .L98
 1924 087c E12F      		mov r30,r17
 1925               	.LVL146:
 1926 087e F0E0      		ldi r31,0
 1927 0880 E050      		subi r30,lo8(-(gs(.L100)))
 1928 0882 F040      		sbci r31,hi8(-(gs(.L100)))
 1929 0884 0C94 0000 		jmp __tablejump2__
 1930               		.p2align	1
 1931               	.L100:
 1932 0888 0000      		.word gs(.L99)
 1933 088a 0000      		.word gs(.L98)
 1934 088c 0000      		.word gs(.L98)
 1935 088e 0000      		.word gs(.L125)
 1936 0890 0000      		.word gs(.L102)
 1937 0892 0000      		.word gs(.L103)
 1938 0894 0000      		.word gs(.L104)
 1939 0896 0000      		.word gs(.L105)
 1940 0898 0000      		.word gs(.L106)
 1941 089a 0000      		.word gs(.L98)
 1942 089c 0000      		.word gs(.L98)
 1943 089e 0000      		.word gs(.L107)
 1944               	.L99:
 505:main.c        ****     zapisz_debug_do_eeprom(0, 3);
 1945               		.loc 1 505 0
 1946 08a0 81E0      		ldi r24,lo8(1)
 1947 08a2 8093 0000 		sts liczba_blyskow_led,r24
 1948 08a6 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 506:main.c        ****     break;
 1949               		.loc 1 506 0
 1950 08aa 63E0      		ldi r22,lo8(3)
 1951 08ac 80E0      		ldi r24,0
 1952               	.LVL147:
 1953               	.L127:
 518:main.c        ****     break;
 1954               		.loc 1 518 0
 1955 08ae 0E94 0000 		call zapisz_debug_do_eeprom
 1956               	.LVL148:
 519:main.c        ****   }
 1957               		.loc 1 519 0
 1958 08b2 00C0      		rjmp .L98
 1959               	.LVL149:
 1960               	.L102:
 510:main.c        ****     timer_report_user_100ms = OKNO_CZASOWE_REPORT_USER_100MS;
 1961               		.loc 1 510 0
 1962 08b4 8091 0000 		lds r24,licznik_report_user
 1963 08b8 8F5F      		subi r24,lo8(-(1))
 1964 08ba 8093 0000 		sts licznik_report_user,r24
 511:main.c        **** 
 1965               		.loc 1 511 0
 1966 08be 8CE2      		ldi r24,lo8(44)
 1967 08c0 91E0      		ldi r25,lo8(1)
 1968 08c2 9093 0000 		sts timer_report_user_100ms+1,r25
 1969 08c6 8093 0000 		sts timer_report_user_100ms,r24
 513:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 1970               		.loc 1 513 0
 1971 08ca 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 1972 08cc 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 1973 08ce 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 1974 08d0 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 1975 08d2 0E94 0000 		call strcpy
 1976               	.LVL150:
 515:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 1977               		.loc 1 515 0
 1978 08d6 0E94 0000 		call generuj_raport_stanu_urzadzenia
 1979               	.LVL151:
 516:main.c        ****     zapal_diode_led_blyski(2); // Komenda REPORT - 2 blyski
 1980               		.loc 1 516 0
 1981 08da 83ED      		ldi r24,lo8(-45)
 1982 08dc 0E94 0000 		call dodaj_komende
 1983               	.LVL152:
 517:main.c        ****     zapisz_debug_do_eeprom(1, 0);
 1984               		.loc 1 517 0
 1985 08e0 82E0      		ldi r24,lo8(2)
 1986 08e2 8093 0000 		sts liczba_blyskow_led,r24
 1987 08e6 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 518:main.c        ****     break;
 1988               		.loc 1 518 0
 1989 08ea 60E0      		ldi r22,0
 1990 08ec 81E0      		ldi r24,lo8(1)
 1991 08ee 00C0      		rjmp .L127
 1992               	.LVL153:
 1993               	.L106:
 1994               	.LBB439:
 523:main.c        ****     uchar *sms = tekst_wysylanego_smsa + strlen((char *)tekst_wysylanego_smsa);
 1995               		.loc 1 523 0
 1996 08f0 60E0      		ldi r22,lo8(__c.3127)
 1997 08f2 70E0      		ldi r23,hi8(__c.3127)
 1998 08f4 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 1999 08f6 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 2000 08f8 0E94 0000 		call strcpy_P
 2001               	.LVL154:
 524:main.c        **** 
 2002               		.loc 1 524 0
 2003 08fc 00E0      		ldi r16,lo8(tekst_wysylanego_smsa)
 2004 08fe 10E0      		ldi r17,hi8(tekst_wysylanego_smsa)
 2005 0900 F801      		movw r30,r16
 2006               		0:
 2007 0902 0190      		ld __tmp_reg__,Z+
 2008 0904 0020      		tst __tmp_reg__
 2009 0906 01F4      		brne 0b
 2010 0908 8F01      		movw r16,r30
 2011 090a 0150      		subi r16,1
 2012 090c 1109      		sbc r17,__zero_reg__
 2013               	.LVL155:
 527:main.c        ****     sms += strlen((char *)sms);
 2014               		.loc 1 527 0
 2015 090e 60E0      		ldi r22,lo8(__c.3130)
 2016 0910 70E0      		ldi r23,hi8(__c.3130)
 2017 0912 C801      		movw r24,r16
 2018 0914 0E94 0000 		call strcpy_P
 2019               	.LVL156:
 528:main.c        ****     *sms++ =
 2020               		.loc 1 528 0
 2021 0918 F801      		movw r30,r16
 2022               		0:
 2023 091a 0190      		ld __tmp_reg__,Z+
 2024 091c 0020      		tst __tmp_reg__
 2025 091e 01F4      		brne 0b
 2026 0920 CF01      		movw r24,r30
 2027 0922 0197      		sbiw r24,1
 2028 0924 6C01      		movw r12,r24
 2029               	.LVL157:
 530:main.c        ****     *sms++ =
 2030               		.loc 1 530 0
 2031 0926 81EF      		ldi r24,lo8(-15)
 2032 0928 9FE0      		ldi r25,lo8(15)
 2033 092a 0E94 0000 		call eeprom_read_byte
 2034               	.LVL158:
 2035 092e 805D      		subi r24,lo8(-(48))
 529:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_2);
 2036               		.loc 1 529 0
 2037 0930 F601      		movw r30,r12
 2038 0932 8083      		st Z,r24
 532:main.c        ****     *sms++ =
 2039               		.loc 1 532 0
 2040 0934 82EF      		ldi r24,lo8(-14)
 2041 0936 9FE0      		ldi r25,lo8(15)
 2042 0938 0E94 0000 		call eeprom_read_byte
 2043               	.LVL159:
 2044 093c 805D      		subi r24,lo8(-(48))
 531:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_3);
 2045               		.loc 1 531 0
 2046 093e F601      		movw r30,r12
 2047 0940 8183      		std Z+1,r24
 534:main.c        ****     *sms++ =
 2048               		.loc 1 534 0
 2049 0942 83EF      		ldi r24,lo8(-13)
 2050 0944 9FE0      		ldi r25,lo8(15)
 2051 0946 0E94 0000 		call eeprom_read_byte
 2052               	.LVL160:
 2053 094a 805D      		subi r24,lo8(-(48))
 533:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_4);
 2054               		.loc 1 533 0
 2055 094c F601      		movw r30,r12
 2056 094e 8283      		std Z+2,r24
 536:main.c        ****     *sms++ = '\n';
 2057               		.loc 1 536 0
 2058 0950 84EF      		ldi r24,lo8(-12)
 2059 0952 9FE0      		ldi r25,lo8(15)
 2060 0954 0E94 0000 		call eeprom_read_byte
 2061               	.LVL161:
 2062 0958 805D      		subi r24,lo8(-(48))
 535:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_5);
 2063               		.loc 1 535 0
 2064 095a F601      		movw r30,r12
 2065 095c 8383      		std Z+3,r24
 537:main.c        **** 
 2066               		.loc 1 537 0
 2067 095e 8601      		movw r16,r12
 2068 0960 0B5F      		subi r16,-5
 2069 0962 1F4F      		sbci r17,-1
 2070               	.LVL162:
 2071 0964 9AE0      		ldi r25,lo8(10)
 2072 0966 F92E      		mov r15,r25
 2073 0968 F482      		std Z+4,r15
 540:main.c        ****     sms += strlen((char *)sms);
 2074               		.loc 1 540 0
 2075 096a 60E0      		ldi r22,lo8(__c.3132)
 2076 096c 70E0      		ldi r23,hi8(__c.3132)
 2077 096e C801      		movw r24,r16
 2078 0970 0E94 0000 		call strcpy_P
 2079               	.LVL163:
 541:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_1), sms, 10);
 2080               		.loc 1 541 0
 2081 0974 F801      		movw r30,r16
 2082               		0:
 2083 0976 0190      		ld __tmp_reg__,Z+
 2084 0978 0020      		tst __tmp_reg__
 2085 097a 01F4      		brne 0b
 2086 097c 8F01      		movw r16,r30
 2087               	.LVL164:
 2088 097e 0150      		subi r16,1
 2089 0980 1109      		sbc r17,__zero_reg__
 2090               	.LVL165:
 542:main.c        ****     sms += strlen((char *)sms);
 2091               		.loc 1 542 0
 2092 0982 86EE      		ldi r24,lo8(-26)
 2093 0984 9FE0      		ldi r25,lo8(15)
 2094 0986 0E94 0000 		call eeprom_read_byte
 2095               	.LVL166:
 2096               	.LBB440:
 2097               	.LBB441:
 2098               		.loc 6 527 0
 2099 098a 4AE0      		ldi r20,lo8(10)
 2100 098c B801      		movw r22,r16
 2101 098e 90E0      		ldi r25,0
 2102 0990 0E94 0000 		call __utoa_ncheck
 2103               	.LVL167:
 2104               	.LBE441:
 2105               	.LBE440:
 543:main.c        **** 
 2106               		.loc 1 543 0
 2107 0994 F801      		movw r30,r16
 2108               		0:
 2109 0996 0190      		ld __tmp_reg__,Z+
 2110 0998 0020      		tst __tmp_reg__
 2111 099a 01F4      		brne 0b
 2112 099c 8F01      		movw r16,r30
 2113               	.LVL168:
 2114 099e 0150      		subi r16,1
 2115 09a0 1109      		sbc r17,__zero_reg__
 2116               	.LVL169:
 545:main.c        ****     sms += strlen((char *)sms);
 2117               		.loc 1 545 0
 2118 09a2 60E0      		ldi r22,lo8(__c.3134)
 2119 09a4 70E0      		ldi r23,hi8(__c.3134)
 2120 09a6 C801      		movw r24,r16
 2121 09a8 0E94 0000 		call strcpy_P
 2122               	.LVL170:
 546:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_2), sms, 10);
 2123               		.loc 1 546 0
 2124 09ac F801      		movw r30,r16
 2125               		0:
 2126 09ae 0190      		ld __tmp_reg__,Z+
 2127 09b0 0020      		tst __tmp_reg__
 2128 09b2 01F4      		brne 0b
 2129 09b4 8F01      		movw r16,r30
 2130               	.LVL171:
 2131 09b6 0150      		subi r16,1
 2132 09b8 1109      		sbc r17,__zero_reg__
 2133               	.LVL172:
 547:main.c        ****     sms += strlen((char *)sms);
 2134               		.loc 1 547 0
 2135 09ba 87EE      		ldi r24,lo8(-25)
 2136 09bc 9FE0      		ldi r25,lo8(15)
 2137 09be 0E94 0000 		call eeprom_read_byte
 2138               	.LVL173:
 2139               	.LBB442:
 2140               	.LBB443:
 2141               		.loc 6 527 0
 2142 09c2 4AE0      		ldi r20,lo8(10)
 2143 09c4 B801      		movw r22,r16
 2144 09c6 90E0      		ldi r25,0
 2145 09c8 0E94 0000 		call __utoa_ncheck
 2146               	.LVL174:
 2147               	.LBE443:
 2148               	.LBE442:
 548:main.c        **** 
 2149               		.loc 1 548 0
 2150 09cc F801      		movw r30,r16
 2151               		0:
 2152 09ce 0190      		ld __tmp_reg__,Z+
 2153 09d0 0020      		tst __tmp_reg__
 2154 09d2 01F4      		brne 0b
 2155 09d4 8F01      		movw r16,r30
 2156               	.LVL175:
 2157 09d6 0150      		subi r16,1
 2158 09d8 1109      		sbc r17,__zero_reg__
 2159               	.LVL176:
 550:main.c        ****     sms += strlen((char *)sms);
 2160               		.loc 1 550 0
 2161 09da 60E0      		ldi r22,lo8(__c.3136)
 2162 09dc 70E0      		ldi r23,hi8(__c.3136)
 2163 09de C801      		movw r24,r16
 2164 09e0 0E94 0000 		call strcpy_P
 2165               	.LVL177:
 551:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_3), sms, 10);
 2166               		.loc 1 551 0
 2167 09e4 F801      		movw r30,r16
 2168               		0:
 2169 09e6 0190      		ld __tmp_reg__,Z+
 2170 09e8 0020      		tst __tmp_reg__
 2171 09ea 01F4      		brne 0b
 2172 09ec 8F01      		movw r16,r30
 2173               	.LVL178:
 2174 09ee 0150      		subi r16,1
 2175 09f0 1109      		sbc r17,__zero_reg__
 2176               	.LVL179:
 552:main.c        ****     sms += strlen((char *)sms);
 2177               		.loc 1 552 0
 2178 09f2 88EE      		ldi r24,lo8(-24)
 2179 09f4 9FE0      		ldi r25,lo8(15)
 2180 09f6 0E94 0000 		call eeprom_read_byte
 2181               	.LVL180:
 2182               	.LBB444:
 2183               	.LBB445:
 2184               		.loc 6 527 0
 2185 09fa 4AE0      		ldi r20,lo8(10)
 2186 09fc B801      		movw r22,r16
 2187 09fe 90E0      		ldi r25,0
 2188 0a00 0E94 0000 		call __utoa_ncheck
 2189               	.LVL181:
 2190               	.LBE445:
 2191               	.LBE444:
 553:main.c        ****     *sms++ = '\n';
 2192               		.loc 1 553 0
 2193 0a04 F801      		movw r30,r16
 2194               		0:
 2195 0a06 0190      		ld __tmp_reg__,Z+
 2196 0a08 0020      		tst __tmp_reg__
 2197 0a0a 01F4      		brne 0b
 2198 0a0c 3197      		sbiw r30,1
 2199               	.LVL182:
 554:main.c        **** 
 2200               		.loc 1 554 0
 2201 0a0e 8F01      		movw r16,r30
 2202 0a10 0F5F      		subi r16,-1
 2203 0a12 1F4F      		sbci r17,-1
 2204               	.LVL183:
 2205 0a14 F082      		st Z,r15
 556:main.c        ****     sms += strlen((char *)sms);
 2206               		.loc 1 556 0
 2207 0a16 60E0      		ldi r22,lo8(__c.3138)
 2208 0a18 70E0      		ldi r23,hi8(__c.3138)
 2209 0a1a C801      		movw r24,r16
 2210 0a1c 0E94 0000 		call strcpy_P
 2211               	.LVL184:
 557:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_4), sms, 10);
 2212               		.loc 1 557 0
 2213 0a20 F801      		movw r30,r16
 2214               		0:
 2215 0a22 0190      		ld __tmp_reg__,Z+
 2216 0a24 0020      		tst __tmp_reg__
 2217 0a26 01F4      		brne 0b
 2218 0a28 8F01      		movw r16,r30
 2219               	.LVL185:
 2220 0a2a 0150      		subi r16,1
 2221 0a2c 1109      		sbc r17,__zero_reg__
 2222               	.LVL186:
 558:main.c        ****     sms += strlen((char *)sms);
 2223               		.loc 1 558 0
 2224 0a2e 89EE      		ldi r24,lo8(-23)
 2225 0a30 9FE0      		ldi r25,lo8(15)
 2226 0a32 0E94 0000 		call eeprom_read_byte
 2227               	.LVL187:
 2228               	.LBB446:
 2229               	.LBB447:
 2230               		.loc 6 527 0
 2231 0a36 4AE0      		ldi r20,lo8(10)
 2232 0a38 B801      		movw r22,r16
 2233 0a3a 90E0      		ldi r25,0
 2234 0a3c 0E94 0000 		call __utoa_ncheck
 2235               	.LVL188:
 2236               	.LBE447:
 2237               	.LBE446:
 559:main.c        **** 
 2238               		.loc 1 559 0
 2239 0a40 F801      		movw r30,r16
 2240               		0:
 2241 0a42 0190      		ld __tmp_reg__,Z+
 2242 0a44 0020      		tst __tmp_reg__
 2243 0a46 01F4      		brne 0b
 2244 0a48 8F01      		movw r16,r30
 2245               	.LVL189:
 2246 0a4a 0150      		subi r16,1
 2247 0a4c 1109      		sbc r17,__zero_reg__
 2248               	.LVL190:
 561:main.c        ****     sms += strlen((char *)sms);
 2249               		.loc 1 561 0
 2250 0a4e 60E0      		ldi r22,lo8(__c.3140)
 2251 0a50 70E0      		ldi r23,hi8(__c.3140)
 2252 0a52 C801      		movw r24,r16
 2253 0a54 0E94 0000 		call strcpy_P
 2254               	.LVL191:
 562:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_5), sms, 10);
 2255               		.loc 1 562 0
 2256 0a58 F801      		movw r30,r16
 2257               		0:
 2258 0a5a 0190      		ld __tmp_reg__,Z+
 2259 0a5c 0020      		tst __tmp_reg__
 2260 0a5e 01F4      		brne 0b
 2261 0a60 8F01      		movw r16,r30
 2262               	.LVL192:
 2263 0a62 0150      		subi r16,1
 2264 0a64 1109      		sbc r17,__zero_reg__
 2265               	.LVL193:
 563:main.c        ****     sms += strlen((char *)sms);
 2266               		.loc 1 563 0
 2267 0a66 8AEE      		ldi r24,lo8(-22)
 2268 0a68 9FE0      		ldi r25,lo8(15)
 2269 0a6a 0E94 0000 		call eeprom_read_byte
 2270               	.LVL194:
 2271               	.LBB448:
 2272               	.LBB449:
 2273               		.loc 6 527 0
 2274 0a6e 4AE0      		ldi r20,lo8(10)
 2275 0a70 B801      		movw r22,r16
 2276 0a72 90E0      		ldi r25,0
 2277 0a74 0E94 0000 		call __utoa_ncheck
 2278               	.LVL195:
 2279               	.LBE449:
 2280               	.LBE448:
 564:main.c        **** 
 2281               		.loc 1 564 0
 2282 0a78 F801      		movw r30,r16
 2283               		0:
 2284 0a7a 0190      		ld __tmp_reg__,Z+
 2285 0a7c 0020      		tst __tmp_reg__
 2286 0a7e 01F4      		brne 0b
 2287 0a80 8F01      		movw r16,r30
 2288               	.LVL196:
 2289 0a82 0150      		subi r16,1
 2290 0a84 1109      		sbc r17,__zero_reg__
 2291               	.LVL197:
 566:main.c        ****     sms += strlen((char *)sms);
 2292               		.loc 1 566 0
 2293 0a86 60E0      		ldi r22,lo8(__c.3142)
 2294 0a88 70E0      		ldi r23,hi8(__c.3142)
 2295 0a8a C801      		movw r24,r16
 2296 0a8c 0E94 0000 		call strcpy_P
 2297               	.LVL198:
 567:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_6), sms, 10);
 2298               		.loc 1 567 0
 2299 0a90 F801      		movw r30,r16
 2300               		0:
 2301 0a92 0190      		ld __tmp_reg__,Z+
 2302 0a94 0020      		tst __tmp_reg__
 2303 0a96 01F4      		brne 0b
 2304 0a98 8F01      		movw r16,r30
 2305               	.LVL199:
 2306 0a9a 0150      		subi r16,1
 2307 0a9c 1109      		sbc r17,__zero_reg__
 2308               	.LVL200:
 568:main.c        ****     sms += strlen((char *)sms);
 2309               		.loc 1 568 0
 2310 0a9e 8BEE      		ldi r24,lo8(-21)
 2311 0aa0 9FE0      		ldi r25,lo8(15)
 2312 0aa2 0E94 0000 		call eeprom_read_byte
 2313               	.LVL201:
 2314               	.LBB450:
 2315               	.LBB451:
 2316               		.loc 6 527 0
 2317 0aa6 4AE0      		ldi r20,lo8(10)
 2318 0aa8 B801      		movw r22,r16
 2319 0aaa 90E0      		ldi r25,0
 2320 0aac 0E94 0000 		call __utoa_ncheck
 2321               	.LVL202:
 2322               	.LBE451:
 2323               	.LBE450:
 569:main.c        **** 
 2324               		.loc 1 569 0
 2325 0ab0 F801      		movw r30,r16
 2326               		0:
 2327 0ab2 0190      		ld __tmp_reg__,Z+
 2328 0ab4 0020      		tst __tmp_reg__
 2329 0ab6 01F4      		brne 0b
 2330 0ab8 8F01      		movw r16,r30
 2331               	.LVL203:
 2332 0aba 0150      		subi r16,1
 2333 0abc 1109      		sbc r17,__zero_reg__
 2334               	.LVL204:
 571:main.c        ****     sms += strlen((char *)sms);
 2335               		.loc 1 571 0
 2336 0abe 60E0      		ldi r22,lo8(__c.3144)
 2337 0ac0 70E0      		ldi r23,hi8(__c.3144)
 2338 0ac2 C801      		movw r24,r16
 2339 0ac4 0E94 0000 		call strcpy_P
 2340               	.LVL205:
 572:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_7), sms, 10);
 2341               		.loc 1 572 0
 2342 0ac8 F801      		movw r30,r16
 2343               		0:
 2344 0aca 0190      		ld __tmp_reg__,Z+
 2345 0acc 0020      		tst __tmp_reg__
 2346 0ace 01F4      		brne 0b
 2347 0ad0 8F01      		movw r16,r30
 2348               	.LVL206:
 2349 0ad2 0150      		subi r16,1
 2350 0ad4 1109      		sbc r17,__zero_reg__
 2351               	.LVL207:
 573:main.c        ****     sms += strlen((char *)sms);
 2352               		.loc 1 573 0
 2353 0ad6 8CEE      		ldi r24,lo8(-20)
 2354 0ad8 9FE0      		ldi r25,lo8(15)
 2355 0ada 0E94 0000 		call eeprom_read_byte
 2356               	.LVL208:
 2357               	.LBB452:
 2358               	.LBB453:
 2359               		.loc 6 527 0
 2360 0ade 4AE0      		ldi r20,lo8(10)
 2361 0ae0 B801      		movw r22,r16
 2362 0ae2 90E0      		ldi r25,0
 2363 0ae4 0E94 0000 		call __utoa_ncheck
 2364               	.LVL209:
 2365               	.LBE453:
 2366               	.LBE452:
 574:main.c        ****     *sms++ = '\n';
 2367               		.loc 1 574 0
 2368 0ae8 F801      		movw r30,r16
 2369               		0:
 2370 0aea 0190      		ld __tmp_reg__,Z+
 2371 0aec 0020      		tst __tmp_reg__
 2372 0aee 01F4      		brne 0b
 2373 0af0 CF01      		movw r24,r30
 2374               	.LVL210:
 575:main.c        **** 
 2375               		.loc 1 575 0
 2376 0af2 0197      		sbiw r24,1
 2377               	.LVL211:
 2378 0af4 FC01      		movw r30,r24
 2379               	.LVL212:
 2380 0af6 F192      		st Z+,r15
 2381 0af8 CF01      		movw r24,r30
 2382               	.LVL213:
 577:main.c        **** 
 2383               		.loc 1 577 0
 2384 0afa 60E0      		ldi r22,lo8(__c.3146)
 2385 0afc 70E0      		ldi r23,hi8(__c.3146)
 2386 0afe 0E94 0000 		call strcpy_P
 2387               	.LVL214:
 579:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 2388               		.loc 1 579 0
 2389 0b02 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 2390 0b04 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 2391 0b06 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 2392 0b08 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 2393               	.L128:
 2394 0b0a 0E94 0000 		call strcpy
 2395               	.LVL215:
 581:main.c        ****     zapal_diode_led_blyski(2);
 2396               		.loc 1 581 0
 2397 0b0e 83ED      		ldi r24,lo8(-45)
 2398               	.L126:
 2399 0b10 0E94 0000 		call dodaj_komende
 2400               	.LVL216:
 2401               	.L125:
 582:main.c        ****     break;
 2402               		.loc 1 582 0
 2403 0b14 82E0      		ldi r24,lo8(2)
 2404 0b16 8093 0000 		sts liczba_blyskow_led,r24
 2405 0b1a 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 583:main.c        ****   }
 2406               		.loc 1 583 0
 2407 0b1e 00C0      		rjmp .L98
 2408               	.LVL217:
 2409               	.L103:
 2410               	.LBE439:
 2411               	.LBB454:
 586:main.c        ****     timer_report_user_100ms = OKNO_CZASOWE_REPORT_USER_100MS;
 2412               		.loc 1 586 0
 2413 0b20 8091 0000 		lds r24,licznik_report_user
 2414 0b24 8F5F      		subi r24,lo8(-(1))
 2415 0b26 8093 0000 		sts licznik_report_user,r24
 587:main.c        **** 
 2416               		.loc 1 587 0
 2417 0b2a 8CE2      		ldi r24,lo8(44)
 2418 0b2c 91E0      		ldi r25,lo8(1)
 2419 0b2e 9093 0000 		sts timer_report_user_100ms+1,r25
 2420 0b32 8093 0000 		sts timer_report_user_100ms,r24
 589:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 2421               		.loc 1 589 0
 2422 0b36 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 2423 0b38 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 2424 0b3a 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 2425 0b3c 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 2426 0b3e 0E94 0000 		call strcpy
 2427               	.LVL218:
 598:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
 2428               		.loc 1 598 0
 2429 0b42 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 2430 0b44 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 2431 0b46 FB01      		movw r30,r22
 2432               		0:
 2433 0b48 0190      		ld __tmp_reg__,Z+
 2434 0b4a 0020      		tst __tmp_reg__
 2435 0b4c 01F4      		brne 0b
 2436 0b4e BF01      		movw r22,r30
 2437 0b50 6150      		subi r22,1
 2438 0b52 7109      		sbc r23,__zero_reg__
 596:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
 2439               		.loc 1 596 0
 2440 0b54 AE01      		movw r20,r28
 2441 0b56 4E5E      		subi r20,-18
 2442 0b58 5F4F      		sbci r21,-1
 2443 0b5a 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 2444 0b5c 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 2445 0b5e 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 2446               	.LVL219:
 2447 0b62 88E0      		ldi r24,lo8(8)
 2448 0b64 C82E      		mov r12,r24
 2449 0b66 D12C      		mov r13,__zero_reg__
 2450               	.LVL220:
 2451               	.L109:
 2452               	.LBB455:
 606:main.c        ****               temp_buf, (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
 2453               		.loc 1 606 0
 2454 0b68 B601      		movw r22,r12
 2455 0b6a CE01      		movw r24,r28
 2456 0b6c 4296      		adiw r24,18
 2457 0b6e 0E94 0000 		call porownaj_numer_telefonu_blok
 2458               	.LVL221:
 2459 0b72 182F      		mov r17,r24
 2460 0b74 8111      		cpse r24,__zero_reg__
 2461 0b76 00C0      		rjmp .L115
 2462 0b78 F5E0      		ldi r31,5
 2463 0b7a CF0E      		add r12,r31
 2464 0b7c D11C      		adc r13,__zero_reg__
 604:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 2465               		.loc 1 604 0
 2466 0b7e 88EA      		ldi r24,-88
 2467 0b80 C816      		cp r12,r24
 2468 0b82 8FE0      		ldi r24,15
 2469 0b84 D806      		cpc r13,r24
 2470 0b86 01F4      		brne .L109
 2471               	.L108:
 2472               	.LVL222:
 2473               	.LBE455:
 616:main.c        ****                                      MAX_LICZBA_ZNAKOW_TELEFON + 1);
 2474               		.loc 1 616 0
 2475 0b88 41E1      		ldi r20,lo8(17)
 2476 0b8a BE01      		movw r22,r28
 2477 0b8c 6F5F      		subi r22,-1
 2478 0b8e 7F4F      		sbci r23,-1
 2479 0b90 CE01      		movw r24,r28
 2480 0b92 4296      		adiw r24,18
 2481 0b94 0E94 0000 		call konwertuj_blok_eeprom_na_telefon
 2482               	.LVL223:
 619:main.c        ****     strcat((char *)tekst_wysylanego_smsa, ": ");
 2483               		.loc 1 619 0
 2484 0b98 BE01      		movw r22,r28
 2485 0b9a 6F5F      		subi r22,-1
 2486 0b9c 7F4F      		sbci r23,-1
 2487 0b9e 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 2488 0ba0 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 2489 0ba2 0E94 0000 		call strcpy
 2490               	.LVL224:
 620:main.c        ****     if (znaleziono) {
 2491               		.loc 1 620 0
 2492 0ba6 60E0      		ldi r22,lo8(.LC3)
 2493 0ba8 70E0      		ldi r23,hi8(.LC3)
 2494 0baa 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 2495 0bac 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 2496 0bae 0E94 0000 		call strcat
 2497               	.LVL225:
 622:main.c        ****     } else {
 2498               		.loc 1 622 0
 2499 0bb2 60E0      		ldi r22,lo8(.LC4)
 2500 0bb4 70E0      		ldi r23,hi8(.LC4)
 621:main.c        ****       strcat((char *)tekst_wysylanego_smsa, "OK");
 2501               		.loc 1 621 0
 2502 0bb6 1111      		cpse r17,__zero_reg__
 2503 0bb8 00C0      		rjmp .L124
 2504               	.LVL226:
 624:main.c        ****     }
 2505               		.loc 1 624 0
 2506 0bba 60E0      		ldi r22,lo8(.LC5)
 2507 0bbc 70E0      		ldi r23,hi8(.LC5)
 2508               	.LVL227:
 2509               	.L124:
 2510 0bbe 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 2511 0bc0 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 2512 0bc2 0E94 0000 		call strcat
 2513               	.LVL228:
 627:main.c        **** 
 2514               		.loc 1 627 0
 2515 0bc6 83ED      		ldi r24,lo8(-45)
 2516 0bc8 0E94 0000 		call dodaj_komende
 2517               	.LVL229:
 629:main.c        **** 
 2518               		.loc 1 629 0
 2519 0bcc 82E0      		ldi r24,lo8(2)
 2520 0bce 8093 0000 		sts liczba_blyskow_led,r24
 2521 0bd2 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 633:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 2522               		.loc 1 633 0
 2523 0bd6 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 2524 0bda 8111      		cpse r24,__zero_reg__
 2525 0bdc 00C0      		rjmp .L112
 633:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 2526               		.loc 1 633 0 is_stmt 0 discriminator 1
 2527 0bde 8091 0000 		lds r24,liczba_znakow_do_zapisu
 2528 0be2 8111      		cpse r24,__zero_reg__
 2529 0be4 00C0      		rjmp .L112
 633:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 2530               		.loc 1 633 0 discriminator 2
 2531 0be6 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 2532 0bea 8111      		cpse r24,__zero_reg__
 2533 0bec 00C0      		rjmp .L112
 633:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 2534               		.loc 1 633 0 discriminator 3
 2535 0bee 8FB3      		in r24,0x1f
 2536               	.L112:
 641:main.c        ****     break;
 2537               		.loc 1 641 0 is_stmt 1
 2538 0bf0 612F      		mov r22,r17
 2539 0bf2 82E0      		ldi r24,lo8(2)
 2540 0bf4 00C0      		rjmp .L127
 2541               	.LVL230:
 2542               	.L115:
 2543               	.LBB456:
 608:main.c        ****         break;
 2544               		.loc 1 608 0
 2545 0bf6 1FEF      		ldi r17,lo8(-1)
 2546 0bf8 00C0      		rjmp .L108
 2547               	.LVL231:
 2548               	.L104:
 2549               	.LBE456:
 2550               	.LBE454:
 645:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 2551               		.loc 1 645 0
 2552 0bfa 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 2553 0bfc 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 2554 0bfe 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 2555 0c00 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 2556 0c02 0E94 0000 		call strcpy
 2557               	.LVL232:
 647:main.c        ****            "Wpisz numer jaki sprawdzasz, np: USER 793557357");
 2558               		.loc 1 647 0
 2559 0c06 60E0      		ldi r22,lo8(.LC6)
 2560 0c08 70E0      		ldi r23,hi8(.LC6)
 2561 0c0a 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 2562 0c0c 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 2563 0c0e 00C0      		rjmp .L128
 2564               	.LVL233:
 2565               	.L105:
 654:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 2566               		.loc 1 654 0
 2567 0c10 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 2568 0c12 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 2569 0c14 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 2570 0c16 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 2571 0c18 0E94 0000 		call strcpy
 2572               	.LVL234:
 656:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW);
 2573               		.loc 1 656 0
 2574 0c1c 1092 0000 		sts numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama,__zero_reg__
 657:main.c        ****     zapal_diode_led_blyski(2);
 2575               		.loc 1 657 0
 2576 0c20 89E8      		ldi r24,lo8(-119)
 2577 0c22 00C0      		rjmp .L126
 2578               	.LVL235:
 2579               	.L107:
 662:main.c        ****             KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 2580               		.loc 1 662 0
 2581 0c24 63E8      		ldi r22,lo8(-125)
 2582 0c26 82E0      		ldi r24,lo8(2)
 2583 0c28 0E94 0000 		call czy_sa_komendy_z_przedzialu
 2584               	.LVL236:
 2585 0c2c 8111      		cpse r24,__zero_reg__
 2586 0c2e 00C0      		rjmp .L98
 665:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
 2587               		.loc 1 665 0
 2588 0c30 89E1      		ldi r24,lo8(25)
 2589 0c32 8093 0000 		sts liczba_blyskow_led,r24
 2590 0c36 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 666:main.c        ****     }
 2591               		.loc 1 666 0
 2592 0c3a 83E0      		ldi r24,lo8(3)
 2593 0c3c 0E94 0000 		call dodaj_komende
 2594               	.LVL237:
 2595 0c40 00C0      		rjmp .L98
 2596               		.cfi_endproc
 2597               	.LFE39:
 2599               	.global	steruj_wejsciem_reset_100ms
 2601               	steruj_wejsciem_reset_100ms:
 2602               	.LFB40:
 677:main.c        ****   static uchar licznik_reset;
 2603               		.loc 1 677 0
 2604               		.cfi_startproc
 2605               	/* prologue: function */
 2606               	/* frame size = 0 */
 2607               	/* stack size = 0 */
 2608               	.L__stack_usage = 0
 2609 0c42 8091 0000 		lds r24,licznik_reset.3167
 679:main.c        ****     if (licznik_reset < 20 * 10)
 2610               		.loc 1 679 0
 2611 0c46 9091 0000 		lds r25,stan_logiczny_na_wejsciu
 2612 0c4a 90FF      		sbrs r25,0
 2613 0c4c 00C0      		rjmp .L130
 680:main.c        ****       ++licznik_reset;
 2614               		.loc 1 680 0
 2615 0c4e 883C      		cpi r24,lo8(-56)
 2616 0c50 00F4      		brsh .L129
 681:main.c        ****   } else {
 2617               		.loc 1 681 0
 2618 0c52 8F5F      		subi r24,lo8(-(1))
 2619 0c54 8093 0000 		sts licznik_reset.3167,r24
 2620 0c58 0895      		ret
 2621               	.L130:
 2622               	.LBB459:
 2623               	.LBB460:
 683:main.c        ****       if (not czy_sa_komendy_z_przedzialu(
 2624               		.loc 1 683 0
 2625 0c5a 883C      		cpi r24,lo8(-56)
 2626 0c5c 00F0      		brlo .L132
 684:main.c        ****               KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 2627               		.loc 1 684 0
 2628 0c5e 63E8      		ldi r22,lo8(-125)
 2629 0c60 82E0      		ldi r24,lo8(2)
 2630 0c62 0E94 0000 		call czy_sa_komendy_z_przedzialu
 2631               	.LVL238:
 2632 0c66 8111      		cpse r24,__zero_reg__
 2633 0c68 00C0      		rjmp .L134
 687:main.c        ****     } else if (licznik_reset >= 5 * 10) {
 2634               		.loc 1 687 0
 2635 0c6a 83E0      		ldi r24,lo8(3)
 2636               	.L136:
 692:main.c        ****     }
 2637               		.loc 1 692 0
 2638 0c6c 0E94 0000 		call dodaj_komende
 2639               	.LVL239:
 2640               	.L134:
 694:main.c        ****   }
 2641               		.loc 1 694 0
 2642 0c70 1092 0000 		sts licznik_reset.3167,__zero_reg__
 2643               	.L129:
 2644               	/* epilogue start */
 2645               	.LBE460:
 2646               	.LBE459:
 696:main.c        **** 
 2647               		.loc 1 696 0
 2648 0c74 0895      		ret
 2649               	.L132:
 2650               	.LBB462:
 2651               	.LBB461:
 688:main.c        ****       if (not czy_sa_komendy_z_przedzialu(
 2652               		.loc 1 688 0
 2653 0c76 8233      		cpi r24,lo8(50)
 2654 0c78 00F0      		brlo .L134
 689:main.c        ****               KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 2655               		.loc 1 689 0
 2656 0c7a 63E8      		ldi r22,lo8(-125)
 2657 0c7c 82E0      		ldi r24,lo8(2)
 2658 0c7e 0E94 0000 		call czy_sa_komendy_z_przedzialu
 2659               	.LVL240:
 2660 0c82 8111      		cpse r24,__zero_reg__
 2661 0c84 00C0      		rjmp .L134
 692:main.c        ****     }
 2662               		.loc 1 692 0
 2663 0c86 82E0      		ldi r24,lo8(2)
 2664 0c88 00C0      		rjmp .L136
 2665               	.LBE461:
 2666               	.LBE462:
 2667               		.cfi_endproc
 2668               	.LFE40:
 2670               	.global	sprawdz_przychodzaca_rozmowe
 2672               	sprawdz_przychodzaca_rozmowe:
 2673               	.LFB41:
 699:main.c        ****   // Super User: pozycje 795-800 omijaja wszystkie blokady
 2674               		.loc 1 699 0
 2675               		.cfi_startproc
 2676 0c8a CF93      		push r28
 2677               	.LCFI58:
 2678               		.cfi_def_cfa_offset 3
 2679               		.cfi_offset 28, -2
 2680 0c8c DF93      		push r29
 2681               	.LCFI59:
 2682               		.cfi_def_cfa_offset 4
 2683               		.cfi_offset 29, -3
 2684               	/* prologue: function */
 2685               	/* frame size = 0 */
 2686               	/* stack size = 2 */
 2687               	.L__stack_usage = 2
 701:main.c        ****       czy_numer_jest_super_userem(numer_telefonu_ktory_dzwoni);
 2688               		.loc 1 701 0
 2689 0c8e 80E0      		ldi r24,lo8(numer_telefonu_ktory_dzwoni)
 2690 0c90 90E0      		ldi r25,hi8(numer_telefonu_ktory_dzwoni)
 2691 0c92 0E94 0000 		call czy_numer_jest_super_userem
 2692               	.LVL241:
 704:main.c        ****     return FALSE; // Ignoruj rozmowy gdy system zablokowany (chyba ze super
 2693               		.loc 1 704 0
 2694 0c96 9091 0000 		lds r25,blokada_systemu
 2695 0c9a 9923      		tst r25
 2696 0c9c 01F0      		breq .L138
 704:main.c        ****     return FALSE; // Ignoruj rozmowy gdy system zablokowany (chyba ze super
 2697               		.loc 1 704 0 is_stmt 0 discriminator 1
 2698 0c9e 8111      		cpse r24,__zero_reg__
 2699 0ca0 00C0      		rjmp .L138
 2700               	.LVL242:
 2701               	.L141:
 705:main.c        ****                   // user)
 2702               		.loc 1 705 0 is_stmt 1
 2703 0ca2 80E0      		ldi r24,0
 2704               	.L137:
 2705               	/* epilogue start */
 750:main.c        **** 
 2706               		.loc 1 750 0
 2707 0ca4 DF91      		pop r29
 2708 0ca6 CF91      		pop r28
 2709 0ca8 0895      		ret
 2710               	.LVL243:
 2711               	.L138:
 709:main.c        ****     return FALSE; // Ignoruj rozmowy gdy blokada czasowa (chyba ze super user)
 2712               		.loc 1 709 0
 2713 0caa 9091 0000 		lds r25,blokada_sterowania_czasowa
 2714 0cae 9923      		tst r25
 2715 0cb0 01F0      		breq .L140
 709:main.c        ****     return FALSE; // Ignoruj rozmowy gdy blokada czasowa (chyba ze super user)
 2716               		.loc 1 709 0 is_stmt 0 discriminator 1
 2717 0cb2 8823      		tst r24
 2718 0cb4 01F0      		breq .L141
 2719               	.L140:
 2720 0cb6 8091 0000 		lds r24,numer_telefonu_ktory_dzwoni
 2721               	.LVL244:
 714:main.c        ****     if (numer_telefonu_ktory_dzwoni[0] != 0)
 2722               		.loc 1 714 0 is_stmt 1
 2723 0cba 9091 0000 		lds r25,tryb_clip
 2724 0cbe 9111      		cpse r25,__zero_reg__
 2725 0cc0 00C0      		rjmp .L142
 715:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA);
 2726               		.loc 1 715 0
 2727 0cc2 8823      		tst r24
 2728 0cc4 01F0      		breq .L143
 716:main.c        **** 
 2729               		.loc 1 716 0
 2730 0cc6 84E8      		ldi r24,lo8(-124)
 2731 0cc8 0E94 0000 		call dodaj_komende
 2732               	.LVL245:
 2733               	.L143:
 719:main.c        ****       return TRUE;
 2734               		.loc 1 719 0
 2735 0ccc 8091 0000 		lds r24,tryb_pracy
 2736 0cd0 8130      		cpi r24,lo8(1)
 2737 0cd2 01F4      		brne .L144
 2738               	.L145:
 720:main.c        **** 
 2739               		.loc 1 720 0
 2740 0cd4 8FEF      		ldi r24,lo8(-1)
 2741 0cd6 00C0      		rjmp .L137
 2742               	.L144:
 2743               	.LBB466:
 2744               	.LBB467:
 725:main.c        ****                                          (char *)numer_telefonu_ktory_dzwoni)],
 2745               		.loc 1 725 0
 2746 0cd8 60E0      		ldi r22,lo8(numer_telefonu_ktory_dzwoni)
 2747 0cda 70E0      		ldi r23,hi8(numer_telefonu_ktory_dzwoni)
 2748 0cdc FB01      		movw r30,r22
 2749               		0:
 2750 0cde 0190      		ld __tmp_reg__,Z+
 2751 0ce0 0020      		tst __tmp_reg__
 2752 0ce2 01F4      		brne 0b
 2753 0ce4 BF01      		movw r22,r30
 2754 0ce6 6150      		subi r22,1
 2755 0ce8 7109      		sbc r23,__zero_reg__
 724:main.c        ****                                      &numer_telefonu_ktory_dzwoni[strlen(
 2756               		.loc 1 724 0
 2757 0cea 40E0      		ldi r20,lo8(bufor_eeprom)
 2758 0cec 50E0      		ldi r21,hi8(bufor_eeprom)
 2759 0cee 80E0      		ldi r24,lo8(numer_telefonu_ktory_dzwoni)
 2760 0cf0 90E0      		ldi r25,hi8(numer_telefonu_ktory_dzwoni)
 2761 0cf2 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 2762               	.LVL246:
 2763 0cf6 C8E0      		ldi r28,lo8(8)
 2764 0cf8 D0E0      		ldi r29,0
 2765               	.LVL247:
 2766               	.L146:
 2767               	.LBB468:
 732:main.c        ****               &bufor_eeprom[0], (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt))) {
 2768               		.loc 1 732 0
 2769 0cfa BE01      		movw r22,r28
 2770 0cfc 80E0      		ldi r24,lo8(bufor_eeprom)
 2771 0cfe 90E0      		ldi r25,hi8(bufor_eeprom)
 2772 0d00 0E94 0000 		call porownaj_numer_telefonu_blok
 2773               	.LVL248:
 2774 0d04 8111      		cpse r24,__zero_reg__
 2775 0d06 00C0      		rjmp .L145
 2776 0d08 2596      		adiw r28,5
 730:main.c        ****          ++nr_uzyt) {
 2777               		.loc 1 730 0
 2778 0d0a C83A      		cpi r28,-88
 2779 0d0c FFE0      		ldi r31,15
 2780 0d0e DF07      		cpc r29,r31
 2781 0d10 01F4      		brne .L146
 2782 0d12 00C0      		rjmp .L141
 2783               	.L142:
 2784               	.LBE468:
 2785               	.LBE467:
 2786               	.LBE466:
 741:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA);
 2787               		.loc 1 741 0
 2788 0d14 8823      		tst r24
 2789 0d16 01F0      		breq .L147
 742:main.c        **** 
 2790               		.loc 1 742 0
 2791 0d18 84E8      		ldi r24,lo8(-124)
 2792 0d1a 0E94 0000 		call dodaj_komende
 2793               	.LVL249:
 2794               	.L147:
 745:main.c        ****     return TRUE;
 2795               		.loc 1 745 0
 2796 0d1e 81E0      		ldi r24,lo8(1)
 2797 0d20 9091 0000 		lds r25,tryb_pracy
 2798 0d24 9130      		cpi r25,lo8(1)
 2799 0d26 01F0      		breq .L148
 2800 0d28 80E0      		ldi r24,0
 2801               	.L148:
 2802 0d2a 8195      		neg r24
 2803 0d2c 00C0      		rjmp .L137
 2804               		.cfi_endproc
 2805               	.LFE41:
 2807               	.global	zakonczono_rozmowe_telefoniczna
 2809               	zakonczono_rozmowe_telefoniczna:
 2810               	.LFB42:
 772:main.c        ****   POMOC_DODAJ2('#', 'a');
 2811               		.loc 1 772 0
 2812               		.cfi_startproc
 2813               	.LVL250:
 2814               	/* prologue: function */
 2815               	/* frame size = 0 */
 2816               	/* stack size = 0 */
 2817               	.L__stack_usage = 0
 774:main.c        ****   licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 2818               		.loc 1 774 0
 2819 0d2e 8CE3      		ldi r24,lo8(60)
 2820               	.LVL251:
 2821 0d30 8093 0000 		sts opoznienie_SIM900_100MS,r24
 775:main.c        ****   ustaw_maksymalny_czas_dzwonienia = 0;
 2822               		.loc 1 775 0
 2823 0d34 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 2824 0d38 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 776:main.c        ****   maksymalny_czas_dzwonienia = 0;
 2825               		.loc 1 776 0
 2826 0d3c 1092 0000 		sts ustaw_maksymalny_czas_dzwonienia,__zero_reg__
 777:main.c        ****   blokada_clip = FALSE;
 2827               		.loc 1 777 0
 2828 0d40 1092 0000 		sts maksymalny_czas_dzwonienia,__zero_reg__
 778:main.c        **** }
 2829               		.loc 1 778 0
 2830 0d44 1092 0000 		sts blokada_clip,__zero_reg__
 2831               	/* epilogue start */
 779:main.c        **** 
 2832               		.loc 1 779 0
 2833 0d48 0895      		ret
 2834               		.cfi_endproc
 2835               	.LFE42:
 2837               	.global	zakonczono_wysylanie_smsa
 2839               	zakonczono_wysylanie_smsa:
 2840               	.LFB43:
 788:main.c        ****   POMOC_DODAJ2('#', 'A');
 2841               		.loc 1 788 0
 2842               		.cfi_startproc
 2843               	.LVL252:
 2844               	/* prologue: function */
 2845               	/* frame size = 0 */
 2846               	/* stack size = 0 */
 2847               	.L__stack_usage = 0
 790:main.c        **** 
 2848               		.loc 1 790 0
 2849 0d4a 8CE3      		ldi r24,lo8(60)
 2850               	.LVL253:
 2851 0d4c 8093 0000 		sts opoznienie_SIM900_100MS,r24
 792:main.c        **** }
 2852               		.loc 1 792 0
 2853 0d50 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 2854               	/* epilogue start */
 793:main.c        **** 
 2855               		.loc 1 793 0
 2856 0d54 0895      		ret
 2857               		.cfi_endproc
 2858               	.LFE43:
 2860               	.global	problem_z_wyslaniem_powiadomienia
 2862               	problem_z_wyslaniem_powiadomienia:
 2863               	.LFB44:
 795:main.c        ****   wykonywanie_rozmowy_telefonicznej = FALSE;
 2864               		.loc 1 795 0
 2865               		.cfi_startproc
 2866               	/* prologue: function */
 2867               	/* frame size = 0 */
 2868               	/* stack size = 0 */
 2869               	.L__stack_usage = 0
 796:main.c        ****   licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 2870               		.loc 1 796 0
 2871 0d56 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 797:main.c        ****   wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 2872               		.loc 1 797 0
 2873 0d5a 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 2874 0d5e 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 798:main.c        ****   czekanie_na_odebranie_zachety = FALSE;
 2875               		.loc 1 798 0
 2876 0d62 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 2877 0d66 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 2878 0d6a 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
 799:main.c        ****   opoznienie_SIM900_100MS = 60;
 2879               		.loc 1 799 0
 2880 0d6e 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
 800:main.c        ****   flaga_wysylanie_smsa = 0;
 2881               		.loc 1 800 0
 2882 0d72 8CE3      		ldi r24,lo8(60)
 2883 0d74 8093 0000 		sts opoznienie_SIM900_100MS,r24
 801:main.c        **** }
 2884               		.loc 1 801 0
 2885 0d78 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
 2886               	/* epilogue start */
 802:main.c        **** 
 2887               		.loc 1 802 0
 2888 0d7c 0895      		ret
 2889               		.cfi_endproc
 2890               	.LFE44:
 2892               	.global	wyzerowanie_danych_SIM900
 2894               	wyzerowanie_danych_SIM900:
 2895               	.LFB45:
   6:main_sim900.h ****   POMOC_DODAJ2('*', 't');
 2896               		.loc 2 6 0
 2897               		.cfi_startproc
 2898               	/* prologue: function */
 2899               	/* frame size = 0 */
 2900               	/* stack size = 0 */
 2901               	.L__stack_usage = 0
 2902               	.LVL254:
   8:main_sim900.h ****   licznik_wysylane_polecenie_SIM900 = 0;
 2903               		.loc 2 8 0
 2904 0d7e 0E94 0000 		call problem_z_wyslaniem_powiadomienia
 2905               	.LVL255:
   9:main_sim900.h ****   aktualnie_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 2906               		.loc 2 9 0
 2907 0d82 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 2908 0d86 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
  10:main_sim900.h ****   liczba_komend_w_kolejce_SIM900 = 0;
 2909               		.loc 2 10 0
 2910 0d8a 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
  11:main_sim900.h ****   licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow = 0;
 2911               		.loc 2 11 0
 2912 0d8e 1092 0000 		sts liczba_komend_w_kolejce_SIM900,__zero_reg__
  12:main_sim900.h ****   czekanie_na_odebranie_zachety = FALSE;
 2913               		.loc 2 12 0
 2914 0d92 1092 0000 		sts licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow,__zero_reg__
  13:main_sim900.h ****   flaga_odebrany_znak_zachety = FALSE;
 2915               		.loc 2 13 0
 2916 0d96 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
  14:main_sim900.h ****   trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 2917               		.loc 2 14 0
 2918 0d9a 1092 0000 		sts flaga_odebrany_znak_zachety,__zero_reg__
  15:main_sim900.h ****   wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
 2919               		.loc 2 15 0
 2920 0d9e 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
  16:main_sim900.h ****   flaga_odczytywanie_smsa = FALSE;
 2921               		.loc 2 16 0
 2922 0da2 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
  17:main_sim900.h **** }
 2923               		.loc 2 17 0
 2924 0da6 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 2925               	/* epilogue start */
  18:main_sim900.h **** 
 2926               		.loc 2 18 0
 2927 0daa 0895      		ret
 2928               		.cfi_endproc
 2929               	.LFE45:
 2931               	.global	reset_modulu_SIM900
 2933               	reset_modulu_SIM900:
 2934               	.LFB46:
  20:main_sim900.h ****   wyzerowanie_danych_SIM900();
 2935               		.loc 2 20 0
 2936               		.cfi_startproc
 2937               	/* prologue: function */
 2938               	/* frame size = 0 */
 2939               	/* stack size = 0 */
 2940               	.L__stack_usage = 0
  21:main_sim900.h ****   POMOC_DODAJ2('*', 'm');
 2941               		.loc 2 21 0
 2942 0dac 0E94 0000 		call wyzerowanie_danych_SIM900
 2943               	.LVL256:
  23:main_sim900.h ****   podlaczony_modul_gsm_SIM900 = FALSE;
 2944               		.loc 2 23 0
 2945 0db0 86E9      		ldi r24,lo8(-106)
 2946 0db2 8093 0000 		sts licznik_100ms_procedura_inicjalizacyjna_SIM900,r24
  24:main_sim900.h ****   podlaczona_karta_SIM_SIM900 = FALSE;
 2947               		.loc 2 24 0
 2948 0db6 1092 0000 		sts podlaczony_modul_gsm_SIM900,__zero_reg__
  25:main_sim900.h ****   licznik_blad_stanu_karty_SIM = 0;
 2949               		.loc 2 25 0
 2950 0dba 1092 0000 		sts podlaczona_karta_SIM_SIM900,__zero_reg__
  26:main_sim900.h ****   licznik_blad_zalogowania_u_operatora = 0;
 2951               		.loc 2 26 0
 2952 0dbe 1092 0000 		sts licznik_blad_stanu_karty_SIM,__zero_reg__
  27:main_sim900.h ****   nazwa_operatora[0] = '\0';
 2953               		.loc 2 27 0
 2954 0dc2 1092 0000 		sts licznik_blad_zalogowania_u_operatora,__zero_reg__
  28:main_sim900.h ****   licznik_ogolny_blad_zalogowania = 0;
 2955               		.loc 2 28 0
 2956 0dc6 1092 0000 		sts nazwa_operatora,__zero_reg__
  29:main_sim900.h ****   blokada_clip = FALSE;
 2957               		.loc 2 29 0
 2958 0dca 1092 0000 		sts licznik_ogolny_blad_zalogowania+1,__zero_reg__
 2959 0dce 1092 0000 		sts licznik_ogolny_blad_zalogowania,__zero_reg__
  30:main_sim900.h ****   nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 2960               		.loc 2 30 0
 2961 0dd2 1092 0000 		sts blokada_clip,__zero_reg__
  31:main_sim900.h ****   poziom_sieci_gsm = POZIOM_SIECI_BLAD;
 2962               		.loc 2 31 0
 2963 0dd6 1092 0000 		sts nastepne_wysylane_polecenie_SIM900,__zero_reg__
  32:main_sim900.h ****   filtruj_komendy_z_przedzialu(KOMENDA_KOLEJKI_USUN_SMSA_1,
 2964               		.loc 2 32 0
 2965 0dda 83E6      		ldi r24,lo8(99)
 2966 0ddc 8093 0000 		sts poziom_sieci_gsm,r24
  33:main_sim900.h ****                                KOMENDA_KOLEJKI_USUN_SMSA_20);
 2967               		.loc 2 33 0
 2968 0de0 61ED      		ldi r22,lo8(-47)
 2969 0de2 8EEB      		ldi r24,lo8(-66)
 2970 0de4 0E94 0000 		call filtruj_komendy_z_przedzialu
 2971               	.LVL257:
  35:main_sim900.h ****       KOMENDA_KOLEJKI_KOMENDA_SIM900,
 2972               		.loc 2 35 0
 2973 0de8 6EE9      		ldi r22,lo8(-98)
 2974 0dea 8AE8      		ldi r24,lo8(-118)
 2975 0dec 0E94 0000 		call filtruj_komendy_z_przedzialu
 2976               	.LVL258:
  38:main_sim900.h ****       KOMENDA_KOLEJKI_SPRAWDZ_PIN,
 2977               		.loc 2 38 0
 2978 0df0 68EA      		ldi r22,lo8(-88)
 2979 0df2 8FE9      		ldi r24,lo8(-97)
 2980 0df4 0E94 0000 		call filtruj_komendy_z_przedzialu
 2981               	.LVL259:
  41:main_sim900.h ****                                KOMENDA_KOLEJKI_WYSLIJ_PDU);
 2982               		.loc 2 41 0
 2983 0df8 65ED      		ldi r22,lo8(-43)
 2984 0dfa 83ED      		ldi r24,lo8(-45)
 2985 0dfc 0E94 0000 		call filtruj_komendy_z_przedzialu
 2986               	.LVL260:
  43:main_sim900.h **** }
 2987               		.loc 2 43 0
 2988 0e00 1092 0000 		sts modul_zalogowany_w_sieci,__zero_reg__
 2989               	/* epilogue start */
  44:main_sim900.h **** 
 2990               		.loc 2 44 0
 2991 0e04 0895      		ret
 2992               		.cfi_endproc
 2993               	.LFE46:
 2995               	.global	obsluga_wysylania_sms
 2997               	obsluga_wysylania_sms:
 2998               	.LFB49:
  52:main_sim900.h **** }
  53:main_sim900.h **** 
  54:main_sim900.h **** void obsluga_wysylania_sms(void) {
 2999               		.loc 2 54 0
 3000               		.cfi_startproc
 3001               	/* prologue: function */
 3002               	/* frame size = 0 */
 3003               	/* stack size = 0 */
 3004               	.L__stack_usage = 0
 3005               	.LVL261:
  55:main_sim900.h ****   POMOC_DODAJ2('#', 'M');
  56:main_sim900.h ****   if (czy_jest_komenda_wyslano_sms()) {
 3006               		.loc 2 56 0
 3007 0e06 8091 0000 		lds r24,komenda_SIM900
 3008 0e0a 8D30      		cpi r24,lo8(13)
 3009 0e0c 01F4      		brne .L174
 3010               	.LVL262:
  57:main_sim900.h ****     POMOC_DODAJ2('#', 'T');
  58:main_sim900.h ****     liczba_prob_wyslania_smsa = 0;
 3011               		.loc 2 58 0
 3012 0e0e 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
 3013               	.LVL263:
 3014               	.LBB489:
 3015               	.LBB490:
 792:main.c        **** }
 3016               		.loc 1 792 0
 3017 0e12 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 3018               	.LBE490:
 3019               	.LBE489:
  59:main_sim900.h ****     zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_ok);
  60:main_sim900.h ****     flaga_wysylanie_smsa = 0;
 3020               		.loc 2 60 0
 3021 0e16 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
  61:main_sim900.h ****     opoznienie_SIM900_100MS = 70;
 3022               		.loc 2 61 0
 3023 0e1a 86E4      		ldi r24,lo8(70)
 3024 0e1c 8093 0000 		sts opoznienie_SIM900_100MS,r24
  62:main_sim900.h ****     return;
 3025               		.loc 2 62 0
 3026 0e20 0895      		ret
 3027               	.LVL264:
 3028               	.L174:
  63:main_sim900.h ****   } else if (
  64:main_sim900.h ****       czy_jest_komenda_blad_CMS()) // spawdzi
 3029               		.loc 2 64 0
 3030 0e22 8091 0000 		lds r24,komenda_SIM900
  63:main_sim900.h ****   } else if (
 3031               		.loc 2 63 0
 3032 0e26 8630      		cpi r24,lo8(6)
 3033 0e28 01F4      		brne .L176
  65:main_sim900.h ****                                    // czy_modul_byl_polaczony_z_internetem
  66:main_sim900.h ****   {
  67:main_sim900.h ****     ++liczba_prob_wyslania_smsa;
 3034               		.loc 2 67 0
 3035 0e2a 2091 0000 		lds r18,liczba_prob_wyslania_smsa
 3036 0e2e 2F5F      		subi r18,lo8(-(1))
 3037 0e30 2093 0000 		sts liczba_prob_wyslania_smsa,r18
  68:main_sim900.h ****     if (numer_bledu_cms == CMS_SM_BL_NOT_READY ||
 3038               		.loc 2 68 0
 3039 0e34 8091 0000 		lds r24,numer_bledu_cms
 3040 0e38 9091 0000 		lds r25,numer_bledu_cms+1
 3041 0e3c 8530      		cpi r24,5
 3042 0e3e 32E0      		ldi r19,2
 3043 0e40 9307      		cpc r25,r19
 3044 0e42 01F0      		breq .L177
 3045               		.loc 2 68 0 is_stmt 0 discriminator 1
 3046 0e44 8A33      		cpi r24,58
 3047 0e46 31E0      		ldi r19,1
 3048 0e48 9307      		cpc r25,r19
 3049 0e4a 01F0      		breq .L177
  69:main_sim900.h ****         numer_bledu_cms == CMS_SIM_BUSY ||
 3050               		.loc 2 69 0 is_stmt 1
 3051 0e4c 8330      		cpi r24,3
 3052 0e4e 32E0      		ldi r19,2
 3053 0e50 9307      		cpc r25,r19
 3054 0e52 01F0      		breq .L177
  70:main_sim900.h ****         numer_bledu_cms == CMS_PC_BUSY // powinien by reset
  71:main_sim900.h ****         || numer_bledu_cms == CMS_INVALID_CHARS_IN_PDU ||
 3055               		.loc 2 71 0
 3056 0e54 8051      		subi r24,16
 3057 0e56 9240      		sbci r25,2
 3058 0e58 0297      		sbiw r24,2
 3059 0e5a 00F4      		brsh .L178
 3060               	.L177:
  72:main_sim900.h ****         numer_bledu_cms == CMS_INCORECT_PDU_LENGTH) {
  73:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 3061               		.loc 2 73 0
 3062 0e5c 8CE3      		ldi r24,lo8(60)
 3063 0e5e 8093 0000 		sts opoznienie_SIM900_100MS,r24
  74:main_sim900.h ****       if (liczba_prob_wyslania_smsa < max_liczba_prob_wyslania_smsa) {
  75:main_sim900.h ****         POMOC_DODAJ2('#', 'C');
  76:main_sim900.h ****         POMOC_DODAJ_HEX(numer_bledu_cms >> 8);
  77:main_sim900.h ****         POMOC_DODAJ_HEX(numer_bledu_cms & 0xff);
  78:main_sim900.h ****         dodaj_komende(flaga_wysylanie_smsa);
 3064               		.loc 2 78 0
 3065 0e62 8091 0000 		lds r24,flaga_wysylanie_smsa
  74:main_sim900.h ****       if (liczba_prob_wyslania_smsa < max_liczba_prob_wyslania_smsa) {
 3066               		.loc 2 74 0
 3067 0e66 2230      		cpi r18,lo8(2)
 3068 0e68 00F0      		brlo .L202
 3069               	.LVL265:
 3070               	.L203:
  79:main_sim900.h ****       } else {
  80:main_sim900.h ****         POMOC_DODAJ2('#', 'D');
  81:main_sim900.h ****         POMOC_DODAJ_HEX(numer_bledu_cms >> 8);
  82:main_sim900.h ****         POMOC_DODAJ_HEX(numer_bledu_cms & 0xff);
  83:main_sim900.h ****         liczba_prob_wyslania_smsa = 0;
  84:main_sim900.h ****         zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
  85:main_sim900.h ****       }
  86:main_sim900.h ****     } else {
  87:main_sim900.h ****       POMOC_DODAJ2('#', 'F');
  88:main_sim900.h ****       POMOC_DODAJ_HEX(numer_bledu_cms >> 8);
  89:main_sim900.h ****       POMOC_DODAJ_HEX(numer_bledu_cms & 0xff);
  90:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
  91:main_sim900.h ****       liczba_prob_wyslania_smsa = 0;
 3071               		.loc 2 91 0
 3072 0e6a 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
 3073               	.LVL266:
 3074               	.LBB491:
 3075               	.LBB492:
 792:main.c        **** }
 3076               		.loc 1 792 0
 3077 0e6e 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 3078               	.LVL267:
 3079               	.L180:
 3080               	.LBE492:
 3081               	.LBE491:
  92:main_sim900.h ****       zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
  93:main_sim900.h ****     }
  94:main_sim900.h ****     flaga_wysylanie_smsa = 0;
 3082               		.loc 2 94 0
 3083 0e72 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
 3084 0e76 0895      		ret
 3085               	.LVL268:
 3086               	.L178:
  90:main_sim900.h ****       liczba_prob_wyslania_smsa = 0;
 3087               		.loc 2 90 0
 3088 0e78 8CE3      		ldi r24,lo8(60)
 3089 0e7a 8093 0000 		sts opoznienie_SIM900_100MS,r24
 3090 0e7e 00C0      		rjmp .L203
 3091               	.LVL269:
 3092               	.L176:
 3093               	.LBB493:
 3094               	.LBB494:
  95:main_sim900.h ****   } else if (czy_jest_komenda_ERROR()) {
 3095               		.loc 2 95 0
 3096 0e80 8091 0000 		lds r24,komenda_SIM900
 3097 0e84 8430      		cpi r24,lo8(4)
 3098 0e86 01F4      		brne .L181
 3099               	.LVL270:
  96:main_sim900.h ****     POMOC_DODAJ2('#', 'G');
  97:main_sim900.h ****     opoznienie_SIM900_100MS = 60;
 3100               		.loc 2 97 0
 3101 0e88 8CE3      		ldi r24,lo8(60)
 3102 0e8a 8093 0000 		sts opoznienie_SIM900_100MS,r24
  98:main_sim900.h ****     czekanie_na_odebranie_zachety = FALSE;
 3103               		.loc 2 98 0
 3104 0e8e 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
  99:main_sim900.h ****     if ((odebrany_blok_SIM900[2] == '>' &&
 3105               		.loc 2 99 0
 3106 0e92 8091 0000 		lds r24,odebrany_blok_SIM900+2
 3107 0e96 8E33      		cpi r24,lo8(62)
 3108 0e98 01F4      		brne .L182
 100:main_sim900.h ****          liczba_odebranych_znakow_SIM900 < 10) ||
 3109               		.loc 2 100 0
 3110 0e9a 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 3111 0e9e 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
  99:main_sim900.h ****     if ((odebrany_blok_SIM900[2] == '>' &&
 3112               		.loc 2 99 0
 3113 0ea2 0A97      		sbiw r24,10
 3114 0ea4 00F0      		brlo .L183
 3115               	.L182:
 101:main_sim900.h ****         flaga_wysylanie_smsa == 0) // SIM900 nie odpowiada
 3116               		.loc 2 101 0
 3117 0ea6 8091 0000 		lds r24,flaga_wysylanie_smsa
 100:main_sim900.h ****          liczba_odebranych_znakow_SIM900 < 10) ||
 3118               		.loc 2 100 0
 3119 0eaa 8111      		cpse r24,__zero_reg__
 3120 0eac 00C0      		rjmp .L184
 3121               	.L183:
 3122               	.LVL271:
 102:main_sim900.h ****     {
 103:main_sim900.h ****       POMOC_DODAJ2('#', 'H');
 104:main_sim900.h ****       liczba_prob_wyslania_smsa = 0;
 3123               		.loc 2 104 0
 3124 0eae 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
 3125               	.LVL272:
 3126               	.LBB495:
 3127               	.LBB496:
 792:main.c        **** }
 3128               		.loc 1 792 0
 3129 0eb2 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 3130               	.LBE496:
 3131               	.LBE495:
 105:main_sim900.h ****       zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
 106:main_sim900.h ****       reset_modulu_SIM900();
 3132               		.loc 2 106 0
 3133 0eb6 0E94 0000 		call reset_modulu_SIM900
 3134               	.LVL273:
 3135 0eba 00C0      		rjmp .L180
 3136               	.LVL274:
 3137               	.L184:
 107:main_sim900.h ****     } else {
 108:main_sim900.h ****       POMOC_DODAJ2('#', 'I');
 109:main_sim900.h ****       if (++liczba_prob_wyslania_smsa <
 3138               		.loc 2 109 0
 3139 0ebc 9091 0000 		lds r25,liczba_prob_wyslania_smsa
 3140 0ec0 9F5F      		subi r25,lo8(-(1))
 3141 0ec2 9093 0000 		sts liczba_prob_wyslania_smsa,r25
 3142 0ec6 9230      		cpi r25,lo8(2)
 3143 0ec8 00F4      		brsh .L203
 3144               	.LVL275:
 3145               	.L202:
 110:main_sim900.h ****           max_liczba_prob_wyslania_smsa) // musi by sta wartoci
 111:main_sim900.h ****         dodaj_komende(flaga_wysylanie_smsa);
 3146               		.loc 2 111 0
 3147 0eca 0E94 0000 		call dodaj_komende
 3148               	.LVL276:
 3149 0ece 00C0      		rjmp .L180
 3150               	.LVL277:
 3151               	.L181:
 112:main_sim900.h ****       else {
 113:main_sim900.h ****         liczba_prob_wyslania_smsa = 0;
 114:main_sim900.h ****         zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
 115:main_sim900.h ****       }
 116:main_sim900.h ****     }
 117:main_sim900.h ****     flaga_wysylanie_smsa = 0;
 118:main_sim900.h ****   } else if (czy_jest_komenda_blad_CME()) {
 3152               		.loc 2 118 0
 3153 0ed0 8091 0000 		lds r24,komenda_SIM900
 3154 0ed4 8530      		cpi r24,lo8(5)
 3155 0ed6 01F4      		brne .L185
 3156               	.LVL278:
 119:main_sim900.h ****     POMOC_DODAJ2('#', 'J');
 120:main_sim900.h ****     POMOC_DODAJ_HEX(numer_bledu_cme >> 8);
 3157               		.loc 2 120 0
 3158 0ed8 8091 0000 		lds r24,numer_bledu_cme
 3159 0edc 9091 0000 		lds r25,numer_bledu_cme+1
 3160               	.LVL279:
 121:main_sim900.h ****     POMOC_DODAJ_HEX(numer_bledu_cme & 0xff);
 122:main_sim900.h ****     if (numer_bledu_cme == CME_SIM_NOT_INSERTED ||
 3161               		.loc 2 122 0
 3162 0ee0 8A30      		cpi r24,10
 3163 0ee2 9105      		cpc r25,__zero_reg__
 3164 0ee4 01F0      		breq .L186
 3165 0ee6 9C01      		movw r18,r24
 3166 0ee8 2D7F      		andi r18,253
 3167 0eea 2D30      		cpi r18,13
 3168 0eec 3105      		cpc r19,__zero_reg__
 3169 0eee 01F0      		breq .L186
 123:main_sim900.h ****         numer_bledu_cme == CME_SIM_FAILURE ||
 124:main_sim900.h ****         numer_bledu_cme == CME_SIM_WRONG ||
 3170               		.loc 2 124 0
 3171 0ef0 4E97      		sbiw r24,30
 3172 0ef2 01F4      		brne .L173
 3173               	.L186:
 3174               	.LVL280:
 125:main_sim900.h ****         numer_bledu_cme == CME_NO_NETWORK_SERVICE) {
 126:main_sim900.h ****       POMOC_DODAJ2('#', 'K');
 127:main_sim900.h ****       liczba_prob_wyslania_smsa = 0;
 3175               		.loc 2 127 0
 3176 0ef4 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
 3177               	.LVL281:
 3178               	.LBB497:
 3179               	.LBB498:
 790:main.c        **** 
 3180               		.loc 1 790 0
 3181 0ef8 8CE3      		ldi r24,lo8(60)
 3182               	.LVL282:
 3183 0efa 8093 0000 		sts opoznienie_SIM900_100MS,r24
 792:main.c        **** }
 3184               		.loc 1 792 0
 3185 0efe 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 3186               	.LBE498:
 3187               	.LBE497:
 128:main_sim900.h ****       zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
 129:main_sim900.h ****       reset_modulu_SIM900();
 3188               		.loc 2 129 0
 3189 0f02 0C94 0000 		jmp reset_modulu_SIM900
 3190               	.LVL283:
 3191               	.L185:
 130:main_sim900.h ****     }
 131:main_sim900.h ****   } else {
 132:main_sim900.h ****     POMOC_DODAJ2('#', 'L');
 133:main_sim900.h ****     POMOC_DODAJ_HEX(komenda_SIM900 >> 8);
 3192               		.loc 2 133 0
 3193 0f06 8091 0000 		lds r24,komenda_SIM900
 3194               	.LVL284:
 134:main_sim900.h ****     POMOC_DODAJ_HEX(komenda_SIM900 & 0xff);
 3195               		.loc 2 134 0
 3196 0f0a 8091 0000 		lds r24,komenda_SIM900
 3197               	.LVL285:
 3198               	.L173:
 3199               	/* epilogue start */
 3200               	.LBE494:
 3201               	.LBE493:
 135:main_sim900.h ****   }
 136:main_sim900.h **** }
 3202               		.loc 2 136 0
 3203 0f0e 0895      		ret
 3204               		.cfi_endproc
 3205               	.LFE49:
 3207               	.global	odpowiedz_na_polecenie
 3209               	odpowiedz_na_polecenie:
 3210               	.LFB50:
 137:main_sim900.h **** 
 138:main_sim900.h **** void odpowiedz_na_polecenie(void) {
 3211               		.loc 2 138 0
 3212               		.cfi_startproc
 3213 0f10 0F93      		push r16
 3214               	.LCFI60:
 3215               		.cfi_def_cfa_offset 3
 3216               		.cfi_offset 16, -2
 3217 0f12 1F93      		push r17
 3218               	.LCFI61:
 3219               		.cfi_def_cfa_offset 4
 3220               		.cfi_offset 17, -3
 3221 0f14 CF93      		push r28
 3222               	.LCFI62:
 3223               		.cfi_def_cfa_offset 5
 3224               		.cfi_offset 28, -4
 3225 0f16 DF93      		push r29
 3226               	.LCFI63:
 3227               		.cfi_def_cfa_offset 6
 3228               		.cfi_offset 29, -5
 3229               	/* prologue: function */
 3230               	/* frame size = 0 */
 3231               	/* stack size = 4 */
 3232               	.L__stack_usage = 4
 139:main_sim900.h **** #define czy_polecenie_sim(POL) czy_polecenie_SIM900(POL, sizeof POL - 1)
 140:main_sim900.h ****   const uchar kom = komenda_SIM900;
 3233               		.loc 2 140 0
 3234 0f18 D091 0000 		lds r29,komenda_SIM900
 3235               	.LVL286:
 141:main_sim900.h **** 
 142:main_sim900.h ****   switch (aktualnie_wysylane_polecenie_SIM900) {
 3236               		.loc 2 142 0
 3237 0f1c C091 0000 		lds r28,aktualnie_wysylane_polecenie_SIM900
 3238 0f20 CE39      		cpi r28,lo8(-98)
 3239 0f22 01F4      		brne .+2
 3240 0f24 00C0      		rjmp .L206
 3241 0f26 00F0      		brlo .+2
 3242 0f28 00C0      		rjmp .L207
 3243 0f2a C539      		cpi r28,lo8(-107)
 3244 0f2c 01F4      		brne .+2
 3245 0f2e 00C0      		rjmp .L208
 3246 0f30 00F4      		brsh .L209
 3247 0f32 CF38      		cpi r28,lo8(-113)
 3248 0f34 01F4      		brne .+2
 3249 0f36 00C0      		rjmp .L210
 3250 0f38 00F4      		brsh .L211
 3251 0f3a CC38      		cpi r28,lo8(-116)
 3252 0f3c 01F4      		brne .+2
 3253 0f3e 00C0      		rjmp .L212
 3254 0f40 CE38      		cpi r28,lo8(-114)
 3255 0f42 01F4      		brne .+2
 3256 0f44 00C0      		rjmp .L213
 3257               	.L205:
 143:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 144:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_ODEBRANO_POLECENIE_ROZPOCZYNAJACE);
 145:main_sim900.h ****     max_oczekiwanie_na_odpowiedz_at = 0;
 146:main_sim900.h ****     break;
 147:main_sim900.h ****   }
 148:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE: {
 149:main_sim900.h ****     static const char polecenie_zegar[] PROGMEM = "+CCLK:";
 150:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 &&
 151:main_sim900.h ****         polozenie_polecenia_SIM900(polecenie_zegar) != NULL) {
 152:main_sim900.h ****       const uchar *p1 =
 153:main_sim900.h ****           strchr(polozenie_polecenia_SIM900(polecenie_zegar), '\"');
 154:main_sim900.h ****       if (p1++ != NULL) {
 155:main_sim900.h ****         const uchar *p2 = strchr(p1, '\"');
 156:main_sim900.h ****         const uchar *p3 = strchr(p1, ',');
 157:main_sim900.h ****         if (p2 != NULL && p3++ != NULL && p2 > p3) {
 158:main_sim900.h ****           // const uchar g = atoi(p3);
 159:main_sim900.h ****           if ((p3 = strchr(p3, ':')) != NULL && p2 > p3++) {
 160:main_sim900.h ****             // Pobierz czas z odpowiedzi +CCLK: "yy/MM/dd,hh:mm:ss+zz"
 161:main_sim900.h ****             // p3 wskazuje na minuty po pierwszym ':'
 162:main_sim900.h ****             // cofnijmy si do pocztku godziny (p3 wskazuje na mm, wic -3 to hh)
 163:main_sim900.h ****             // ale w kodzie powyej p3 byo przesuwane.
 164:main_sim900.h **** 
 165:main_sim900.h ****             // Restart parsowania dla pewnoci:
 166:main_sim900.h ****             // "24/01/01,12:34:56+00"
 167:main_sim900.h ****             const char *ptr_time = strchr(p1, ',');
 168:main_sim900.h ****             if (ptr_time) {
 169:main_sim900.h ****               ptr_time++; // skip comma
 170:main_sim900.h ****               if (strlen(ptr_time) >= 8) {
 171:main_sim900.h ****                 memcpy(rtc_czas, ptr_time, 8);
 172:main_sim900.h ****                 rtc_czas[8] = '\0';
 173:main_sim900.h **** 
 174:main_sim900.h ****                 // Aktualizacja blokady czasowej
 175:main_sim900.h ****                 if (czas_start_h == 0xFF) {
 176:main_sim900.h ****                   blokada_sterowania_czasowa = FALSE;
 177:main_sim900.h ****                 } else {
 178:main_sim900.h ****                   // Parsowanie aktualnego czasu
 179:main_sim900.h ****                   int curr_h = (rtc_czas[0] - '0') * 10 + (rtc_czas[1] - '0');
 180:main_sim900.h ****                   int curr_m = (rtc_czas[3] - '0') * 10 + (rtc_czas[4] - '0');
 181:main_sim900.h ****                   int curr_time = curr_h * 60 + curr_m;
 182:main_sim900.h **** 
 183:main_sim900.h ****                   int start_time = czas_start_h * 60 + czas_start_m;
 184:main_sim900.h ****                   int stop_time = czas_stop_h * 60 + czas_stop_m;
 185:main_sim900.h **** 
 186:main_sim900.h ****                   if (start_time <= stop_time) {
 187:main_sim900.h ****                     // Normalny przedzial (np. 08:00 - 16:00)
 188:main_sim900.h ****                     if (curr_time >= start_time && curr_time <= stop_time)
 189:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 190:main_sim900.h ****                     else
 191:main_sim900.h ****                       blokada_sterowania_czasowa = TRUE;
 192:main_sim900.h ****                   } else {
 193:main_sim900.h ****                     // Przejscie przez polnoc (np. 22:00 - 06:00)
 194:main_sim900.h ****                     if (curr_time >= start_time || curr_time <= stop_time)
 195:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 196:main_sim900.h ****                     else
 197:main_sim900.h ****                       blokada_sterowania_czasowa = TRUE;
 198:main_sim900.h ****                   }
 199:main_sim900.h ****                 }
 200:main_sim900.h ****               }
 201:main_sim900.h ****             }
 202:main_sim900.h ****           }
 203:main_sim900.h ****         }
 204:main_sim900.h ****       }
 205:main_sim900.h ****     }
 206:main_sim900.h ****     break;
 207:main_sim900.h ****   }
 208:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_PIN: {
 209:main_sim900.h ****     static const char polecenie_pin_ready[] PROGMEM = "+CPIN: READY";
 210:main_sim900.h ****     static uchar nr_zapytania_o_pin;
 211:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 212:main_sim900.h ****       if (polozenie_polecenia_SIM900(polecenie_pin_ready) != NULL) {
 213:main_sim900.h ****         podlaczona_karta_SIM_SIM900 = TRUE;
 214:main_sim900.h ****         bledny_PIN = FALSE;
 215:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 216:main_sim900.h ****       } else
 217:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_PODAJ_PIN);
 218:main_sim900.h ****       nr_zapytania_o_pin = 0;
 219:main_sim900.h ****     } else if (kom == CME_ERROR_KOMENDA_SIM900 &&
 220:main_sim900.h ****                numer_bledu_cme == CME_SIM_BUSY)
 221:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 222:main_sim900.h ****     else if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900()) {
 223:main_sim900.h ****       if (++nr_zapytania_o_pin >= 20) {
 224:main_sim900.h ****         reset_modulu_SIM900();
 225:main_sim900.h ****         nr_zapytania_o_pin = 0;
 226:main_sim900.h ****       } else {
 227:main_sim900.h ****         opoznienie_SIM900_100MS = 20;
 228:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 229:main_sim900.h ****       }
 230:main_sim900.h ****     } else
 231:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 232:main_sim900.h ****     break;
 233:main_sim900.h ****   }
 234:main_sim900.h ****   case KOMENDA_KOLEJKI_PODAJ_PIN: {
 235:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 236:main_sim900.h ****       podlaczona_karta_SIM_SIM900 = TRUE;
 237:main_sim900.h ****       bledny_PIN = FALSE;
 238:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 239:main_sim900.h ****       opoznienie_SIM900_100MS = 50;
 240:main_sim900.h ****     } else if (kom == CME_ERROR_KOMENDA_SIM900 &&
 241:main_sim900.h ****                numer_bledu_cme == CME_SIM_INCORECT_PASWORD)
 242:main_sim900.h ****       bledny_PIN = TRUE;
 243:main_sim900.h ****     else if (kom == CME_ERROR_KOMENDA_SIM900 && numer_bledu_cme == CME_SIM_BUSY)
 244:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 245:main_sim900.h ****     else if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900())
 246:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 247:main_sim900.h ****     else
 248:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 249:main_sim900.h ****     break;
 250:main_sim900.h ****   }
 251:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY: {
 252:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900)
 253:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW);
 254:main_sim900.h ****     else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 255:main_sim900.h ****       if (numer_bledu_cms == CMS_SIM_BUSY ||
 256:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 257:main_sim900.h ****         opoznienie_SIM900_100MS = 60;
 258:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 259:main_sim900.h ****       }
 260:main_sim900.h ****     } else if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900())
 261:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 262:main_sim900.h ****     break;
 263:main_sim900.h ****   }
 264:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW: {
 265:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900)
 266:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW);
 267:main_sim900.h ****     else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 268:main_sim900.h ****       if (numer_bledu_cms == CMS_SIM_BUSY ||
 269:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 270:main_sim900.h ****         opoznienie_SIM900_100MS = 20;
 271:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 272:main_sim900.h ****       }
 273:main_sim900.h ****     } else {
 274:main_sim900.h ****       opoznienie_SIM900_100MS = 10;
 275:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 276:main_sim900.h ****     }
 277:main_sim900.h ****     break;
 278:main_sim900.h ****   }
 279:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_WYSYLANIE_INFO_O_DZWONIACYM: {
 280:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 ||
 281:main_sim900.h ****         (kom == CME_ERROR_KOMENDA_SIM900 &&
 282:main_sim900.h ****          (numer_bledu_cme == CME_OPERATION_NOT_ALLOWED ||
 283:main_sim900.h ****           numer_bledu_cme == CME_OPERATION_NOT_SUPPORTED))) {
 284:main_sim900.h ****       dodaj_komende(nastepne_wysylane_polecenie_SIM900);
 285:main_sim900.h ****       nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 286:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 287:main_sim900.h ****     } else if (kom != OK_KOMENDA_SIM900 &&
 288:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 289:main_sim900.h ****                    MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 290:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 291:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 292:main_sim900.h ****     break;
 293:main_sim900.h ****   }
 294:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_POZIOM_SIECI: {
 295:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 296:main_sim900.h ****       static const uchar urc[] PROGMEM = "+CSQ:";
 297:main_sim900.h ****       const uchar *p1 = polozenie_polecenia_SIM900(urc);
 298:main_sim900.h ****       if (p1 != NULL) {
 299:main_sim900.h ****         p1 += strlen_R(urc) + 1;
 300:main_sim900.h ****         poziom_sieci_gsm = strtol(p1, NULL, 10);
 301:main_sim900.h ****         // if ( poziom_sieci_gsm != POZIOM_SIECI_BLAD )
 302:main_sim900.h ****         //	POMOC_DODAJ2('*', '0' + poziom_sieci_gsm / 4);
 303:main_sim900.h ****         // else
 304:main_sim900.h ****         //{
 305:main_sim900.h ****         //	POMOC_DODAJ2('*', 'c');
 306:main_sim900.h ****         // }
 307:main_sim900.h ****       }
 308:main_sim900.h ****     } else
 309:main_sim900.h ****       poziom_sieci_gsm = POZIOM_SIECI_BLAD;
 310:main_sim900.h ****     break;
 311:main_sim900.h ****   }
 312:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_ZAREJESTROWANIE: {
 313:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 314:main_sim900.h ****       static const uchar urc[] PROGMEM = "+CREG:";
 315:main_sim900.h ****       const uchar *p1 = polozenie_polecenia_SIM900(urc);
 316:main_sim900.h ****       if (p1 != NULL) {
 317:main_sim900.h ****         p1 += strlen_R(urc) + 1;
 318:main_sim900.h ****         if (*p1 != ',')
 319:main_sim900.h ****           ++p1;
 320:main_sim900.h ****         if (*p1 != ',')
 321:main_sim900.h ****           ++p1;
 322:main_sim900.h ****         if (*p1 != ',')
 323:main_sim900.h ****           ++p1;
 324:main_sim900.h ****         ++p1;
 325:main_sim900.h ****         uchar stan_zarejestrowania = (uchar)strtol(p1, NULL, 10);
 326:main_sim900.h ****         if (stan_zarejestrowania == 0 || stan_zarejestrowania == 3 ||
 327:main_sim900.h ****             stan_zarejestrowania == 4) {
 328:main_sim900.h ****           reset_modulu_SIM900();
 329:main_sim900.h ****         } else if (stan_zarejestrowania == 1 || stan_zarejestrowania == 5) {
 330:main_sim900.h ****           modul_zalogowany_w_sieci = TRUE;
 331:main_sim900.h ****         }
 332:main_sim900.h ****       }
 333:main_sim900.h ****     }
 334:main_sim900.h ****     break;
 335:main_sim900.h ****   }
 336:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_STAN_KARTY_SIM: {
 337:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 || (kom == CME_ERROR_KOMENDA_SIM900 &&
 338:main_sim900.h ****                                      (numer_bledu_cme == CME_INVALID_INDEX ||
 339:main_sim900.h ****                                       numer_bledu_cme == CME_NOT_FOUND))) {
 340:main_sim900.h ****       licznik_blad_stanu_karty_SIM = 0;
 341:main_sim900.h ****     } else {
 342:main_sim900.h ****       ++licznik_blad_stanu_karty_SIM;
 343:main_sim900.h ****     }
 344:main_sim900.h ****     break;
 345:main_sim900.h ****   }
 346:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_ZALOGOWANIE_U_OPERATORA: {
 347:main_sim900.h ****     static const char polecenie_operator[] PROGMEM = "+COPS:";
 348:main_sim900.h ****     uchar w = FALSE;
 349:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 && czy_polecenie_sim(polecenie_operator)) {
 350:main_sim900.h ****       const uchar *p1 =
 351:main_sim900.h ****           strchr(polozenie_polecenia_SIM900(polecenie_operator), ',');
 352:main_sim900.h ****       if (p1 != NULL) {
 353:main_sim900.h ****         p1 = strchr(p1, ',');
 354:main_sim900.h ****         if (p1 != NULL) {
 355:main_sim900.h ****           p1 = strchr(p1, '\"');
 356:main_sim900.h ****           if (p1++ != NULL) {
 357:main_sim900.h ****             const uchar *p2 = strchr(p1, '\"');
 358:main_sim900.h ****             if (p2 != NULL && p1 != p2) {
 359:main_sim900.h ****               const uchar m = min(p2 - p1, ROZMIAR_NAZWA_OPERATORA);
 360:main_sim900.h ****               memcpy(nazwa_operatora, p1, m);
 361:main_sim900.h ****               nazwa_operatora[m] = '\0';
 362:main_sim900.h ****               w = TRUE;
 363:main_sim900.h ****             }
 364:main_sim900.h ****           }
 365:main_sim900.h ****         }
 366:main_sim900.h ****       }
 367:main_sim900.h ****     }
 368:main_sim900.h ****     if (w)
 369:main_sim900.h ****       licznik_blad_zalogowania_u_operatora = 0;
 370:main_sim900.h ****     else {
 371:main_sim900.h ****       ++licznik_blad_zalogowania_u_operatora;
 372:main_sim900.h ****     }
 373:main_sim900.h ****     // POMOC_DODAJ2('*', w ? '+' : '-');
 374:main_sim900.h ****     break;
 375:main_sim900.h ****   }
 376:main_sim900.h ****   case KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS: {
 377:main_sim900.h ****     if (kom ==
 378:main_sim900.h ****         CMS_ERROR_KOMENDA_SIM900 /*&& numer_bledu_cms == CMS_SMS_ME_RESERVED*/) // co le interpretu
 379:main_sim900.h ****       ; // nic nie robi
 380:main_sim900.h ****     else if (kom != OK_KOMENDA_SIM900)
 381:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 382:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 383:main_sim900.h ****     break;
 384:main_sim900.h ****   }
 385:main_sim900.h ****   case KOMENDA_KOLEJKI_ODBIERZ_ROZMOWE: {
 386:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 ||
 387:main_sim900.h ****         czy_jest_komenda_uzytkownik_odebral_rozmowe()) {
 388:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = TRUE;
 389:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 390:main_sim900.h **** 
 391:main_sim900.h ****       // DTMF START
 392:main_sim900.h ****       if (!tryb_clip) {
 393:main_sim900.h ****         licznik_timeout_rozmowy_100ms = MAX_LICZNIK_TIMEOUT_ROZMOWY_100MS;
 394:main_sim900.h ****         opoznienie_SIM900_100MS =
 395:main_sim900.h ****             20; // 2 sekundy opoznienia przed wyslaniem tonu
 396:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_TON_DTMF); // Beep potwierdzenia
 397:main_sim900.h ****       }
 398:main_sim900.h ****     } else if ((kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900()) &&
 399:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 400:main_sim900.h ****                    MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 401:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 402:main_sim900.h ****     else if (kom == NO_CARRIER_KOMENDA_SIM900) {
 403:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 404:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 405:main_sim900.h ****     } else
 406:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 407:main_sim900.h ****     break;
 408:main_sim900.h ****   }
 409:main_sim900.h ****   case KOMENDA_KOLEJKI_ODRZUC_ROZMOWE: {
 410:main_sim900.h ****     if (kom != OK_KOMENDA_SIM900)
 411:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 412:main_sim900.h ****     else {
 413:main_sim900.h ****       zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_zakonczenie);
 414:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 415:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 416:main_sim900.h ****     }
 417:main_sim900.h ****     break;
 418:main_sim900.h ****   }
 419:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1:
 420:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_2:
 421:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_3:
 422:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_4:
 423:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_5:
 424:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_6:
 425:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_7:
 426:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_8:
 427:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_9:
 428:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_10:
 429:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_11:
 430:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_12:
 431:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_13:
 432:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_14:
 433:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_15:
 434:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_16:
 435:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_17:
 436:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_18:
 437:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_19:
 438:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20: {
 439:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 440:main_sim900.h ****       // odczytany sms
 441:main_sim900.h ****       const uchar *ptr = polozenie_polecenia_SIM900(PSTR("+CMGR:")); // (1)
 442:main_sim900.h ****       ptr = strchr(ptr, ZNAK_KONCA_ODBIERANIA_ZNAKOW_LF);            // (1)
 443:main_sim900.h ****       // const uchar* ptr = strchr(&odebrany_blok_SIM900[7],
 444:main_sim900.h ****       // ZNAK_KONCA_ODBIERANIA_ZNAKOW_LF);
 445:main_sim900.h ****       if (ptr != NULL) {
 446:main_sim900.h ****         ++ptr;
 447:main_sim900.h ****         const uchar *ptr2 = strchr(ptr, ZNAK_KONCA_WYSYLANIA_ZNAKOW_CR);
 448:main_sim900.h ****         if (ptr2 != NULL) {
 449:main_sim900.h ****           dlugosc_pdu = (ptr2 - ptr) / 2;
 450:main_sim900.h ****           if (dlugosc_pdu > MAX_DLUGOSC_PDU)
 451:main_sim900.h ****             dlugosc_pdu = MAX_DLUGOSC_PDU;
 452:main_sim900.h ****           konwertuj_blok_dwa_znaki_na_znak_pdu(ptr, dlugosc_pdu, bufor_pdu);
 453:main_sim900.h ****           dodaj_komende(KOMENDA_KOLEJKI_INTERPRETUJ_PDU);
 454:main_sim900.h ****           const uchar nr_smsa = aktualnie_wysylane_polecenie_SIM900 -
 455:main_sim900.h ****                                 KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1;
 456:main_sim900.h ****           dodaj_komende(KOMENDA_KOLEJKI_USUN_SMSA_1 + nr_smsa);
 457:main_sim900.h ****           flaga_odczytywanie_smsa = TRUE;
 458:main_sim900.h ****           POMOC_DODAJ2('#', 'O');
 459:main_sim900.h ****         } else
 460:main_sim900.h ****           flaga_odczytywanie_smsa = FALSE;
 461:main_sim900.h ****       } else
 462:main_sim900.h ****         flaga_odczytywanie_smsa = FALSE;
 463:main_sim900.h ****     } else if (kom == CME_ERROR_KOMENDA_SIM900) {
 464:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 465:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 466:main_sim900.h ****     } else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 467:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 468:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 469:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 470:main_sim900.h ****       POMOC_DODAJ2('#', 'P');
 471:main_sim900.h ****       POMOC_DODAJ_HEX(numer_bledu_cms >> 8);
 472:main_sim900.h ****       POMOC_DODAJ_HEX(numer_bledu_cms & 0xff);
 473:main_sim900.h ****     } else {
 474:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 475:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 476:main_sim900.h ****     }
 477:main_sim900.h ****     break;
 478:main_sim900.h ****   }
 479:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_1:
 480:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_2:
 481:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_3:
 482:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_4:
 483:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_5:
 484:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_6:
 485:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_7:
 486:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_8:
 487:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_9:
 488:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_10:
 489:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_11:
 490:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_12:
 491:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_13:
 492:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_14:
 493:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_15:
 494:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_16:
 495:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_17:
 496:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_18:
 497:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_19:
 498:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_20: {
 499:main_sim900.h ****     if (kom == CMS_ERROR_KOMENDA_SIM900 &&
 500:main_sim900.h ****         numer_bledu_cms != CMS_INVALID_MEMORY_INDEX) {
 501:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 502:main_sim900.h ****     } else if (kom == ERROR_KOMENDA_SIM900)
 503:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 504:main_sim900.h ****     else if (czy_jest_blad_SIM900())
 505:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 506:main_sim900.h ****     POMOC_DODAJ2('#', 'Q');
 507:main_sim900.h ****     opoznienie_SIM900_100MS = 25;
 508:main_sim900.h ****     break;
 509:main_sim900.h ****   }
 510:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT: {
 511:main_sim900.h ****     // czekanie_na_odebranie_zachety = FALSE; byo
 512:main_sim900.h ****     break;
 513:main_sim900.h ****   }
 514:main_sim900.h ****   case KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE: {
 515:main_sim900.h ****     if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900()) {
 516:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 517:main_sim900.h ****       if (++liczba_wykonanych_komend_identycznego_polecenia <
 518:main_sim900.h ****           MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 519:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 520:main_sim900.h ****       else {
 521:main_sim900.h ****         liczba_wykonanych_komend_identycznego_polecenia = 0;
 522:main_sim900.h ****         zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 523:main_sim900.h ****         trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 524:main_sim900.h ****         wykonywanie_rozmowy_telefonicznej = FALSE;
 525:main_sim900.h ****         licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 526:main_sim900.h ****       }
 527:main_sim900.h ****     } else
 528:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 529:main_sim900.h ****     break;
 530:main_sim900.h ****   }
 531:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW:
 532:main_sim900.h ****     if (kom != OK_KOMENDA_SIM900) {
 533:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 534:main_sim900.h ****       opoznienie_SIM900_100MS = 20;
 535:main_sim900.h ****       break;
 536:main_sim900.h ****     } // bez break
 537:main_sim900.h ****     goto obsluga_standardowej_instrukcji_at;
 538:main_sim900.h ****   case KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1: {
 539:main_sim900.h ****     if (polozenie_polecenia_SIM900(PSTR(">")) != 0) {
 540:main_sim900.h ****       reset_modulu_SIM900();
 541:main_sim900.h ****       break;
 542:main_sim900.h ****     }
 543:main_sim900.h ****   }
 544:main_sim900.h ****   case KOMENDA_KOLEJKI_WSTAWIENIE_MORING_GDY_DZWONI:
 545:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_WZMOCNIENIE_MIKROFONU:
 546:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_CICHY_TRYB:
 547:main_sim900.h ****   case KOMENDA_KOLEJKI_WYCISZ_DZWONKI:
 548:main_sim900.h ****   case KOMENDA_KOLEJKI_ODBIERAJ_SMS_FLASH:
 549:main_sim900.h ****   case KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ:
 550:main_sim900.h ****   case KOMENDA_KOLEJKI_WLACZ_CZAS_Z_SIECI: {
 551:main_sim900.h ****   obsluga_standardowej_instrukcji_at:
 552:main_sim900.h ****     if (kom != OK_KOMENDA_SIM900 &&
 553:main_sim900.h ****         ++liczba_wykonanych_komend_identycznego_polecenia <
 554:main_sim900.h ****             MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 555:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 556:main_sim900.h ****     else {
 557:main_sim900.h ****       dodaj_komende(nastepne_wysylane_polecenie_SIM900);
 558:main_sim900.h ****       if (nastepne_wysylane_polecenie_SIM900 >=
 559:main_sim900.h ****               KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 560:main_sim900.h ****           nastepne_wysylane_polecenie_SIM900 <=
 561:main_sim900.h ****               KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 562:main_sim900.h ****         flaga_odczytywanie_smsa = FALSE;
 563:main_sim900.h ****       }
 564:main_sim900.h ****       nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 565:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 566:main_sim900.h ****     }
 567:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 568:main_sim900.h ****     break;
 569:main_sim900.h ****   }
 570:main_sim900.h ****   }
 571:main_sim900.h **** #undef czy_polecenie_sim
 572:main_sim900.h ****   wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 3258               		.loc 2 572 0
 3259 0f46 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 3260 0f4a 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 3261 0f4e 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
 3262               	/* epilogue start */
 573:main_sim900.h **** }
 3263               		.loc 2 573 0
 3264 0f52 DF91      		pop r29
 3265               	.LVL287:
 3266 0f54 CF91      		pop r28
 3267 0f56 1F91      		pop r17
 3268 0f58 0F91      		pop r16
 3269 0f5a 0895      		ret
 3270               	.LVL288:
 3271               	.L211:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3272               		.loc 2 142 0
 3273 0f5c C239      		cpi r28,lo8(-110)
 3274 0f5e 01F4      		brne .+2
 3275 0f60 00C0      		rjmp .L214
 3276 0f62 C439      		cpi r28,lo8(-108)
 3277 0f64 01F4      		brne .L205
 3278               	.L215:
 552:main_sim900.h ****         ++liczba_wykonanych_komend_identycznego_polecenia <
 3279               		.loc 2 552 0
 3280 0f66 D130      		cpi r29,lo8(1)
 3281 0f68 01F4      		brne .+2
 3282 0f6a 00C0      		rjmp .L292
 553:main_sim900.h ****             MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 3283               		.loc 2 553 0 discriminator 1
 3284 0f6c 8091 0000 		lds r24,liczba_wykonanych_komend_identycznego_polecenia
 3285 0f70 8F5F      		subi r24,lo8(-(1))
 552:main_sim900.h ****         ++liczba_wykonanych_komend_identycznego_polecenia <
 3286               		.loc 2 552 0 discriminator 1
 3287 0f72 8093 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,r24
 3288 0f76 8330      		cpi r24,lo8(3)
 3289 0f78 00F0      		brlo .+2
 3290 0f7a 00C0      		rjmp .L292
 555:main_sim900.h ****     else {
 3291               		.loc 2 555 0
 3292 0f7c 8C2F      		mov r24,r28
 3293 0f7e 00C0      		rjmp .L399
 3294               	.L209:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3295               		.loc 2 142 0
 3296 0f80 C939      		cpi r28,lo8(-103)
 3297 0f82 01F4      		brne .+2
 3298 0f84 00C0      		rjmp .L216
 3299 0f86 00F4      		brsh .L217
 3300 0f88 C639      		cpi r28,lo8(-106)
 3301 0f8a 01F4      		brne .+2
 3302 0f8c 00C0      		rjmp .L218
 3303 0f8e C739      		cpi r28,lo8(-105)
 3304 0f90 01F4      		brne .L205
 411:main_sim900.h ****     else {
 3305               		.loc 2 411 0
 3306 0f92 87E9      		ldi r24,lo8(-105)
 410:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3307               		.loc 2 410 0
 3308 0f94 D130      		cpi r29,lo8(1)
 3309 0f96 01F0      		breq .+2
 3310 0f98 00C0      		rjmp .L404
 413:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 3311               		.loc 2 413 0
 3312 0f9a 81E0      		ldi r24,lo8(1)
 3313 0f9c 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 3314               	.LVL289:
 414:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 3315               		.loc 2 414 0
 3316 0fa0 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 415:main_sim900.h ****     }
 3317               		.loc 2 415 0
 3318 0fa4 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 3319 0fa8 00C0      		rjmp .L205
 3320               	.L217:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3321               		.loc 2 142 0
 3322 0faa CB39      		cpi r28,lo8(-101)
 3323 0fac 01F4      		brne .+2
 3324 0fae 00C0      		rjmp .L220
 3325 0fb0 00F4      		brsh .+2
 3326 0fb2 00C0      		rjmp .L221
 3327 0fb4 CD39      		cpi r28,lo8(-99)
 3328 0fb6 01F4      		brne .L205
 313:main_sim900.h ****       static const uchar urc[] PROGMEM = "+CREG:";
 3329               		.loc 2 313 0
 3330 0fb8 D130      		cpi r29,lo8(1)
 3331 0fba 01F4      		brne .L205
 3332               	.LBB519:
 315:main_sim900.h ****       if (p1 != NULL) {
 3333               		.loc 2 315 0
 3334 0fbc 80E0      		ldi r24,lo8(urc.3242)
 3335 0fbe 90E0      		ldi r25,hi8(urc.3242)
 3336 0fc0 0E94 0000 		call polozenie_polecenia_SIM900
 3337               	.LVL290:
 3338 0fc4 FC01      		movw r30,r24
 3339               	.LVL291:
 316:main_sim900.h ****         p1 += strlen_R(urc) + 1;
 3340               		.loc 2 316 0
 3341 0fc6 892B      		or r24,r25
 3342 0fc8 01F4      		brne .+2
 3343 0fca 00C0      		rjmp .L205
 3344               	.LVL292:
 3345               	.LBB520:
 318:main_sim900.h ****           ++p1;
 3346               		.loc 2 318 0
 3347 0fcc 2781      		ldd r18,Z+7
 3348 0fce 2C32      		cpi r18,lo8(44)
 3349 0fd0 01F0      		breq .+2
 3350 0fd2 00C0      		rjmp .L264
 317:main_sim900.h ****         if (*p1 != ',')
 3351               		.loc 2 317 0
 3352 0fd4 3796      		adiw r30,7
 3353               	.LVL293:
 3354               	.L265:
 320:main_sim900.h ****           ++p1;
 3355               		.loc 2 320 0
 3356 0fd6 8081      		ld r24,Z
 3357 0fd8 8C32      		cpi r24,lo8(44)
 3358 0fda 01F0      		breq .L266
 3359 0fdc 3196      		adiw r30,1
 3360               	.LVL294:
 3361               	.L266:
 322:main_sim900.h ****           ++p1;
 3362               		.loc 2 322 0
 3363 0fde 8081      		ld r24,Z
 3364 0fe0 8C32      		cpi r24,lo8(44)
 3365 0fe2 01F0      		breq .L267
 3366 0fe4 3196      		adiw r30,1
 3367               	.LVL295:
 3368               	.L267:
 325:main_sim900.h ****         if (stan_zarejestrowania == 0 || stan_zarejestrowania == 3 ||
 3369               		.loc 2 325 0
 3370 0fe6 4AE0      		ldi r20,lo8(10)
 3371 0fe8 50E0      		ldi r21,0
 3372 0fea 70E0      		ldi r23,0
 3373 0fec 60E0      		ldi r22,0
 3374 0fee CF01      		movw r24,r30
 3375 0ff0 0196      		adiw r24,1
 3376               	.LVL296:
 3377 0ff2 0E94 0000 		call strtol
 3378               	.LVL297:
 326:main_sim900.h ****             stan_zarejestrowania == 4) {
 3379               		.loc 2 326 0
 3380 0ff6 6623      		tst r22
 3381 0ff8 01F0      		breq .L268
 326:main_sim900.h ****             stan_zarejestrowania == 4) {
 3382               		.loc 2 326 0 is_stmt 0 discriminator 1
 3383 0ffa 8DEF      		ldi r24,lo8(-3)
 3384 0ffc 860F      		add r24,r22
 3385 0ffe 8230      		cpi r24,lo8(2)
 3386 1000 00F0      		brlo .+2
 3387 1002 00C0      		rjmp .L269
 3388               	.LVL298:
 3389               	.L268:
 328:main_sim900.h ****         } else if (stan_zarejestrowania == 1 || stan_zarejestrowania == 5) {
 3390               		.loc 2 328 0 is_stmt 1
 3391 1004 0E94 0000 		call reset_modulu_SIM900
 3392               	.LVL299:
 3393 1008 00C0      		rjmp .L205
 3394               	.L207:
 3395               	.LBE520:
 3396               	.LBE519:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3397               		.loc 2 142 0
 3398 100a CA3A      		cpi r28,lo8(-86)
 3399 100c 00F4      		brsh .L223
 3400 100e C63A      		cpi r28,lo8(-90)
 3401 1010 00F0      		brlo .+2
 3402 1012 00C0      		rjmp .L215
 3403 1014 C13A      		cpi r28,lo8(-95)
 3404 1016 01F4      		brne .+2
 3405 1018 00C0      		rjmp .L215
 3406 101a 00F4      		brsh .L224
 3407 101c CF39      		cpi r28,lo8(-97)
 3408 101e 01F4      		brne .+2
 3409 1020 00C0      		rjmp .L225
 3410 1022 C03A      		cpi r28,lo8(-96)
 3411 1024 01F0      		breq .+2
 3412 1026 00C0      		rjmp .L205
 265:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW);
 3413               		.loc 2 265 0
 3414 1028 D130      		cpi r29,lo8(1)
 3415 102a 01F0      		breq .+2
 3416 102c 00C0      		rjmp .L256
 266:main_sim900.h ****     else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 3417               		.loc 2 266 0
 3418 102e 8FE8      		ldi r24,lo8(-113)
 3419 1030 00C0      		rjmp .L404
 3420               	.L224:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3421               		.loc 2 142 0
 3422 1032 C23A      		cpi r28,lo8(-94)
 3423 1034 01F4      		brne .+2
 3424 1036 00C0      		rjmp .L227
 3425 1038 C43A      		cpi r28,lo8(-92)
 3426 103a 01F4      		brne .+2
 3427 103c 00C0      		rjmp .L215
 3428 103e 00C0      		rjmp .L205
 3429               	.L223:
 3430 1040 C23D      		cpi r28,lo8(-46)
 3431 1042 00F4      		brsh .L228
 3432 1044 CE3B      		cpi r28,lo8(-66)
 3433 1046 00F4      		brsh .+2
 3434 1048 00C0      		rjmp .L396
 499:main_sim900.h ****         numer_bledu_cms != CMS_INVALID_MEMORY_INDEX) {
 3435               		.loc 2 499 0
 3436 104a D630      		cpi r29,lo8(6)
 3437 104c 01F0      		breq .+2
 3438 104e 00C0      		rjmp .L287
 499:main_sim900.h ****         numer_bledu_cms != CMS_INVALID_MEMORY_INDEX) {
 3439               		.loc 2 499 0 is_stmt 0 discriminator 1
 3440 1050 8091 0000 		lds r24,numer_bledu_cms
 3441 1054 9091 0000 		lds r25,numer_bledu_cms+1
 3442 1058 8134      		cpi r24,65
 3443 105a 9140      		sbci r25,1
 3444 105c 01F4      		brne .+2
 3445 105e 00C0      		rjmp .L288
 3446               	.L401:
 505:main_sim900.h ****     POMOC_DODAJ2('#', 'Q');
 3447               		.loc 2 505 0 is_stmt 1
 3448 1060 8C2F      		mov r24,r28
 3449 1062 0E94 0000 		call dodaj_komende
 3450               	.LVL300:
 3451 1066 00C0      		rjmp .L289
 3452               	.L228:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3453               		.loc 2 142 0
 3454 1068 C63D      		cpi r28,lo8(-42)
 3455 106a 01F4      		brne .+2
 3456 106c 00C0      		rjmp .L231
 3457 106e CD3F      		cpi r28,lo8(-3)
 3458 1070 01F0      		breq .+2
 3459 1072 00C0      		rjmp .L205
 539:main_sim900.h ****       reset_modulu_SIM900();
 3460               		.loc 2 539 0
 3461 1074 80E0      		ldi r24,lo8(__c.3305)
 3462 1076 90E0      		ldi r25,hi8(__c.3305)
 3463 1078 0E94 0000 		call polozenie_polecenia_SIM900
 3464               	.LVL301:
 3465 107c 892B      		or r24,r25
 3466 107e 01F4      		brne .+2
 3467 1080 00C0      		rjmp .L215
 3468 1082 00C0      		rjmp .L268
 3469               	.L212:
 144:main_sim900.h ****     max_oczekiwanie_na_odpowiedz_at = 0;
 3470               		.loc 2 144 0
 3471 1084 8DE8      		ldi r24,lo8(-115)
 3472 1086 0E94 0000 		call dodaj_komende
 3473               	.LVL302:
 145:main_sim900.h ****     break;
 3474               		.loc 2 145 0
 3475 108a 1092 0000 		sts max_oczekiwanie_na_odpowiedz_at,__zero_reg__
 146:main_sim900.h ****   }
 3476               		.loc 2 146 0
 3477 108e 00C0      		rjmp .L205
 3478               	.L206:
 3479               	.LBB522:
 150:main_sim900.h ****         polozenie_polecenia_SIM900(polecenie_zegar) != NULL) {
 3480               		.loc 2 150 0
 3481 1090 D130      		cpi r29,lo8(1)
 3482 1092 01F0      		breq .+2
 3483 1094 00C0      		rjmp .L205
 151:main_sim900.h ****       const uchar *p1 =
 3484               		.loc 2 151 0 discriminator 1
 3485 1096 80E0      		ldi r24,lo8(polecenie_zegar.3221)
 3486 1098 90E0      		ldi r25,hi8(polecenie_zegar.3221)
 3487 109a 0E94 0000 		call polozenie_polecenia_SIM900
 3488               	.LVL303:
 150:main_sim900.h ****         polozenie_polecenia_SIM900(polecenie_zegar) != NULL) {
 3489               		.loc 2 150 0 discriminator 1
 3490 109e 0097      		sbiw r24,0
 3491 10a0 01F4      		brne .+2
 3492 10a2 00C0      		rjmp .L205
 3493               	.LBB523:
 152:main_sim900.h ****           strchr(polozenie_polecenia_SIM900(polecenie_zegar), '\"');
 3494               		.loc 2 152 0
 3495 10a4 62E2      		ldi r22,lo8(34)
 3496 10a6 70E0      		ldi r23,0
 3497 10a8 0E94 0000 		call strchr
 3498               	.LVL304:
 154:main_sim900.h ****         const uchar *p2 = strchr(p1, '\"');
 3499               		.loc 2 154 0
 3500 10ac 0097      		sbiw r24,0
 3501 10ae 01F4      		brne .+2
 3502 10b0 00C0      		rjmp .L205
 3503 10b2 EC01      		movw r28,r24
 3504 10b4 2196      		adiw r28,1
 3505               	.LVL305:
 3506               	.LBB524:
 155:main_sim900.h ****         const uchar *p3 = strchr(p1, ',');
 3507               		.loc 2 155 0
 3508 10b6 62E2      		ldi r22,lo8(34)
 3509 10b8 70E0      		ldi r23,0
 3510 10ba CE01      		movw r24,r28
 3511 10bc 0E94 0000 		call strchr
 3512               	.LVL306:
 3513 10c0 8C01      		movw r16,r24
 3514               	.LVL307:
 156:main_sim900.h ****         if (p2 != NULL && p3++ != NULL && p2 > p3) {
 3515               		.loc 2 156 0
 3516 10c2 6CE2      		ldi r22,lo8(44)
 3517 10c4 70E0      		ldi r23,0
 3518 10c6 CE01      		movw r24,r28
 3519 10c8 0E94 0000 		call strchr
 3520               	.LVL308:
 157:main_sim900.h ****           // const uchar g = atoi(p3);
 3521               		.loc 2 157 0
 3522 10cc 0115      		cp r16,__zero_reg__
 3523 10ce 1105      		cpc r17,__zero_reg__
 3524 10d0 01F4      		brne .+2
 3525 10d2 00C0      		rjmp .L205
 3526               	.LVL309:
 157:main_sim900.h ****           // const uchar g = atoi(p3);
 3527               		.loc 2 157 0 is_stmt 0 discriminator 1
 3528 10d4 0097      		sbiw r24,0
 3529 10d6 01F4      		brne .+2
 3530 10d8 00C0      		rjmp .L205
 157:main_sim900.h ****           // const uchar g = atoi(p3);
 3531               		.loc 2 157 0 discriminator 2
 3532 10da EC01      		movw r28,r24
 3533               	.LVL310:
 3534 10dc 2196      		adiw r28,1
 3535               	.LVL311:
 3536 10de C017      		cp r28,r16
 3537 10e0 D107      		cpc r29,r17
 3538 10e2 00F0      		brlo .+2
 3539 10e4 00C0      		rjmp .L205
 159:main_sim900.h ****             // Pobierz czas z odpowiedzi +CCLK: "yy/MM/dd,hh:mm:ss+zz"
 3540               		.loc 2 159 0 is_stmt 1
 3541 10e6 6AE3      		ldi r22,lo8(58)
 3542 10e8 70E0      		ldi r23,0
 3543 10ea CE01      		movw r24,r28
 3544 10ec 0E94 0000 		call strchr
 3545               	.LVL312:
 3546 10f0 0097      		sbiw r24,0
 3547 10f2 01F4      		brne .+2
 3548 10f4 00C0      		rjmp .L205
 3549               	.LVL313:
 159:main_sim900.h ****             // Pobierz czas z odpowiedzi +CCLK: "yy/MM/dd,hh:mm:ss+zz"
 3550               		.loc 2 159 0 is_stmt 0 discriminator 1
 3551 10f6 8017      		cp r24,r16
 3552 10f8 9107      		cpc r25,r17
 3553 10fa 00F0      		brlo .+2
 3554 10fc 00C0      		rjmp .L205
 3555               	.LVL314:
 3556               	.LBB525:
 170:main_sim900.h ****                 memcpy(rtc_czas, ptr_time, 8);
 3557               		.loc 2 170 0 is_stmt 1
 3558 10fe FE01      		movw r30,r28
 3559               		0:
 3560 1100 0190      		ld __tmp_reg__,Z+
 3561 1102 0020      		tst __tmp_reg__
 3562 1104 01F4      		brne 0b
 3563 1106 3197      		sbiw r30,1
 3564 1108 EC1B      		sub r30,r28
 3565 110a FD0B      		sbc r31,r29
 3566 110c 3897      		sbiw r30,8
 3567 110e 00F4      		brsh .+2
 3568 1110 00C0      		rjmp .L205
 171:main_sim900.h ****                 rtc_czas[8] = '\0';
 3569               		.loc 2 171 0
 3570 1112 88E0      		ldi r24,lo8(8)
 3571               	.LVL315:
 3572 1114 FE01      		movw r30,r28
 3573 1116 A0E0      		ldi r26,lo8(rtc_czas)
 3574 1118 B0E0      		ldi r27,hi8(rtc_czas)
 3575               		0:
 3576 111a 0190      		ld r0,Z+
 3577 111c 0D92      		st X+,r0
 3578 111e 8A95      		dec r24
 3579 1120 01F4      		brne 0b
 172:main_sim900.h **** 
 3580               		.loc 2 172 0
 3581 1122 1092 0000 		sts rtc_czas+8,__zero_reg__
 175:main_sim900.h ****                   blokada_sterowania_czasowa = FALSE;
 3582               		.loc 2 175 0
 3583 1126 7091 0000 		lds r23,czas_start_h
 3584 112a 7F3F      		cpi r23,lo8(-1)
 3585 112c 01F4      		brne .L235
 3586               	.L238:
 176:main_sim900.h ****                 } else {
 3587               		.loc 2 176 0
 3588 112e 1092 0000 		sts blokada_sterowania_czasowa,__zero_reg__
 3589 1132 00C0      		rjmp .L205
 3590               	.L235:
 3591               	.LVL316:
 3592               	.LBB526:
 179:main_sim900.h ****                   int curr_m = (rtc_czas[3] - '0') * 10 + (rtc_czas[4] - '0');
 3593               		.loc 2 179 0
 3594 1134 2091 0000 		lds r18,rtc_czas
 3595 1138 2053      		subi r18,48
 3596 113a 330B      		sbc r19,r19
 3597 113c EAE0      		ldi r30,lo8(10)
 3598 113e E29F      		mul r30,r18
 3599 1140 C001      		movw r24,r0
 3600 1142 E39F      		mul r30,r19
 3601 1144 900D      		add r25,r0
 3602 1146 1124      		clr __zero_reg__
 3603 1148 2091 0000 		lds r18,rtc_czas+1
 3604 114c 2053      		subi r18,48
 3605 114e 330B      		sbc r19,r19
 3606 1150 820F      		add r24,r18
 3607 1152 931F      		adc r25,r19
 181:main_sim900.h **** 
 3608               		.loc 2 181 0
 3609 1154 6CE3      		ldi r22,lo8(60)
 3610 1156 689F      		mul r22,r24
 3611 1158 A001      		movw r20,r0
 3612 115a 699F      		mul r22,r25
 3613 115c 500D      		add r21,r0
 3614 115e 1124      		clr __zero_reg__
 180:main_sim900.h ****                   int curr_time = curr_h * 60 + curr_m;
 3615               		.loc 2 180 0
 3616 1160 2091 0000 		lds r18,rtc_czas+3
 3617 1164 2053      		subi r18,48
 3618 1166 330B      		sbc r19,r19
 3619 1168 E29F      		mul r30,r18
 3620 116a C001      		movw r24,r0
 3621 116c E39F      		mul r30,r19
 3622 116e 900D      		add r25,r0
 3623 1170 1124      		clr __zero_reg__
 3624 1172 2091 0000 		lds r18,rtc_czas+4
 3625 1176 2053      		subi r18,48
 3626 1178 330B      		sbc r19,r19
 3627 117a 820F      		add r24,r18
 3628 117c 931F      		adc r25,r19
 181:main_sim900.h **** 
 3629               		.loc 2 181 0
 3630 117e 480F      		add r20,r24
 3631 1180 591F      		adc r21,r25
 3632               	.LVL317:
 183:main_sim900.h ****                   int stop_time = czas_stop_h * 60 + czas_stop_m;
 3633               		.loc 2 183 0
 3634 1182 2091 0000 		lds r18,czas_start_m
 3635 1186 30E0      		ldi r19,0
 3636 1188 769F      		mul r23,r22
 3637 118a 200D      		add r18,r0
 3638 118c 311D      		adc r19,r1
 3639 118e 1124      		clr __zero_reg__
 3640               	.LVL318:
 184:main_sim900.h **** 
 3641               		.loc 2 184 0
 3642 1190 7091 0000 		lds r23,czas_stop_h
 3643 1194 8091 0000 		lds r24,czas_stop_m
 3644 1198 90E0      		ldi r25,0
 3645 119a 769F      		mul r23,r22
 3646 119c 800D      		add r24,r0
 3647 119e 911D      		adc r25,r1
 3648 11a0 1124      		clr __zero_reg__
 3649               	.LVL319:
 186:main_sim900.h ****                     // Normalny przedzial (np. 08:00 - 16:00)
 3650               		.loc 2 186 0
 3651 11a2 8217      		cp r24,r18
 3652 11a4 9307      		cpc r25,r19
 3653 11a6 04F0      		brlt .L236
 188:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 3654               		.loc 2 188 0
 3655 11a8 4217      		cp r20,r18
 3656 11aa 5307      		cpc r21,r19
 3657 11ac 04F0      		brlt .L237
 3658               	.L397:
 194:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 3659               		.loc 2 194 0 discriminator 1
 3660 11ae 8417      		cp r24,r20
 3661 11b0 9507      		cpc r25,r21
 3662 11b2 04F0      		brlt .+2
 3663 11b4 00C0      		rjmp .L238
 3664               	.L237:
 191:main_sim900.h ****                   } else {
 3665               		.loc 2 191 0
 3666 11b6 8FEF      		ldi r24,lo8(-1)
 3667               	.LVL320:
 3668 11b8 8093 0000 		sts blokada_sterowania_czasowa,r24
 3669 11bc 00C0      		rjmp .L205
 3670               	.LVL321:
 3671               	.L236:
 194:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 3672               		.loc 2 194 0
 3673 11be 4217      		cp r20,r18
 3674 11c0 5307      		cpc r21,r19
 3675 11c2 04F0      		brlt .L397
 3676 11c4 00C0      		rjmp .L238
 3677               	.LVL322:
 3678               	.L225:
 3679               	.LBE526:
 3680               	.LBE525:
 3681               	.LBE524:
 3682               	.LBE523:
 3683               	.LBE522:
 3684               	.LBB527:
 211:main_sim900.h ****       if (polozenie_polecenia_SIM900(polecenie_pin_ready) != NULL) {
 3685               		.loc 2 211 0
 3686 11c6 D130      		cpi r29,lo8(1)
 3687 11c8 01F4      		brne .L239
 212:main_sim900.h ****         podlaczona_karta_SIM_SIM900 = TRUE;
 3688               		.loc 2 212 0
 3689 11ca 80E0      		ldi r24,lo8(polecenie_pin_ready.3232)
 3690 11cc 90E0      		ldi r25,hi8(polecenie_pin_ready.3232)
 3691 11ce 0E94 0000 		call polozenie_polecenia_SIM900
 3692               	.LVL323:
 3693 11d2 892B      		or r24,r25
 3694 11d4 01F0      		breq .L240
 213:main_sim900.h ****         bledny_PIN = FALSE;
 3695               		.loc 2 213 0
 3696 11d6 8FEF      		ldi r24,lo8(-1)
 3697 11d8 8093 0000 		sts podlaczona_karta_SIM_SIM900,r24
 214:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 3698               		.loc 2 214 0
 3699 11dc 1092 0000 		sts bledny_PIN,__zero_reg__
 215:main_sim900.h ****       } else
 3700               		.loc 2 215 0
 3701 11e0 82E9      		ldi r24,lo8(-110)
 3702               	.L398:
 217:main_sim900.h ****       nr_zapytania_o_pin = 0;
 3703               		.loc 2 217 0
 3704 11e2 0E94 0000 		call dodaj_komende
 3705               	.LVL324:
 3706               	.L402:
 225:main_sim900.h ****       } else {
 3707               		.loc 2 225 0
 3708 11e6 1092 0000 		sts nr_zapytania_o_pin.3233,__zero_reg__
 3709 11ea 00C0      		rjmp .L205
 3710               	.L240:
 217:main_sim900.h ****       nr_zapytania_o_pin = 0;
 3711               		.loc 2 217 0
 3712 11ec 8EE8      		ldi r24,lo8(-114)
 3713 11ee 00C0      		rjmp .L398
 3714               	.L239:
 219:main_sim900.h ****                numer_bledu_cme == CME_SIM_BUSY)
 3715               		.loc 2 219 0
 3716 11f0 D530      		cpi r29,lo8(5)
 3717 11f2 01F4      		brne .L242
 219:main_sim900.h ****                numer_bledu_cme == CME_SIM_BUSY)
 3718               		.loc 2 219 0 is_stmt 0 discriminator 1
 3719 11f4 8091 0000 		lds r24,numer_bledu_cme
 3720 11f8 9091 0000 		lds r25,numer_bledu_cme+1
 3721 11fc 0E97      		sbiw r24,14
 3722 11fe 01F4      		brne .L243
 3723               	.L406:
 228:main_sim900.h ****       }
 3724               		.loc 2 228 0 is_stmt 1
 3725 1200 8FE9      		ldi r24,lo8(-97)
 3726               	.L404:
 3727               	.LBE527:
 266:main_sim900.h ****     else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 3728               		.loc 2 266 0
 3729 1202 0E94 0000 		call dodaj_komende
 3730               	.LVL325:
 3731 1206 00C0      		rjmp .L205
 3732               	.L242:
 3733               	.LBB528:
 222:main_sim900.h ****       if (++nr_zapytania_o_pin >= 20) {
 3734               		.loc 2 222 0
 3735 1208 D430      		cpi r29,lo8(4)
 3736 120a 01F0      		breq .L244
 3737               	.L243:
 222:main_sim900.h ****       if (++nr_zapytania_o_pin >= 20) {
 3738               		.loc 2 222 0 is_stmt 0 discriminator 1
 3739 120c 8091 0000 		lds r24,komenda_SIM900
 3740 1210 8038      		cpi r24,lo8(-128)
 3741 1212 01F4      		brne .L406
 3742               	.L244:
 223:main_sim900.h ****         reset_modulu_SIM900();
 3743               		.loc 2 223 0 is_stmt 1
 3744 1214 8091 0000 		lds r24,nr_zapytania_o_pin.3233
 3745 1218 8F5F      		subi r24,lo8(-(1))
 3746 121a 8093 0000 		sts nr_zapytania_o_pin.3233,r24
 3747 121e 8431      		cpi r24,lo8(20)
 3748 1220 00F0      		brlo .L246
 224:main_sim900.h ****         nr_zapytania_o_pin = 0;
 3749               		.loc 2 224 0
 3750 1222 0E94 0000 		call reset_modulu_SIM900
 3751               	.LVL326:
 3752 1226 00C0      		rjmp .L402
 3753               	.L246:
 227:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3754               		.loc 2 227 0
 3755 1228 84E1      		ldi r24,lo8(20)
 3756 122a 8093 0000 		sts opoznienie_SIM900_100MS,r24
 3757 122e 00C0      		rjmp .L406
 3758               	.L213:
 3759               	.LBE528:
 235:main_sim900.h ****       podlaczona_karta_SIM_SIM900 = TRUE;
 3760               		.loc 2 235 0
 3761 1230 D130      		cpi r29,lo8(1)
 3762 1232 01F4      		brne .L247
 236:main_sim900.h ****       bledny_PIN = FALSE;
 3763               		.loc 2 236 0
 3764 1234 8FEF      		ldi r24,lo8(-1)
 3765 1236 8093 0000 		sts podlaczona_karta_SIM_SIM900,r24
 237:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 3766               		.loc 2 237 0
 3767 123a 1092 0000 		sts bledny_PIN,__zero_reg__
 238:main_sim900.h ****       opoznienie_SIM900_100MS = 50;
 3768               		.loc 2 238 0
 3769 123e 82E9      		ldi r24,lo8(-110)
 3770 1240 0E94 0000 		call dodaj_komende
 3771               	.LVL327:
 239:main_sim900.h ****     } else if (kom == CME_ERROR_KOMENDA_SIM900 &&
 3772               		.loc 2 239 0
 3773 1244 82E3      		ldi r24,lo8(50)
 3774               	.L403:
 534:main_sim900.h ****       break;
 3775               		.loc 2 534 0
 3776 1246 8093 0000 		sts opoznienie_SIM900_100MS,r24
 535:main_sim900.h ****     } // bez break
 3777               		.loc 2 535 0
 3778 124a 00C0      		rjmp .L205
 3779               	.L247:
 240:main_sim900.h ****                numer_bledu_cme == CME_SIM_INCORECT_PASWORD)
 3780               		.loc 2 240 0
 3781 124c D530      		cpi r29,lo8(5)
 3782 124e 01F4      		brne .L248
 241:main_sim900.h ****       bledny_PIN = TRUE;
 3783               		.loc 2 241 0 discriminator 1
 3784 1250 8091 0000 		lds r24,numer_bledu_cme
 3785 1254 9091 0000 		lds r25,numer_bledu_cme+1
 240:main_sim900.h ****                numer_bledu_cme == CME_SIM_INCORECT_PASWORD)
 3786               		.loc 2 240 0 discriminator 1
 3787 1258 8031      		cpi r24,16
 3788 125a 9105      		cpc r25,__zero_reg__
 3789 125c 01F4      		brne .L249
 242:main_sim900.h ****     else if (kom == CME_ERROR_KOMENDA_SIM900 && numer_bledu_cme == CME_SIM_BUSY)
 3790               		.loc 2 242 0
 3791 125e 8FEF      		ldi r24,lo8(-1)
 3792 1260 8093 0000 		sts bledny_PIN,r24
 3793 1264 00C0      		rjmp .L205
 3794               	.L249:
 243:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3795               		.loc 2 243 0 discriminator 1
 3796 1266 0E97      		sbiw r24,14
 3797 1268 01F4      		brne .L250
 3798               	.L251:
 244:main_sim900.h ****     else if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900())
 3799               		.loc 2 244 0
 3800 126a 8EE8      		ldi r24,lo8(-114)
 3801 126c 00C0      		rjmp .L404
 3802               	.L248:
 245:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3803               		.loc 2 245 0
 3804 126e D430      		cpi r29,lo8(4)
 3805 1270 01F0      		breq .L251
 3806               	.L250:
 245:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3807               		.loc 2 245 0 is_stmt 0 discriminator 1
 3808 1272 8091 0000 		lds r24,komenda_SIM900
 3809 1276 00C0      		rjmp .L251
 3810               	.L214:
 252:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW);
 3811               		.loc 2 252 0 is_stmt 1
 3812 1278 D130      		cpi r29,lo8(1)
 3813 127a 01F4      		brne .L252
 3814               	.L405:
 275:main_sim900.h ****     }
 3815               		.loc 2 275 0
 3816 127c 80EA      		ldi r24,lo8(-96)
 3817 127e 00C0      		rjmp .L404
 3818               	.L252:
 254:main_sim900.h ****       if (numer_bledu_cms == CMS_SIM_BUSY ||
 3819               		.loc 2 254 0
 3820 1280 D630      		cpi r29,lo8(6)
 3821 1282 01F4      		brne .L253
 255:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 3822               		.loc 2 255 0
 3823 1284 8091 0000 		lds r24,numer_bledu_cms
 3824 1288 9091 0000 		lds r25,numer_bledu_cms+1
 3825 128c 8A33      		cpi r24,58
 3826 128e 21E0      		ldi r18,1
 3827 1290 9207      		cpc r25,r18
 3828 1292 01F0      		breq .L254
 255:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 3829               		.loc 2 255 0 is_stmt 0 discriminator 1
 3830 1294 8530      		cpi r24,5
 3831 1296 9240      		sbci r25,2
 3832 1298 01F0      		breq .+2
 3833 129a 00C0      		rjmp .L205
 3834               	.L254:
 257:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3835               		.loc 2 257 0 is_stmt 1
 3836 129c 8CE3      		ldi r24,lo8(60)
 3837 129e 8093 0000 		sts opoznienie_SIM900_100MS,r24
 3838               	.L255:
 261:main_sim900.h ****     break;
 3839               		.loc 2 261 0
 3840 12a2 82E9      		ldi r24,lo8(-110)
 3841 12a4 00C0      		rjmp .L404
 3842               	.L253:
 260:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3843               		.loc 2 260 0
 3844 12a6 D430      		cpi r29,lo8(4)
 3845 12a8 01F0      		breq .L255
 260:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3846               		.loc 2 260 0 is_stmt 0 discriminator 1
 3847 12aa 8091 0000 		lds r24,komenda_SIM900
 3848 12ae 8038      		cpi r24,lo8(-128)
 3849 12b0 01F0      		breq .+2
 3850 12b2 00C0      		rjmp .L205
 3851 12b4 00C0      		rjmp .L255
 3852               	.L256:
 267:main_sim900.h ****       if (numer_bledu_cms == CMS_SIM_BUSY ||
 3853               		.loc 2 267 0 is_stmt 1
 3854 12b6 D630      		cpi r29,lo8(6)
 3855 12b8 01F4      		brne .L257
 268:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 3856               		.loc 2 268 0
 3857 12ba 8091 0000 		lds r24,numer_bledu_cms
 3858 12be 9091 0000 		lds r25,numer_bledu_cms+1
 3859 12c2 8A33      		cpi r24,58
 3860 12c4 21E0      		ldi r18,1
 3861 12c6 9207      		cpc r25,r18
 3862 12c8 01F0      		breq .L258
 268:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 3863               		.loc 2 268 0 is_stmt 0 discriminator 1
 3864 12ca 8530      		cpi r24,5
 3865 12cc 9240      		sbci r25,2
 3866 12ce 01F0      		breq .+2
 3867 12d0 00C0      		rjmp .L205
 3868               	.L258:
 270:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3869               		.loc 2 270 0 is_stmt 1
 3870 12d2 84E1      		ldi r24,lo8(20)
 3871               	.L407:
 274:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3872               		.loc 2 274 0
 3873 12d4 8093 0000 		sts opoznienie_SIM900_100MS,r24
 3874 12d8 00C0      		rjmp .L405
 3875               	.L257:
 3876 12da 8AE0      		ldi r24,lo8(10)
 3877 12dc 00C0      		rjmp .L407
 3878               	.L227:
 280:main_sim900.h ****         (kom == CME_ERROR_KOMENDA_SIM900 &&
 3879               		.loc 2 280 0
 3880 12de D130      		cpi r29,lo8(1)
 3881 12e0 01F0      		breq .L259
 280:main_sim900.h ****         (kom == CME_ERROR_KOMENDA_SIM900 &&
 3882               		.loc 2 280 0 is_stmt 0 discriminator 1
 3883 12e2 D530      		cpi r29,lo8(5)
 3884 12e4 01F4      		brne .L260
 282:main_sim900.h ****           numer_bledu_cme == CME_OPERATION_NOT_SUPPORTED))) {
 3885               		.loc 2 282 0 is_stmt 1
 3886 12e6 8091 0000 		lds r24,numer_bledu_cme
 3887 12ea 9091 0000 		lds r25,numer_bledu_cme+1
 3888 12ee 0397      		sbiw r24,3
 281:main_sim900.h ****          (numer_bledu_cme == CME_OPERATION_NOT_ALLOWED ||
 3889               		.loc 2 281 0
 3890 12f0 0297      		sbiw r24,2
 3891 12f2 00F4      		brsh .L260
 3892               	.L259:
 284:main_sim900.h ****       nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 3893               		.loc 2 284 0
 3894 12f4 8091 0000 		lds r24,nastepne_wysylane_polecenie_SIM900
 3895 12f8 0E94 0000 		call dodaj_komende
 3896               	.LVL328:
 3897               	.L293:
 564:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 3898               		.loc 2 564 0
 3899 12fc 1092 0000 		sts nastepne_wysylane_polecenie_SIM900,__zero_reg__
 565:main_sim900.h ****     }
 3900               		.loc 2 565 0
 3901 1300 1092 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,__zero_reg__
 3902 1304 00C0      		rjmp .L261
 3903               	.L260:
 288:main_sim900.h ****                    MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 3904               		.loc 2 288 0 discriminator 1
 3905 1306 8091 0000 		lds r24,liczba_wykonanych_komend_identycznego_polecenia
 3906 130a 8F5F      		subi r24,lo8(-(1))
 287:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 3907               		.loc 2 287 0 discriminator 1
 3908 130c 8093 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,r24
 3909 1310 8330      		cpi r24,lo8(3)
 3910 1312 00F4      		brsh .L261
 290:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 3911               		.loc 2 290 0
 3912 1314 82EA      		ldi r24,lo8(-94)
 3913               	.L399:
 3914 1316 0E94 0000 		call dodaj_komende
 3915               	.LVL329:
 3916               	.L261:
 291:main_sim900.h ****     break;
 3917               		.loc 2 291 0
 3918 131a 82E0      		ldi r24,lo8(2)
 3919 131c 00C0      		rjmp .L403
 3920               	.L220:
 295:main_sim900.h ****       static const uchar urc[] PROGMEM = "+CSQ:";
 3921               		.loc 2 295 0
 3922 131e D130      		cpi r29,lo8(1)
 3923 1320 01F4      		brne .L263
 3924               	.LBB529:
 297:main_sim900.h ****       if (p1 != NULL) {
 3925               		.loc 2 297 0
 3926 1322 80E0      		ldi r24,lo8(urc.3239)
 3927 1324 90E0      		ldi r25,hi8(urc.3239)
 3928 1326 0E94 0000 		call polozenie_polecenia_SIM900
 3929               	.LVL330:
 298:main_sim900.h ****         p1 += strlen_R(urc) + 1;
 3930               		.loc 2 298 0
 3931 132a 0097      		sbiw r24,0
 3932 132c 01F4      		brne .+2
 3933 132e 00C0      		rjmp .L205
 3934               	.LVL331:
 300:main_sim900.h ****         // if ( poziom_sieci_gsm != POZIOM_SIECI_BLAD )
 3935               		.loc 2 300 0
 3936 1330 4AE0      		ldi r20,lo8(10)
 3937 1332 50E0      		ldi r21,0
 3938 1334 70E0      		ldi r23,0
 3939 1336 60E0      		ldi r22,0
 3940 1338 0696      		adiw r24,6
 3941               	.LVL332:
 3942 133a 0E94 0000 		call strtol
 3943               	.LVL333:
 3944 133e 6093 0000 		sts poziom_sieci_gsm,r22
 3945 1342 00C0      		rjmp .L205
 3946               	.L263:
 3947               	.LBE529:
 309:main_sim900.h ****     break;
 3948               		.loc 2 309 0
 3949 1344 83E6      		ldi r24,lo8(99)
 3950 1346 8093 0000 		sts poziom_sieci_gsm,r24
 3951 134a 00C0      		rjmp .L205
 3952               	.LVL334:
 3953               	.L264:
 3954               	.LBB530:
 3955               	.LBB521:
 319:main_sim900.h ****         if (*p1 != ',')
 3956               		.loc 2 319 0
 3957 134c 3896      		adiw r30,8
 3958               	.LVL335:
 3959 134e 00C0      		rjmp .L265
 3960               	.LVL336:
 3961               	.L269:
 329:main_sim900.h ****           modul_zalogowany_w_sieci = TRUE;
 3962               		.loc 2 329 0
 3963 1350 6B7F      		andi r22,lo8(-5)
 3964               	.LVL337:
 3965 1352 6130      		cpi r22,lo8(1)
 3966 1354 01F0      		breq .+2
 3967 1356 00C0      		rjmp .L205
 330:main_sim900.h ****         }
 3968               		.loc 2 330 0
 3969 1358 8FEF      		ldi r24,lo8(-1)
 3970 135a 8093 0000 		sts modul_zalogowany_w_sieci,r24
 3971 135e 00C0      		rjmp .L205
 3972               	.L216:
 3973               	.LBE521:
 3974               	.LBE530:
 337:main_sim900.h ****                                      (numer_bledu_cme == CME_INVALID_INDEX ||
 3975               		.loc 2 337 0
 3976 1360 D130      		cpi r29,lo8(1)
 3977 1362 01F0      		breq .L270
 337:main_sim900.h ****                                      (numer_bledu_cme == CME_INVALID_INDEX ||
 3978               		.loc 2 337 0 is_stmt 0 discriminator 1
 3979 1364 D530      		cpi r29,lo8(5)
 3980 1366 01F4      		brne .L271
 338:main_sim900.h ****                                       numer_bledu_cme == CME_NOT_FOUND))) {
 3981               		.loc 2 338 0 is_stmt 1 discriminator 2
 3982 1368 8091 0000 		lds r24,numer_bledu_cme
 3983 136c 9091 0000 		lds r25,numer_bledu_cme+1
 3984 1370 4597      		sbiw r24,21
 337:main_sim900.h ****                                      (numer_bledu_cme == CME_INVALID_INDEX ||
 3985               		.loc 2 337 0 discriminator 2
 3986 1372 0297      		sbiw r24,2
 3987 1374 00F4      		brsh .L271
 3988               	.L270:
 340:main_sim900.h ****     } else {
 3989               		.loc 2 340 0
 3990 1376 1092 0000 		sts licznik_blad_stanu_karty_SIM,__zero_reg__
 3991 137a 00C0      		rjmp .L205
 3992               	.L271:
 342:main_sim900.h ****     }
 3993               		.loc 2 342 0
 3994 137c 8091 0000 		lds r24,licznik_blad_stanu_karty_SIM
 3995 1380 8F5F      		subi r24,lo8(-(1))
 3996 1382 8093 0000 		sts licznik_blad_stanu_karty_SIM,r24
 3997 1386 00C0      		rjmp .L205
 3998               	.L221:
 3999               	.LVL338:
 4000               	.LBB531:
 349:main_sim900.h ****       const uchar *p1 =
 4001               		.loc 2 349 0
 4002 1388 D130      		cpi r29,lo8(1)
 4003 138a 01F0      		breq .+2
 4004 138c 00C0      		rjmp .L272
 4005               	.LVL339:
 4006               	.LBB532:
 4007               	.LBB533:
  47:main_sim900.h **** }
 4008               		.loc 2 47 0
 4009 138e 46E0      		ldi r20,lo8(6)
 4010 1390 50E0      		ldi r21,0
 4011 1392 60E0      		ldi r22,lo8(polecenie_operator.3247)
 4012 1394 70E0      		ldi r23,hi8(polecenie_operator.3247)
 4013 1396 80E0      		ldi r24,lo8(odebrany_blok_SIM900+2)
 4014 1398 90E0      		ldi r25,hi8(odebrany_blok_SIM900+2)
 4015 139a 0E94 0000 		call strncmp_P
 4016               	.LVL340:
 4017               	.LBE533:
 4018               	.LBE532:
 349:main_sim900.h ****       const uchar *p1 =
 4019               		.loc 2 349 0
 4020 139e 892B      		or r24,r25
 4021 13a0 01F4      		brne .L272
 4022               	.LBB534:
 351:main_sim900.h ****       if (p1 != NULL) {
 4023               		.loc 2 351 0
 4024 13a2 80E0      		ldi r24,lo8(polecenie_operator.3247)
 4025 13a4 90E0      		ldi r25,hi8(polecenie_operator.3247)
 4026 13a6 0E94 0000 		call polozenie_polecenia_SIM900
 4027               	.LVL341:
 350:main_sim900.h ****           strchr(polozenie_polecenia_SIM900(polecenie_operator), ',');
 4028               		.loc 2 350 0
 4029 13aa 6CE2      		ldi r22,lo8(44)
 4030 13ac 70E0      		ldi r23,0
 4031 13ae 0E94 0000 		call strchr
 4032               	.LVL342:
 352:main_sim900.h ****         p1 = strchr(p1, ',');
 4033               		.loc 2 352 0
 4034 13b2 0097      		sbiw r24,0
 4035 13b4 01F0      		breq .L272
 353:main_sim900.h ****         if (p1 != NULL) {
 4036               		.loc 2 353 0
 4037 13b6 6CE2      		ldi r22,lo8(44)
 4038 13b8 70E0      		ldi r23,0
 4039 13ba 0E94 0000 		call strchr
 4040               	.LVL343:
 354:main_sim900.h ****           p1 = strchr(p1, '\"');
 4041               		.loc 2 354 0
 4042 13be 0097      		sbiw r24,0
 4043 13c0 01F0      		breq .L272
 355:main_sim900.h ****           if (p1++ != NULL) {
 4044               		.loc 2 355 0
 4045 13c2 62E2      		ldi r22,lo8(34)
 4046 13c4 70E0      		ldi r23,0
 4047 13c6 0E94 0000 		call strchr
 4048               	.LVL344:
 356:main_sim900.h ****             const uchar *p2 = strchr(p1, '\"');
 4049               		.loc 2 356 0
 4050 13ca 0097      		sbiw r24,0
 4051 13cc 01F0      		breq .L272
 4052 13ce 8C01      		movw r16,r24
 4053 13d0 0F5F      		subi r16,-1
 4054 13d2 1F4F      		sbci r17,-1
 4055               	.LVL345:
 4056               	.LBB535:
 357:main_sim900.h ****             if (p2 != NULL && p1 != p2) {
 4057               		.loc 2 357 0
 4058 13d4 62E2      		ldi r22,lo8(34)
 4059 13d6 70E0      		ldi r23,0
 4060 13d8 C801      		movw r24,r16
 4061 13da 0E94 0000 		call strchr
 4062               	.LVL346:
 358:main_sim900.h ****               const uchar m = min(p2 - p1, ROZMIAR_NAZWA_OPERATORA);
 4063               		.loc 2 358 0
 4064 13de 0097      		sbiw r24,0
 4065 13e0 01F0      		breq .L272
 358:main_sim900.h ****               const uchar m = min(p2 - p1, ROZMIAR_NAZWA_OPERATORA);
 4066               		.loc 2 358 0 is_stmt 0 discriminator 1
 4067 13e2 0817      		cp r16,r24
 4068 13e4 1907      		cpc r17,r25
 4069 13e6 01F0      		breq .L272
 4070               	.LVL347:
 4071               	.LBB536:
 359:main_sim900.h ****               memcpy(nazwa_operatora, p1, m);
 4072               		.loc 2 359 0 is_stmt 1
 4073 13e8 801B      		sub r24,r16
 4074 13ea 910B      		sbc r25,r17
 4075               	.LVL348:
 4076 13ec 8C30      		cpi r24,12
 4077 13ee 9105      		cpc r25,__zero_reg__
 4078 13f0 04F0      		brlt .L273
 4079 13f2 8BE0      		ldi r24,lo8(11)
 4080 13f4 90E0      		ldi r25,0
 4081               	.L273:
 4082 13f6 EC01      		movw r28,r24
 4083 13f8 DD27      		clr r29
 360:main_sim900.h ****               nazwa_operatora[m] = '\0';
 4084               		.loc 2 360 0
 4085 13fa AE01      		movw r20,r28
 4086 13fc B801      		movw r22,r16
 4087 13fe 80E0      		ldi r24,lo8(nazwa_operatora)
 4088 1400 90E0      		ldi r25,hi8(nazwa_operatora)
 4089 1402 0E94 0000 		call memcpy
 4090               	.LVL349:
 361:main_sim900.h ****               w = TRUE;
 4091               		.loc 2 361 0
 4092 1406 C050      		subi r28,lo8(-(nazwa_operatora))
 4093 1408 D040      		sbci r29,hi8(-(nazwa_operatora))
 4094 140a 1882      		st Y,__zero_reg__
 4095               	.LVL350:
 4096               	.LBE536:
 4097               	.LBE535:
 4098               	.LBE534:
 369:main_sim900.h ****     else {
 4099               		.loc 2 369 0
 4100 140c 1092 0000 		sts licznik_blad_zalogowania_u_operatora,__zero_reg__
 4101 1410 00C0      		rjmp .L205
 4102               	.LVL351:
 4103               	.L272:
 371:main_sim900.h ****     }
 4104               		.loc 2 371 0
 4105 1412 8091 0000 		lds r24,licznik_blad_zalogowania_u_operatora
 4106 1416 8F5F      		subi r24,lo8(-(1))
 4107 1418 8093 0000 		sts licznik_blad_zalogowania_u_operatora,r24
 4108 141c 00C0      		rjmp .L205
 4109               	.LVL352:
 4110               	.L208:
 4111               	.LBE531:
 377:main_sim900.h ****         CMS_ERROR_KOMENDA_SIM900 /*&& numer_bledu_cms == CMS_SMS_ME_RESERVED*/) // co le interpretu
 4112               		.loc 2 377 0
 4113 141e D630      		cpi r29,lo8(6)
 4114 1420 01F4      		brne .+2
 4115 1422 00C0      		rjmp .L261
 381:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 4116               		.loc 2 381 0
 4117 1424 85E9      		ldi r24,lo8(-107)
 380:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 4118               		.loc 2 380 0
 4119 1426 D130      		cpi r29,lo8(1)
 4120 1428 01F0      		breq .+2
 4121 142a 00C0      		rjmp .L399
 4122 142c 00C0      		rjmp .L261
 4123               	.L218:
 386:main_sim900.h ****         czy_jest_komenda_uzytkownik_odebral_rozmowe()) {
 4124               		.loc 2 386 0
 4125 142e D130      		cpi r29,lo8(1)
 4126 1430 01F0      		breq .L275
 387:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = TRUE;
 4127               		.loc 2 387 0 discriminator 1
 4128 1432 8091 0000 		lds r24,komenda_SIM900
 386:main_sim900.h ****         czy_jest_komenda_uzytkownik_odebral_rozmowe()) {
 4129               		.loc 2 386 0 discriminator 1
 4130 1436 8C30      		cpi r24,lo8(12)
 4131 1438 01F4      		brne .L276
 4132               	.L275:
 388:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 4133               		.loc 2 388 0
 4134 143a 8FEF      		ldi r24,lo8(-1)
 4135 143c 8093 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,r24
 389:main_sim900.h **** 
 4136               		.loc 2 389 0
 4137 1440 1092 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,__zero_reg__
 392:main_sim900.h ****         licznik_timeout_rozmowy_100ms = MAX_LICZNIK_TIMEOUT_ROZMOWY_100MS;
 4138               		.loc 2 392 0
 4139 1444 8091 0000 		lds r24,tryb_clip
 4140 1448 8111      		cpse r24,__zero_reg__
 4141 144a 00C0      		rjmp .L205
 393:main_sim900.h ****         opoznienie_SIM900_100MS =
 4142               		.loc 2 393 0
 4143 144c 8CE2      		ldi r24,lo8(44)
 4144 144e 91E0      		ldi r25,lo8(1)
 4145 1450 9093 0000 		sts licznik_timeout_rozmowy_100ms+1,r25
 4146 1454 8093 0000 		sts licznik_timeout_rozmowy_100ms,r24
 394:main_sim900.h ****             20; // 2 sekundy opoznienia przed wyslaniem tonu
 4147               		.loc 2 394 0
 4148 1458 84E1      		ldi r24,lo8(20)
 4149 145a 8093 0000 		sts opoznienie_SIM900_100MS,r24
 396:main_sim900.h ****       }
 4150               		.loc 2 396 0
 4151 145e 85EA      		ldi r24,lo8(-91)
 4152 1460 00C0      		rjmp .L404
 4153               	.L276:
 398:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 4154               		.loc 2 398 0
 4155 1462 D430      		cpi r29,lo8(4)
 4156 1464 01F0      		breq .L277
 398:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 4157               		.loc 2 398 0 is_stmt 0 discriminator 2
 4158 1466 8091 0000 		lds r24,komenda_SIM900
 4159 146a 8038      		cpi r24,lo8(-128)
 4160 146c 01F4      		brne .L278
 4161               	.L277:
 399:main_sim900.h ****                    MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 4162               		.loc 2 399 0 is_stmt 1 discriminator 3
 4163 146e 8091 0000 		lds r24,liczba_wykonanych_komend_identycznego_polecenia
 4164 1472 8F5F      		subi r24,lo8(-(1))
 398:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 4165               		.loc 2 398 0 discriminator 3
 4166 1474 8093 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,r24
 4167 1478 8330      		cpi r24,lo8(3)
 4168 147a 00F4      		brsh .L278
 401:main_sim900.h ****     else if (kom == NO_CARRIER_KOMENDA_SIM900) {
 4169               		.loc 2 401 0
 4170 147c 86E9      		ldi r24,lo8(-106)
 4171 147e 00C0      		rjmp .L404
 4172               	.L278:
 402:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 4173               		.loc 2 402 0
 4174 1480 D330      		cpi r29,lo8(3)
 4175 1482 01F4      		brne .L279
 403:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 4176               		.loc 2 403 0
 4177 1484 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 4178               	.L279:
 406:main_sim900.h ****     break;
 4179               		.loc 2 406 0
 4180 1488 1092 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,__zero_reg__
 4181 148c 00C0      		rjmp .L205
 4182               	.L396:
 439:main_sim900.h ****       // odczytany sms
 4183               		.loc 2 439 0
 4184 148e D130      		cpi r29,lo8(1)
 4185 1490 01F4      		brne .L281
 4186               	.LBB537:
 441:main_sim900.h ****       ptr = strchr(ptr, ZNAK_KONCA_ODBIERANIA_ZNAKOW_LF);            // (1)
 4187               		.loc 2 441 0
 4188 1492 80E0      		ldi r24,lo8(__c.3276)
 4189 1494 90E0      		ldi r25,hi8(__c.3276)
 4190 1496 0E94 0000 		call polozenie_polecenia_SIM900
 4191               	.LVL353:
 442:main_sim900.h ****       // const uchar* ptr = strchr(&odebrany_blok_SIM900[7],
 4192               		.loc 2 442 0
 4193 149a 6AE0      		ldi r22,lo8(10)
 4194 149c 70E0      		ldi r23,0
 4195 149e 0E94 0000 		call strchr
 4196               	.LVL354:
 445:main_sim900.h ****         ++ptr;
 4197               		.loc 2 445 0
 4198 14a2 0097      		sbiw r24,0
 4199 14a4 01F0      		breq .L282
 4200               	.LBB538:
 446:main_sim900.h ****         const uchar *ptr2 = strchr(ptr, ZNAK_KONCA_WYSYLANIA_ZNAKOW_CR);
 4201               		.loc 2 446 0
 4202 14a6 EC01      		movw r28,r24
 4203 14a8 2196      		adiw r28,1
 4204               	.LVL355:
 447:main_sim900.h ****         if (ptr2 != NULL) {
 4205               		.loc 2 447 0
 4206 14aa 6DE0      		ldi r22,lo8(13)
 4207 14ac 70E0      		ldi r23,0
 4208 14ae CE01      		movw r24,r28
 4209 14b0 0E94 0000 		call strchr
 4210               	.LVL356:
 448:main_sim900.h ****           dlugosc_pdu = (ptr2 - ptr) / 2;
 4211               		.loc 2 448 0
 4212 14b4 0097      		sbiw r24,0
 4213 14b6 01F0      		breq .L282
 4214               	.LBB539:
 449:main_sim900.h ****           if (dlugosc_pdu > MAX_DLUGOSC_PDU)
 4215               		.loc 2 449 0
 4216 14b8 8C1B      		sub r24,r28
 4217 14ba 9D0B      		sbc r25,r29
 4218               	.LVL357:
 4219 14bc 97FD      		sbrc r25,7
 4220 14be 0196      		adiw r24,1
 4221               	.L283:
 4222 14c0 9595      		asr r25
 4223 14c2 8795      		ror r24
 450:main_sim900.h ****             dlugosc_pdu = MAX_DLUGOSC_PDU;
 4224               		.loc 2 450 0
 4225 14c4 893C      		cpi r24,lo8(-55)
 4226 14c6 00F4      		brsh .L284
 4227               	.L400:
 451:main_sim900.h ****           konwertuj_blok_dwa_znaki_na_znak_pdu(ptr, dlugosc_pdu, bufor_pdu);
 4228               		.loc 2 451 0
 4229 14c8 8093 0000 		sts dlugosc_pdu,r24
 452:main_sim900.h ****           dodaj_komende(KOMENDA_KOLEJKI_INTERPRETUJ_PDU);
 4230               		.loc 2 452 0
 4231 14cc 40E0      		ldi r20,lo8(bufor_pdu)
 4232 14ce 50E0      		ldi r21,hi8(bufor_pdu)
 4233 14d0 6091 0000 		lds r22,dlugosc_pdu
 4234 14d4 CE01      		movw r24,r28
 4235 14d6 0E94 0000 		call konwertuj_blok_dwa_znaki_na_znak_pdu
 4236               	.LVL358:
 453:main_sim900.h ****           const uchar nr_smsa = aktualnie_wysylane_polecenie_SIM900 -
 4237               		.loc 2 453 0
 4238 14da 82ED      		ldi r24,lo8(-46)
 4239 14dc 0E94 0000 		call dodaj_komende
 4240               	.LVL359:
 456:main_sim900.h ****           flaga_odczytywanie_smsa = TRUE;
 4241               		.loc 2 456 0
 4242 14e0 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4243 14e4 8C5E      		subi r24,lo8(-(20))
 4244 14e6 0E94 0000 		call dodaj_komende
 4245               	.LVL360:
 457:main_sim900.h ****           POMOC_DODAJ2('#', 'O');
 4246               		.loc 2 457 0
 4247 14ea 8FEF      		ldi r24,lo8(-1)
 4248 14ec 8093 0000 		sts flaga_odczytywanie_smsa,r24
 4249               	.LVL361:
 4250 14f0 00C0      		rjmp .L205
 4251               	.LVL362:
 4252               	.L284:
 451:main_sim900.h ****           konwertuj_blok_dwa_znaki_na_znak_pdu(ptr, dlugosc_pdu, bufor_pdu);
 4253               		.loc 2 451 0
 4254 14f2 88EC      		ldi r24,lo8(-56)
 4255 14f4 00C0      		rjmp .L400
 4256               	.LVL363:
 4257               	.L282:
 4258               	.LBE539:
 460:main_sim900.h ****       } else
 4259               		.loc 2 460 0
 4260 14f6 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 4261 14fa 00C0      		rjmp .L205
 4262               	.L281:
 4263               	.LBE538:
 4264               	.LBE537:
 463:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 4265               		.loc 2 463 0
 4266 14fc D630      		cpi r29,lo8(6)
 4267 14fe 01F0      		breq .L286
 4268               	.L408:
 468:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 4269               		.loc 2 468 0
 4270 1500 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 469:main_sim900.h ****       POMOC_DODAJ2('#', 'P');
 4271               		.loc 2 469 0
 4272 1504 8CE3      		ldi r24,lo8(60)
 4273 1506 00C0      		rjmp .L403
 4274               	.L286:
 467:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 4275               		.loc 2 467 0
 4276 1508 8C2F      		mov r24,r28
 4277 150a 0E94 0000 		call dodaj_komende
 4278               	.LVL364:
 4279 150e 00C0      		rjmp .L408
 4280               	.L287:
 502:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 4281               		.loc 2 502 0
 4282 1510 D430      		cpi r29,lo8(4)
 4283 1512 01F4      		brne .+2
 4284 1514 00C0      		rjmp .L401
 4285               	.L288:
 504:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 4286               		.loc 2 504 0
 4287 1516 8091 0000 		lds r24,komenda_SIM900
 4288 151a 8038      		cpi r24,lo8(-128)
 4289 151c 01F4      		brne .+2
 4290 151e 00C0      		rjmp .L401
 4291               	.L289:
 4292               	.LVL365:
 507:main_sim900.h ****     break;
 4293               		.loc 2 507 0
 4294 1520 89E1      		ldi r24,lo8(25)
 4295 1522 00C0      		rjmp .L403
 4296               	.LVL366:
 4297               	.L231:
 515:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 4298               		.loc 2 515 0
 4299 1524 D430      		cpi r29,lo8(4)
 4300 1526 01F0      		breq .L290
 515:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 4301               		.loc 2 515 0 is_stmt 0 discriminator 1
 4302 1528 8091 0000 		lds r24,komenda_SIM900
 4303 152c 8038      		cpi r24,lo8(-128)
 4304 152e 01F0      		breq .+2
 4305 1530 00C0      		rjmp .L279
 4306               	.L290:
 516:main_sim900.h ****       if (++liczba_wykonanych_komend_identycznego_polecenia <
 4307               		.loc 2 516 0 is_stmt 1
 4308 1532 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 517:main_sim900.h ****           MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 4309               		.loc 2 517 0
 4310 1536 8091 0000 		lds r24,liczba_wykonanych_komend_identycznego_polecenia
 4311 153a 8F5F      		subi r24,lo8(-(1))
 4312 153c 8093 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,r24
 4313 1540 8330      		cpi r24,lo8(3)
 4314 1542 00F4      		brsh .L291
 519:main_sim900.h ****       else {
 4315               		.loc 2 519 0
 4316 1544 86ED      		ldi r24,lo8(-42)
 4317 1546 00C0      		rjmp .L404
 4318               	.L291:
 521:main_sim900.h ****         zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 4319               		.loc 2 521 0
 4320 1548 1092 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,__zero_reg__
 522:main_sim900.h ****         trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 4321               		.loc 2 522 0
 4322 154c 80E0      		ldi r24,0
 4323 154e 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 4324               	.LVL367:
 523:main_sim900.h ****         wykonywanie_rozmowy_telefonicznej = FALSE;
 4325               		.loc 2 523 0
 4326 1552 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 524:main_sim900.h ****         licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 4327               		.loc 2 524 0
 4328 1556 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 525:main_sim900.h ****       }
 4329               		.loc 2 525 0
 4330 155a 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 4331 155e 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 4332 1562 00C0      		rjmp .L205
 4333               	.L210:
 532:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 4334               		.loc 2 532 0
 4335 1564 D130      		cpi r29,lo8(1)
 4336 1566 01F0      		breq .L292
 533:main_sim900.h ****       opoznienie_SIM900_100MS = 20;
 4337               		.loc 2 533 0
 4338 1568 8FE8      		ldi r24,lo8(-113)
 4339 156a 0E94 0000 		call dodaj_komende
 4340               	.LVL368:
 534:main_sim900.h ****       break;
 4341               		.loc 2 534 0
 4342 156e 84E1      		ldi r24,lo8(20)
 4343 1570 00C0      		rjmp .L403
 4344               	.L292:
 557:main_sim900.h ****       if (nastepne_wysylane_polecenie_SIM900 >=
 4345               		.loc 2 557 0
 4346 1572 8091 0000 		lds r24,nastepne_wysylane_polecenie_SIM900
 4347 1576 0E94 0000 		call dodaj_komende
 4348               	.LVL369:
 559:main_sim900.h ****           nastepne_wysylane_polecenie_SIM900 <=
 4349               		.loc 2 559 0
 4350 157a 8091 0000 		lds r24,nastepne_wysylane_polecenie_SIM900
 4351 157e 8A5A      		subi r24,lo8(-(86))
 558:main_sim900.h ****               KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 4352               		.loc 2 558 0
 4353 1580 8431      		cpi r24,lo8(20)
 4354 1582 00F0      		brlo .+2
 4355 1584 00C0      		rjmp .L293
 562:main_sim900.h ****       }
 4356               		.loc 2 562 0
 4357 1586 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 4358 158a 00C0      		rjmp .L293
 4359               		.cfi_endproc
 4360               	.LFE50:
 4362               	.global	obsluga_komendy_SIM900
 4364               	obsluga_komendy_SIM900:
 4365               	.LFB51:
 574:main_sim900.h **** 
 575:main_sim900.h **** void obsluga_komendy_SIM900(void) {
 4366               		.loc 2 575 0
 4367               		.cfi_startproc
 4368 158c 0F93      		push r16
 4369               	.LCFI64:
 4370               		.cfi_def_cfa_offset 3
 4371               		.cfi_offset 16, -2
 4372 158e 1F93      		push r17
 4373               	.LCFI65:
 4374               		.cfi_def_cfa_offset 4
 4375               		.cfi_offset 17, -3
 4376 1590 CF93      		push r28
 4377               	.LCFI66:
 4378               		.cfi_def_cfa_offset 5
 4379               		.cfi_offset 28, -4
 4380 1592 DF93      		push r29
 4381               	.LCFI67:
 4382               		.cfi_def_cfa_offset 6
 4383               		.cfi_offset 29, -5
 4384               	/* prologue: function */
 4385               	/* frame size = 0 */
 4386               	/* stack size = 4 */
 4387               	.L__stack_usage = 4
 576:main_sim900.h ****   if (!czy_jest_bezczynny_SIM900())
 4388               		.loc 2 576 0
 4389 1594 8091 0000 		lds r24,komenda_SIM900
 577:main_sim900.h ****     POMOC_SIM900_DODAJ(odebrany_blok_SIM900);
 578:main_sim900.h **** 
 579:main_sim900.h ****   if (czy_jest_blad_SIM900() || oproznij_bufor_SIM900_po_bledzie) {
 4390               		.loc 2 579 0
 4391 1598 8091 0000 		lds r24,komenda_SIM900
 4392 159c 8038      		cpi r24,lo8(-128)
 4393 159e 01F0      		breq .L410
 4394               		.loc 2 579 0 is_stmt 0 discriminator 1
 4395 15a0 8091 0000 		lds r24,oproznij_bufor_SIM900_po_bledzie
 4396 15a4 8823      		tst r24
 4397 15a6 01F0      		breq .L411
 4398               	.L410:
 580:main_sim900.h ****     komenda_SIM900 = BLAD_SIM900;
 4399               		.loc 2 580 0 is_stmt 1
 4400 15a8 80E8      		ldi r24,lo8(-128)
 4401 15aa 8093 0000 		sts komenda_SIM900,r24
 581:main_sim900.h ****     odpowiedz_na_polecenie();
 4402               		.loc 2 581 0
 4403 15ae 0E94 0000 		call odpowiedz_na_polecenie
 4404               	.LVL370:
 582:main_sim900.h ****     opoznienie_SIM900_100MS = 50;
 4405               		.loc 2 582 0
 4406 15b2 82E3      		ldi r24,lo8(50)
 4407 15b4 8093 0000 		sts opoznienie_SIM900_100MS,r24
 583:main_sim900.h ****     oproznij_bufor_SIM900_po_bledzie = TRUE;
 4408               		.loc 2 583 0
 4409 15b8 8FEF      		ldi r24,lo8(-1)
 4410 15ba 8093 0000 		sts oproznij_bufor_SIM900_po_bledzie,r24
 4411               	.LVL371:
 4412               	.L409:
 4413               	/* epilogue start */
 584:main_sim900.h ****     POMOC_DODAJ2('*', 'd');
 585:main_sim900.h ****     return;
 586:main_sim900.h ****   }
 587:main_sim900.h **** 
 588:main_sim900.h ****   if (czy_jest_komenda_wyslane_polecenie_SIM900()) {
 589:main_sim900.h ****     if ((liczba_wysylanych_znakow_SIM900 != liczba_odebranych_znakow_SIM900 ||
 590:main_sim900.h ****          memcmp(odebrany_blok_SIM900, wysylany_blok_SIM900,
 591:main_sim900.h ****                 liczba_wysylanych_znakow_SIM900) != 0) &&
 592:main_sim900.h ****         !czekanie_na_odebranie_zachety) {
 593:main_sim900.h ****       komenda_SIM900 = BLAD_SIM900;
 594:main_sim900.h ****       oproznij_bufor_SIM900_po_bledzie = TRUE;
 595:main_sim900.h ****       opoznienie_SIM900_100MS = 50;
 596:main_sim900.h ****       POMOC_DODAJ2('*', 'e');
 597:main_sim900.h ****     }
 598:main_sim900.h ****     return;
 599:main_sim900.h ****   }
 600:main_sim900.h **** 
 601:main_sim900.h ****   if (czy_jest_komenda_rozmowa_telefoniczna()) {
 602:main_sim900.h ****     POMOC_DODAJ2('#', 'b');
 603:main_sim900.h ****     // numer_telefonu_ktory_dzwoni[0] = '\0';  // REMOVED: Niepotrzebne
 604:main_sim900.h ****     // czyszczenie - numer jest zaraz nadpisywany
 605:main_sim900.h ****     const uchar *p1 = strchr(polozenie_polecenia_SIM900(PSTR("+CLIP:")), '\"');
 606:main_sim900.h ****     if (p1++ != NULL) {
 607:main_sim900.h ****       const uchar *p2 = strchr(p1, '\"');
 608:main_sim900.h ****       if (p2 != NULL) {
 609:main_sim900.h ****         const uchar l = p2 - p1;
 610:main_sim900.h ****         if (l < MAX_LICZBA_ZNAKOW_TELEFON) {
 611:main_sim900.h ****           memcpy(numer_telefonu_ktory_dzwoni, p1, l);
 612:main_sim900.h ****           numer_telefonu_ktory_dzwoni[l] = '\0';
 613:main_sim900.h ****           POMOC_DODAJ_HEX(l);
 614:main_sim900.h ****           if (licznik_blad_zalogowania_u_operatora != 0)
 615:main_sim900.h ****             licznik_blad_zalogowania_u_operatora = 0;
 616:main_sim900.h ****           if (poziom_sieci_gsm == 0 || poziom_sieci_gsm == POZIOM_SIECI_BLAD)
 617:main_sim900.h ****             poziom_sieci_gsm = 16;
 618:main_sim900.h ****         }
 619:main_sim900.h ****       }
 620:main_sim900.h ****     }
 621:main_sim900.h ****     filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_PRZYCHODZACA_ROZMOWE);
 622:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 623:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 624:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 625:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 626:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 627:main_sim900.h ****     }
 628:main_sim900.h ****     wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 629:main_sim900.h ****     return;
 630:main_sim900.h ****   }
 631:main_sim900.h **** 
 632:main_sim900.h ****   if (czy_jest_komenda_zakonczenie_rozmowy_telefonicznej()) {
 633:main_sim900.h ****     POMOC_DODAJ2('#', 'c');
 634:main_sim900.h ****     zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 635:main_sim900.h ****     trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 636:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 637:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 638:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 ==
 639:main_sim900.h ****         KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE) {
 640:main_sim900.h ****       wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 641:main_sim900.h ****     }
 642:main_sim900.h ****     return;
 643:main_sim900.h ****   }
 644:main_sim900.h **** 
 645:main_sim900.h ****   if (czy_jest_komenda_uzytkownik_odebral_dzwonek()) {
 646:main_sim900.h ****     POMOC_DODAJ2('#', 'd');
 647:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 == KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE)
 648:main_sim900.h ****       odpowiedz_na_polecenie();
 649:main_sim900.h ****     if (ustaw_maksymalny_czas_dzwonienia == 0)
 650:main_sim900.h ****       maksymalny_czas_dzwonienia = 90; // standardowy czas czekania 9 sekund
 651:main_sim900.h ****     else {
 652:main_sim900.h ****       maksymalny_czas_dzwonienia = ustaw_maksymalny_czas_dzwonienia;
 653:main_sim900.h ****       ustaw_maksymalny_czas_dzwonienia = 0;
 654:main_sim900.h ****     }
 655:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = TRUE;
 656:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 657:main_sim900.h ****     return;
 658:main_sim900.h ****   }
 659:main_sim900.h **** 
 660:main_sim900.h ****   // Obsluga +DTMF:
 661:main_sim900.h ****   const uchar *ptr_dtmf = polozenie_polecenia_SIM900(PSTR("+DTMF:"));
 662:main_sim900.h ****   if (ptr_dtmf != NULL) {
 663:main_sim900.h ****     POMOC_DODAJ2('#', 'D');
 664:main_sim900.h ****     ptr_dtmf += 7; // Skip "+DTMF: "
 665:main_sim900.h ****     while (*ptr_dtmf == ' ')
 666:main_sim900.h ****       ++ptr_dtmf;
 667:main_sim900.h ****     const uchar dtmf_key = *ptr_dtmf;
 668:main_sim900.h ****     POMOC_DODAJ(dtmf_key);
 669:main_sim900.h **** 
 670:main_sim900.h ****     if (!tryb_clip) // Tylko w trybie DTMF
 671:main_sim900.h ****     {
 672:main_sim900.h ****       if (dtmf_key == '1') {
 673:main_sim900.h ****         stan_wyjscie[0] = TRUE;
 674:main_sim900.h ****         licznik_przelacznik_wyjscia[0] = 2 * 10ul; // 2 sekundy retrigger
 675:main_sim900.h ****         zapal_diode_led(10);
 676:main_sim900.h ****       }
 677:main_sim900.h ****     }
 678:main_sim900.h ****     resetuj_komende_SIM900(); // Krytyczne dla kolejnych znakow
 679:main_sim900.h ****     return;
 680:main_sim900.h ****   }
 681:main_sim900.h **** 
 682:main_sim900.h ****   if (czy_jest_komenda_uzytkownik_odebral_rozmowe()) {
 683:main_sim900.h ****     POMOC_DODAJ2('#', 'e');
 684:main_sim900.h ****     if (tryb_clip) {
 685:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 686:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
 687:main_sim900.h ****     }
 688:main_sim900.h ****     return;
 689:main_sim900.h ****   }
 690:main_sim900.h ****   if (czy_jest_komenda_brak_sygnalu_tonowego()) {
 691:main_sim900.h ****     POMOC_DODAJ2('#', 'f');
 692:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 == KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE)
 693:main_sim900.h ****       odpowiedz_na_polecenie();
 694:main_sim900.h ****     zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 695:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 696:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 697:main_sim900.h ****     return;
 698:main_sim900.h ****   }
 699:main_sim900.h **** 
 700:main_sim900.h ****   if (czy_jest_komenda_telefon_zajety()) {
 701:main_sim900.h ****     POMOC_DODAJ2('#', 'g');
 702:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 == KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE)
 703:main_sim900.h ****       odpowiedz_na_polecenie();
 704:main_sim900.h ****     zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 705:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 706:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 707:main_sim900.h ****     return;
 708:main_sim900.h ****   }
 709:main_sim900.h **** 
 710:main_sim900.h ****   if (czy_jest_komenda_nowy_SMS()) {
 711:main_sim900.h ****     const uchar *ptr = strchr(polozenie_polecenia_SIM900(PSTR("+CMTI:")), ',');
 712:main_sim900.h ****     if (ptr != NULL) {
 713:main_sim900.h ****       uint numer_smsa = (uint)strtoul(ptr + 1, NULL, 10);
 714:main_sim900.h ****       if (numer_smsa > 0 && numer_smsa <= 20) // Hardcoded 20
 715:main_sim900.h ****       {
 716:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 + numer_smsa - 1);
 717:main_sim900.h ****         opoznienie_SIM900_100MS = 1; // 20 (1)
 718:main_sim900.h ****       }
 719:main_sim900.h ****     }
 720:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 721:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 722:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 723:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 724:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 725:main_sim900.h ****       wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 726:main_sim900.h ****     }
 727:main_sim900.h ****     return;
 728:main_sim900.h ****   }
 729:main_sim900.h **** 
 730:main_sim900.h ****   if (czy_jest_komenda_otrzymano_sms_flash()) {
 731:main_sim900.h ****     opoznienie_SIM900_100MS = 20;
 732:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 733:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 734:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 735:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 736:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 737:main_sim900.h ****       wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 738:main_sim900.h ****     }
 739:main_sim900.h ****     const uchar *p1 = strchr(polozenie_polecenia_SIM900(PSTR("+CUSD:")), '\"');
 740:main_sim900.h ****     if (p1++ != NULL) {
 741:main_sim900.h ****       uchar *p2 = strchr(p1, '\"');
 742:main_sim900.h ****       if (p2 != NULL) {
 743:main_sim900.h ****         //*p2 = '\0';
 744:main_sim900.h ****         // tekst_wysylanego_smsa[0] = '*';
 745:main_sim900.h ****         // strncpy(&tekst_wysylanego_smsa[1], p1, MAX_LICZBA_ZNAKOW_SMS - 1);
 746:main_sim900.h ****         // tekst_wysylanego_smsa[MAX_LICZBA_ZNAKOW_SMS] = 0;
 747:main_sim900.h ****       }
 748:main_sim900.h ****     }
 749:main_sim900.h ****     return;
 750:main_sim900.h ****   }
 751:main_sim900.h **** 
 752:main_sim900.h ****   if (flaga_wysylanie_smsa)
 753:main_sim900.h ****     obsluga_wysylania_sms();
 754:main_sim900.h **** 
 755:main_sim900.h ****   if (liczba_odebranych_znakow_SIM900 != 0 &&
 756:main_sim900.h ****       komenda_SIM900 != BRAK_KOMENDY_SIM900)
 757:main_sim900.h ****     odpowiedz_na_polecenie();
 758:main_sim900.h **** }
 4414               		.loc 2 758 0
 4415 15be DF91      		pop r29
 4416 15c0 CF91      		pop r28
 4417 15c2 1F91      		pop r17
 4418 15c4 0F91      		pop r16
 4419 15c6 0895      		ret
 4420               	.L411:
 588:main_sim900.h ****     if ((liczba_wysylanych_znakow_SIM900 != liczba_odebranych_znakow_SIM900 ||
 4421               		.loc 2 588 0
 4422 15c8 8091 0000 		lds r24,komenda_SIM900
 4423 15cc 8138      		cpi r24,lo8(-127)
 4424 15ce 01F4      		brne .L413
 589:main_sim900.h ****          memcmp(odebrany_blok_SIM900, wysylany_blok_SIM900,
 4425               		.loc 2 589 0
 4426 15d0 2091 0000 		lds r18,liczba_wysylanych_znakow_SIM900
 4427 15d4 3091 0000 		lds r19,liczba_wysylanych_znakow_SIM900+1
 4428 15d8 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 4429 15dc 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
 4430 15e0 2817      		cp r18,r24
 4431 15e2 3907      		cpc r19,r25
 4432 15e4 01F4      		brne .L414
 590:main_sim900.h ****                 liczba_wysylanych_znakow_SIM900) != 0) &&
 4433               		.loc 2 590 0 discriminator 1
 4434 15e6 4091 0000 		lds r20,liczba_wysylanych_znakow_SIM900
 4435 15ea 5091 0000 		lds r21,liczba_wysylanych_znakow_SIM900+1
 4436 15ee 60E0      		ldi r22,lo8(wysylany_blok_SIM900)
 4437 15f0 70E0      		ldi r23,hi8(wysylany_blok_SIM900)
 4438 15f2 80E0      		ldi r24,lo8(odebrany_blok_SIM900)
 4439 15f4 90E0      		ldi r25,hi8(odebrany_blok_SIM900)
 4440 15f6 0E94 0000 		call memcmp
 4441               	.LVL372:
 589:main_sim900.h ****          memcmp(odebrany_blok_SIM900, wysylany_blok_SIM900,
 4442               		.loc 2 589 0 discriminator 1
 4443 15fa 892B      		or r24,r25
 4444 15fc 01F0      		breq .L409
 4445               	.L414:
 592:main_sim900.h ****       komenda_SIM900 = BLAD_SIM900;
 4446               		.loc 2 592 0
 4447 15fe 8091 0000 		lds r24,czekanie_na_odebranie_zachety
 591:main_sim900.h ****         !czekanie_na_odebranie_zachety) {
 4448               		.loc 2 591 0
 4449 1602 8111      		cpse r24,__zero_reg__
 4450 1604 00C0      		rjmp .L409
 593:main_sim900.h ****       oproznij_bufor_SIM900_po_bledzie = TRUE;
 4451               		.loc 2 593 0
 4452 1606 80E8      		ldi r24,lo8(-128)
 4453 1608 8093 0000 		sts komenda_SIM900,r24
 594:main_sim900.h ****       opoznienie_SIM900_100MS = 50;
 4454               		.loc 2 594 0
 4455 160c 8FEF      		ldi r24,lo8(-1)
 4456 160e 8093 0000 		sts oproznij_bufor_SIM900_po_bledzie,r24
 595:main_sim900.h ****       POMOC_DODAJ2('*', 'e');
 4457               		.loc 2 595 0
 4458 1612 82E3      		ldi r24,lo8(50)
 4459 1614 8093 0000 		sts opoznienie_SIM900_100MS,r24
 4460               	.LVL373:
 4461 1618 00C0      		rjmp .L409
 4462               	.LVL374:
 4463               	.L413:
 4464               	.LBB554:
 4465               	.LBB555:
 601:main_sim900.h ****     POMOC_DODAJ2('#', 'b');
 4466               		.loc 2 601 0
 4467 161a 8091 0000 		lds r24,komenda_SIM900
 4468 161e 8A30      		cpi r24,lo8(10)
 4469 1620 01F0      		breq .+2
 4470 1622 00C0      		rjmp .L416
 4471               	.LVL375:
 4472               	.LBB556:
 605:main_sim900.h ****     if (p1++ != NULL) {
 4473               		.loc 2 605 0
 4474 1624 80E0      		ldi r24,lo8(__c.3318)
 4475 1626 90E0      		ldi r25,hi8(__c.3318)
 4476 1628 0E94 0000 		call polozenie_polecenia_SIM900
 4477               	.LVL376:
 4478 162c 62E2      		ldi r22,lo8(34)
 4479 162e 70E0      		ldi r23,0
 4480 1630 0E94 0000 		call strchr
 4481               	.LVL377:
 606:main_sim900.h ****       const uchar *p2 = strchr(p1, '\"');
 4482               		.loc 2 606 0
 4483 1634 0097      		sbiw r24,0
 4484 1636 01F0      		breq .L418
 4485 1638 8C01      		movw r16,r24
 4486 163a 0F5F      		subi r16,-1
 4487 163c 1F4F      		sbci r17,-1
 4488               	.LVL378:
 4489               	.LBB557:
 607:main_sim900.h ****       if (p2 != NULL) {
 4490               		.loc 2 607 0
 4491 163e 62E2      		ldi r22,lo8(34)
 4492 1640 70E0      		ldi r23,0
 4493 1642 C801      		movw r24,r16
 4494 1644 0E94 0000 		call strchr
 4495               	.LVL379:
 608:main_sim900.h ****         const uchar l = p2 - p1;
 4496               		.loc 2 608 0
 4497 1648 0097      		sbiw r24,0
 4498 164a 01F0      		breq .L418
 4499               	.LBB558:
 609:main_sim900.h ****         if (l < MAX_LICZBA_ZNAKOW_TELEFON) {
 4500               		.loc 2 609 0
 4501 164c EC01      		movw r28,r24
 4502 164e C01B      		sub r28,r16
 4503 1650 D10B      		sbc r29,r17
 4504               	.LVL380:
 610:main_sim900.h ****           memcpy(numer_telefonu_ktory_dzwoni, p1, l);
 4505               		.loc 2 610 0
 4506 1652 C031      		cpi r28,lo8(16)
 4507 1654 00F4      		brsh .L418
 4508 1656 DD27      		clr r29
 4509               	.LVL381:
 611:main_sim900.h ****           numer_telefonu_ktory_dzwoni[l] = '\0';
 4510               		.loc 2 611 0
 4511 1658 AE01      		movw r20,r28
 4512 165a B801      		movw r22,r16
 4513 165c 80E0      		ldi r24,lo8(numer_telefonu_ktory_dzwoni)
 4514 165e 90E0      		ldi r25,hi8(numer_telefonu_ktory_dzwoni)
 4515               	.LVL382:
 4516 1660 0E94 0000 		call memcpy
 4517               	.LVL383:
 612:main_sim900.h ****           POMOC_DODAJ_HEX(l);
 4518               		.loc 2 612 0
 4519 1664 C050      		subi r28,lo8(-(numer_telefonu_ktory_dzwoni))
 4520 1666 D040      		sbci r29,hi8(-(numer_telefonu_ktory_dzwoni))
 4521 1668 1882      		st Y,__zero_reg__
 4522               	.LVL384:
 614:main_sim900.h ****             licznik_blad_zalogowania_u_operatora = 0;
 4523               		.loc 2 614 0
 4524 166a 8091 0000 		lds r24,licznik_blad_zalogowania_u_operatora
 4525 166e 8111      		cpse r24,__zero_reg__
 615:main_sim900.h ****           if (poziom_sieci_gsm == 0 || poziom_sieci_gsm == POZIOM_SIECI_BLAD)
 4526               		.loc 2 615 0
 4527 1670 1092 0000 		sts licznik_blad_zalogowania_u_operatora,__zero_reg__
 4528               	.L420:
 616:main_sim900.h ****             poziom_sieci_gsm = 16;
 4529               		.loc 2 616 0
 4530 1674 8091 0000 		lds r24,poziom_sieci_gsm
 4531 1678 8823      		tst r24
 4532 167a 01F0      		breq .L421
 4533 167c 8336      		cpi r24,lo8(99)
 4534 167e 01F4      		brne .L418
 4535               	.L421:
 617:main_sim900.h ****         }
 4536               		.loc 2 617 0
 4537 1680 80E1      		ldi r24,lo8(16)
 4538 1682 8093 0000 		sts poziom_sieci_gsm,r24
 4539               	.LVL385:
 4540               	.L418:
 4541               	.LBE558:
 4542               	.LBE557:
 621:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 4543               		.loc 2 621 0
 4544 1686 88E9      		ldi r24,lo8(-104)
 4545 1688 0E94 0000 		call filtruj_i_dodaj_komende
 4546               	.LVL386:
 623:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 4547               		.loc 2 623 0
 4548 168c 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4549 1690 8A5A      		subi r24,lo8(-(86))
 622:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 4550               		.loc 2 622 0
 4551 1692 8431      		cpi r24,lo8(20)
 4552 1694 00F4      		brsh .L422
 4553               	.LVL387:
 4554               	.L478:
 626:main_sim900.h ****     }
 4555               		.loc 2 626 0
 4556 1696 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 4557               	.L422:
 628:main_sim900.h ****     return;
 4558               		.loc 2 628 0
 4559 169a 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 4560 169e 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 4561 16a2 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
 4562 16a6 00C0      		rjmp .L409
 4563               	.L416:
 4564               	.LBE556:
 632:main_sim900.h ****     POMOC_DODAJ2('#', 'c');
 4565               		.loc 2 632 0
 4566 16a8 8091 0000 		lds r24,komenda_SIM900
 4567 16ac 8330      		cpi r24,lo8(3)
 4568 16ae 01F4      		brne .L423
 4569               	.LVL388:
 634:main_sim900.h ****     trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 4570               		.loc 2 634 0
 4571 16b0 80E0      		ldi r24,0
 4572 16b2 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 4573               	.LVL389:
 635:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 4574               		.loc 2 635 0
 4575 16b6 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 636:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 4576               		.loc 2 636 0
 4577 16ba 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 637:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 ==
 4578               		.loc 2 637 0
 4579 16be 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 4580 16c2 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 638:main_sim900.h ****         KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE) {
 4581               		.loc 2 638 0
 4582 16c6 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4583 16ca 863D      		cpi r24,lo8(-42)
 4584 16cc 01F0      		breq .+2
 4585 16ce 00C0      		rjmp .L409
 4586 16d0 00C0      		rjmp .L422
 4587               	.LVL390:
 4588               	.L423:
 645:main_sim900.h ****     POMOC_DODAJ2('#', 'd');
 4589               		.loc 2 645 0
 4590 16d2 8091 0000 		lds r24,komenda_SIM900
 4591 16d6 8230      		cpi r24,lo8(2)
 4592 16d8 01F4      		brne .L424
 4593               	.LVL391:
 647:main_sim900.h ****       odpowiedz_na_polecenie();
 4594               		.loc 2 647 0
 4595 16da 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4596 16de 863D      		cpi r24,lo8(-42)
 4597 16e0 01F4      		brne .L425
 648:main_sim900.h ****     if (ustaw_maksymalny_czas_dzwonienia == 0)
 4598               		.loc 2 648 0
 4599 16e2 0E94 0000 		call odpowiedz_na_polecenie
 4600               	.LVL392:
 4601               	.L425:
 649:main_sim900.h ****       maksymalny_czas_dzwonienia = 90; // standardowy czas czekania 9 sekund
 4602               		.loc 2 649 0
 4603 16e6 8091 0000 		lds r24,ustaw_maksymalny_czas_dzwonienia
 4604 16ea 8111      		cpse r24,__zero_reg__
 4605 16ec 00C0      		rjmp .L426
 650:main_sim900.h ****     else {
 4606               		.loc 2 650 0
 4607 16ee 8AE5      		ldi r24,lo8(90)
 4608 16f0 8093 0000 		sts maksymalny_czas_dzwonienia,r24
 4609               	.L427:
 655:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 4610               		.loc 2 655 0
 4611 16f4 8FEF      		ldi r24,lo8(-1)
 4612 16f6 8093 0000 		sts wykonywanie_rozmowy_telefonicznej,r24
 4613               	.LVL393:
 4614               	.L479:
 696:main_sim900.h ****     return;
 4615               		.loc 2 696 0
 4616 16fa 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 4617 16fe 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 4618 1702 00C0      		rjmp .L409
 4619               	.LVL394:
 4620               	.L426:
 652:main_sim900.h ****       ustaw_maksymalny_czas_dzwonienia = 0;
 4621               		.loc 2 652 0
 4622 1704 8093 0000 		sts maksymalny_czas_dzwonienia,r24
 653:main_sim900.h ****     }
 4623               		.loc 2 653 0
 4624 1708 1092 0000 		sts ustaw_maksymalny_czas_dzwonienia,__zero_reg__
 4625 170c 00C0      		rjmp .L427
 4626               	.LVL395:
 4627               	.L424:
 661:main_sim900.h ****   if (ptr_dtmf != NULL) {
 4628               		.loc 2 661 0
 4629 170e 80E0      		ldi r24,lo8(__c.3323)
 4630 1710 90E0      		ldi r25,hi8(__c.3323)
 4631 1712 0E94 0000 		call polozenie_polecenia_SIM900
 4632               	.LVL396:
 662:main_sim900.h ****     POMOC_DODAJ2('#', 'D');
 4633               		.loc 2 662 0
 4634 1716 0097      		sbiw r24,0
 4635 1718 01F0      		breq .L428
 4636               	.LVL397:
 4637               	.LBB559:
 664:main_sim900.h ****     while (*ptr_dtmf == ' ')
 4638               		.loc 2 664 0
 4639 171a FC01      		movw r30,r24
 4640 171c 3796      		adiw r30,7
 4641               	.LVL398:
 4642               	.L429:
 665:main_sim900.h ****       ++ptr_dtmf;
 4643               		.loc 2 665 0
 4644 171e 8191      		ld r24,Z+
 4645               	.LVL399:
 4646 1720 8032      		cpi r24,lo8(32)
 4647 1722 01F0      		breq .L429
 4648               	.LVL400:
 670:main_sim900.h ****     {
 4649               		.loc 2 670 0
 4650 1724 9091 0000 		lds r25,tryb_clip
 4651 1728 9111      		cpse r25,__zero_reg__
 4652 172a 00C0      		rjmp .L430
 672:main_sim900.h ****         stan_wyjscie[0] = TRUE;
 4653               		.loc 2 672 0
 4654 172c 8133      		cpi r24,lo8(49)
 4655 172e 01F4      		brne .L430
 673:main_sim900.h ****         licznik_przelacznik_wyjscia[0] = 2 * 10ul; // 2 sekundy retrigger
 4656               		.loc 2 673 0
 4657 1730 8FEF      		ldi r24,lo8(-1)
 4658               	.LVL401:
 4659 1732 8093 0000 		sts stan_wyjscie,r24
 4660               	.LVL402:
 674:main_sim900.h ****         zapal_diode_led(10);
 4661               		.loc 2 674 0
 4662 1736 84E1      		ldi r24,lo8(20)
 4663 1738 90E0      		ldi r25,0
 4664 173a A0E0      		ldi r26,0
 4665 173c B0E0      		ldi r27,0
 4666 173e 8093 0000 		sts licznik_przelacznik_wyjscia,r24
 4667 1742 9093 0000 		sts licznik_przelacznik_wyjscia+1,r25
 4668 1746 A093 0000 		sts licznik_przelacznik_wyjscia+2,r26
 4669 174a B093 0000 		sts licznik_przelacznik_wyjscia+3,r27
 675:main_sim900.h ****       }
 4670               		.loc 2 675 0
 4671 174e 8BE0      		ldi r24,lo8(11)
 4672 1750 8093 0000 		sts licznik_100ms_dioda_led,r24
 4673               	.L430:
 678:main_sim900.h ****     return;
 4674               		.loc 2 678 0
 4675 1754 1092 0000 		sts komenda_SIM900,__zero_reg__
 4676 1758 00C0      		rjmp .L409
 4677               	.LVL403:
 4678               	.L428:
 4679               	.LBE559:
 682:main_sim900.h ****     POMOC_DODAJ2('#', 'e');
 4680               		.loc 2 682 0
 4681 175a 8091 0000 		lds r24,komenda_SIM900
 4682               	.LVL404:
 4683 175e 8C30      		cpi r24,lo8(12)
 4684 1760 01F4      		brne .L431
 4685               	.LVL405:
 684:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 4686               		.loc 2 684 0
 4687 1762 8091 0000 		lds r24,tryb_clip
 4688 1766 8823      		tst r24
 4689 1768 01F4      		brne .+2
 4690 176a 00C0      		rjmp .L409
 685:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
 4691               		.loc 2 685 0
 4692 176c 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 686:main_sim900.h ****     }
 4693               		.loc 2 686 0
 4694 1770 87E9      		ldi r24,lo8(-105)
 4695               	/* epilogue start */
 4696               	.LBE555:
 4697               	.LBE554:
 4698               		.loc 2 758 0
 4699 1772 DF91      		pop r29
 4700 1774 CF91      		pop r28
 4701 1776 1F91      		pop r17
 4702 1778 0F91      		pop r16
 4703               	.LBB565:
 4704               	.LBB563:
 686:main_sim900.h ****     }
 4705               		.loc 2 686 0
 4706 177a 0C94 0000 		jmp dodaj_komende
 4707               	.LVL406:
 4708               	.L431:
 690:main_sim900.h ****     POMOC_DODAJ2('#', 'f');
 4709               		.loc 2 690 0
 4710 177e 8091 0000 		lds r24,komenda_SIM900
 4711 1782 8930      		cpi r24,lo8(9)
 4712 1784 01F4      		brne .L432
 4713               	.L476:
 4714               	.LVL407:
 692:main_sim900.h ****       odpowiedz_na_polecenie();
 4715               		.loc 2 692 0
 4716 1786 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4717 178a 863D      		cpi r24,lo8(-42)
 4718 178c 01F4      		brne .L433
 693:main_sim900.h ****     zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 4719               		.loc 2 693 0
 4720 178e 0E94 0000 		call odpowiedz_na_polecenie
 4721               	.LVL408:
 4722               	.L433:
 694:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 4723               		.loc 2 694 0
 4724 1792 80E0      		ldi r24,0
 4725 1794 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 4726               	.LVL409:
 695:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 4727               		.loc 2 695 0
 4728 1798 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 4729 179c 00C0      		rjmp .L479
 4730               	.LVL410:
 4731               	.L432:
 700:main_sim900.h ****     POMOC_DODAJ2('#', 'g');
 4732               		.loc 2 700 0
 4733 179e 8091 0000 		lds r24,komenda_SIM900
 4734 17a2 8730      		cpi r24,lo8(7)
 4735 17a4 01F0      		breq .L476
 710:main_sim900.h ****     const uchar *ptr = strchr(polozenie_polecenia_SIM900(PSTR("+CMTI:")), ',');
 4736               		.loc 2 710 0
 4737 17a6 8091 0000 		lds r24,komenda_SIM900
 4738 17aa 8830      		cpi r24,lo8(8)
 4739 17ac 01F4      		brne .L436
 4740               	.LBB560:
 711:main_sim900.h ****     if (ptr != NULL) {
 4741               		.loc 2 711 0
 4742 17ae 80E0      		ldi r24,lo8(__c.3330)
 4743 17b0 90E0      		ldi r25,hi8(__c.3330)
 4744 17b2 0E94 0000 		call polozenie_polecenia_SIM900
 4745               	.LVL411:
 4746 17b6 6CE2      		ldi r22,lo8(44)
 4747 17b8 70E0      		ldi r23,0
 4748 17ba 0E94 0000 		call strchr
 4749               	.LVL412:
 712:main_sim900.h ****       uint numer_smsa = (uint)strtoul(ptr + 1, NULL, 10);
 4750               		.loc 2 712 0
 4751 17be 0097      		sbiw r24,0
 4752 17c0 01F0      		breq .L438
 4753               	.LBB561:
 713:main_sim900.h ****       if (numer_smsa > 0 && numer_smsa <= 20) // Hardcoded 20
 4754               		.loc 2 713 0
 4755 17c2 4AE0      		ldi r20,lo8(10)
 4756 17c4 50E0      		ldi r21,0
 4757 17c6 70E0      		ldi r23,0
 4758 17c8 60E0      		ldi r22,0
 4759 17ca 0196      		adiw r24,1
 4760               	.LVL413:
 4761 17cc 0E94 0000 		call strtoul
 4762               	.LVL414:
 714:main_sim900.h ****       {
 4763               		.loc 2 714 0
 4764 17d0 9B01      		movw r18,r22
 4765 17d2 2150      		subi r18,1
 4766 17d4 3109      		sbc r19,__zero_reg__
 4767 17d6 2431      		cpi r18,20
 4768 17d8 3105      		cpc r19,__zero_reg__
 4769 17da 00F4      		brsh .L438
 716:main_sim900.h ****         opoznienie_SIM900_100MS = 1; // 20 (1)
 4770               		.loc 2 716 0
 4771 17dc 89EA      		ldi r24,lo8(-87)
 4772 17de 860F      		add r24,r22
 4773 17e0 0E94 0000 		call dodaj_komende
 4774               	.LVL415:
 717:main_sim900.h ****       }
 4775               		.loc 2 717 0
 4776 17e4 81E0      		ldi r24,lo8(1)
 4777               	.L477:
 4778 17e6 8093 0000 		sts opoznienie_SIM900_100MS,r24
 4779               	.L438:
 4780               	.LBE561:
 721:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 4781               		.loc 2 721 0
 4782 17ea 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4783 17ee 8A5A      		subi r24,lo8(-(86))
 720:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 4784               		.loc 2 720 0
 4785 17f0 8431      		cpi r24,lo8(20)
 4786 17f2 00F4      		brsh .+2
 4787 17f4 00C0      		rjmp .L478
 4788 17f6 00C0      		rjmp .L409
 4789               	.L436:
 4790               	.LBE560:
 730:main_sim900.h ****     opoznienie_SIM900_100MS = 20;
 4791               		.loc 2 730 0
 4792 17f8 8091 0000 		lds r24,komenda_SIM900
 4793 17fc 8E30      		cpi r24,lo8(14)
 4794 17fe 01F4      		brne .L440
 4795               	.LBB562:
 731:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 4796               		.loc 2 731 0
 4797 1800 84E1      		ldi r24,lo8(20)
 4798 1802 00C0      		rjmp .L477
 4799               	.L440:
 4800               	.LBE562:
 752:main_sim900.h ****     obsluga_wysylania_sms();
 4801               		.loc 2 752 0
 4802 1804 8091 0000 		lds r24,flaga_wysylanie_smsa
 4803 1808 8111      		cpse r24,__zero_reg__
 753:main_sim900.h **** 
 4804               		.loc 2 753 0
 4805 180a 0E94 0000 		call obsluga_wysylania_sms
 4806               	.LVL416:
 4807               	.L442:
 755:main_sim900.h ****       komenda_SIM900 != BRAK_KOMENDY_SIM900)
 4808               		.loc 2 755 0
 4809 180e 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 4810 1812 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
 4811 1816 892B      		or r24,r25
 4812 1818 01F4      		brne .+2
 4813 181a 00C0      		rjmp .L409
 756:main_sim900.h ****     odpowiedz_na_polecenie();
 4814               		.loc 2 756 0
 4815 181c 8091 0000 		lds r24,komenda_SIM900
 755:main_sim900.h ****       komenda_SIM900 != BRAK_KOMENDY_SIM900)
 4816               		.loc 2 755 0
 4817 1820 8823      		tst r24
 4818 1822 01F4      		brne .+2
 4819 1824 00C0      		rjmp .L409
 4820               	/* epilogue start */
 4821               	.LBE563:
 4822               	.LBE565:
 4823               		.loc 2 758 0
 4824 1826 DF91      		pop r29
 4825 1828 CF91      		pop r28
 4826 182a 1F91      		pop r17
 4827 182c 0F91      		pop r16
 4828               	.LBB566:
 4829               	.LBB564:
 757:main_sim900.h **** }
 4830               		.loc 2 757 0
 4831 182e 0C94 0000 		jmp odpowiedz_na_polecenie
 4832               	.LVL417:
 4833               	.LBE564:
 4834               	.LBE566:
 4835               		.cfi_endproc
 4836               	.LFE51:
 4838               	.global	wyslanie_polecenia_ROM
 4840               	wyslanie_polecenia_ROM:
 4841               	.LFB52:
 759:main_sim900.h **** 
 760:main_sim900.h **** uchar wyslanie_polecenia_ROM(const uchar czy_mozna_wysylac_dane_do_SIM900,
 761:main_sim900.h ****                              const komenda_typ wykonywana_komenda,
 762:main_sim900.h ****                              const komenda_typ nastepne_wysylane_polecenie,
 763:main_sim900.h ****                              PGM_P instrukcja) {
 4842               		.loc 2 763 0
 4843               		.cfi_startproc
 4844               	.LVL418:
 4845               	/* prologue: function */
 4846               	/* frame size = 0 */
 4847               	/* stack size = 0 */
 4848               	.L__stack_usage = 0
 764:main_sim900.h ****   if (!czy_mozna_wysylac_dane_do_SIM900) {
 4849               		.loc 2 764 0
 4850 1832 8111      		cpse r24,__zero_reg__
 4851 1834 00C0      		rjmp .L481
 765:main_sim900.h ****     dodaj_komende(wykonywana_komenda);
 4852               		.loc 2 765 0
 4853 1836 862F      		mov r24,r22
 4854               	.LVL419:
 4855 1838 0E94 0000 		call dodaj_komende
 4856               	.LVL420:
 766:main_sim900.h ****     return FALSE;
 4857               		.loc 2 766 0
 4858 183c 80E0      		ldi r24,0
 4859 183e 0895      		ret
 4860               	.LVL421:
 4861               	.L481:
 767:main_sim900.h ****   }
 768:main_sim900.h ****   wysylane_polecenie_SIM900 = wykonywana_komenda;
 4862               		.loc 2 768 0
 4863 1840 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 4864 1844 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 4865 1848 6093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r22
 769:main_sim900.h ****   nastepne_wysylane_polecenie_SIM900 = nastepne_wysylane_polecenie;
 4866               		.loc 2 769 0
 4867 184c 4093 0000 		sts nastepne_wysylane_polecenie_SIM900,r20
 770:main_sim900.h ****   wyslij_polecenie_ROM_SIM900(instrukcja);
 4868               		.loc 2 770 0
 4869 1850 C901      		movw r24,r18
 4870               	.LVL422:
 4871 1852 0E94 0000 		call wyslij_polecenie_ROM_SIM900
 4872               	.LVL423:
 771:main_sim900.h ****   return TRUE;
 4873               		.loc 2 771 0
 4874 1856 8FEF      		ldi r24,lo8(-1)
 4875               	/* epilogue start */
 772:main_sim900.h **** }
 4876               		.loc 2 772 0
 4877 1858 0895      		ret
 4878               		.cfi_endproc
 4879               	.LFE52:
 4881               	.global	wyslij_sms
 4883               	wyslij_sms:
 4884               	.LFB53:
 773:main_sim900.h **** 
 774:main_sim900.h **** #ifndef memcpy_E
 775:main_sim900.h **** #define memcpy_E(sink, source, l)                                              \
 776:main_sim900.h ****   eeprom_read_block((sink), (void *)(source), (l))
 777:main_sim900.h **** #endif
 778:main_sim900.h **** 
 779:main_sim900.h **** void wyslij_sms(const uchar wyslij_pdu) {
 4885               		.loc 2 779 0
 4886               		.cfi_startproc
 4887               	.LVL424:
 4888 185a 0F93      		push r16
 4889               	.LCFI68:
 4890               		.cfi_def_cfa_offset 3
 4891               		.cfi_offset 16, -2
 4892 185c CF93      		push r28
 4893               	.LCFI69:
 4894               		.cfi_def_cfa_offset 4
 4895               		.cfi_offset 28, -3
 4896 185e DF93      		push r29
 4897               	.LCFI70:
 4898               		.cfi_def_cfa_offset 5
 4899               		.cfi_offset 29, -4
 4900               	/* prologue: function */
 4901               	/* frame size = 0 */
 4902               	/* stack size = 3 */
 4903               	.L__stack_usage = 3
 780:main_sim900.h ****   czekanie_na_odebranie_zachety = TRUE;
 4904               		.loc 2 780 0
 4905 1860 9FEF      		ldi r25,lo8(-1)
 4906 1862 9093 0000 		sts czekanie_na_odebranie_zachety,r25
 781:main_sim900.h ****   flaga_odebrany_znak_zachety = FALSE;
 4907               		.loc 2 781 0
 4908 1866 1092 0000 		sts flaga_odebrany_znak_zachety,__zero_reg__
 782:main_sim900.h ****   if (!wyslij_pdu) {
 4909               		.loc 2 782 0
 4910 186a 8111      		cpse r24,__zero_reg__
 4911 186c 00C0      		rjmp .L484
 4912               	.LBB567:
 783:main_sim900.h ****     // Zmiana: 5 blyskow LED przy wysylaniu SMS
 784:main_sim900.h ****     zapal_diode_led_blyski(5);
 4913               		.loc 2 784 0
 4914 186e 85E0      		ldi r24,lo8(5)
 4915               	.LVL425:
 4916 1870 8093 0000 		sts liczba_blyskow_led,r24
 4917 1874 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 785:main_sim900.h ****     flaga_wysylanie_smsa = KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT;
 4918               		.loc 2 785 0
 4919 1878 83ED      		ldi r24,lo8(-45)
 4920 187a 8093 0000 		sts flaga_wysylanie_smsa,r24
 786:main_sim900.h ****     bufor_pdu[0] = 0xff; // memcpy_E(bufor_pdu, (void*)EEPROM_ADRES_CENTRUM_SMS,
 4921               		.loc 2 786 0
 4922 187e 9093 0000 		sts bufor_pdu,r25
 787:main_sim900.h ****                          // LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 788:main_sim900.h ****     konwertuj_blok_eeprom_na_telefon(
 4923               		.loc 2 788 0
 4924 1882 4AE0      		ldi r20,lo8(10)
 4925 1884 60E0      		ldi r22,lo8(bufor_eeprom)
 4926 1886 70E0      		ldi r23,hi8(bufor_eeprom)
 4927 1888 80E0      		ldi r24,lo8(bufor_pdu)
 4928 188a 90E0      		ldi r25,hi8(bufor_pdu)
 4929 188c 0E94 0000 		call konwertuj_blok_eeprom_na_telefon
 4930               	.LVL426:
 789:main_sim900.h ****         bufor_pdu, bufor_eeprom, 2 * LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 790:main_sim900.h ****     uchar *ptr = zapisz_naglowek_pdu(bufor_pdu, numer_telefonu_wysylanego_smsa,
 4931               		.loc 2 790 0
 4932 1890 00E0      		ldi r16,0
 4933 1892 20E0      		ldi r18,0
 4934 1894 40E0      		ldi r20,lo8(bufor_eeprom)
 4935 1896 50E0      		ldi r21,hi8(bufor_eeprom)
 4936 1898 60E0      		ldi r22,lo8(numer_telefonu_wysylanego_smsa)
 4937 189a 70E0      		ldi r23,hi8(numer_telefonu_wysylanego_smsa)
 4938 189c 80E0      		ldi r24,lo8(bufor_pdu)
 4939 189e 90E0      		ldi r25,hi8(bufor_pdu)
 4940 18a0 0E94 0000 		call zapisz_naglowek_pdu
 4941               	.LVL427:
 791:main_sim900.h ****                                      bufor_eeprom, 0x00, 0x00);
 792:main_sim900.h ****     dlugosc_pdu = ascii_to_pdu(ptr, tekst_wysylanego_smsa) - bufor_pdu;
 4942               		.loc 2 792 0
 4943 18a4 40E0      		ldi r20,lo8(tekst_wysylanego_smsa)
 4944 18a6 50E0      		ldi r21,hi8(tekst_wysylanego_smsa)
 4945 18a8 FA01      		movw r30,r20
 4946               		0:
 4947 18aa 0190      		ld __tmp_reg__,Z+
 4948 18ac 0020      		tst __tmp_reg__
 4949 18ae 01F4      		brne 0b
 4950 18b0 AF01      		movw r20,r30
 4951 18b2 4150      		subi r20,1
 4952 18b4 5109      		sbc r21,__zero_reg__
 4953 18b6 60E0      		ldi r22,lo8(tekst_wysylanego_smsa)
 4954 18b8 70E0      		ldi r23,hi8(tekst_wysylanego_smsa)
 4955 18ba 0E94 0000 		call ascii_to_pdu_blok
 4956               	.LVL428:
 4957               	.L486:
 4958               	.LBE567:
 4959               	.LBB568:
 793:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 794:main_sim900.h ****     uchar l = strlen(numer_telefonu_wysylanego_smsa);
 795:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
 796:main_sim900.h ****       POMOC_DODAJ(numer_telefonu_wysylanego_smsa[i]);
 797:main_sim900.h ****     POMOC_DODAJ(' ');
 798:main_sim900.h ****     l = strlen(tekst_wysylanego_smsa);
 799:main_sim900.h ****     if (l > 20)
 800:main_sim900.h ****       l = 20;
 801:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
 802:main_sim900.h ****       POMOC_DODAJ(tekst_wysylanego_smsa[i]);
 803:main_sim900.h **** #endif
 804:main_sim900.h ****   } else {
 805:main_sim900.h ****     // Zmiana: 5 blyskow LED przy wysylaniu PDU
 806:main_sim900.h ****     zapal_diode_led_blyski(5);
 807:main_sim900.h ****     flaga_wysylanie_smsa = KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU;
 808:main_sim900.h ****     const uchar TP_DCS = tekst_wysylanego_smsa[0]; // message class
 809:main_sim900.h ****     bufor_pdu[0] = 0xff; // memcpy_E(bufor_pdu, (void*)EEPROM_ADRES_CENTRUM_SMS,
 810:main_sim900.h ****                          // LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 811:main_sim900.h ****     konwertuj_blok_eeprom_na_telefon(
 812:main_sim900.h ****         bufor_pdu, bufor_eeprom, 2 * LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 813:main_sim900.h ****     uchar *ptr = zapisz_naglowek_pdu(bufor_pdu, numer_telefonu_wysylanego_smsa,
 814:main_sim900.h ****                                      bufor_eeprom, 0x00, TP_DCS);
 815:main_sim900.h ****     memcpy(ptr, &tekst_wysylanego_smsa[2], tekst_wysylanego_smsa[1]);
 816:main_sim900.h ****     dlugosc_pdu = (ptr + tekst_wysylanego_smsa[1]) - bufor_pdu;
 4960               		.loc 2 816 0
 4961 18be 8050      		subi r24,lo8(bufor_pdu)
 4962 18c0 9040      		sbci r25,hi8(bufor_pdu)
 4963 18c2 8093 0000 		sts dlugosc_pdu,r24
 4964               	.LBE568:
 817:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 818:main_sim900.h ****     uchar l = strlen(numer_telefonu_wysylanego_smsa);
 819:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
 820:main_sim900.h ****       POMOC_DODAJ(numer_telefonu_wysylanego_smsa[i]);
 821:main_sim900.h ****     POMOC_DODAJ(' ');
 822:main_sim900.h ****     POMOC_DODAJ('P');
 823:main_sim900.h ****     POMOC_DODAJ('D');
 824:main_sim900.h ****     POMOC_DODAJ('U');
 825:main_sim900.h **** #endif
 826:main_sim900.h ****   }
 827:main_sim900.h ****   const uchar oktety = dlugosc_pdu - 1 - bufor_pdu[0];
 4965               		.loc 2 827 0
 4966 18c6 C091 0000 		lds r28,dlugosc_pdu
 4967 18ca C150      		subi r28,lo8(-(-1))
 4968 18cc 8091 0000 		lds r24,bufor_pdu
 4969 18d0 C81B      		sub r28,r24
 4970               	.LVL429:
 828:main_sim900.h ****   static const char instrukcja_wyslij_smsa[] PROGMEM = "+cmgs=";
 829:main_sim900.h ****   memcpy_R(wysylane_dane_RAM_SIM900, instrukcja_wyslij_smsa);
 4971               		.loc 2 829 0
 4972 18d2 46E0      		ldi r20,lo8(6)
 4973 18d4 50E0      		ldi r21,0
 4974 18d6 60E0      		ldi r22,lo8(instrukcja_wyslij_smsa.3350)
 4975 18d8 70E0      		ldi r23,hi8(instrukcja_wyslij_smsa.3350)
 4976 18da 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 4977 18dc 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 4978 18de 0E94 0000 		call memcpy_P
 4979               	.LVL430:
 4980               	.LBB569:
 4981               	.LBB570:
 4982               		.loc 6 527 0
 4983 18e2 4AE0      		ldi r20,lo8(10)
 4984 18e4 60E0      		ldi r22,lo8(wysylany_blok_SIM900+8)
 4985 18e6 70E0      		ldi r23,hi8(wysylany_blok_SIM900+8)
 4986               	.LVL431:
 4987 18e8 8C2F      		mov r24,r28
 4988 18ea 90E0      		ldi r25,0
 4989 18ec 0E94 0000 		call __utoa_ncheck
 4990               	.LVL432:
 4991               	.LBE570:
 4992               	.LBE569:
 830:main_sim900.h ****   utoa(oktety, wysylane_dane_RAM_SIM900 + strlen_R(instrukcja_wyslij_smsa), 10);
 831:main_sim900.h ****   max_oczekiwanie_na_odpowiedz = 250;
 4993               		.loc 2 831 0
 4994 18f0 8AEF      		ldi r24,lo8(-6)
 4995 18f2 8093 0000 		sts max_oczekiwanie_na_odpowiedz,r24
 4996               	/* epilogue start */
 832:main_sim900.h ****   wyslij_polecenie_RAM_SIM900();
 833:main_sim900.h ****   POMOC_DODAJ2('#', 'S');
 834:main_sim900.h **** }
 4997               		.loc 2 834 0
 4998 18f6 DF91      		pop r29
 4999 18f8 CF91      		pop r28
 5000               	.LVL433:
 5001 18fa 0F91      		pop r16
 832:main_sim900.h ****   wyslij_polecenie_RAM_SIM900();
 5002               		.loc 2 832 0
 5003 18fc 0C94 0000 		jmp wyslij_polecenie_RAM_SIM900
 5004               	.LVL434:
 5005               	.L484:
 5006               	.LBB571:
 806:main_sim900.h ****     flaga_wysylanie_smsa = KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU;
 5007               		.loc 2 806 0
 5008 1900 85E0      		ldi r24,lo8(5)
 5009               	.LVL435:
 5010 1902 8093 0000 		sts liczba_blyskow_led,r24
 5011 1906 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 807:main_sim900.h ****     const uchar TP_DCS = tekst_wysylanego_smsa[0]; // message class
 5012               		.loc 2 807 0
 5013 190a 84ED      		ldi r24,lo8(-44)
 5014 190c 8093 0000 		sts flaga_wysylanie_smsa,r24
 808:main_sim900.h ****     bufor_pdu[0] = 0xff; // memcpy_E(bufor_pdu, (void*)EEPROM_ADRES_CENTRUM_SMS,
 5015               		.loc 2 808 0
 5016 1910 0091 0000 		lds r16,tekst_wysylanego_smsa
 5017               	.LVL436:
 809:main_sim900.h ****                          // LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 5018               		.loc 2 809 0
 5019 1914 9093 0000 		sts bufor_pdu,r25
 811:main_sim900.h ****         bufor_pdu, bufor_eeprom, 2 * LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 5020               		.loc 2 811 0
 5021 1918 4AE0      		ldi r20,lo8(10)
 5022 191a 60E0      		ldi r22,lo8(bufor_eeprom)
 5023 191c 70E0      		ldi r23,hi8(bufor_eeprom)
 5024 191e 80E0      		ldi r24,lo8(bufor_pdu)
 5025 1920 90E0      		ldi r25,hi8(bufor_pdu)
 5026 1922 0E94 0000 		call konwertuj_blok_eeprom_na_telefon
 5027               	.LVL437:
 813:main_sim900.h ****                                      bufor_eeprom, 0x00, TP_DCS);
 5028               		.loc 2 813 0
 5029 1926 20E0      		ldi r18,0
 5030 1928 40E0      		ldi r20,lo8(bufor_eeprom)
 5031 192a 50E0      		ldi r21,hi8(bufor_eeprom)
 5032 192c 60E0      		ldi r22,lo8(numer_telefonu_wysylanego_smsa)
 5033 192e 70E0      		ldi r23,hi8(numer_telefonu_wysylanego_smsa)
 5034 1930 80E0      		ldi r24,lo8(bufor_pdu)
 5035 1932 90E0      		ldi r25,hi8(bufor_pdu)
 5036 1934 0E94 0000 		call zapisz_naglowek_pdu
 5037               	.LVL438:
 5038 1938 EC01      		movw r28,r24
 5039               	.LVL439:
 815:main_sim900.h ****     dlugosc_pdu = (ptr + tekst_wysylanego_smsa[1]) - bufor_pdu;
 5040               		.loc 2 815 0
 5041 193a 4091 0000 		lds r20,tekst_wysylanego_smsa+1
 5042 193e 50E0      		ldi r21,0
 5043 1940 60E0      		ldi r22,lo8(tekst_wysylanego_smsa+2)
 5044 1942 70E0      		ldi r23,hi8(tekst_wysylanego_smsa+2)
 5045 1944 0E94 0000 		call memcpy
 5046               	.LVL440:
 816:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 5047               		.loc 2 816 0
 5048 1948 8091 0000 		lds r24,tekst_wysylanego_smsa+1
 5049 194c 8C0F      		add r24,r28
 5050 194e 9D2F      		mov r25,r29
 5051 1950 911D      		adc r25,__zero_reg__
 5052 1952 00C0      		rjmp .L486
 5053               	.LBE571:
 5054               		.cfi_endproc
 5055               	.LFE53:
 5057               	.global	wykonanie_komend_SIM900
 5059               	wykonanie_komend_SIM900:
 5060               	.LFB54:
 835:main_sim900.h **** 
 836:main_sim900.h **** uchar wykonanie_komend_SIM900(void) {
 5061               		.loc 2 836 0
 5062               		.cfi_startproc
 5063 1954 EF92      		push r14
 5064               	.LCFI71:
 5065               		.cfi_def_cfa_offset 3
 5066               		.cfi_offset 14, -2
 5067 1956 FF92      		push r15
 5068               	.LCFI72:
 5069               		.cfi_def_cfa_offset 4
 5070               		.cfi_offset 15, -3
 5071 1958 0F93      		push r16
 5072               	.LCFI73:
 5073               		.cfi_def_cfa_offset 5
 5074               		.cfi_offset 16, -4
 5075 195a 1F93      		push r17
 5076               	.LCFI74:
 5077               		.cfi_def_cfa_offset 6
 5078               		.cfi_offset 17, -5
 5079 195c CF93      		push r28
 5080               	.LCFI75:
 5081               		.cfi_def_cfa_offset 7
 5082               		.cfi_offset 28, -6
 5083 195e DF93      		push r29
 5084               	.LCFI76:
 5085               		.cfi_def_cfa_offset 8
 5086               		.cfi_offset 29, -7
 5087 1960 00D0      		rcall .
 5088 1962 1F92      		push __zero_reg__
 5089               	.LCFI77:
 5090               		.cfi_def_cfa_offset 11
 5091 1964 CDB7      		in r28,__SP_L__
 5092 1966 DEB7      		in r29,__SP_H__
 5093               	.LCFI78:
 5094               		.cfi_def_cfa_register 28
 5095               	/* prologue: function */
 5096               	/* frame size = 3 */
 5097               	/* stack size = 9 */
 5098               	.L__stack_usage = 9
 837:main_sim900.h ****   const uchar czy_gsm_zajety =
 838:main_sim900.h ****       flaga_odczytywanie_smsa || flaga_wysylanie_smsa ||
 5099               		.loc 2 838 0
 5100 1968 9091 0000 		lds r25,flaga_odczytywanie_smsa
 839:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej ||
 840:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika ||
 841:main_sim900.h ****       aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
 842:main_sim900.h ****       opoznienie_SIM900_100MS || czekanie_na_odebranie_zachety;
 5101               		.loc 2 842 0
 5102 196c 9111      		cpse r25,__zero_reg__
 5103 196e 00C0      		rjmp .L589
 838:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej ||
 5104               		.loc 2 838 0
 5105 1970 8091 0000 		lds r24,flaga_wysylanie_smsa
 5106 1974 8111      		cpse r24,__zero_reg__
 5107 1976 00C0      		rjmp .L589
 838:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej ||
 5108               		.loc 2 838 0 is_stmt 0 discriminator 1
 5109 1978 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5110 197c 8111      		cpse r24,__zero_reg__
 5111 197e 00C0      		rjmp .L589
 839:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej ||
 5112               		.loc 2 839 0 is_stmt 1
 5113 1980 8091 0000 		lds r24,trwa_rozmowa_przychodzaca_od_uzytkownika
 5114 1984 8111      		cpse r24,__zero_reg__
 5115 1986 00C0      		rjmp .L589
 840:main_sim900.h ****       aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
 5116               		.loc 2 840 0
 5117 1988 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 5118 198c 8111      		cpse r24,__zero_reg__
 5119 198e 00C0      		rjmp .L589
 841:main_sim900.h ****       opoznienie_SIM900_100MS || czekanie_na_odebranie_zachety;
 5120               		.loc 2 841 0
 5121 1990 8091 0000 		lds r24,opoznienie_SIM900_100MS
 5122 1994 8111      		cpse r24,__zero_reg__
 5123 1996 00C0      		rjmp .L589
 5124               		.loc 2 842 0 discriminator 2
 5125 1998 2091 0000 		lds r18,czekanie_na_odebranie_zachety
 5126 199c 81E0      		ldi r24,lo8(1)
 5127 199e 2111      		cpse r18,__zero_reg__
 5128 19a0 00C0      		rjmp .L489
 5129 19a2 80E0      		ldi r24,0
 5130               	.L489:
 5131               	.LVL441:
 843:main_sim900.h **** 
 844:main_sim900.h ****   const uchar czy_mozna_wysylac_dane_do_SIM900 =
 845:main_sim900.h ****       !czy_gsm_zajety && CZY_MOZNA_WYSYLAC_DANE_SIM900() &&
 5132               		.loc 2 845 0 discriminator 2
 5133 19a4 8111      		cpse r24,__zero_reg__
 5134 19a6 00C0      		rjmp .L592
 5135               	.LVL442:
 5136               		.loc 2 845 0 is_stmt 0 discriminator 1
 5137 19a8 2091 C100 		lds r18,193
 5138 19ac 26FD      		sbrc r18,6
 5139 19ae 00C0      		rjmp .L592
 5140               		.loc 2 845 0 discriminator 3
 5141 19b0 2091 0000 		lds r18,podlaczony_modul_gsm_SIM900
 5142 19b4 2223      		tst r18
 5143 19b6 01F0      		breq .L592
 846:main_sim900.h ****       czy_jest_bezczynny_SIM900();
 5144               		.loc 2 846 0 is_stmt 1 discriminator 5
 5145 19b8 2091 0000 		lds r18,komenda_SIM900
 845:main_sim900.h ****       czy_jest_bezczynny_SIM900();
 5146               		.loc 2 845 0 discriminator 5
 5147 19bc 01E0      		ldi r16,lo8(1)
 5148 19be 2111      		cpse r18,__zero_reg__
 5149 19c0 00C0      		rjmp .L592
 5150               	.LVL443:
 5151               	.L490:
 847:main_sim900.h **** 
 848:main_sim900.h ****   const komenda_typ wykonywana_komenda = komendy_kolejka[0];
 5152               		.loc 2 848 0
 5153 19c2 1091 0000 		lds r17,komendy_kolejka
 5154               	.LVL444:
 849:main_sim900.h ****   switch (wykonywana_komenda) {
 5155               		.loc 2 849 0
 5156 19c6 E12E      		mov r14,r17
 5157 19c8 F12C      		mov r15,__zero_reg__
 5158 19ca 1D39      		cpi r17,lo8(-99)
 5159 19cc 01F4      		brne .+2
 5160 19ce 00C0      		rjmp .L493
 5161 19d0 00F0      		brlo .+2
 5162 19d2 00C0      		rjmp .L494
 5163 19d4 1239      		cpi r17,lo8(-110)
 5164 19d6 01F4      		brne .+2
 5165 19d8 00C0      		rjmp .L495
 5166 19da 00F4      		brsh .L496
 5167 19dc 1D38      		cpi r17,lo8(-115)
 5168 19de 01F4      		brne .+2
 5169 19e0 00C0      		rjmp .L497
 5170 19e2 00F4      		brsh .L498
 5171 19e4 1B38      		cpi r17,lo8(-117)
 5172 19e6 01F4      		brne .+2
 5173 19e8 00C0      		rjmp .L499
 5174 19ea 00F0      		brlo .+2
 5175 19ec 00C0      		rjmp .L500
 5176 19ee 1A38      		cpi r17,lo8(-118)
 5177 19f0 01F4      		brne .+2
 5178 19f2 00C0      		rjmp .L501
 5179               	.L492:
 850:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 851:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU: {
 852:main_sim900.h ****     POWTORZ_JESLI(flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS);
 853:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 854:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 855:main_sim900.h ****     wyslij_sms(wykonywana_komenda == KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
 856:main_sim900.h ****     break;
 857:main_sim900.h ****   }
 858:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_PDU: {
 859:main_sim900.h ****     czekanie_na_odebranie_zachety = FALSE;
 860:main_sim900.h ****     konwertuj_pdu_na_blok_wysylany(wysylany_blok_SIM900, bufor_pdu,
 861:main_sim900.h ****                                    dlugosc_pdu);
 862:main_sim900.h ****     const uint liczba_znakow = 2 * dlugosc_pdu + 1;
 863:main_sim900.h ****     wysylany_blok_SIM900[liczba_znakow - 1] = ZNAK_CTRL_Z;
 864:main_sim900.h ****     wyslij_znaki_SIM900(liczba_znakow);
 865:main_sim900.h ****     break;
 866:main_sim900.h ****   }
 867:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1:
 868:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_2:
 869:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_3:
 870:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_4:
 871:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_5:
 872:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_6:
 873:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_7:
 874:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_8:
 875:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_9:
 876:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_10:
 877:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_11:
 878:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_12:
 879:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_13:
 880:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_14:
 881:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_15:
 882:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_16:
 883:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_17:
 884:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_18:
 885:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_19:
 886:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20: {
 887:main_sim900.h ****     POWTORZ_JESLI(flaga_odczytywanie_smsa || !modul_zalogowany_w_sieci ||
 888:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 889:main_sim900.h ****                   wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK ||
 890:main_sim900.h ****                   flaga_wysylanie_smsa ||
 891:main_sim900.h ****                   aktualnie_wysylane_polecenie_SIM900 ==
 892:main_sim900.h ****                       KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 893:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 894:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 895:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW,
 896:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW) ||
 897:main_sim900.h ****                   czy_sa_komendy_z_przedzialu(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT,
 898:main_sim900.h ****                                               KOMENDA_KOLEJKI_WYSLIJ_PDU) ||
 899:main_sim900.h ****                   czy_sa_komendy_z_przedzialu(
 900:main_sim900.h ****                       KOMENDA_KOLEJKI_ODBIERZ_ROZMOWE,
 901:main_sim900.h ****                       KOMENDA_KOLEJKI_SPRAWDZ_PRZYCHODZACA_ROZMOWE));
 902:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 903:main_sim900.h ****     flaga_odczytywanie_smsa = TRUE;
 904:main_sim900.h ****     static const char instrukcja_odczytaj_smsa[] PROGMEM = "+cmgr=";
 905:main_sim900.h ****     memcpy_R(wysylane_dane_RAM_SIM900, instrukcja_odczytaj_smsa);
 906:main_sim900.h ****     const uint nr_smsa =
 907:main_sim900.h ****         wykonywana_komenda - KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 + 1;
 908:main_sim900.h ****     utoa(nr_smsa, wysylane_dane_RAM_SIM900 + strlen_R(instrukcja_odczytaj_smsa),
 909:main_sim900.h ****          10);
 910:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 911:main_sim900.h ****     POMOC_DODAJ2('#', 'X');
 912:main_sim900.h ****     break;
 913:main_sim900.h ****   }
 914:main_sim900.h ****   case KOMENDA_KOLEJKI_INTERPRETUJ_PDU: {
 915:main_sim900.h ****     const uchar *ptr = pobierz_numer_telefonu_nadawcy_z_PDU(
 916:main_sim900.h ****         bufor_pdu, numer_telefonu_odebranego_smsa,
 917:main_sim900.h ****         &nie_wysylaj_echa_z_powodu_nietypowego_smsa);
 918:main_sim900.h ****     if (ptr == 0) // (1)
 919:main_sim900.h ****     {
 920:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 921:main_sim900.h ****       break;
 922:main_sim900.h ****     }
 923:main_sim900.h ****     {
 924:main_sim900.h ****       uchar rok, miesiac, dzien;
 925:main_sim900.h ****       ptr = pobierz_date_z_PDU(ptr, &rok, &miesiac, &dzien);
 926:main_sim900.h ****     }
 927:main_sim900.h ****     {
 928:main_sim900.h ****       uchar godzina, minuta, sekunda;
 929:main_sim900.h ****       ptr = pobierz_czas_z_PDU(ptr, &godzina, &minuta, &sekunda);
 930:main_sim900.h **** 
 931:main_sim900.h ****       // Zapisz timestamp z SMS do późniejszego użycia
 932:main_sim900.h ****       // (zostanie użyty w wykonanie_polecenia_sms jeśli kod ABCD jest poprawny)
 933:main_sim900.h ****       sms_timestamp_godzina = godzina;
 934:main_sim900.h ****       sms_timestamp_minuta = minuta;
 935:main_sim900.h ****       extern uchar sms_timestamp_sekunda;
 936:main_sim900.h ****       sms_timestamp_sekunda = sekunda;
 937:main_sim900.h ****     }
 938:main_sim900.h ****     ptr_start_pdu_z_wiadomoscia = (uchar *)ptr;
 939:main_sim900.h ****     pdu_to_ascii(ptr, tekst_odebranego_smsa, MAX_LICZBA_ZNAKOW_SMS + 1);
 940:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 941:main_sim900.h ****     const uchar l = min(strlen(tekst_odebranego_smsa), 20);
 942:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
 943:main_sim900.h ****       POMOC_DODAJ(tekst_odebranego_smsa[i]);
 944:main_sim900.h **** #endif
 945:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_INTERPRETUJ_ODEBRANEGO_SMSA);
 946:main_sim900.h ****     break;
 947:main_sim900.h ****   }
 948:main_sim900.h ****   case KOMENDA_KOLEJKI_INTERPRETUJ_ODEBRANEGO_SMSA: {
 949:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 950:main_sim900.h ****     zapal_diode_led(10);
 951:main_sim900.h ****     wykonanie_polecenia_sms();
 952:main_sim900.h ****     flaga_odczytywanie_smsa = FALSE;
 953:main_sim900.h ****     break;
 954:main_sim900.h ****   }
 955:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_1:
 956:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_2:
 957:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_3:
 958:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_4:
 959:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_5:
 960:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_6:
 961:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_7:
 962:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_8:
 963:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_9:
 964:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_10:
 965:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_11:
 966:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_12:
 967:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_13:
 968:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_14:
 969:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_15:
 970:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_16:
 971:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_17:
 972:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_18:
 973:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_19:
 974:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_20: {
 975:main_sim900.h ****     POWTORZ_JESLI(flaga_odczytywanie_smsa || flaga_trwa_rozmowa_wychodzaca ||
 976:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 977:main_sim900.h ****                   czekanie_na_odebranie_zachety)
 978:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 979:main_sim900.h ****     static const char instrukcja_usun_smsa[] PROGMEM = "+cmgd=";
 980:main_sim900.h ****     memcpy_R(wysylane_dane_RAM_SIM900, instrukcja_usun_smsa);
 981:main_sim900.h ****     const uint nr_smsa = wykonywana_komenda - KOMENDA_KOLEJKI_USUN_SMSA_1 + 1;
 982:main_sim900.h ****     utoa(nr_smsa, wysylane_dane_RAM_SIM900 + strlen_R(instrukcja_usun_smsa),
 983:main_sim900.h ****          10);
 984:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 985:main_sim900.h ****     POMOC_DODAJ2('#', 'Y');
 986:main_sim900.h ****     break;
 987:main_sim900.h ****   }
 988:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_PRZYCHODZACA_ROZMOWE: {
 989:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 990:main_sim900.h ****     zapal_diode_led(10);
 991:main_sim900.h **** 
 992:main_sim900.h ****     uchar status_ok =
 993:main_sim900.h ****         sprawdz_przychodzaca_rozmowe(); // Returns TRUE if number authorized
 994:main_sim900.h **** 
 995:main_sim900.h ****     if (status_ok) {
 996:main_sim900.h ****       if (tryb_clip) {
 997:main_sim900.h ****         // Tryb CLIP: wlacz wyjscie i ODRZUC polaczenie
 998:main_sim900.h ****         if (polozenie_polecenia_SIM900(PSTR("+CMTI:")) == NULL) {
 999:main_sim900.h ****           ustaw_wyjscie_clip();
1000:main_sim900.h ****         }
1001:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
1002:main_sim900.h ****       } else {
1003:main_sim900.h ****         // Tryb DTMF: ODBIERZ polaczenie
1004:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_ODBIERZ_ROZMOWE);
1005:main_sim900.h ****       }
1006:main_sim900.h ****     } else {
1007:main_sim900.h ****       // Status NIE OK - odrzuc
1008:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
1009:main_sim900.h ****     }
1010:main_sim900.h ****     blokada_clip = TRUE;
1011:main_sim900.h ****     break;
1012:main_sim900.h ****   }
1013:main_sim900.h ****   case KOMENDA_KOLEJKI_ODRZUC_ROZMOWE: {
1014:main_sim900.h ****     POWTORZ_JESLI(
1015:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
1016:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
1017:main_sim900.h ****         czekanie_na_odebranie_zachety || wykonywanie_rozmowy_telefonicznej ||
1018:main_sim900.h ****         !CZY_MOZNA_WYSYLAC_DANE_SIM900() || !czy_jest_bezczynny_SIM900());
1019:main_sim900.h ****     wysylane_polecenie_SIM900 = wykonywana_komenda;
1020:main_sim900.h ****     static const char instrukcja_odrzuc_rozmowe[] PROGMEM = "h";
1021:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_odrzuc_rozmowe);
1022:main_sim900.h ****     break;
1023:main_sim900.h ****   }
1024:main_sim900.h ****   case KOMENDA_KOLEJKI_ODBIERZ_ROZMOWE: {
1025:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1026:main_sim900.h ****     static const char instrukcja_odbierz_rozmowe[] PROGMEM = "a";
1027:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_odbierz_rozmowe);
1028:main_sim900.h ****     POMOC_DODAJ2('#', 'p');
1029:main_sim900.h ****     break;
1030:main_sim900.h ****   }
1031:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_TON_DTMF: {
1032:main_sim900.h ****     // Czekaj na koncowke inicjalizacji polaczenia/opoznienia?
1033:main_sim900.h ****     POWTORZ_JESLI(opoznienie_SIM900_100MS);
1034:main_sim900.h ****     if (!CZY_MOZNA_WYSYLAC_DANE_SIM900() || !czy_jest_bezczynny_SIM900() ||
1035:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
1036:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
1037:main_sim900.h ****       break;
1038:main_sim900.h ****     }
1039:main_sim900.h ****     wysylane_polecenie_SIM900 = wykonywana_komenda;
1040:main_sim900.h ****     static const char instrukcja_vts[] PROGMEM = "+vts=1";
1041:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_vts);
1042:main_sim900.h ****     POMOC_DODAJ2('#', 'V');
1043:main_sim900.h ****     break;
1044:main_sim900.h ****   }
1045:main_sim900.h ****   case KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE: {
1046:main_sim900.h ****     POWTORZ_JESLI(!modul_zalogowany_w_sieci || opoznienie_SIM900_100MS);
1047:main_sim900.h ****     if (wykonywanie_rozmowy_telefonicznej)
1048:main_sim900.h ****       break;
1049:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1050:main_sim900.h ****     zapal_diode_led(20);
1051:main_sim900.h ****     wysylane_dane_RAM_SIM900[0] = 'd';
1052:main_sim900.h ****     // static const char doladowanie[] PROGMEM = "*100*59484869838559#";
1053:main_sim900.h ****     // strcpy_P(numer_telefonu_do_ktorego_dzwonic, doladowanie);
1054:main_sim900.h ****     strcpy(wysylane_dane_RAM_SIM900 + 1, numer_telefonu_do_ktorego_dzwonic);
1055:main_sim900.h ****     uchar l = strlen(numer_telefonu_do_ktorego_dzwonic) + 1;
1056:main_sim900.h ****     wysylane_dane_RAM_SIM900[l] = ';';
1057:main_sim900.h ****     wysylane_dane_RAM_SIM900[l + 1] = '\0';
1058:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
1059:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 300;
1060:main_sim900.h ****     POMOC_DODAJ2('#', 'h');
1061:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
1062:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
1063:main_sim900.h ****       POMOC_DODAJ(numer_telefonu_do_ktorego_dzwonic[i]);
1064:main_sim900.h **** #endif
1065:main_sim900.h ****     break;
1066:main_sim900.h ****   }
1067:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_POZIOM_SIECI: {
1068:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1069:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1070:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1071:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1072:main_sim900.h ****       if (poziom_sieci_gsm == POZIOM_SIECI_BLAD ||
1073:main_sim900.h ****           poziom_sieci_gsm == 0) // poziom sieci bez zmian
1074:main_sim900.h ****         poziom_sieci_gsm = 16;
1075:main_sim900.h ****       break;
1076:main_sim900.h ****     }
1077:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1078:main_sim900.h ****     static const char instrukcja_poziom_sieci[] PROGMEM = "+csq";
1079:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_poziom_sieci);
1080:main_sim900.h ****     break;
1081:main_sim900.h ****   }
1082:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_ZAREJESTROWANIE: {
1083:main_sim900.h ****     // Usunięto warunek !modul_zalogowany_w_sieci - musimy sprawdzać ZAWSZE!
1084:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1085:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1086:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1087:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1088:main_sim900.h ****       break;
1089:main_sim900.h ****     }
1090:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1091:main_sim900.h ****     static const char instrukcja_creg[] PROGMEM = "+creg?";
1092:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_creg);
1093:main_sim900.h ****     break;
1094:main_sim900.h ****   }
1095:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_STAN_KARTY_SIM: {
1096:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1097:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1098:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1099:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1100:main_sim900.h ****       licznik_blad_stanu_karty_SIM = 0;
1101:main_sim900.h ****       break;
1102:main_sim900.h ****     }
1103:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1104:main_sim900.h ****     static const char instrukcja_odczyt_ksiazki[] PROGMEM = "+cpbr=26";
1105:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_odczyt_ksiazki);
1106:main_sim900.h ****     break;
1107:main_sim900.h ****   }
1108:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_ZALOGOWANIE_U_OPERATORA: {
1109:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1110:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1111:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1112:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1113:main_sim900.h ****       licznik_blad_zalogowania_u_operatora = 0;
1114:main_sim900.h ****       break;
1115:main_sim900.h ****     }
1116:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1117:main_sim900.h ****     static const char instrukcja_sprawdz_operatora[] PROGMEM = "+cops?";
1118:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_sprawdz_operatora);
1119:main_sim900.h ****     break;
1120:main_sim900.h ****   }
1121:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE: {
1122:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1123:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1124:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1125:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK)
1126:main_sim900.h ****       break;
1127:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1128:main_sim900.h ****     static const char instrukcja_cclk[] PROGMEM = "+cclk?";
1129:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_cclk);
1130:main_sim900.h ****     break;
1131:main_sim900.h ****   }
1132:main_sim900.h ****   case KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS: {
1133:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1134:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM = "+cdscb";
1135:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_ustawienie_pamieci);
1136:main_sim900.h ****     break;
1137:main_sim900.h ****   }
1138:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW: {
1139:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1140:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM =
1141:main_sim900.h ****         "+cpms=\"SM\",\"SM\",\"SM\"";
1142:main_sim900.h ****     nastepne_wysylane_polecenie_SIM900 =
1143:main_sim900.h ****         KOMENDA_KOLEJKI_WSTAWIENIE_MORING_GDY_DZWONI;
1144:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_ustawienie_pamieci);
1145:main_sim900.h ****     break;
1146:main_sim900.h ****   }
1147:main_sim900.h ****   case KOMENDA_KOLEJKI_PODLACZONY_MODUL_GSM: {
1148:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT);
1149:main_sim900.h ****     opoznienie_zatrzymaj_odpytywanie_urzadzenia = 20;
1150:main_sim900.h ****     ustaw_odbior_SIM900();
1151:main_sim900.h ****     break;
1152:main_sim900.h ****   }
1153:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: { // po wczeniu zasilania wysya 2
1154:main_sim900.h ****                                               // razy, bo za pierwszym razem nie
1155:main_sim900.h ****                                               // dziaa kontrola RTS / CTS w
1156:main_sim900.h ****                                               // SIM800
1157:main_sim900.h ****     if (max_oczekiwanie_na_odpowiedz_at)
1158:main_sim900.h ****       break;
1159:main_sim900.h ****     if (opoznienie_zatrzymaj_odpytywanie_urzadzenia) {
1160:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
1161:main_sim900.h ****       break;
1162:main_sim900.h ****     }
1163:main_sim900.h ****     if (CZY_WYSYLANIE_DANYCH_SIM900()) {
1164:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
1165:main_sim900.h ****       break;
1166:main_sim900.h ****     }
1167:main_sim900.h ****     ustaw_odbior_SIM900();
1168:main_sim900.h ****     wysylane_polecenie_SIM900 = wykonywana_komenda;
1169:main_sim900.h ****     max_oczekiwanie_na_odpowiedz_at = 20;
1170:main_sim900.h ****     static const char instrukcja_at[] PROGMEM = "+ifc=2,2";
1171:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_at);
1172:main_sim900.h ****     break;
1173:main_sim900.h ****   }
1174:main_sim900.h ****   case KOMENDA_KOLEJKI_ODEBRANO_POLECENIE_ROZPOCZYNAJACE: {
1175:main_sim900.h ****     podlaczony_modul_gsm_SIM900 = TRUE;
1176:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_PIN);
1177:main_sim900.h ****     opoznienie_SIM900_100MS = 40;
1178:main_sim900.h ****     break;
1179:main_sim900.h ****   }
1180:main_sim900.h ****   case KOMENDA_KOLEJKI_PODAJ_PIN: {
1181:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1182:main_sim900.h ****     static const char instrukcja_podaj_pin[] PROGMEM = "+cpin=\"1976\"";
1183:main_sim900.h ****     strcpy_P(wysylane_dane_RAM_SIM900, instrukcja_podaj_pin);
1184:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
1185:main_sim900.h ****     break;
1186:main_sim900.h ****   }
1187:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY: {
1188:main_sim900.h ****     static uchar drugi_raz = FALSE;
1189:main_sim900.h ****     if (drugi_raz) {
1190:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW);
1191:main_sim900.h ****       break;
1192:main_sim900.h ****     }
1193:main_sim900.h ****     drugi_raz = TRUE;
1194:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1195:main_sim900.h ****     static const char instrukcja_usun_wszystkie_smsy[] PROGMEM = "+cmgda=6";
1196:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_usun_wszystkie_smsy);
1197:main_sim900.h ****     break;
1198:main_sim900.h ****   }
1199:main_sim900.h ****   case KOMENDA_KOLEJKI_KOMENDA_SIM900: {
1200:main_sim900.h ****     obsluga_komendy_SIM900();
1201:main_sim900.h ****     if (komenda_SIM900 != KOMENDA_SIM900_WYSLANE_POLECENIE)
1202:main_sim900.h ****       max_oczekiwanie_na_odpowiedz = 20;
1203:main_sim900.h ****     resetuj_komende_SIM900();
1204:main_sim900.h ****     break;
1205:main_sim900.h ****   }
1206:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_WZMOCNIENIE_MIKROFONU: {
1207:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1208:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1209:main_sim900.h ****     static const char instrukcja[] PROGMEM =
1210:main_sim900.h ****         "+cmic=0,15"; // ustawienie od 0 ... 15
1211:main_sim900.h ****     strcpy_P(wysylane_dane_RAM_SIM900, instrukcja);
1212:main_sim900.h ****     nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_ROZPOCZNIJ_PRACE;
1213:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
1214:main_sim900.h ****     break;
1215:main_sim900.h ****   }
1216:main_sim900.h ****   case KOMENDA_KOLEJKI_ROZPOCZNIJ_PRACE: {
1217:main_sim900.h ****     POMOC_DODAJ2('*', 'h');
1218:main_sim900.h ****     if (podlaczona_karta_SIM_SIM900) {
1219:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS);
1220:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_MODUL_ZALOGOWANY);
1221:main_sim900.h ****     }
1222:main_sim900.h ****     break;
1223:main_sim900.h ****   }
1224:main_sim900.h ****   case KOMENDA_KOLEJKI_MODUL_ZALOGOWANY: {
1225:main_sim900.h ****     // Nie ustawiamy modul_zalogowany_w_sieci tutaj!
1226:main_sim900.h ****     // Flaga jest ustawiana tylko przez +CREG gdy faktycznie zalogowany
1227:main_sim900.h ****     break;
1228:main_sim900.h ****   }
1229:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_ZEGAR_SIM900: {
1230:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1231:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1232:main_sim900.h ****     strcpy(wysylane_dane_RAM_SIM900, bufor_ustaw_czas);
1233:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
1234:main_sim900.h ****     break;
1235:main_sim900.h ****   }
1236:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_PIN:
1237:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW:
1238:main_sim900.h ****   case KOMENDA_KOLEJKI_WSTAWIENIE_MORING_GDY_DZWONI:
1239:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_WYSYLANIE_INFO_O_DZWONIACYM:
1240:main_sim900.h ****   case KOMENDA_KOLEJKI_WLACZ_DETEKCJE_DTMF:
1241:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_CICHY_TRYB:
1242:main_sim900.h ****   case KOMENDA_KOLEJKI_WYCISZ_DZWONKI:
1243:main_sim900.h ****   case KOMENDA_KOLEJKI_ODBIERAJ_SMS_FLASH:
1244:main_sim900.h ****   case KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ:
1245:main_sim900.h ****   case KOMENDA_KOLEJKI_WLACZ_CZAS_Z_SIECI: {
1246:main_sim900.h **** 
1247:main_sim900.h **** #define MAX_ROZMIAR_POLECENIA_GSM 14
1248:main_sim900.h **** 
1249:main_sim900.h ****     static const char instrukcje[10][MAX_ROZMIAR_POLECENIA_GSM] PROGMEM = {
1250:main_sim900.h ****         "+cpin?",         "+cnmi=2,1,2,1", "+moring=1", "+clip=1",
1251:main_sim900.h ****         "+ddet=1,10,1",   "+calm=1",       "+crsl=1",   "+cusd=1",
1252:main_sim900.h ****         "+cpbw=26,\"1\"", "+clts=0",
1253:main_sim900.h ****     };
1254:main_sim900.h ****     static const komenda_typ nastepna_komenda[10] PROGMEM = {
1255:main_sim900.h ****         KOMENDA_KOLEJKI_BRAK_KOMENDY,
1256:main_sim900.h ****         KOMENDA_KOLEJKI_BRAK_KOMENDY,
1257:main_sim900.h ****         KOMENDA_KOLEJKI_USTAW_WYSYLANIE_INFO_O_DZWONIACYM,
1258:main_sim900.h ****         KOMENDA_KOLEJKI_WLACZ_DETEKCJE_DTMF,
1259:main_sim900.h ****         KOMENDA_KOLEJKI_USTAW_CICHY_TRYB,
1260:main_sim900.h ****         KOMENDA_KOLEJKI_WYCISZ_DZWONKI,
1261:main_sim900.h ****         KOMENDA_KOLEJKI_ODBIERAJ_SMS_FLASH,
1262:main_sim900.h ****         KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ,
1263:main_sim900.h ****         KOMENDA_KOLEJKI_WLACZ_CZAS_Z_SIECI,
1264:main_sim900.h ****         KOMENDA_KOLEJKI_USTAW_WZMOCNIENIE_MIKROFONU,
1265:main_sim900.h ****     };
1266:main_sim900.h ****     // RE-DOING THIS CHUNK TO BE SAFE AND CORRECT
1267:main_sim900.h **** 
1268:main_sim900.h ****     const uchar nr = wykonywana_komenda - KOMENDA_KOLEJKI_SPRAWDZ_PIN;
1269:main_sim900.h ****     if (!wyslanie_polecenia_ROM(
1270:main_sim900.h ****             czy_mozna_wysylac_dane_do_SIM900, wykonywana_komenda,
1271:main_sim900.h ****             pgm_read_word(&nastepna_komenda[nr]), &instrukcje[nr][0]))
1272:main_sim900.h ****       break;
1273:main_sim900.h ****     POMOC_DODAJ2('*', 's');
1274:main_sim900.h ****     POMOC_DODAJ_HEX(nr);
1275:main_sim900.h ****     break;
1276:main_sim900.h ****   }
1277:main_sim900.h ****   default:
1278:main_sim900.h ****     return FALSE;
 5180               		.loc 2 1278 0
 5181 19f4 80E0      		ldi r24,0
 5182               	.LVL445:
 5183               	.L487:
 5184               	/* epilogue start */
1279:main_sim900.h ****   }
1280:main_sim900.h ****   return TRUE;
1281:main_sim900.h **** }
 5185               		.loc 2 1281 0
 5186 19f6 0F90      		pop __tmp_reg__
 5187 19f8 0F90      		pop __tmp_reg__
 5188 19fa 0F90      		pop __tmp_reg__
 5189 19fc DF91      		pop r29
 5190 19fe CF91      		pop r28
 5191 1a00 1F91      		pop r17
 5192 1a02 0F91      		pop r16
 5193               	.LVL446:
 5194 1a04 FF90      		pop r15
 5195 1a06 EF90      		pop r14
 5196               	.LVL447:
 5197 1a08 0895      		ret
 5198               	.L589:
 842:main_sim900.h **** 
 5199               		.loc 2 842 0
 5200 1a0a 81E0      		ldi r24,lo8(1)
 5201               	.L592:
 845:main_sim900.h ****       czy_jest_bezczynny_SIM900();
 5202               		.loc 2 845 0
 5203 1a0c 00E0      		ldi r16,0
 5204 1a0e 00C0      		rjmp .L490
 5205               	.LVL448:
 5206               	.L498:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5207               		.loc 2 849 0
 5208 1a10 1F38      		cpi r17,lo8(-113)
 5209 1a12 01F4      		brne .+2
 5210 1a14 00C0      		rjmp .L502
 5211 1a16 00F4      		brsh .+2
 5212 1a18 00C0      		rjmp .L503
 5213 1a1a 1039      		cpi r17,lo8(-112)
 5214 1a1c 01F4      		brne .+2
 5215 1a1e 00C0      		rjmp .L504
 5216 1a20 1139      		cpi r17,lo8(-111)
 5217 1a22 01F4      		brne .L492
 5218               	.L609:
1280:main_sim900.h **** }
 5219               		.loc 2 1280 0
 5220 1a24 8FEF      		ldi r24,lo8(-1)
 5221 1a26 00C0      		rjmp .L487
 5222               	.L496:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5223               		.loc 2 849 0
 5224 1a28 1739      		cpi r17,lo8(-105)
 5225 1a2a 01F4      		brne .+2
 5226 1a2c 00C0      		rjmp .L506
 5227 1a2e 00F4      		brsh .L507
 5228 1a30 1539      		cpi r17,lo8(-107)
 5229 1a32 01F4      		brne .+2
 5230 1a34 00C0      		rjmp .L508
 5231 1a36 00F0      		brlo .+2
 5232 1a38 00C0      		rjmp .L509
 5233 1a3a 1439      		cpi r17,lo8(-108)
 5234 1a3c 01F4      		brne .L492
 5235               	.LBB572:
1207:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5236               		.loc 2 1207 0
 5237 1a3e 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5238 1a42 8111      		cpse r24,__zero_reg__
 5239 1a44 00C0      		rjmp .L580
1207:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5240               		.loc 2 1207 0 is_stmt 0 discriminator 2
 5241 1a46 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5242 1a4a 8111      		cpse r24,__zero_reg__
 5243 1a4c 00C0      		rjmp .L580
1207:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5244               		.loc 2 1207 0 discriminator 4
 5245 1a4e 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5246 1a52 8111      		cpse r24,__zero_reg__
 5247 1a54 00C0      		rjmp .L580
1207:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5248               		.loc 2 1207 0 discriminator 6
 5249 1a56 F99B      		sbis 0x1f,1
 5250 1a58 00C0      		rjmp .L581
 5251               	.L580:
1207:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5252               		.loc 2 1207 0 discriminator 7
 5253 1a5a 84E9      		ldi r24,lo8(-108)
 5254 1a5c 00C0      		rjmp .L650
 5255               	.L507:
 5256               	.LBE572:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5257               		.loc 2 849 0 is_stmt 1
 5258 1a5e 1939      		cpi r17,lo8(-103)
 5259 1a60 01F4      		brne .+2
 5260 1a62 00C0      		rjmp .L511
 5261 1a64 00F4      		brsh .+2
 5262 1a66 00C0      		rjmp .L512
 5263 1a68 1A39      		cpi r17,lo8(-102)
 5264 1a6a 01F4      		brne .+2
 5265 1a6c 00C0      		rjmp .L513
 5266 1a6e 1B39      		cpi r17,lo8(-101)
 5267 1a70 01F4      		brne .L492
 5268               	.LBB573:
1068:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5269               		.loc 2 1068 0
 5270 1a72 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 5271 1a76 9111      		cpse r25,__zero_reg__
 5272 1a78 00C0      		rjmp .L560
1068:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5273               		.loc 2 1068 0 is_stmt 0 discriminator 1
 5274 1a7a 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 5275 1a7e 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5276 1a82 232B      		or r18,r19
 5277 1a84 01F4      		brne .L560
1068:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5278               		.loc 2 1068 0 discriminator 2
 5279 1a86 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 5280 1a8a 9111      		cpse r25,__zero_reg__
 5281 1a8c 00C0      		rjmp .L560
1069:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 5282               		.loc 2 1069 0 is_stmt 1
 5283 1a8e 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 5284 1a92 9111      		cpse r25,__zero_reg__
 5285 1a94 00C0      		rjmp .L560
1070:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 5286               		.loc 2 1070 0
 5287 1a96 8111      		cpse r24,__zero_reg__
 5288 1a98 00C0      		rjmp .L560
1070:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 5289               		.loc 2 1070 0 is_stmt 0 discriminator 1
 5290 1a9a 8091 0000 		lds r24,wysylanie_smsa_clipa
 5291 1a9e 8823      		tst r24
 5292 1aa0 01F4      		brne .+2
 5293 1aa2 00C0      		rjmp .L561
 5294               	.L560:
1072:main_sim900.h ****           poziom_sieci_gsm == 0) // poziom sieci bez zmian
 5295               		.loc 2 1072 0 is_stmt 1
 5296 1aa4 8091 0000 		lds r24,poziom_sieci_gsm
 5297 1aa8 8336      		cpi r24,lo8(99)
 5298 1aaa 01F0      		breq .L562
1072:main_sim900.h ****           poziom_sieci_gsm == 0) // poziom sieci bez zmian
 5299               		.loc 2 1072 0 is_stmt 0 discriminator 1
 5300 1aac 8111      		cpse r24,__zero_reg__
 5301 1aae 00C0      		rjmp .L609
 5302               	.L562:
1074:main_sim900.h ****       break;
 5303               		.loc 2 1074 0 is_stmt 1
 5304 1ab0 80E1      		ldi r24,lo8(16)
 5305 1ab2 8093 0000 		sts poziom_sieci_gsm,r24
 5306 1ab6 00C0      		rjmp .L609
 5307               	.L494:
 5308               	.LBE573:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5309               		.loc 2 849 0
 5310 1ab8 123D      		cpi r17,lo8(-46)
 5311 1aba 00F0      		brlo .+2
 5312 1abc 00C0      		rjmp .L515
 5313 1abe 1E3B      		cpi r17,lo8(-66)
 5314 1ac0 00F0      		brlo .+2
 5315 1ac2 00C0      		rjmp .L516
 5316 1ac4 153A      		cpi r17,lo8(-91)
 5317 1ac6 01F4      		brne .+2
 5318 1ac8 00C0      		rjmp .L517
 5319 1aca 00F4      		brsh .L518
 5320 1acc 1E39      		cpi r17,lo8(-98)
 5321 1ace 01F4      		brne .+2
 5322 1ad0 00C0      		rjmp .L519
 5323               	.L520:
 5324               	.LBB574:
1268:main_sim900.h ****     if (!wyslanie_polecenia_ROM(
 5325               		.loc 2 1268 0
 5326 1ad2 21E6      		ldi r18,lo8(97)
 5327 1ad4 210F      		add r18,r17
 5328               	.LVL449:
 5329               	.LBB575:
1271:main_sim900.h ****       break;
 5330               		.loc 2 1271 0
 5331 1ad6 E22F      		mov r30,r18
 5332 1ad8 F0E0      		ldi r31,0
 5333 1ada E050      		subi r30,lo8(-(nastepna_komenda.3469))
 5334 1adc F040      		sbci r31,hi8(-(nastepna_komenda.3469))
 5335               	.LVL450:
 5336               	/* #APP */
 5337               	 ;  1271 "main_sim900.h" 1
 5338 1ade 4591      		lpm r20, Z+
 5339 1ae0 5491      		lpm r21, Z
 5340               		
 5341               	 ;  0 "" 2
 5342               	.LVL451:
 5343               	/* #NOAPP */
 5344               	.LBE575:
1269:main_sim900.h ****             czy_mozna_wysylac_dane_do_SIM900, wykonywana_komenda,
 5345               		.loc 2 1269 0
 5346 1ae2 FEE0      		ldi r31,lo8(14)
 5347 1ae4 2F9F      		mul r18,r31
 5348 1ae6 9001      		movw r18,r0
 5349 1ae8 1124      		clr __zero_reg__
 5350               	.LVL452:
 5351 1aea 2050      		subi r18,lo8(-(instrukcje.3468))
 5352 1aec 3040      		sbci r19,hi8(-(instrukcje.3468))
 5353 1aee 612F      		mov r22,r17
 5354 1af0 802F      		mov r24,r16
 5355 1af2 0E94 0000 		call wyslanie_polecenia_ROM
 5356               	.LVL453:
 5357 1af6 00C0      		rjmp .L609
 5358               	.LVL454:
 5359               	.L518:
 5360               	.LBE574:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5361               		.loc 2 849 0
 5362 1af8 1A3A      		cpi r17,lo8(-86)
 5363 1afa 00F0      		brlo .L520
 5364               	.LBB576:
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5365               		.loc 2 887 0
 5366 1afc 9111      		cpse r25,__zero_reg__
 5367 1afe 00C0      		rjmp .L656
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5368               		.loc 2 887 0 is_stmt 0 discriminator 2
 5369 1b00 8091 0000 		lds r24,modul_zalogowany_w_sieci
 5370 1b04 8823      		tst r24
 5371 1b06 01F4      		brne .+2
 5372 1b08 00C0      		rjmp .L656
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5373               		.loc 2 887 0 discriminator 4
 5374 1b0a 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5375 1b0e 8111      		cpse r24,__zero_reg__
 5376 1b10 00C0      		rjmp .L656
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5377               		.loc 2 887 0 discriminator 6
 5378 1b12 8091 0000 		lds r24,licznik_bezpieczenstwa_wykonywana_rozmowa
 5379 1b16 9091 0000 		lds r25,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5380 1b1a 892B      		or r24,r25
 5381 1b1c 01F0      		breq .+2
 5382 1b1e 00C0      		rjmp .L656
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5383               		.loc 2 887 0 discriminator 8
 5384 1b20 8091 0000 		lds r24,opoznienie_SIM900_100MS
 5385 1b24 8111      		cpse r24,__zero_reg__
 5386 1b26 00C0      		rjmp .L656
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5387               		.loc 2 887 0 discriminator 10
 5388 1b28 8091 0000 		lds r24,wysylanie_smsa_clipa
 5389 1b2c 8111      		cpse r24,__zero_reg__
 5390 1b2e 00C0      		rjmp .L656
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5391               		.loc 2 887 0 discriminator 12
 5392 1b30 8091 0000 		lds r24,flaga_wysylanie_smsa
 5393 1b34 8111      		cpse r24,__zero_reg__
 5394 1b36 00C0      		rjmp .L656
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5395               		.loc 2 887 0 discriminator 14
 5396 1b38 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 5397 1b3c 8239      		cpi r24,lo8(-110)
 5398 1b3e 01F4      		brne .+2
 5399 1b40 00C0      		rjmp .L656
 893:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 5400               		.loc 2 893 0 is_stmt 1
 5401 1b42 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5402 1b46 8111      		cpse r24,__zero_reg__
 5403 1b48 00C0      		rjmp .L656
 893:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 5404               		.loc 2 893 0 is_stmt 0 discriminator 2
 5405 1b4a 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5406 1b4e 8111      		cpse r24,__zero_reg__
 5407 1b50 00C0      		rjmp .L656
 893:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 5408               		.loc 2 893 0 discriminator 4
 5409 1b52 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5410 1b56 8111      		cpse r24,__zero_reg__
 5411 1b58 00C0      		rjmp .L656
 893:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 5412               		.loc 2 893 0 discriminator 6
 5413 1b5a F999      		sbic 0x1f,1
 5414 1b5c 00C0      		rjmp .L656
 894:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW,
 5415               		.loc 2 894 0 is_stmt 1
 5416 1b5e 61E0      		ldi r22,lo8(1)
 5417 1b60 81E0      		ldi r24,lo8(1)
 5418 1b62 0E94 0000 		call czy_sa_komendy_z_przedzialu
 5419               	.LVL455:
 5420 1b66 8111      		cpse r24,__zero_reg__
 5421 1b68 00C0      		rjmp .L656
 894:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW,
 5422               		.loc 2 894 0 is_stmt 0 discriminator 2
 5423 1b6a 65ED      		ldi r22,lo8(-43)
 5424 1b6c 83ED      		ldi r24,lo8(-45)
 5425 1b6e 0E94 0000 		call czy_sa_komendy_z_przedzialu
 5426               	.LVL456:
 5427 1b72 8111      		cpse r24,__zero_reg__
 5428 1b74 00C0      		rjmp .L656
 894:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW,
 5429               		.loc 2 894 0 discriminator 4
 5430 1b76 68E9      		ldi r22,lo8(-104)
 5431 1b78 86E9      		ldi r24,lo8(-106)
 5432 1b7a 0E94 0000 		call czy_sa_komendy_z_przedzialu
 5433               	.LVL457:
 5434 1b7e 8111      		cpse r24,__zero_reg__
 5435 1b80 00C0      		rjmp .L656
 902:main_sim900.h ****     flaga_odczytywanie_smsa = TRUE;
 5436               		.loc 2 902 0 is_stmt 1
 5437 1b82 0023      		tst r16
 5438 1b84 01F4      		brne .+2
 5439 1b86 00C0      		rjmp .L656
 902:main_sim900.h ****     flaga_odczytywanie_smsa = TRUE;
 5440               		.loc 2 902 0 is_stmt 0 discriminator 2
 5441 1b88 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5442 1b8c 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5443 1b90 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
 903:main_sim900.h ****     static const char instrukcja_odczytaj_smsa[] PROGMEM = "+cmgr=";
 5444               		.loc 2 903 0 is_stmt 1 discriminator 2
 5445 1b94 8FEF      		ldi r24,lo8(-1)
 5446 1b96 8093 0000 		sts flaga_odczytywanie_smsa,r24
 905:main_sim900.h ****     const uint nr_smsa =
 5447               		.loc 2 905 0 discriminator 2
 5448 1b9a 46E0      		ldi r20,lo8(6)
 5449 1b9c 50E0      		ldi r21,0
 5450 1b9e 60E0      		ldi r22,lo8(instrukcja_odczytaj_smsa.3382)
 5451 1ba0 70E0      		ldi r23,hi8(instrukcja_odczytaj_smsa.3382)
 5452 1ba2 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 5453 1ba4 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 5454 1ba6 0E94 0000 		call memcpy_P
 5455               	.LVL458:
 5456               	.LBB577:
 5457               	.LBB578:
 5458               		.loc 6 527 0 discriminator 2
 5459 1baa 4AE0      		ldi r20,lo8(10)
 5460 1bac 60E0      		ldi r22,lo8(wysylany_blok_SIM900+8)
 5461 1bae 70E0      		ldi r23,hi8(wysylany_blok_SIM900+8)
 5462               	.LVL459:
 5463 1bb0 C701      		movw r24,r14
 5464 1bb2 895A      		subi r24,-87
 5465 1bb4 9109      		sbc r25,__zero_reg__
 5466               	.LVL460:
 5467               	.L657:
 5468               	.LBE578:
 5469               	.LBE577:
 5470               	.LBE576:
 5471               	.LBB579:
 5472               	.LBB580:
 5473               	.LBB581:
 5474 1bb6 0E94 0000 		call __utoa_ncheck
 5475               	.LVL461:
 5476               	.L651:
 5477               	.LBE581:
 5478               	.LBE580:
 5479               	.LBE579:
1233:main_sim900.h ****     break;
 5480               		.loc 2 1233 0 discriminator 2
 5481 1bba 0E94 0000 		call wyslij_polecenie_RAM_SIM900
 5482               	.LVL462:
 5483 1bbe 00C0      		rjmp .L609
 5484               	.L515:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5485               		.loc 2 849 0
 5486 1bc0 153D      		cpi r17,lo8(-43)
 5487 1bc2 01F4      		brne .+2
 5488 1bc4 00C0      		rjmp .L522
 5489 1bc6 00F4      		brsh .L523
 5490 1bc8 123D      		cpi r17,lo8(-46)
 5491 1bca 01F4      		brne .L648
 5492               	.LBB584:
 915:main_sim900.h ****         bufor_pdu, numer_telefonu_odebranego_smsa,
 5493               		.loc 2 915 0
 5494 1bcc 40E0      		ldi r20,lo8(nie_wysylaj_echa_z_powodu_nietypowego_smsa)
 5495 1bce 50E0      		ldi r21,hi8(nie_wysylaj_echa_z_powodu_nietypowego_smsa)
 5496 1bd0 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 5497 1bd2 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 5498 1bd4 80E0      		ldi r24,lo8(bufor_pdu)
 5499 1bd6 90E0      		ldi r25,hi8(bufor_pdu)
 5500 1bd8 0E94 0000 		call pobierz_numer_telefonu_nadawcy_z_PDU
 5501               	.LVL463:
 918:main_sim900.h ****     {
 5502               		.loc 2 918 0
 5503 1bdc 0097      		sbiw r24,0
 5504 1bde 01F0      		breq .+2
 5505 1be0 00C0      		rjmp .L542
 5506               	.LVL464:
 5507               	.L652:
 5508               	.LBE584:
 952:main_sim900.h ****     break;
 5509               		.loc 2 952 0
 5510 1be2 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 5511 1be6 00C0      		rjmp .L609
 5512               	.L523:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5513               		.loc 2 849 0
 5514 1be8 183D      		cpi r17,lo8(-40)
 5515 1bea 01F4      		brne .+2
 5516 1bec 00C0      		rjmp .L526
 5517 1bee 1E3F      		cpi r17,lo8(-2)
 5518 1bf0 01F4      		brne .+2
 5519 1bf2 00C0      		rjmp .L527
 5520 1bf4 163D      		cpi r17,lo8(-42)
 5521 1bf6 01F0      		breq .+2
 5522 1bf8 00C0      		rjmp .L492
 5523               	.LBB587:
1046:main_sim900.h ****     if (wykonywanie_rozmowy_telefonicznej)
 5524               		.loc 2 1046 0
 5525 1bfa 8091 0000 		lds r24,modul_zalogowany_w_sieci
 5526 1bfe 8823      		tst r24
 5527 1c00 01F0      		breq .L558
1046:main_sim900.h ****     if (wykonywanie_rozmowy_telefonicznej)
 5528               		.loc 2 1046 0 is_stmt 0 discriminator 2
 5529 1c02 8091 0000 		lds r24,opoznienie_SIM900_100MS
 5530 1c06 8823      		tst r24
 5531 1c08 01F4      		brne .+2
 5532 1c0a 00C0      		rjmp .L559
 5533               	.L558:
1046:main_sim900.h ****     if (wykonywanie_rozmowy_telefonicznej)
 5534               		.loc 2 1046 0 discriminator 3
 5535 1c0c 86ED      		ldi r24,lo8(-42)
 5536 1c0e 00C0      		rjmp .L650
 5537               	.L648:
 5538               	.LBE587:
 852:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 5539               		.loc 2 852 0 is_stmt 1
 5540 1c10 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5541 1c14 8111      		cpse r24,__zero_reg__
 5542 1c16 00C0      		rjmp .L656
 852:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 5543               		.loc 2 852 0 is_stmt 0 discriminator 2
 5544 1c18 8091 0000 		lds r24,licznik_bezpieczenstwa_wykonywana_rozmowa
 5545 1c1c 9091 0000 		lds r25,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5546 1c20 892B      		or r24,r25
 5547 1c22 01F4      		brne .L656
 852:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 5548               		.loc 2 852 0 discriminator 4
 5549 1c24 8091 0000 		lds r24,opoznienie_SIM900_100MS
 5550 1c28 8823      		tst r24
 5551 1c2a 01F0      		breq .L530
 5552               	.L656:
 5553               	.LBB588:
 978:main_sim900.h ****     static const char instrukcja_usun_smsa[] PROGMEM = "+cmgd=";
 5554               		.loc 2 978 0 is_stmt 1 discriminator 1
 5555 1c2c 812F      		mov r24,r17
 5556 1c2e 00C0      		rjmp .L650
 5557               	.L530:
 5558               	.LBE588:
 853:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5559               		.loc 2 853 0
 5560 1c30 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5561 1c34 8111      		cpse r24,__zero_reg__
 5562 1c36 00C0      		rjmp .L656
 853:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5563               		.loc 2 853 0 is_stmt 0 discriminator 2
 5564 1c38 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5565 1c3c 8111      		cpse r24,__zero_reg__
 5566 1c3e 00C0      		rjmp .L656
 853:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5567               		.loc 2 853 0 discriminator 4
 5568 1c40 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5569 1c44 8111      		cpse r24,__zero_reg__
 5570 1c46 00C0      		rjmp .L656
 853:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5571               		.loc 2 853 0 discriminator 6
 5572 1c48 F999      		sbic 0x1f,1
 5573 1c4a 00C0      		rjmp .L656
 854:main_sim900.h ****     wyslij_sms(wykonywana_komenda == KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
 5574               		.loc 2 854 0 is_stmt 1
 5575 1c4c 0023      		tst r16
 5576 1c4e 01F0      		breq .L656
 854:main_sim900.h ****     wyslij_sms(wykonywana_komenda == KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
 5577               		.loc 2 854 0 is_stmt 0 discriminator 2
 5578 1c50 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5579 1c54 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5580 1c58 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
 855:main_sim900.h ****     break;
 5581               		.loc 2 855 0 is_stmt 1 discriminator 2
 5582 1c5c 81E0      		ldi r24,lo8(1)
 5583 1c5e 143D      		cpi r17,lo8(-44)
 5584 1c60 01F0      		breq .L534
 5585 1c62 80E0      		ldi r24,0
 5586               	.L534:
 5587 1c64 0E94 0000 		call wyslij_sms
 5588               	.LVL465:
 5589 1c68 00C0      		rjmp .L609
 5590               	.L522:
 5591               	.LBB589:
 859:main_sim900.h ****     konwertuj_pdu_na_blok_wysylany(wysylany_blok_SIM900, bufor_pdu,
 5592               		.loc 2 859 0
 5593 1c6a 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
 860:main_sim900.h ****                                    dlugosc_pdu);
 5594               		.loc 2 860 0
 5595 1c6e 4091 0000 		lds r20,dlugosc_pdu
 5596 1c72 60E0      		ldi r22,lo8(bufor_pdu)
 5597 1c74 70E0      		ldi r23,hi8(bufor_pdu)
 5598 1c76 80E0      		ldi r24,lo8(wysylany_blok_SIM900)
 5599 1c78 90E0      		ldi r25,hi8(wysylany_blok_SIM900)
 5600 1c7a 0E94 0000 		call konwertuj_pdu_na_blok_wysylany
 5601               	.LVL466:
 862:main_sim900.h ****     wysylany_blok_SIM900[liczba_znakow - 1] = ZNAK_CTRL_Z;
 5602               		.loc 2 862 0
 5603 1c7e 8091 0000 		lds r24,dlugosc_pdu
 5604 1c82 90E0      		ldi r25,0
 5605 1c84 880F      		lsl r24
 5606 1c86 991F      		rol r25
 5607 1c88 0196      		adiw r24,1
 5608               	.LVL467:
 863:main_sim900.h ****     wyslij_znaki_SIM900(liczba_znakow);
 5609               		.loc 2 863 0
 5610 1c8a FC01      		movw r30,r24
 5611 1c8c E050      		subi r30,lo8(-(wysylany_blok_SIM900-1))
 5612 1c8e F040      		sbci r31,hi8(-(wysylany_blok_SIM900-1))
 5613 1c90 2AE1      		ldi r18,lo8(26)
 5614 1c92 2083      		st Z,r18
 864:main_sim900.h ****     break;
 5615               		.loc 2 864 0
 5616 1c94 0E94 0000 		call wyslij_znaki_SIM900
 5617               	.LVL468:
 5618 1c98 00C0      		rjmp .L609
 5619               	.LVL469:
 5620               	.L542:
 5621               	.LBE589:
 5622               	.LBB590:
 5623               	.LBB585:
 925:main_sim900.h ****     }
 5624               		.loc 2 925 0
 5625 1c9a 9E01      		movw r18,r28
 5626 1c9c 2F5F      		subi r18,-1
 5627 1c9e 3F4F      		sbci r19,-1
 5628 1ca0 AE01      		movw r20,r28
 5629 1ca2 4E5F      		subi r20,-2
 5630 1ca4 5F4F      		sbci r21,-1
 5631 1ca6 BE01      		movw r22,r28
 5632 1ca8 6D5F      		subi r22,-3
 5633 1caa 7F4F      		sbci r23,-1
 5634 1cac 0E94 0000 		call pobierz_date_z_PDU
 5635               	.LVL470:
 5636               	.LBE585:
 5637               	.LBB586:
 929:main_sim900.h **** 
 5638               		.loc 2 929 0
 5639 1cb0 9E01      		movw r18,r28
 5640 1cb2 2F5F      		subi r18,-1
 5641 1cb4 3F4F      		sbci r19,-1
 5642 1cb6 AE01      		movw r20,r28
 5643 1cb8 4E5F      		subi r20,-2
 5644 1cba 5F4F      		sbci r21,-1
 5645 1cbc BE01      		movw r22,r28
 5646 1cbe 6D5F      		subi r22,-3
 5647 1cc0 7F4F      		sbci r23,-1
 5648 1cc2 0E94 0000 		call pobierz_czas_z_PDU
 5649               	.LVL471:
 933:main_sim900.h ****       sms_timestamp_minuta = minuta;
 5650               		.loc 2 933 0
 5651 1cc6 2B81      		ldd r18,Y+3
 5652 1cc8 2093 0000 		sts sms_timestamp_godzina,r18
 934:main_sim900.h ****       extern uchar sms_timestamp_sekunda;
 5653               		.loc 2 934 0
 5654 1ccc 2A81      		ldd r18,Y+2
 5655 1cce 2093 0000 		sts sms_timestamp_minuta,r18
 936:main_sim900.h ****     }
 5656               		.loc 2 936 0
 5657 1cd2 2981      		ldd r18,Y+1
 5658 1cd4 2093 0000 		sts sms_timestamp_sekunda,r18
 5659               	.LBE586:
 938:main_sim900.h ****     pdu_to_ascii(ptr, tekst_odebranego_smsa, MAX_LICZBA_ZNAKOW_SMS + 1);
 5660               		.loc 2 938 0
 5661 1cd8 9093 0000 		sts ptr_start_pdu_z_wiadomoscia+1,r25
 5662 1cdc 8093 0000 		sts ptr_start_pdu_z_wiadomoscia,r24
 939:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 5663               		.loc 2 939 0
 5664 1ce0 41EA      		ldi r20,lo8(-95)
 5665 1ce2 60E0      		ldi r22,lo8(wysylany_blok_SIM900+239)
 5666 1ce4 70E0      		ldi r23,hi8(wysylany_blok_SIM900+239)
 5667 1ce6 0E94 0000 		call pdu_to_ascii
 5668               	.LVL472:
 5669               	.L543:
 5670               	.LBE590:
 949:main_sim900.h ****     zapal_diode_led(10);
 5671               		.loc 2 949 0 discriminator 7
 5672 1cea 88ED      		ldi r24,lo8(-40)
 5673               	.L650:
1230:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5674               		.loc 2 1230 0 discriminator 7
 5675 1cec 0E94 0000 		call dodaj_komende
 5676               	.LVL473:
 5677 1cf0 00C0      		rjmp .L609
 5678               	.L526:
 949:main_sim900.h ****     zapal_diode_led(10);
 5679               		.loc 2 949 0
 5680 1cf2 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5681 1cf6 8111      		cpse r24,__zero_reg__
 5682 1cf8 00C0      		rjmp .L543
 949:main_sim900.h ****     zapal_diode_led(10);
 5683               		.loc 2 949 0 is_stmt 0 discriminator 2
 5684 1cfa 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5685 1cfe 8111      		cpse r24,__zero_reg__
 5686 1d00 00C0      		rjmp .L543
 949:main_sim900.h ****     zapal_diode_led(10);
 5687               		.loc 2 949 0 discriminator 4
 5688 1d02 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5689 1d06 8111      		cpse r24,__zero_reg__
 5690 1d08 00C0      		rjmp .L543
 949:main_sim900.h ****     zapal_diode_led(10);
 5691               		.loc 2 949 0 discriminator 6
 5692 1d0a F999      		sbic 0x1f,1
 5693 1d0c 00C0      		rjmp .L543
 950:main_sim900.h ****     wykonanie_polecenia_sms();
 5694               		.loc 2 950 0 is_stmt 1
 5695 1d0e 8BE0      		ldi r24,lo8(11)
 5696 1d10 8093 0000 		sts licznik_100ms_dioda_led,r24
 951:main_sim900.h ****     flaga_odczytywanie_smsa = FALSE;
 5697               		.loc 2 951 0
 5698 1d14 0E94 0000 		call wykonanie_polecenia_sms
 5699               	.LVL474:
 5700 1d18 00C0      		rjmp .L652
 5701               	.L516:
 5702               	.LBB591:
 975:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5703               		.loc 2 975 0
 5704 1d1a 9111      		cpse r25,__zero_reg__
 5705 1d1c 00C0      		rjmp .L656
 975:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5706               		.loc 2 975 0 is_stmt 0 discriminator 2
 5707 1d1e 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5708 1d22 8111      		cpse r24,__zero_reg__
 5709 1d24 00C0      		rjmp .L656
 975:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5710               		.loc 2 975 0 discriminator 4
 5711 1d26 8091 0000 		lds r24,licznik_bezpieczenstwa_wykonywana_rozmowa
 5712 1d2a 9091 0000 		lds r25,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5713 1d2e 892B      		or r24,r25
 5714 1d30 01F0      		breq .+2
 5715 1d32 00C0      		rjmp .L656
 975:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5716               		.loc 2 975 0 discriminator 6
 5717 1d34 8091 0000 		lds r24,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 5718 1d38 8111      		cpse r24,__zero_reg__
 5719 1d3a 00C0      		rjmp .L656
 975:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5720               		.loc 2 975 0 discriminator 8
 5721 1d3c 8091 0000 		lds r24,czekanie_na_odebranie_zachety
 5722 1d40 8111      		cpse r24,__zero_reg__
 5723 1d42 00C0      		rjmp .L656
 978:main_sim900.h ****     static const char instrukcja_usun_smsa[] PROGMEM = "+cmgd=";
 5724               		.loc 2 978 0 is_stmt 1
 5725 1d44 0023      		tst r16
 5726 1d46 01F4      		brne .+2
 5727 1d48 00C0      		rjmp .L656
 978:main_sim900.h ****     static const char instrukcja_usun_smsa[] PROGMEM = "+cmgd=";
 5728               		.loc 2 978 0 is_stmt 0 discriminator 2
 5729 1d4a 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5730 1d4e 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5731 1d52 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
 980:main_sim900.h ****     const uint nr_smsa = wykonywana_komenda - KOMENDA_KOLEJKI_USUN_SMSA_1 + 1;
 5732               		.loc 2 980 0 is_stmt 1 discriminator 2
 5733 1d56 46E0      		ldi r20,lo8(6)
 5734 1d58 50E0      		ldi r21,0
 5735 1d5a 60E0      		ldi r22,lo8(instrukcja_usun_smsa.3415)
 5736 1d5c 70E0      		ldi r23,hi8(instrukcja_usun_smsa.3415)
 5737 1d5e 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 5738 1d60 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 5739 1d62 0E94 0000 		call memcpy_P
 5740               	.LVL475:
 5741               	.LBB583:
 5742               	.LBB582:
 5743               		.loc 6 527 0 discriminator 2
 5744 1d66 4AE0      		ldi r20,lo8(10)
 5745 1d68 60E0      		ldi r22,lo8(wysylany_blok_SIM900+8)
 5746 1d6a 70E0      		ldi r23,hi8(wysylany_blok_SIM900+8)
 5747               	.LVL476:
 5748 1d6c C701      		movw r24,r14
 5749 1d6e 8D5B      		subi r24,-67
 5750 1d70 9109      		sbc r25,__zero_reg__
 5751               	.LVL477:
 5752 1d72 00C0      		rjmp .L657
 5753               	.LVL478:
 5754               	.L512:
 5755               	.LBE582:
 5756               	.LBE583:
 5757               	.LBE591:
 5758               	.LBB592:
 989:main_sim900.h ****     zapal_diode_led(10);
 5759               		.loc 2 989 0
 5760 1d74 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5761 1d78 8111      		cpse r24,__zero_reg__
 5762 1d7a 00C0      		rjmp .L548
 989:main_sim900.h ****     zapal_diode_led(10);
 5763               		.loc 2 989 0 is_stmt 0 discriminator 2
 5764 1d7c 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5765 1d80 8111      		cpse r24,__zero_reg__
 5766 1d82 00C0      		rjmp .L548
 989:main_sim900.h ****     zapal_diode_led(10);
 5767               		.loc 2 989 0 discriminator 4
 5768 1d84 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5769 1d88 8111      		cpse r24,__zero_reg__
 5770 1d8a 00C0      		rjmp .L548
 989:main_sim900.h ****     zapal_diode_led(10);
 5771               		.loc 2 989 0 discriminator 6
 5772 1d8c F99B      		sbis 0x1f,1
 5773 1d8e 00C0      		rjmp .L549
 5774               	.L548:
 989:main_sim900.h ****     zapal_diode_led(10);
 5775               		.loc 2 989 0 discriminator 7
 5776 1d90 88E9      		ldi r24,lo8(-104)
 5777 1d92 00C0      		rjmp .L650
 5778               	.L549:
 990:main_sim900.h **** 
 5779               		.loc 2 990 0 is_stmt 1
 5780 1d94 8BE0      		ldi r24,lo8(11)
 5781 1d96 8093 0000 		sts licznik_100ms_dioda_led,r24
 992:main_sim900.h ****         sprawdz_przychodzaca_rozmowe(); // Returns TRUE if number authorized
 5782               		.loc 2 992 0
 5783 1d9a 0E94 0000 		call sprawdz_przychodzaca_rozmowe
 5784               	.LVL479:
 995:main_sim900.h ****       if (tryb_clip) {
 5785               		.loc 2 995 0
 5786 1d9e 8823      		tst r24
 5787 1da0 01F0      		breq .L550
 996:main_sim900.h ****         // Tryb CLIP: wlacz wyjscie i ODRZUC polaczenie
 5788               		.loc 2 996 0
 5789 1da2 8091 0000 		lds r24,tryb_clip
 5790               	.LVL480:
 5791 1da6 8823      		tst r24
 5792 1da8 01F0      		breq .L551
 998:main_sim900.h ****           ustaw_wyjscie_clip();
 5793               		.loc 2 998 0
 5794 1daa 80E0      		ldi r24,lo8(__c.3419)
 5795 1dac 90E0      		ldi r25,hi8(__c.3419)
 5796 1dae 0E94 0000 		call polozenie_polecenia_SIM900
 5797               	.LVL481:
 5798 1db2 892B      		or r24,r25
 5799 1db4 01F4      		brne .L550
 999:main_sim900.h ****         }
 5800               		.loc 2 999 0
 5801 1db6 0E94 0000 		call ustaw_wyjscie_clip
 5802               	.LVL482:
 5803               	.L550:
1001:main_sim900.h ****       } else {
 5804               		.loc 2 1001 0
 5805 1dba 87E9      		ldi r24,lo8(-105)
 5806               	.L649:
1004:main_sim900.h ****       }
 5807               		.loc 2 1004 0
 5808 1dbc 0E94 0000 		call dodaj_komende
 5809               	.LVL483:
1010:main_sim900.h ****     break;
 5810               		.loc 2 1010 0
 5811 1dc0 8FEF      		ldi r24,lo8(-1)
 5812 1dc2 8093 0000 		sts blokada_clip,r24
1011:main_sim900.h ****   }
 5813               		.loc 2 1011 0
 5814 1dc6 00C0      		rjmp .L487
 5815               	.L551:
1004:main_sim900.h ****       }
 5816               		.loc 2 1004 0
 5817 1dc8 86E9      		ldi r24,lo8(-106)
 5818 1dca 00C0      		rjmp .L649
 5819               	.L506:
 5820               	.LBE592:
 5821               	.LBB593:
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5822               		.loc 2 1014 0
 5823 1dcc 8091 0000 		lds r24,flaga_wysylanie_smsa
 5824 1dd0 8111      		cpse r24,__zero_reg__
 5825 1dd2 00C0      		rjmp .L553
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5826               		.loc 2 1014 0 is_stmt 0 discriminator 2
 5827 1dd4 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5828 1dd8 8111      		cpse r24,__zero_reg__
 5829 1dda 00C0      		rjmp .L553
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5830               		.loc 2 1014 0 discriminator 4
 5831 1ddc 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 5832 1de0 8111      		cpse r24,__zero_reg__
 5833 1de2 00C0      		rjmp .L553
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5834               		.loc 2 1014 0 discriminator 6
 5835 1de4 8091 0000 		lds r24,czekanie_na_odebranie_zachety
 5836 1de8 8111      		cpse r24,__zero_reg__
 5837 1dea 00C0      		rjmp .L553
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5838               		.loc 2 1014 0 discriminator 10
 5839 1dec 8091 C100 		lds r24,193
 5840 1df0 86FD      		sbrc r24,6
 5841 1df2 00C0      		rjmp .L553
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5842               		.loc 2 1014 0 discriminator 12
 5843 1df4 8091 0000 		lds r24,podlaczony_modul_gsm_SIM900
 5844 1df8 8823      		tst r24
 5845 1dfa 01F0      		breq .L553
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5846               		.loc 2 1014 0 discriminator 14
 5847 1dfc 8091 0000 		lds r24,komenda_SIM900
 5848 1e00 8823      		tst r24
 5849 1e02 01F0      		breq .L554
 5850               	.L553:
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5851               		.loc 2 1014 0 discriminator 15
 5852 1e04 87E9      		ldi r24,lo8(-105)
 5853 1e06 00C0      		rjmp .L650
 5854               	.L554:
1019:main_sim900.h ****     static const char instrukcja_odrzuc_rozmowe[] PROGMEM = "h";
 5855               		.loc 2 1019 0 is_stmt 1
 5856 1e08 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5857 1e0c 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5858 1e10 87E9      		ldi r24,lo8(-105)
 5859 1e12 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1021:main_sim900.h ****     break;
 5860               		.loc 2 1021 0
 5861 1e16 80E0      		ldi r24,lo8(instrukcja_odrzuc_rozmowe.3422)
 5862 1e18 90E0      		ldi r25,hi8(instrukcja_odrzuc_rozmowe.3422)
 5863               	.L653:
 5864               	.LBE593:
 5865               	.LBB594:
1196:main_sim900.h ****     break;
 5866               		.loc 2 1196 0 discriminator 2
 5867 1e1a 0E94 0000 		call wyslij_polecenie_ROM_SIM900
 5868               	.LVL484:
 5869 1e1e 00C0      		rjmp .L609
 5870               	.L509:
 5871               	.LBE594:
 5872               	.LBB595:
1025:main_sim900.h ****     static const char instrukcja_odbierz_rozmowe[] PROGMEM = "a";
 5873               		.loc 2 1025 0
 5874 1e20 86E9      		ldi r24,lo8(-106)
 5875 1e22 0023      		tst r16
 5876 1e24 01F4      		brne .+2
 5877 1e26 00C0      		rjmp .L650
1025:main_sim900.h ****     static const char instrukcja_odbierz_rozmowe[] PROGMEM = "a";
 5878               		.loc 2 1025 0 is_stmt 0 discriminator 2
 5879 1e28 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5880 1e2c 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5881 1e30 86E9      		ldi r24,lo8(-106)
 5882 1e32 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1027:main_sim900.h ****     POMOC_DODAJ2('#', 'p');
 5883               		.loc 2 1027 0 is_stmt 1 discriminator 2
 5884 1e36 80E0      		ldi r24,lo8(instrukcja_odbierz_rozmowe.3424)
 5885 1e38 90E0      		ldi r25,hi8(instrukcja_odbierz_rozmowe.3424)
 5886 1e3a 00C0      		rjmp .L653
 5887               	.L517:
 5888               	.LBE595:
 5889               	.LBB596:
1033:main_sim900.h ****     if (!CZY_MOZNA_WYSYLAC_DANE_SIM900() || !czy_jest_bezczynny_SIM900() ||
 5890               		.loc 2 1033 0
 5891 1e3c 8091 0000 		lds r24,opoznienie_SIM900_100MS
 5892 1e40 8823      		tst r24
 5893 1e42 01F0      		breq .L556
 5894               	.L557:
1033:main_sim900.h ****     if (!CZY_MOZNA_WYSYLAC_DANE_SIM900() || !czy_jest_bezczynny_SIM900() ||
 5895               		.loc 2 1033 0 is_stmt 0 discriminator 1
 5896 1e44 85EA      		ldi r24,lo8(-91)
 5897 1e46 00C0      		rjmp .L650
 5898               	.L556:
1034:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 5899               		.loc 2 1034 0 is_stmt 1
 5900 1e48 8091 C100 		lds r24,193
 5901 1e4c 86FD      		sbrc r24,6
 5902 1e4e 00C0      		rjmp .L557
1034:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 5903               		.loc 2 1034 0 is_stmt 0 discriminator 1
 5904 1e50 8091 0000 		lds r24,podlaczony_modul_gsm_SIM900
 5905 1e54 8823      		tst r24
 5906 1e56 01F0      		breq .L557
1034:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 5907               		.loc 2 1034 0 discriminator 2
 5908 1e58 8091 0000 		lds r24,komenda_SIM900
 5909 1e5c 8111      		cpse r24,__zero_reg__
 5910 1e5e 00C0      		rjmp .L557
1034:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 5911               		.loc 2 1034 0 discriminator 3
 5912 1e60 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 5913 1e64 8111      		cpse r24,__zero_reg__
 5914 1e66 00C0      		rjmp .L557
1039:main_sim900.h ****     static const char instrukcja_vts[] PROGMEM = "+vts=1";
 5915               		.loc 2 1039 0 is_stmt 1
 5916 1e68 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5917 1e6c 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5918 1e70 85EA      		ldi r24,lo8(-91)
 5919 1e72 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1041:main_sim900.h ****     POMOC_DODAJ2('#', 'V');
 5920               		.loc 2 1041 0
 5921 1e76 80E0      		ldi r24,lo8(instrukcja_vts.3426)
 5922 1e78 90E0      		ldi r25,hi8(instrukcja_vts.3426)
 5923 1e7a 00C0      		rjmp .L653
 5924               	.L559:
 5925               	.LBE596:
 5926               	.LBB597:
1047:main_sim900.h ****       break;
 5927               		.loc 2 1047 0
 5928 1e7c 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5929 1e80 8111      		cpse r24,__zero_reg__
 5930 1e82 00C0      		rjmp .L609
1049:main_sim900.h ****     zapal_diode_led(20);
 5931               		.loc 2 1049 0
 5932 1e84 0023      		tst r16
 5933 1e86 01F4      		brne .+2
 5934 1e88 00C0      		rjmp .L558
1049:main_sim900.h ****     zapal_diode_led(20);
 5935               		.loc 2 1049 0 is_stmt 0 discriminator 2
 5936 1e8a 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5937 1e8e 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5938 1e92 86ED      		ldi r24,lo8(-42)
 5939 1e94 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1050:main_sim900.h ****     wysylane_dane_RAM_SIM900[0] = 'd';
 5940               		.loc 2 1050 0 is_stmt 1 discriminator 2
 5941 1e98 85E1      		ldi r24,lo8(21)
 5942 1e9a 8093 0000 		sts licznik_100ms_dioda_led,r24
1051:main_sim900.h ****     // static const char doladowanie[] PROGMEM = "*100*59484869838559#";
 5943               		.loc 2 1051 0 discriminator 2
 5944 1e9e 84E6      		ldi r24,lo8(100)
 5945 1ea0 8093 0000 		sts wysylany_blok_SIM900+2,r24
1054:main_sim900.h ****     uchar l = strlen(numer_telefonu_do_ktorego_dzwonic) + 1;
 5946               		.loc 2 1054 0 discriminator 2
 5947 1ea4 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 5948 1ea6 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 5949 1ea8 80E0      		ldi r24,lo8(wysylany_blok_SIM900+3)
 5950 1eaa 90E0      		ldi r25,hi8(wysylany_blok_SIM900+3)
 5951 1eac 0E94 0000 		call strcpy
 5952               	.LVL485:
1055:main_sim900.h ****     wysylane_dane_RAM_SIM900[l] = ';';
 5953               		.loc 2 1055 0 discriminator 2
 5954 1eb0 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 5955 1eb2 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 5956 1eb4 FC01      		movw r30,r24
 5957               		0:
 5958 1eb6 0190      		ld __tmp_reg__,Z+
 5959 1eb8 0020      		tst __tmp_reg__
 5960 1eba 01F4      		brne 0b
 5961 1ebc CF01      		movw r24,r30
 5962 1ebe 8050      		subi r24,lo8(numer_telefonu_do_ktorego_dzwonic+1)
 5963 1ec0 9040      		sbci r25,hi8(numer_telefonu_do_ktorego_dzwonic+1)
 5964               	.LVL486:
 5965 1ec2 8F5F      		subi r24,lo8(-(1))
 5966               	.LVL487:
1056:main_sim900.h ****     wysylane_dane_RAM_SIM900[l + 1] = '\0';
 5967               		.loc 2 1056 0 discriminator 2
 5968 1ec4 90E0      		ldi r25,0
 5969 1ec6 FC01      		movw r30,r24
 5970               	.LVL488:
 5971 1ec8 E050      		subi r30,lo8(-(wysylany_blok_SIM900+2))
 5972 1eca F040      		sbci r31,hi8(-(wysylany_blok_SIM900+2))
 5973 1ecc 2BE3      		ldi r18,lo8(59)
 5974 1ece 2083      		st Z,r18
1057:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 5975               		.loc 2 1057 0 discriminator 2
 5976 1ed0 8050      		subi r24,lo8(-(wysylany_blok_SIM900+3))
 5977 1ed2 9040      		sbci r25,hi8(-(wysylany_blok_SIM900+3))
 5978 1ed4 FC01      		movw r30,r24
 5979 1ed6 1082      		st Z,__zero_reg__
1058:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 300;
 5980               		.loc 2 1058 0 discriminator 2
 5981 1ed8 0E94 0000 		call wyslij_polecenie_RAM_SIM900
 5982               	.LVL489:
1059:main_sim900.h ****     POMOC_DODAJ2('#', 'h');
 5983               		.loc 2 1059 0 discriminator 2
 5984 1edc 8CE2      		ldi r24,lo8(44)
 5985 1ede 91E0      		ldi r25,lo8(1)
 5986 1ee0 9093 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,r25
 5987 1ee4 8093 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,r24
 5988               	.LVL490:
 5989 1ee8 00C0      		rjmp .L609
 5990               	.LVL491:
 5991               	.L561:
 5992               	.LBE597:
 5993               	.LBB598:
1077:main_sim900.h ****     static const char instrukcja_poziom_sieci[] PROGMEM = "+csq";
 5994               		.loc 2 1077 0
 5995 1eea 8BE9      		ldi r24,lo8(-101)
 5996 1eec 0023      		tst r16
 5997 1eee 01F4      		brne .+2
 5998 1ef0 00C0      		rjmp .L650
1077:main_sim900.h ****     static const char instrukcja_poziom_sieci[] PROGMEM = "+csq";
 5999               		.loc 2 1077 0 is_stmt 0 discriminator 2
 6000 1ef2 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6001 1ef6 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6002 1efa 8BE9      		ldi r24,lo8(-101)
 6003 1efc 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1079:main_sim900.h ****     break;
 6004               		.loc 2 1079 0 is_stmt 1 discriminator 2
 6005 1f00 80E0      		ldi r24,lo8(instrukcja_poziom_sieci.3430)
 6006 1f02 90E0      		ldi r25,hi8(instrukcja_poziom_sieci.3430)
 6007 1f04 00C0      		rjmp .L653
 6008               	.L493:
 6009               	.LBE598:
 6010               	.LBB599:
1084:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6011               		.loc 2 1084 0
 6012 1f06 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 6013 1f0a 9111      		cpse r25,__zero_reg__
 6014 1f0c 00C0      		rjmp .L609
1084:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6015               		.loc 2 1084 0 is_stmt 0 discriminator 1
 6016 1f0e 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 6017 1f12 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 6018 1f16 232B      		or r18,r19
 6019 1f18 01F0      		breq .+2
 6020 1f1a 00C0      		rjmp .L609
1084:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6021               		.loc 2 1084 0 discriminator 2
 6022 1f1c 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6023 1f20 9111      		cpse r25,__zero_reg__
 6024 1f22 00C0      		rjmp .L609
1085:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 6025               		.loc 2 1085 0 is_stmt 1
 6026 1f24 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 6027 1f28 9111      		cpse r25,__zero_reg__
 6028 1f2a 00C0      		rjmp .L609
1086:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 6029               		.loc 2 1086 0
 6030 1f2c 8111      		cpse r24,__zero_reg__
 6031 1f2e 00C0      		rjmp .L609
1086:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 6032               		.loc 2 1086 0 is_stmt 0 discriminator 1
 6033 1f30 8091 0000 		lds r24,wysylanie_smsa_clipa
 6034 1f34 8111      		cpse r24,__zero_reg__
 6035 1f36 00C0      		rjmp .L609
1090:main_sim900.h ****     static const char instrukcja_creg[] PROGMEM = "+creg?";
 6036               		.loc 2 1090 0 is_stmt 1
 6037 1f38 8DE9      		ldi r24,lo8(-99)
 6038 1f3a 0023      		tst r16
 6039 1f3c 01F4      		brne .+2
 6040 1f3e 00C0      		rjmp .L650
1090:main_sim900.h ****     static const char instrukcja_creg[] PROGMEM = "+creg?";
 6041               		.loc 2 1090 0 is_stmt 0 discriminator 2
 6042 1f40 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6043 1f44 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6044 1f48 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
1092:main_sim900.h ****     break;
 6045               		.loc 2 1092 0 is_stmt 1 discriminator 2
 6046 1f4c 80E0      		ldi r24,lo8(instrukcja_creg.3432)
 6047 1f4e 90E0      		ldi r25,hi8(instrukcja_creg.3432)
 6048 1f50 00C0      		rjmp .L653
 6049               	.L511:
 6050               	.LBE599:
 6051               	.LBB600:
1096:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6052               		.loc 2 1096 0
 6053 1f52 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 6054 1f56 9111      		cpse r25,__zero_reg__
 6055 1f58 00C0      		rjmp .L565
1096:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6056               		.loc 2 1096 0 is_stmt 0 discriminator 1
 6057 1f5a 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 6058 1f5e 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 6059 1f62 232B      		or r18,r19
 6060 1f64 01F4      		brne .L565
1096:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6061               		.loc 2 1096 0 discriminator 2
 6062 1f66 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6063 1f6a 9111      		cpse r25,__zero_reg__
 6064 1f6c 00C0      		rjmp .L565
1097:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 6065               		.loc 2 1097 0 is_stmt 1
 6066 1f6e 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 6067 1f72 9111      		cpse r25,__zero_reg__
 6068 1f74 00C0      		rjmp .L565
1098:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 6069               		.loc 2 1098 0
 6070 1f76 8111      		cpse r24,__zero_reg__
 6071 1f78 00C0      		rjmp .L565
1098:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 6072               		.loc 2 1098 0 is_stmt 0 discriminator 1
 6073 1f7a 8091 0000 		lds r24,wysylanie_smsa_clipa
 6074 1f7e 8823      		tst r24
 6075 1f80 01F0      		breq .L566
 6076               	.L565:
1100:main_sim900.h ****       break;
 6077               		.loc 2 1100 0 is_stmt 1
 6078 1f82 1092 0000 		sts licznik_blad_stanu_karty_SIM,__zero_reg__
 6079 1f86 00C0      		rjmp .L609
 6080               	.L566:
1103:main_sim900.h ****     static const char instrukcja_odczyt_ksiazki[] PROGMEM = "+cpbr=26";
 6081               		.loc 2 1103 0
 6082 1f88 89E9      		ldi r24,lo8(-103)
 6083 1f8a 0023      		tst r16
 6084 1f8c 01F4      		brne .+2
 6085 1f8e 00C0      		rjmp .L650
1103:main_sim900.h ****     static const char instrukcja_odczyt_ksiazki[] PROGMEM = "+cpbr=26";
 6086               		.loc 2 1103 0 is_stmt 0 discriminator 2
 6087 1f90 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6088 1f94 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6089 1f98 89E9      		ldi r24,lo8(-103)
 6090 1f9a 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1105:main_sim900.h ****     break;
 6091               		.loc 2 1105 0 is_stmt 1 discriminator 2
 6092 1f9e 80E0      		ldi r24,lo8(instrukcja_odczyt_ksiazki.3434)
 6093 1fa0 90E0      		ldi r25,hi8(instrukcja_odczyt_ksiazki.3434)
 6094 1fa2 00C0      		rjmp .L653
 6095               	.L513:
 6096               	.LBE600:
 6097               	.LBB601:
1109:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6098               		.loc 2 1109 0
 6099 1fa4 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 6100 1fa8 9111      		cpse r25,__zero_reg__
 6101 1faa 00C0      		rjmp .L568
1109:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6102               		.loc 2 1109 0 is_stmt 0 discriminator 1
 6103 1fac 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 6104 1fb0 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 6105 1fb4 232B      		or r18,r19
 6106 1fb6 01F4      		brne .L568
1109:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6107               		.loc 2 1109 0 discriminator 2
 6108 1fb8 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6109 1fbc 9111      		cpse r25,__zero_reg__
 6110 1fbe 00C0      		rjmp .L568
1110:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 6111               		.loc 2 1110 0 is_stmt 1
 6112 1fc0 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 6113 1fc4 9111      		cpse r25,__zero_reg__
 6114 1fc6 00C0      		rjmp .L568
1111:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 6115               		.loc 2 1111 0
 6116 1fc8 8111      		cpse r24,__zero_reg__
 6117 1fca 00C0      		rjmp .L568
1111:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 6118               		.loc 2 1111 0 is_stmt 0 discriminator 1
 6119 1fcc 8091 0000 		lds r24,wysylanie_smsa_clipa
 6120 1fd0 8823      		tst r24
 6121 1fd2 01F0      		breq .L569
 6122               	.L568:
1113:main_sim900.h ****       break;
 6123               		.loc 2 1113 0 is_stmt 1
 6124 1fd4 1092 0000 		sts licznik_blad_zalogowania_u_operatora,__zero_reg__
 6125 1fd8 00C0      		rjmp .L609
 6126               	.L569:
1116:main_sim900.h ****     static const char instrukcja_sprawdz_operatora[] PROGMEM = "+cops?";
 6127               		.loc 2 1116 0
 6128 1fda 8AE9      		ldi r24,lo8(-102)
 6129 1fdc 0023      		tst r16
 6130 1fde 01F4      		brne .+2
 6131 1fe0 00C0      		rjmp .L650
1116:main_sim900.h ****     static const char instrukcja_sprawdz_operatora[] PROGMEM = "+cops?";
 6132               		.loc 2 1116 0 is_stmt 0 discriminator 2
 6133 1fe2 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6134 1fe6 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6135 1fea 8AE9      		ldi r24,lo8(-102)
 6136 1fec 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1118:main_sim900.h ****     break;
 6137               		.loc 2 1118 0 is_stmt 1 discriminator 2
 6138 1ff0 80E0      		ldi r24,lo8(instrukcja_sprawdz_operatora.3436)
 6139 1ff2 90E0      		ldi r25,hi8(instrukcja_sprawdz_operatora.3436)
 6140 1ff4 00C0      		rjmp .L653
 6141               	.L519:
 6142               	.LBE601:
 6143               	.LBB602:
1122:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6144               		.loc 2 1122 0
 6145 1ff6 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 6146 1ffa 9111      		cpse r25,__zero_reg__
 6147 1ffc 00C0      		rjmp .L609
1122:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6148               		.loc 2 1122 0 is_stmt 0 discriminator 1
 6149 1ffe 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 6150 2002 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 6151 2006 232B      		or r18,r19
 6152 2008 01F0      		breq .+2
 6153 200a 00C0      		rjmp .L609
1122:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6154               		.loc 2 1122 0 discriminator 2
 6155 200c 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6156 2010 9111      		cpse r25,__zero_reg__
 6157 2012 00C0      		rjmp .L609
1123:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 6158               		.loc 2 1123 0 is_stmt 1
 6159 2014 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 6160 2018 9111      		cpse r25,__zero_reg__
 6161 201a 00C0      		rjmp .L609
1124:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK)
 6162               		.loc 2 1124 0
 6163 201c 8111      		cpse r24,__zero_reg__
 6164 201e 00C0      		rjmp .L609
1124:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK)
 6165               		.loc 2 1124 0 is_stmt 0 discriminator 1
 6166 2020 8091 0000 		lds r24,wysylanie_smsa_clipa
 6167 2024 8111      		cpse r24,__zero_reg__
 6168 2026 00C0      		rjmp .L609
1127:main_sim900.h ****     static const char instrukcja_cclk[] PROGMEM = "+cclk?";
 6169               		.loc 2 1127 0 is_stmt 1
 6170 2028 8EE9      		ldi r24,lo8(-98)
 6171 202a 0023      		tst r16
 6172 202c 01F4      		brne .+2
 6173 202e 00C0      		rjmp .L650
1127:main_sim900.h ****     static const char instrukcja_cclk[] PROGMEM = "+cclk?";
 6174               		.loc 2 1127 0 is_stmt 0 discriminator 2
 6175 2030 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6176 2034 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6177 2038 8EE9      		ldi r24,lo8(-98)
 6178 203a 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1129:main_sim900.h ****     break;
 6179               		.loc 2 1129 0 is_stmt 1 discriminator 2
 6180 203e 80E0      		ldi r24,lo8(instrukcja_cclk.3438)
 6181 2040 90E0      		ldi r25,hi8(instrukcja_cclk.3438)
 6182 2042 00C0      		rjmp .L653
 6183               	.L508:
 6184               	.LBE602:
 6185               	.LBB603:
1133:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM = "+cdscb";
 6186               		.loc 2 1133 0
 6187 2044 85E9      		ldi r24,lo8(-107)
 6188 2046 0023      		tst r16
 6189 2048 01F4      		brne .+2
 6190 204a 00C0      		rjmp .L650
1133:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM = "+cdscb";
 6191               		.loc 2 1133 0 is_stmt 0 discriminator 2
 6192 204c 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6193 2050 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6194 2054 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
1135:main_sim900.h ****     break;
 6195               		.loc 2 1135 0 is_stmt 1 discriminator 2
 6196 2058 80E0      		ldi r24,lo8(instrukcja_ustawienie_pamieci.3440)
 6197 205a 90E0      		ldi r25,hi8(instrukcja_ustawienie_pamieci.3440)
 6198 205c 00C0      		rjmp .L653
 6199               	.L502:
 6200               	.LBE603:
 6201               	.LBB604:
1139:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM =
 6202               		.loc 2 1139 0
 6203 205e 8FE8      		ldi r24,lo8(-113)
 6204 2060 0023      		tst r16
 6205 2062 01F4      		brne .+2
 6206 2064 00C0      		rjmp .L650
1139:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM =
 6207               		.loc 2 1139 0 is_stmt 0 discriminator 2
 6208 2066 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6209 206a 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6210 206e 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
1142:main_sim900.h ****         KOMENDA_KOLEJKI_WSTAWIENIE_MORING_GDY_DZWONI;
 6211               		.loc 2 1142 0 is_stmt 1 discriminator 2
 6212 2072 81EA      		ldi r24,lo8(-95)
 6213 2074 8093 0000 		sts nastepne_wysylane_polecenie_SIM900,r24
1144:main_sim900.h ****     break;
 6214               		.loc 2 1144 0 discriminator 2
 6215 2078 80E0      		ldi r24,lo8(instrukcja_ustawienie_pamieci.3442)
 6216 207a 90E0      		ldi r25,hi8(instrukcja_ustawienie_pamieci.3442)
 6217 207c 00C0      		rjmp .L653
 6218               	.L499:
 6219               	.LBE604:
1148:main_sim900.h ****     opoznienie_zatrzymaj_odpytywanie_urzadzenia = 20;
 6220               		.loc 2 1148 0
 6221 207e 8CE8      		ldi r24,lo8(-116)
 6222 2080 0E94 0000 		call dodaj_komende
 6223               	.LVL492:
1149:main_sim900.h ****     ustaw_odbior_SIM900();
 6224               		.loc 2 1149 0
 6225 2084 84E1      		ldi r24,lo8(20)
 6226 2086 8093 0000 		sts opoznienie_zatrzymaj_odpytywanie_urzadzenia,r24
1150:main_sim900.h ****     break;
 6227               		.loc 2 1150 0
 6228 208a 1092 0000 		sts liczba_odebranych_znakow_SIM900+1,__zero_reg__
 6229 208e 1092 0000 		sts liczba_odebranych_znakow_SIM900,__zero_reg__
 6230 2092 1092 0000 		sts licznik_opoznienie_oczekiwania_na_bajt_SIM900,__zero_reg__
 6231 2096 80B7      		in r24,0x30
 6232 2098 8260      		ori r24,lo8(2)
 6233 209a 80BF      		out 0x30,r24
 6234               	/* #APP */
 6235               	 ;  1150 "main_sim900.h" 1
 6236 209c F894      		cli
 6237               	 ;  0 "" 2
 6238               	/* #NOAPP */
 6239 209e 8091 C100 		lds r24,193
 6240 20a2 8068      		ori r24,lo8(-128)
 6241 20a4 8093 C100 		sts 193,r24
 6242               	/* #APP */
 6243               	 ;  1150 "main_sim900.h" 1
 6244 20a8 7894      		sei
 6245               	 ;  0 "" 2
 6246               	 ;  1150 "main_sim900.h" 1
 6247 20aa 0000      		nop
 6248               	 ;  0 "" 2
 6249               	/* #NOAPP */
 6250 20ac 4598      		cbi 0x8,5
 6251 20ae 00C0      		rjmp .L609
 6252               	.L500:
 6253               	.LBB605:
1157:main_sim900.h ****       break;
 6254               		.loc 2 1157 0
 6255 20b0 8091 0000 		lds r24,max_oczekiwanie_na_odpowiedz_at
 6256 20b4 8111      		cpse r24,__zero_reg__
 6257 20b6 00C0      		rjmp .L609
1159:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
 6258               		.loc 2 1159 0
 6259 20b8 8091 0000 		lds r24,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6260 20bc 8823      		tst r24
 6261 20be 01F0      		breq .L574
 6262               	.L575:
1160:main_sim900.h ****       break;
 6263               		.loc 2 1160 0
 6264 20c0 8CE8      		ldi r24,lo8(-116)
 6265 20c2 00C0      		rjmp .L650
 6266               	.L574:
1163:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
 6267               		.loc 2 1163 0
 6268 20c4 8091 C100 		lds r24,193
 6269 20c8 86FD      		sbrc r24,6
 6270 20ca 00C0      		rjmp .L575
1167:main_sim900.h ****     wysylane_polecenie_SIM900 = wykonywana_komenda;
 6271               		.loc 2 1167 0
 6272 20cc 1092 0000 		sts liczba_odebranych_znakow_SIM900+1,__zero_reg__
 6273 20d0 1092 0000 		sts liczba_odebranych_znakow_SIM900,__zero_reg__
 6274 20d4 1092 0000 		sts licznik_opoznienie_oczekiwania_na_bajt_SIM900,__zero_reg__
 6275 20d8 80B7      		in r24,0x30
 6276 20da 8260      		ori r24,lo8(2)
 6277 20dc 80BF      		out 0x30,r24
 6278               	/* #APP */
 6279               	 ;  1167 "main_sim900.h" 1
 6280 20de F894      		cli
 6281               	 ;  0 "" 2
 6282               	/* #NOAPP */
 6283 20e0 8091 C100 		lds r24,193
 6284 20e4 8068      		ori r24,lo8(-128)
 6285 20e6 8093 C100 		sts 193,r24
 6286               	/* #APP */
 6287               	 ;  1167 "main_sim900.h" 1
 6288 20ea 7894      		sei
 6289               	 ;  0 "" 2
 6290               	 ;  1167 "main_sim900.h" 1
 6291 20ec 0000      		nop
 6292               	 ;  0 "" 2
 6293               	/* #NOAPP */
 6294 20ee 4598      		cbi 0x8,5
1168:main_sim900.h ****     max_oczekiwanie_na_odpowiedz_at = 20;
 6295               		.loc 2 1168 0
 6296 20f0 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6297 20f4 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6298 20f8 8CE8      		ldi r24,lo8(-116)
 6299 20fa 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1169:main_sim900.h ****     static const char instrukcja_at[] PROGMEM = "+ifc=2,2";
 6300               		.loc 2 1169 0
 6301 20fe 84E1      		ldi r24,lo8(20)
 6302 2100 8093 0000 		sts max_oczekiwanie_na_odpowiedz_at,r24
1171:main_sim900.h ****     break;
 6303               		.loc 2 1171 0
 6304 2104 80E0      		ldi r24,lo8(instrukcja_at.3445)
 6305 2106 90E0      		ldi r25,hi8(instrukcja_at.3445)
 6306 2108 00C0      		rjmp .L653
 6307               	.L497:
 6308               	.LBE605:
1175:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_PIN);
 6309               		.loc 2 1175 0
 6310 210a 8FEF      		ldi r24,lo8(-1)
 6311 210c 8093 0000 		sts podlaczony_modul_gsm_SIM900,r24
1176:main_sim900.h ****     opoznienie_SIM900_100MS = 40;
 6312               		.loc 2 1176 0
 6313 2110 8FE9      		ldi r24,lo8(-97)
 6314 2112 0E94 0000 		call dodaj_komende
 6315               	.LVL493:
1177:main_sim900.h ****     break;
 6316               		.loc 2 1177 0
 6317 2116 88E2      		ldi r24,lo8(40)
 6318 2118 8093 0000 		sts opoznienie_SIM900_100MS,r24
 6319 211c 00C0      		rjmp .L609
 6320               	.L503:
 6321               	.LBB606:
1181:main_sim900.h ****     static const char instrukcja_podaj_pin[] PROGMEM = "+cpin=\"1976\"";
 6322               		.loc 2 1181 0
 6323 211e 8EE8      		ldi r24,lo8(-114)
 6324 2120 0023      		tst r16
 6325 2122 01F4      		brne .+2
 6326 2124 00C0      		rjmp .L650
1181:main_sim900.h ****     static const char instrukcja_podaj_pin[] PROGMEM = "+cpin=\"1976\"";
 6327               		.loc 2 1181 0 is_stmt 0 discriminator 2
 6328 2126 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6329 212a 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6330 212e 8EE8      		ldi r24,lo8(-114)
 6331 2130 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1183:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 6332               		.loc 2 1183 0 is_stmt 1 discriminator 2
 6333 2134 60E0      		ldi r22,lo8(instrukcja_podaj_pin.3448)
 6334 2136 70E0      		ldi r23,hi8(instrukcja_podaj_pin.3448)
 6335 2138 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 6336 213a 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 6337 213c 0E94 0000 		call strcpy_P
 6338               	.LVL494:
 6339 2140 00C0      		rjmp .L651
 6340               	.L495:
 6341               	.LBE606:
 6342               	.LBB607:
1189:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW);
 6343               		.loc 2 1189 0
 6344 2142 8091 0000 		lds r24,drugi_raz.3450
 6345 2146 8823      		tst r24
 6346 2148 01F0      		breq .L577
1190:main_sim900.h ****       break;
 6347               		.loc 2 1190 0
 6348 214a 80EA      		ldi r24,lo8(-96)
 6349 214c 00C0      		rjmp .L650
 6350               	.L577:
1193:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6351               		.loc 2 1193 0
 6352 214e 8FEF      		ldi r24,lo8(-1)
 6353 2150 8093 0000 		sts drugi_raz.3450,r24
1194:main_sim900.h ****     static const char instrukcja_usun_wszystkie_smsy[] PROGMEM = "+cmgda=6";
 6354               		.loc 2 1194 0
 6355 2154 82E9      		ldi r24,lo8(-110)
 6356 2156 0023      		tst r16
 6357 2158 01F4      		brne .+2
 6358 215a 00C0      		rjmp .L650
1194:main_sim900.h ****     static const char instrukcja_usun_wszystkie_smsy[] PROGMEM = "+cmgda=6";
 6359               		.loc 2 1194 0 is_stmt 0 discriminator 2
 6360 215c 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6361 2160 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6362 2164 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
1196:main_sim900.h ****     break;
 6363               		.loc 2 1196 0 is_stmt 1 discriminator 2
 6364 2168 80E0      		ldi r24,lo8(instrukcja_usun_wszystkie_smsy.3451)
 6365 216a 90E0      		ldi r25,hi8(instrukcja_usun_wszystkie_smsy.3451)
 6366 216c 00C0      		rjmp .L653
 6367               	.L501:
 6368               	.LBE607:
1200:main_sim900.h ****     if (komenda_SIM900 != KOMENDA_SIM900_WYSLANE_POLECENIE)
 6369               		.loc 2 1200 0
 6370 216e 0E94 0000 		call obsluga_komendy_SIM900
 6371               	.LVL495:
1201:main_sim900.h ****       max_oczekiwanie_na_odpowiedz = 20;
 6372               		.loc 2 1201 0
 6373 2172 8091 0000 		lds r24,komenda_SIM900
 6374 2176 8138      		cpi r24,lo8(-127)
 6375 2178 01F0      		breq .L579
1202:main_sim900.h ****     resetuj_komende_SIM900();
 6376               		.loc 2 1202 0
 6377 217a 84E1      		ldi r24,lo8(20)
 6378 217c 8093 0000 		sts max_oczekiwanie_na_odpowiedz,r24
 6379               	.L579:
1203:main_sim900.h ****     break;
 6380               		.loc 2 1203 0
 6381 2180 1092 0000 		sts komenda_SIM900,__zero_reg__
 6382 2184 00C0      		rjmp .L609
 6383               	.L581:
 6384               	.LBB608:
1208:main_sim900.h ****     static const char instrukcja[] PROGMEM =
 6385               		.loc 2 1208 0
 6386 2186 0023      		tst r16
 6387 2188 01F4      		brne .+2
 6388 218a 00C0      		rjmp .L580
1208:main_sim900.h ****     static const char instrukcja[] PROGMEM =
 6389               		.loc 2 1208 0 is_stmt 0 discriminator 2
 6390 218c 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6391 2190 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6392 2194 84E9      		ldi r24,lo8(-108)
 6393 2196 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1211:main_sim900.h ****     nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_ROZPOCZNIJ_PRACE;
 6394               		.loc 2 1211 0 is_stmt 1 discriminator 2
 6395 219a 60E0      		ldi r22,lo8(instrukcja.3454)
 6396 219c 70E0      		ldi r23,hi8(instrukcja.3454)
 6397 219e 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 6398 21a0 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 6399 21a2 0E94 0000 		call strcpy_P
 6400               	.LVL496:
1212:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 6401               		.loc 2 1212 0 discriminator 2
 6402 21a6 80E9      		ldi r24,lo8(-112)
 6403 21a8 8093 0000 		sts nastepne_wysylane_polecenie_SIM900,r24
 6404 21ac 00C0      		rjmp .L651
 6405               	.L504:
 6406               	.LVL497:
 6407               	.LBE608:
1218:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS);
 6408               		.loc 2 1218 0
 6409 21ae 8091 0000 		lds r24,podlaczona_karta_SIM_SIM900
 6410 21b2 8823      		tst r24
 6411 21b4 01F4      		brne .+2
 6412 21b6 00C0      		rjmp .L609
1219:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_MODUL_ZALOGOWANY);
 6413               		.loc 2 1219 0
 6414 21b8 85E9      		ldi r24,lo8(-107)
 6415 21ba 0E94 0000 		call dodaj_komende
 6416               	.LVL498:
1220:main_sim900.h ****     }
 6417               		.loc 2 1220 0
 6418 21be 81E9      		ldi r24,lo8(-111)
 6419 21c0 00C0      		rjmp .L650
 6420               	.LVL499:
 6421               	.L527:
1230:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6422               		.loc 2 1230 0
 6423 21c2 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 6424 21c6 8111      		cpse r24,__zero_reg__
 6425 21c8 00C0      		rjmp .L582
1230:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6426               		.loc 2 1230 0 is_stmt 0 discriminator 2
 6427 21ca 8091 0000 		lds r24,liczba_znakow_do_zapisu
 6428 21ce 8111      		cpse r24,__zero_reg__
 6429 21d0 00C0      		rjmp .L582
1230:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6430               		.loc 2 1230 0 discriminator 4
 6431 21d2 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 6432 21d6 8111      		cpse r24,__zero_reg__
 6433 21d8 00C0      		rjmp .L582
1230:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6434               		.loc 2 1230 0 discriminator 6
 6435 21da F99B      		sbis 0x1f,1
 6436 21dc 00C0      		rjmp .L583
 6437               	.L582:
1230:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6438               		.loc 2 1230 0 discriminator 7
 6439 21de 8EEF      		ldi r24,lo8(-2)
 6440 21e0 00C0      		rjmp .L650
 6441               	.L583:
1231:main_sim900.h ****     strcpy(wysylane_dane_RAM_SIM900, bufor_ustaw_czas);
 6442               		.loc 2 1231 0 is_stmt 1
 6443 21e2 0023      		tst r16
 6444 21e4 01F0      		breq .L582
1231:main_sim900.h ****     strcpy(wysylane_dane_RAM_SIM900, bufor_ustaw_czas);
 6445               		.loc 2 1231 0 is_stmt 0 discriminator 2
 6446 21e6 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6447 21ea 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6448 21ee 8EEF      		ldi r24,lo8(-2)
 6449 21f0 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1232:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 6450               		.loc 2 1232 0 is_stmt 1 discriminator 2
 6451 21f4 60E0      		ldi r22,lo8(bufor_ustaw_czas)
 6452 21f6 70E0      		ldi r23,hi8(bufor_ustaw_czas)
 6453 21f8 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 6454 21fa 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 6455 21fc 0E94 0000 		call strcpy
 6456               	.LVL500:
 6457 2200 00C0      		rjmp .L651
 6458               		.cfi_endproc
 6459               	.LFE54:
 6461               	.global	steruj_SIM900_100MS
 6463               	steruj_SIM900_100MS:
 6464               	.LFB55:
1282:main_sim900.h **** 
1283:main_sim900.h **** void steruj_SIM900_100MS(void) {
 6465               		.loc 2 1283 0
 6466               		.cfi_startproc
 6467               	/* prologue: function */
 6468               	/* frame size = 0 */
 6469               	/* stack size = 0 */
 6470               	.L__stack_usage = 0
1284:main_sim900.h ****   if (opoznienie_SIM900_100MS && --opoznienie_SIM900_100MS == 0)
 6471               		.loc 2 1284 0
 6472 2202 8091 0000 		lds r24,opoznienie_SIM900_100MS
 6473 2206 8823      		tst r24
 6474 2208 01F0      		breq .L660
 6475               		.loc 2 1284 0 is_stmt 0 discriminator 1
 6476 220a 8150      		subi r24,lo8(-(-1))
 6477 220c 8093 0000 		sts opoznienie_SIM900_100MS,r24
 6478 2210 8111      		cpse r24,__zero_reg__
 6479 2212 00C0      		rjmp .L660
1285:main_sim900.h ****     oproznij_bufor_SIM900_po_bledzie = FALSE;
 6480               		.loc 2 1285 0 is_stmt 1
 6481 2214 1092 0000 		sts oproznij_bufor_SIM900_po_bledzie,__zero_reg__
 6482               	.L660:
1286:main_sim900.h **** 
1287:main_sim900.h ****   if (opoznienie_wysylania_clipow_100MS)
 6483               		.loc 2 1287 0
 6484 2218 8091 0000 		lds r24,opoznienie_wysylania_clipow_100MS
 6485 221c 9091 0000 		lds r25,opoznienie_wysylania_clipow_100MS+1
 6486 2220 0097      		sbiw r24,0
 6487 2222 01F0      		breq .L662
1288:main_sim900.h ****     --opoznienie_wysylania_clipow_100MS;
 6488               		.loc 2 1288 0
 6489 2224 0197      		sbiw r24,1
 6490 2226 9093 0000 		sts opoznienie_wysylania_clipow_100MS+1,r25
 6491 222a 8093 0000 		sts opoznienie_wysylania_clipow_100MS,r24
 6492               	.L662:
1289:main_sim900.h **** 
1290:main_sim900.h ****   // Timeout rozmowy - automatyczne rozlaczenie po 30 sekundach
1291:main_sim900.h ****   if (licznik_timeout_rozmowy_100ms) {
 6493               		.loc 2 1291 0
 6494 222e 8091 0000 		lds r24,licznik_timeout_rozmowy_100ms
 6495 2232 9091 0000 		lds r25,licznik_timeout_rozmowy_100ms+1
 6496 2236 0097      		sbiw r24,0
 6497 2238 01F0      		breq .L664
1292:main_sim900.h ****     if (--licznik_timeout_rozmowy_100ms == 0 &&
 6498               		.loc 2 1292 0
 6499 223a 0197      		sbiw r24,1
 6500 223c 9093 0000 		sts licznik_timeout_rozmowy_100ms+1,r25
 6501 2240 8093 0000 		sts licznik_timeout_rozmowy_100ms,r24
 6502 2244 892B      		or r24,r25
 6503 2246 01F4      		brne .L664
 6504               		.loc 2 1292 0 is_stmt 0 discriminator 1
 6505 2248 8091 0000 		lds r24,trwa_rozmowa_przychodzaca_od_uzytkownika
 6506 224c 8823      		tst r24
 6507 224e 01F0      		breq .L664
1293:main_sim900.h ****         trwa_rozmowa_przychodzaca_od_uzytkownika) {
1294:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
 6508               		.loc 2 1294 0 is_stmt 1
 6509 2250 87E9      		ldi r24,lo8(-105)
 6510 2252 0E94 0000 		call dodaj_komende
 6511               	.LVL501:
 6512               	.L664:
1295:main_sim900.h ****       POMOC_DODAJ2('#', 'X'); // Timeout marker
1296:main_sim900.h ****     }
1297:main_sim900.h ****   }
1298:main_sim900.h **** 
1299:main_sim900.h ****   if (max_oczekiwanie_na_odpowiedz_at) {
 6513               		.loc 2 1299 0
 6514 2256 8091 0000 		lds r24,max_oczekiwanie_na_odpowiedz_at
 6515 225a 8823      		tst r24
 6516 225c 01F0      		breq .L667
1300:main_sim900.h ****     if (--max_oczekiwanie_na_odpowiedz_at == 0) {
 6517               		.loc 2 1300 0
 6518 225e 8150      		subi r24,lo8(-(-1))
 6519 2260 8093 0000 		sts max_oczekiwanie_na_odpowiedz_at,r24
 6520 2264 8111      		cpse r24,__zero_reg__
 6521 2266 00C0      		rjmp .L667
1301:main_sim900.h ****       wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 6522               		.loc 2 1301 0
 6523 2268 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6524 226c 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6525 2270 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
1302:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT);
 6526               		.loc 2 1302 0
 6527 2274 8CE8      		ldi r24,lo8(-116)
 6528 2276 0E94 0000 		call dodaj_komende
 6529               	.LVL502:
1303:main_sim900.h ****       sprawdzaj_wejscie_CTS_SIM900 = FALSE;
 6530               		.loc 2 1303 0
 6531 227a 1092 0000 		sts sprawdzaj_wejscie_CTS_SIM900,__zero_reg__
1304:main_sim900.h ****       zakoncz_wysylanie_SIM900();
 6532               		.loc 2 1304 0
 6533               	/* #APP */
 6534               	 ;  1304 "main_sim900.h" 1
 6535 227e F894      		cli
 6536               	 ;  0 "" 2
 6537               	/* #NOAPP */
 6538 2280 8091 C100 		lds r24,193
 6539 2284 8F7B      		andi r24,lo8(-65)
 6540 2286 8093 C100 		sts 193,r24
 6541               	/* #APP */
 6542               	 ;  1304 "main_sim900.h" 1
 6543 228a 7894      		sei
 6544               	 ;  0 "" 2
 6545               	 ;  1304 "main_sim900.h" 1
 6546 228c 0000      		nop
 6547               	 ;  0 "" 2
 6548               	/* #NOAPP */
 6549               	.L667:
1305:main_sim900.h ****     }
1306:main_sim900.h ****   }
1307:main_sim900.h **** 
1308:main_sim900.h ****   if (procedura_inicjalizacyjna_SIM900_100MS())
 6550               		.loc 2 1308 0
 6551 228e 0E94 0000 		call procedura_inicjalizacyjna_SIM900_100MS
 6552               	.LVL503:
 6553 2292 8823      		tst r24
 6554 2294 01F0      		breq .L669
1309:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_PODLACZONY_MODUL_GSM);
 6555               		.loc 2 1309 0
 6556 2296 8BE8      		ldi r24,lo8(-117)
 6557 2298 0E94 0000 		call dodaj_komende
 6558               	.LVL504:
 6559               	.L669:
1310:main_sim900.h **** 
1311:main_sim900.h ****   if (maksymalny_czas_dzwonienia) {
 6560               		.loc 2 1311 0
 6561 229c 8091 0000 		lds r24,maksymalny_czas_dzwonienia
 6562 22a0 8823      		tst r24
 6563 22a2 01F0      		breq .L671
1312:main_sim900.h ****     if (--maksymalny_czas_dzwonienia == 0) {
 6564               		.loc 2 1312 0
 6565 22a4 8150      		subi r24,lo8(-(-1))
 6566 22a6 8093 0000 		sts maksymalny_czas_dzwonienia,r24
 6567 22aa 8111      		cpse r24,__zero_reg__
 6568 22ac 00C0      		rjmp .L671
 6569               	.LVL505:
1313:main_sim900.h ****       POMOC_DODAJ2('#', 'i');
1314:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
 6570               		.loc 2 1314 0
 6571 22ae 87E9      		ldi r24,lo8(-105)
 6572 22b0 0E94 0000 		call dodaj_komende
 6573               	.LVL506:
 6574               	.L671:
1315:main_sim900.h ****     }
1316:main_sim900.h ****   }
1317:main_sim900.h **** 
1318:main_sim900.h ****   if (licznik_bezpieczenstwa_wykonywana_rozmowa) {
 6575               		.loc 2 1318 0
 6576 22b4 8091 0000 		lds r24,licznik_bezpieczenstwa_wykonywana_rozmowa
 6577 22b8 9091 0000 		lds r25,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 6578 22bc 0097      		sbiw r24,0
 6579 22be 01F0      		breq .L674
1319:main_sim900.h ****     if (--licznik_bezpieczenstwa_wykonywana_rozmowa == 0) {
 6580               		.loc 2 1319 0
 6581 22c0 0197      		sbiw r24,1
 6582 22c2 9093 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,r25
 6583 22c6 8093 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,r24
 6584 22ca 892B      		or r24,r25
 6585 22cc 01F4      		brne .L674
 6586               	.LVL507:
1320:main_sim900.h ****       POMOC_DODAJ2('#', 'j');
1321:main_sim900.h ****       zakonczono_rozmowe_telefoniczna(
 6587               		.loc 2 1321 0
 6588 22ce 82E0      		ldi r24,lo8(2)
 6589 22d0 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 6590               	.LVL508:
1322:main_sim900.h ****           powod_zakonczenia_rozmowy_przekroczony_czas);
1323:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 6591               		.loc 2 1323 0
 6592 22d4 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
1324:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 6593               		.loc 2 1324 0
 6594 22d8 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 6595               	.LVL509:
 6596               	.L674:
 6597               	.LBB609:
1325:main_sim900.h ****     }
1326:main_sim900.h ****   }
1327:main_sim900.h **** 
1328:main_sim900.h **** #ifndef WYLACZ_AUTOMATYCZNE_KONTROLOWANIE_SIMCOM
1329:main_sim900.h **** 
1330:main_sim900.h ****   { // poziom sieci i zalogowanie u operatora
1331:main_sim900.h ****     static uchar licznik_cyklu_8_sek = 0;
1332:main_sim900.h ****     if (++licznik_cyklu_8_sek == 48)
 6598               		.loc 2 1332 0
 6599 22dc 8091 0000 		lds r24,licznik_cyklu_8_sek.3478
 6600 22e0 8F5F      		subi r24,lo8(-(1))
 6601 22e2 8093 0000 		sts licznik_cyklu_8_sek.3478,r24
 6602 22e6 8033      		cpi r24,lo8(48)
 6603 22e8 01F0      		breq .+2
 6604 22ea 00C0      		rjmp .L676
1333:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_POZIOM_SIECI);
 6605               		.loc 2 1333 0
 6606 22ec 8BE9      		ldi r24,lo8(-101)
 6607               	.L718:
1334:main_sim900.h ****     else if (licznik_cyklu_8_sek == 52)
1335:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_ZAREJESTROWANIE);
1336:main_sim900.h ****     else if (licznik_cyklu_8_sek == 56)
1337:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_ZALOGOWANIE_U_OPERATORA);
1338:main_sim900.h ****     else if (licznik_cyklu_8_sek == 60) {
1339:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_STAN_KARTY_SIM);
1340:main_sim900.h ****     } else if (licznik_cyklu_8_sek >= 80) {
1341:main_sim900.h ****       licznik_cyklu_8_sek = 0;
1342:main_sim900.h ****       if (modul_zalogowany_w_sieci)
1343:main_sim900.h ****         filtruj_i_dodaj_komende(
 6608               		.loc 2 1343 0
 6609 22ee 0E94 0000 		call filtruj_i_dodaj_komende
 6610               	.LVL510:
 6611               	.L677:
 6612               	.LBE609:
1344:main_sim900.h ****             KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE);
1345:main_sim900.h ****     }
1346:main_sim900.h ****   }
1347:main_sim900.h **** 
1348:main_sim900.h ****   if (opoznienie_zatrzymaj_odpytywanie_urzadzenia)
 6613               		.loc 2 1348 0
 6614 22f2 8091 0000 		lds r24,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6615 22f6 8823      		tst r24
 6616 22f8 01F0      		breq .L683
1349:main_sim900.h ****     --opoznienie_zatrzymaj_odpytywanie_urzadzenia;
 6617               		.loc 2 1349 0
 6618 22fa 8150      		subi r24,lo8(-(-1))
 6619 22fc 8093 0000 		sts opoznienie_zatrzymaj_odpytywanie_urzadzenia,r24
 6620               	.L683:
1350:main_sim900.h **** 
1351:main_sim900.h ****   if (modul_zalogowany_w_sieci &&
 6621               		.loc 2 1351 0
 6622 2300 8091 0000 		lds r24,modul_zalogowany_w_sieci
 6623 2304 8823      		tst r24
 6624 2306 01F4      		brne .+2
 6625 2308 00C0      		rjmp .L684
1352:main_sim900.h ****       (poziom_sieci_gsm == POZIOM_SIECI_BLAD || poziom_sieci_gsm == 0)) {
 6626               		.loc 2 1352 0 discriminator 1
 6627 230a 8091 0000 		lds r24,poziom_sieci_gsm
1351:main_sim900.h ****       (poziom_sieci_gsm == POZIOM_SIECI_BLAD || poziom_sieci_gsm == 0)) {
 6628               		.loc 2 1351 0 discriminator 1
 6629 230e 8336      		cpi r24,lo8(99)
 6630 2310 01F0      		breq .L685
 6631               		.loc 2 1352 0
 6632 2312 8111      		cpse r24,__zero_reg__
 6633 2314 00C0      		rjmp .L684
 6634               	.L685:
1353:main_sim900.h ****     if (licznik_awaria_brak_zasiegu < MAX_LICZNIK_AWARIA_BRAK_ZASIEGU) {
 6635               		.loc 2 1353 0
 6636 2316 8091 0000 		lds r24,licznik_awaria_brak_zasiegu
 6637 231a 9091 0000 		lds r25,licznik_awaria_brak_zasiegu+1
 6638 231e 8835      		cpi r24,88
 6639 2320 22E0      		ldi r18,2
 6640 2322 9207      		cpc r25,r18
 6641 2324 00F4      		brsh .L687
1354:main_sim900.h ****       if (++licznik_awaria_brak_zasiegu == MAX_LICZNIK_AWARIA_BRAK_ZASIEGU) {
 6642               		.loc 2 1354 0
 6643 2326 0196      		adiw r24,1
 6644 2328 8835      		cpi r24,88
 6645 232a 22E0      		ldi r18,2
 6646 232c 9207      		cpc r25,r18
 6647 232e 01F4      		brne .+2
 6648 2330 00C0      		rjmp .L688
 6649 2332 9093 0000 		sts licznik_awaria_brak_zasiegu+1,r25
 6650 2336 8093 0000 		sts licznik_awaria_brak_zasiegu,r24
 6651               	.L687:
1355:main_sim900.h ****         licznik_awaria_brak_zasiegu = 0;
1356:main_sim900.h ****         POMOC_DODAJ2('*', 'j');
1357:main_sim900.h ****         reset_modulu_SIM900();
1358:main_sim900.h ****       }
1359:main_sim900.h ****     }
1360:main_sim900.h ****   } else
1361:main_sim900.h ****     licznik_awaria_brak_zasiegu = 0;
1362:main_sim900.h **** 
1363:main_sim900.h ****   if (CZY_BLAD_KARTY_SIM() || CZY_BLAD_ZALOGOWANIA_U_OPERATORA()) {
 6652               		.loc 2 1363 0
 6653 233a 8091 0000 		lds r24,licznik_blad_stanu_karty_SIM
 6654 233e 8630      		cpi r24,lo8(6)
 6655 2340 00F4      		brsh .L690
 6656               		.loc 2 1363 0 is_stmt 0 discriminator 1
 6657 2342 8091 0000 		lds r24,licznik_blad_zalogowania_u_operatora
 6658 2346 8431      		cpi r24,lo8(20)
 6659 2348 00F0      		brlo .L691
 6660               	.L690:
 6661               	.LVL511:
1364:main_sim900.h ****     POMOC_DODAJ2('*', 'k');
1365:main_sim900.h ****     reset_modulu_SIM900();
 6662               		.loc 2 1365 0 is_stmt 1
 6663 234a 0E94 0000 		call reset_modulu_SIM900
 6664               	.LVL512:
 6665               	.L691:
1366:main_sim900.h ****   }
1367:main_sim900.h **** #endif
1368:main_sim900.h **** 
1369:main_sim900.h ****   if (licznik_reset_modulu_SIM900) {
 6666               		.loc 2 1369 0
 6667 234e 8091 0000 		lds r24,licznik_reset_modulu_SIM900
 6668 2352 8823      		tst r24
 6669 2354 01F0      		breq .L693
1370:main_sim900.h ****     if (--licznik_reset_modulu_SIM900 == 0) {
 6670               		.loc 2 1370 0
 6671 2356 8150      		subi r24,lo8(-(-1))
 6672 2358 8093 0000 		sts licznik_reset_modulu_SIM900,r24
 6673 235c 8111      		cpse r24,__zero_reg__
 6674 235e 00C0      		rjmp .L693
 6675               	.LVL513:
1371:main_sim900.h ****       POMOC_DODAJ2('*', 'l');
1372:main_sim900.h ****       reset_modulu_SIM900();
 6676               		.loc 2 1372 0
 6677 2360 0E94 0000 		call reset_modulu_SIM900
 6678               	.LVL514:
 6679               	.L693:
1373:main_sim900.h ****     }
1374:main_sim900.h ****   }
1375:main_sim900.h **** 
1376:main_sim900.h ****   if (!modul_zalogowany_w_sieci) {
 6680               		.loc 2 1376 0
 6681 2364 8091 0000 		lds r24,modul_zalogowany_w_sieci
 6682 2368 8111      		cpse r24,__zero_reg__
 6683 236a 00C0      		rjmp .L695
1377:main_sim900.h ****     if (++licznik_ogolny_blad_zalogowania > MAX_LICZNIK_OGOLNY_BLAD_ZALOGOWANIA)
 6684               		.loc 2 1377 0
 6685 236c 8091 0000 		lds r24,licznik_ogolny_blad_zalogowania
 6686 2370 9091 0000 		lds r25,licznik_ogolny_blad_zalogowania+1
 6687 2374 0196      		adiw r24,1
 6688 2376 9093 0000 		sts licznik_ogolny_blad_zalogowania+1,r25
 6689 237a 8093 0000 		sts licznik_ogolny_blad_zalogowania,r24
 6690 237e 813B      		cpi r24,-79
 6691 2380 9440      		sbci r25,4
 6692 2382 00F0      		brlo .L658
1378:main_sim900.h ****       reset_modulu_SIM900();
 6693               		.loc 2 1378 0
 6694 2384 0C94 0000 		jmp reset_modulu_SIM900
 6695               	.LVL515:
 6696               	.L676:
 6697               	.LBB610:
1334:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_ZAREJESTROWANIE);
 6698               		.loc 2 1334 0
 6699 2388 8433      		cpi r24,lo8(52)
 6700 238a 01F4      		brne .L678
1335:main_sim900.h ****     else if (licznik_cyklu_8_sek == 56)
 6701               		.loc 2 1335 0
 6702 238c 8DE9      		ldi r24,lo8(-99)
 6703 238e 00C0      		rjmp .L718
 6704               	.L678:
1336:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_ZALOGOWANIE_U_OPERATORA);
 6705               		.loc 2 1336 0
 6706 2390 8833      		cpi r24,lo8(56)
 6707 2392 01F4      		brne .L679
1337:main_sim900.h ****     else if (licznik_cyklu_8_sek == 60) {
 6708               		.loc 2 1337 0
 6709 2394 8AE9      		ldi r24,lo8(-102)
 6710 2396 00C0      		rjmp .L718
 6711               	.L679:
1338:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_STAN_KARTY_SIM);
 6712               		.loc 2 1338 0
 6713 2398 8C33      		cpi r24,lo8(60)
 6714 239a 01F4      		brne .L680
1339:main_sim900.h ****     } else if (licznik_cyklu_8_sek >= 80) {
 6715               		.loc 2 1339 0
 6716 239c 89E9      		ldi r24,lo8(-103)
 6717 239e 00C0      		rjmp .L718
 6718               	.L680:
1340:main_sim900.h ****       licznik_cyklu_8_sek = 0;
 6719               		.loc 2 1340 0
 6720 23a0 8035      		cpi r24,lo8(80)
 6721 23a2 00F4      		brsh .+2
 6722 23a4 00C0      		rjmp .L677
 6723 23a6 8091 0000 		lds r24,modul_zalogowany_w_sieci
1341:main_sim900.h ****       if (modul_zalogowany_w_sieci)
 6724               		.loc 2 1341 0
 6725 23aa 1092 0000 		sts licznik_cyklu_8_sek.3478,__zero_reg__
1342:main_sim900.h ****         filtruj_i_dodaj_komende(
 6726               		.loc 2 1342 0
 6727 23ae 8823      		tst r24
 6728 23b0 01F4      		brne .+2
 6729 23b2 00C0      		rjmp .L677
1343:main_sim900.h ****             KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE);
 6730               		.loc 2 1343 0
 6731 23b4 8EE9      		ldi r24,lo8(-98)
 6732 23b6 00C0      		rjmp .L718
 6733               	.L688:
 6734               	.LBE610:
1355:main_sim900.h ****         POMOC_DODAJ2('*', 'j');
 6735               		.loc 2 1355 0
 6736 23b8 1092 0000 		sts licznik_awaria_brak_zasiegu+1,__zero_reg__
 6737 23bc 1092 0000 		sts licznik_awaria_brak_zasiegu,__zero_reg__
 6738               	.LVL516:
1357:main_sim900.h ****       }
 6739               		.loc 2 1357 0
 6740 23c0 0E94 0000 		call reset_modulu_SIM900
 6741               	.LVL517:
 6742 23c4 00C0      		rjmp .L687
 6743               	.LVL518:
 6744               	.L684:
1361:main_sim900.h **** 
 6745               		.loc 2 1361 0
 6746 23c6 1092 0000 		sts licznik_awaria_brak_zasiegu+1,__zero_reg__
 6747 23ca 1092 0000 		sts licznik_awaria_brak_zasiegu,__zero_reg__
 6748 23ce 00C0      		rjmp .L687
 6749               	.L695:
1379:main_sim900.h ****   } else
1380:main_sim900.h ****     licznik_ogolny_blad_zalogowania = 0;
 6750               		.loc 2 1380 0
 6751 23d0 1092 0000 		sts licznik_ogolny_blad_zalogowania+1,__zero_reg__
 6752 23d4 1092 0000 		sts licznik_ogolny_blad_zalogowania,__zero_reg__
 6753               	.L658:
 6754               	/* epilogue start */
1381:main_sim900.h **** }
 6755               		.loc 2 1381 0
 6756 23d8 0895      		ret
 6757               		.cfi_endproc
 6758               	.LFE55:
 6760               	.global	steruj_SIM900_10MS
 6762               	steruj_SIM900_10MS:
 6763               	.LFB56:
1382:main_sim900.h **** 
1383:main_sim900.h **** void steruj_SIM900_10MS(void) {
 6764               		.loc 2 1383 0
 6765               		.cfi_startproc
 6766               	/* prologue: function */
 6767               	/* frame size = 0 */
 6768               	/* stack size = 0 */
 6769               	.L__stack_usage = 0
1384:main_sim900.h ****   if (czy_jest_komenda_SIM900())
 6770               		.loc 2 1384 0
 6771 23da 8091 0000 		lds r24,komenda_SIM900
 6772 23de 8823      		tst r24
 6773 23e0 01F4      		brne .+2
 6774 23e2 00C0      		rjmp .L720
 6775               	.L722:
1385:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_KOMENDA_SIM900);
 6776               		.loc 2 1385 0
 6777 23e4 8AE8      		ldi r24,lo8(-118)
 6778 23e6 0E94 0000 		call dodaj_komende
 6779               	.LVL519:
 6780               	.L721:
1386:main_sim900.h **** 
1387:main_sim900.h ****   if (flaga_odebrany_znak_zachety) {
 6781               		.loc 2 1387 0
 6782 23ea 8091 0000 		lds r24,flaga_odebrany_znak_zachety
 6783 23ee 8823      		tst r24
 6784 23f0 01F0      		breq .L723
1388:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_PDU);
 6785               		.loc 2 1388 0
 6786 23f2 85ED      		ldi r24,lo8(-43)
 6787 23f4 0E94 0000 		call dodaj_komende
 6788               	.LVL520:
1389:main_sim900.h ****     // czekanie_na_odebranie_zachety = FALSE;	// byo
1390:main_sim900.h ****     flaga_odebrany_znak_zachety = FALSE;
 6789               		.loc 2 1390 0
 6790 23f8 1092 0000 		sts flaga_odebrany_znak_zachety,__zero_reg__
 6791               	.LVL521:
 6792               	.L723:
 6793               	.LBB611:
1391:main_sim900.h ****     POMOC_DODAJ2('#', 'm');
1392:main_sim900.h ****   }
1393:main_sim900.h **** 
1394:main_sim900.h ****   { // kontrola wysyania sms-w i clipw
1395:main_sim900.h ****     static uint licznik_bezpieczenstwa = 0;
1396:main_sim900.h ****     if (modul_zalogowany_w_sieci && flaga_wysylanie_smsa) {
 6794               		.loc 2 1396 0
 6795 23fc 8091 0000 		lds r24,modul_zalogowany_w_sieci
 6796 2400 8823      		tst r24
 6797 2402 01F4      		brne .+2
 6798 2404 00C0      		rjmp .L724
 6799               		.loc 2 1396 0 is_stmt 0 discriminator 1
 6800 2406 8091 0000 		lds r24,flaga_wysylanie_smsa
 6801 240a 8823      		tst r24
 6802 240c 01F4      		brne .+2
 6803 240e 00C0      		rjmp .L724
1397:main_sim900.h ****       if (++licznik_bezpieczenstwa >= 5000) // 50 sek
 6804               		.loc 2 1397 0 is_stmt 1
 6805 2410 8091 0000 		lds r24,licznik_bezpieczenstwa.3482
 6806 2414 9091 0000 		lds r25,licznik_bezpieczenstwa.3482+1
 6807 2418 0196      		adiw r24,1
 6808 241a 8838      		cpi r24,-120
 6809 241c 23E1      		ldi r18,19
 6810 241e 9207      		cpc r25,r18
 6811 2420 00F0      		brlo .+2
 6812 2422 00C0      		rjmp .L725
 6813 2424 9093 0000 		sts licznik_bezpieczenstwa.3482+1,r25
 6814 2428 8093 0000 		sts licznik_bezpieczenstwa.3482,r24
 6815               	.L726:
 6816               	.LBE611:
 6817               	.LBB612:
1398:main_sim900.h ****       {
1399:main_sim900.h ****         POMOC_DODAJ2('#', 'Z');
1400:main_sim900.h ****         licznik_bezpieczenstwa = 0;
1401:main_sim900.h ****         komenda_SIM900 = ERROR_KOMENDA_SIM900;
1402:main_sim900.h ****         obsluga_wysylania_sms();
1403:main_sim900.h ****       }
1404:main_sim900.h ****     } else
1405:main_sim900.h ****       licznik_bezpieczenstwa = 0;
1406:main_sim900.h ****   }
1407:main_sim900.h **** 
1408:main_sim900.h ****   { // kontrola programu: zbyt dugi okres wykonywania polecenia do SIM900 lub
1409:main_sim900.h ****     // jego brak
1410:main_sim900.h ****     static komenda_typ poprzednia_komenda;
1411:main_sim900.h ****     static uint licznik_poprzednia_komenda;
1412:main_sim900.h ****     static uint licznik_odebranych_znakow;
1413:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY &&
 6818               		.loc 2 1413 0
 6819 242c 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 6820 2430 9091 0000 		lds r25,trwa_rozmowa_przychodzaca_od_uzytkownika
 6821 2434 8823      		tst r24
 6822 2436 01F4      		brne .+2
 6823 2438 00C0      		rjmp .L727
 6824               		.loc 2 1413 0 is_stmt 0 discriminator 1
 6825 243a 2091 0000 		lds r18,poprzednia_komenda.3483
 6826 243e 8213      		cpse r24,r18
 6827 2440 00C0      		rjmp .L728
1414:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 == poprzednia_komenda &&
 6828               		.loc 2 1414 0 is_stmt 1
 6829 2442 9111      		cpse r25,__zero_reg__
 6830 2444 00C0      		rjmp .L729
 6831               	.LVL522:
 6832               	.LBB613:
1415:main_sim900.h ****         !trwa_rozmowa_przychodzaca_od_uzytkownika) {
1416:main_sim900.h ****       uint max_licznik_poprzednia_komenda = 5 * 100; // 5 sek;
1417:main_sim900.h ****       if (aktualnie_wysylane_polecenie_SIM900 ==
 6833               		.loc 2 1417 0
 6834 2446 8C38      		cpi r24,lo8(-116)
 6835 2448 01F0      		breq .L743
1418:main_sim900.h ****               KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT ||
 6836               		.loc 2 1418 0
 6837 244a 9BE2      		ldi r25,lo8(43)
 6838 244c 980F      		add r25,r24
1416:main_sim900.h ****       if (aktualnie_wysylane_polecenie_SIM900 ==
 6839               		.loc 2 1416 0
 6840 244e 44EF      		ldi r20,lo8(-12)
 6841 2450 51E0      		ldi r21,lo8(1)
 6842               		.loc 2 1418 0
 6843 2452 9230      		cpi r25,lo8(2)
 6844 2454 00F4      		brsh .L730
 6845               	.L743:
1419:main_sim900.h ****           aktualnie_wysylane_polecenie_SIM900 == KOMENDA_KOLEJKI_WYSLIJ_PDU ||
1420:main_sim900.h ****           aktualnie_wysylane_polecenie_SIM900 ==
1421:main_sim900.h ****               KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE)
1422:main_sim900.h ****         max_licznik_poprzednia_komenda = 2 * 60 * 100; // 2 minuty
 6846               		.loc 2 1422 0
 6847 2456 40EE      		ldi r20,lo8(-32)
 6848 2458 5EE2      		ldi r21,lo8(46)
 6849               	.L730:
 6850               	.LVL523:
1423:main_sim900.h **** 
1424:main_sim900.h ****       if (aktualnie_wysylane_polecenie_SIM900 ==
1425:main_sim900.h ****               KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT // zmienione (1)
1426:main_sim900.h ****           || aktualnie_wysylane_polecenie_SIM900 ==
 6851               		.loc 2 1426 0
 6852 245a 9DE2      		ldi r25,lo8(45)
 6853 245c 980F      		add r25,r24
1424:main_sim900.h ****               KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT // zmienione (1)
 6854               		.loc 2 1424 0
 6855 245e 9230      		cpi r25,lo8(2)
 6856 2460 00F4      		brsh .L731
1427:main_sim900.h ****                  KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
1428:main_sim900.h ****         max_licznik_poprzednia_komenda = 15 * 100;
 6857               		.loc 2 1428 0
 6858 2462 4CED      		ldi r20,lo8(-36)
 6859 2464 55E0      		ldi r21,lo8(5)
 6860               	.LVL524:
 6861               	.L731:
1429:main_sim900.h **** 
1430:main_sim900.h ****       if (++licznik_poprzednia_komenda >= max_licznik_poprzednia_komenda) {
 6862               		.loc 2 1430 0
 6863 2466 2091 0000 		lds r18,licznik_poprzednia_komenda.3484
 6864 246a 3091 0000 		lds r19,licznik_poprzednia_komenda.3484+1
 6865 246e 2F5F      		subi r18,-1
 6866 2470 3F4F      		sbci r19,-1
 6867 2472 2417      		cp r18,r20
 6868 2474 3507      		cpc r19,r21
 6869 2476 00F4      		brsh .L732
 6870 2478 3093 0000 		sts licznik_poprzednia_komenda.3484+1,r19
 6871 247c 2093 0000 		sts licznik_poprzednia_komenda.3484,r18
 6872               	.LVL525:
 6873               	.L733:
1431:main_sim900.h ****         licznik_poprzednia_komenda = 0;
1432:main_sim900.h ****         POMOC_DODAJ2('#', 'r');
1433:main_sim900.h ****         POMOC_DODAJ_HEX(aktualnie_wysylane_polecenie_SIM900 >> 8);
1434:main_sim900.h ****         POMOC_DODAJ_HEX(aktualnie_wysylane_polecenie_SIM900);
1435:main_sim900.h ****         if (aktualnie_wysylane_polecenie_SIM900 !=
1436:main_sim900.h ****             KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1) {
1437:main_sim900.h ****           if (aktualnie_wysylane_polecenie_SIM900 ==
1438:main_sim900.h ****                   KOMENDA_KOLEJKI_ODRZUC_ROZMOWE ||
1439:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
1440:main_sim900.h ****                   KOMENDA_KOLEJKI_PODAJ_PIN ||
1441:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
1442:main_sim900.h ****                   KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW ||
1443:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
1444:main_sim900.h ****                   KOMENDA_KOLEJKI_USTAW_WZMOCNIENIE_MIKROFONU ||
1445:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
1446:main_sim900.h ****                   KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS ||
1447:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
1448:main_sim900.h ****                    KOMENDA_KOLEJKI_SPRAWDZ_PIN &&
1449:main_sim900.h ****                aktualnie_wysylane_polecenie_SIM900 <=
1450:main_sim900.h ****                    KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ) ||
1451:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
1452:main_sim900.h ****                    KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
1453:main_sim900.h ****                aktualnie_wysylane_polecenie_SIM900 <=
1454:main_sim900.h ****                    KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) ||
1455:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
1456:main_sim900.h ****                    KOMENDA_KOLEJKI_USUN_SMSA_1 &&
1457:main_sim900.h ****                aktualnie_wysylane_polecenie_SIM900 <=
1458:main_sim900.h ****                    KOMENDA_KOLEJKI_USUN_SMSA_20)) {
1459:main_sim900.h ****             nastepne_wysylane_polecenie_SIM900 =
1460:main_sim900.h ****                 aktualnie_wysylane_polecenie_SIM900;
1461:main_sim900.h ****           } else
1462:main_sim900.h ****             nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
1463:main_sim900.h ****           wyzerowanie_danych_SIM900();
1464:main_sim900.h ****           wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1;
1465:main_sim900.h ****           wysylane_dane_RAM_SIM900[0] = '\0';
1466:main_sim900.h ****           wyslij_polecenie_RAM_SIM900();
1467:main_sim900.h ****         } else
1468:main_sim900.h ****           reset_modulu_SIM900();
1469:main_sim900.h ****       }
1470:main_sim900.h ****       licznik_odebranych_znakow = 0;
 6874               		.loc 2 1470 0
 6875 2480 1092 0000 		sts licznik_odebranych_znakow.3485+1,__zero_reg__
 6876 2484 1092 0000 		sts licznik_odebranych_znakow.3485,__zero_reg__
 6877               	.L737:
 6878               	.LBE613:
1471:main_sim900.h ****     } else if (aktualnie_wysylane_polecenie_SIM900 !=
1472:main_sim900.h ****                    KOMENDA_KOLEJKI_BRAK_KOMENDY &&
1473:main_sim900.h ****                trwa_rozmowa_przychodzaca_od_uzytkownika &&
1474:main_sim900.h ****                czy_jest_bezczynny_SIM900()) {
1475:main_sim900.h ****       {
1476:main_sim900.h ****         cli();
1477:main_sim900.h ****         const uint l = liczba_odebranych_znakow_SIM900;
1478:main_sim900.h ****         sei();
1479:main_sim900.h ****         if (licznik_odebranych_znakow < l)
1480:main_sim900.h ****           licznik_odebranych_znakow = l;
1481:main_sim900.h ****       }
1482:main_sim900.h ****       if (licznik_odebranych_znakow >=
1483:main_sim900.h ****           MIN_LICZBA_ODEBRANYCH_ZNAKOW_KONCZACYCH_ROZMOWE_W_TRAKCIE_PODSLUCHU) {
1484:main_sim900.h ****         if (++licznik_poprzednia_komenda >= 5 * 100) // 5 sek
1485:main_sim900.h ****         {
1486:main_sim900.h ****           licznik_poprzednia_komenda = 0;
1487:main_sim900.h ****           zakonczono_rozmowe_telefoniczna(
1488:main_sim900.h ****               powod_zakonczenia_rozmowy_zakonczenie);
1489:main_sim900.h ****           licznik_odebranych_znakow = 0;
1490:main_sim900.h ****           POMOC_DODAJ2('#', 'q');
1491:main_sim900.h ****           reset_modulu_SIM900();
1492:main_sim900.h ****         }
1493:main_sim900.h ****       }
1494:main_sim900.h ****     } else {
1495:main_sim900.h ****       licznik_poprzednia_komenda = 0;
1496:main_sim900.h ****       if (!trwa_rozmowa_przychodzaca_od_uzytkownika)
1497:main_sim900.h ****         licznik_odebranych_znakow = 0;
1498:main_sim900.h ****     }
1499:main_sim900.h **** 
1500:main_sim900.h ****     poprzednia_komenda = aktualnie_wysylane_polecenie_SIM900;
 6879               		.loc 2 1500 0
 6880 2488 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 6881 248c 8093 0000 		sts poprzednia_komenda.3483,r24
 6882               	/* epilogue start */
 6883               	.LBE612:
1501:main_sim900.h ****   }
1502:main_sim900.h **** }
 6884               		.loc 2 1502 0
 6885 2490 0895      		ret
 6886               	.L720:
1384:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_KOMENDA_SIM900);
 6887               		.loc 2 1384 0 discriminator 1
 6888 2492 0E94 0000 		call czy_jest_nowa_komenda_SIM900
 6889               	.LVL526:
 6890 2496 8111      		cpse r24,__zero_reg__
 6891 2498 00C0      		rjmp .L722
 6892 249a 00C0      		rjmp .L721
 6893               	.L725:
 6894               	.LVL527:
 6895               	.LBB616:
1400:main_sim900.h ****         komenda_SIM900 = ERROR_KOMENDA_SIM900;
 6896               		.loc 2 1400 0
 6897 249c 1092 0000 		sts licznik_bezpieczenstwa.3482+1,__zero_reg__
 6898 24a0 1092 0000 		sts licznik_bezpieczenstwa.3482,__zero_reg__
1401:main_sim900.h ****         obsluga_wysylania_sms();
 6899               		.loc 2 1401 0
 6900 24a4 84E0      		ldi r24,lo8(4)
 6901 24a6 8093 0000 		sts komenda_SIM900,r24
1402:main_sim900.h ****       }
 6902               		.loc 2 1402 0
 6903 24aa 0E94 0000 		call obsluga_wysylania_sms
 6904               	.LVL528:
 6905 24ae 00C0      		rjmp .L726
 6906               	.LVL529:
 6907               	.L724:
1405:main_sim900.h ****   }
 6908               		.loc 2 1405 0
 6909 24b0 1092 0000 		sts licznik_bezpieczenstwa.3482+1,__zero_reg__
 6910 24b4 1092 0000 		sts licznik_bezpieczenstwa.3482,__zero_reg__
 6911 24b8 00C0      		rjmp .L726
 6912               	.LVL530:
 6913               	.L732:
 6914               	.LBE616:
 6915               	.LBB617:
 6916               	.LBB614:
1431:main_sim900.h ****         POMOC_DODAJ2('#', 'r');
 6917               		.loc 2 1431 0
 6918 24ba 1092 0000 		sts licznik_poprzednia_komenda.3484+1,__zero_reg__
 6919 24be 1092 0000 		sts licznik_poprzednia_komenda.3484,__zero_reg__
 6920               	.LVL531:
1435:main_sim900.h ****             KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1) {
 6921               		.loc 2 1435 0
 6922 24c2 8D3F      		cpi r24,lo8(-3)
 6923 24c4 01F0      		breq .L734
1437:main_sim900.h ****                   KOMENDA_KOLEJKI_ODRZUC_ROZMOWE ||
 6924               		.loc 2 1437 0
 6925 24c6 8739      		cpi r24,lo8(-105)
 6926 24c8 01F0      		breq .L735
1438:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
 6927               		.loc 2 1438 0
 6928 24ca 92E7      		ldi r25,lo8(114)
 6929 24cc 980F      		add r25,r24
 6930 24ce 9230      		cpi r25,lo8(2)
 6931 24d0 00F0      		brlo .L735
1442:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
 6932               		.loc 2 1442 0
 6933 24d2 9CE6      		ldi r25,lo8(108)
 6934 24d4 980F      		add r25,r24
 6935 24d6 9230      		cpi r25,lo8(2)
 6936 24d8 00F0      		brlo .L735
1448:main_sim900.h ****                aktualnie_wysylane_polecenie_SIM900 <=
 6937               		.loc 2 1448 0
 6938 24da 91E6      		ldi r25,lo8(97)
 6939 24dc 980F      		add r25,r24
1446:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
 6940               		.loc 2 1446 0
 6941 24de 9A30      		cpi r25,lo8(10)
 6942 24e0 00F0      		brlo .L735
1450:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
 6943               		.loc 2 1450 0
 6944 24e2 96E5      		ldi r25,lo8(86)
 6945 24e4 980F      		add r25,r24
 6946 24e6 9832      		cpi r25,lo8(40)
 6947 24e8 00F0      		brlo .L735
1462:main_sim900.h ****           wyzerowanie_danych_SIM900();
 6948               		.loc 2 1462 0
 6949 24ea 1092 0000 		sts nastepne_wysylane_polecenie_SIM900,__zero_reg__
 6950               	.L736:
1463:main_sim900.h ****           wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1;
 6951               		.loc 2 1463 0
 6952 24ee 0E94 0000 		call wyzerowanie_danych_SIM900
 6953               	.LVL532:
1464:main_sim900.h ****           wysylane_dane_RAM_SIM900[0] = '\0';
 6954               		.loc 2 1464 0
 6955 24f2 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6956 24f6 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6957 24fa 8DEF      		ldi r24,lo8(-3)
 6958 24fc 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1465:main_sim900.h ****           wyslij_polecenie_RAM_SIM900();
 6959               		.loc 2 1465 0
 6960 2500 1092 0000 		sts wysylany_blok_SIM900+2,__zero_reg__
1466:main_sim900.h ****         } else
 6961               		.loc 2 1466 0
 6962 2504 0E94 0000 		call wyslij_polecenie_RAM_SIM900
 6963               	.LVL533:
 6964 2508 00C0      		rjmp .L733
 6965               	.LVL534:
 6966               	.L735:
1459:main_sim900.h ****                 aktualnie_wysylane_polecenie_SIM900;
 6967               		.loc 2 1459 0
 6968 250a 8093 0000 		sts nastepne_wysylane_polecenie_SIM900,r24
 6969 250e 00C0      		rjmp .L736
 6970               	.L734:
1468:main_sim900.h ****       }
 6971               		.loc 2 1468 0
 6972 2510 0E94 0000 		call reset_modulu_SIM900
 6973               	.LVL535:
 6974 2514 00C0      		rjmp .L733
 6975               	.LVL536:
 6976               	.L728:
 6977               	.LBE614:
1472:main_sim900.h ****                trwa_rozmowa_przychodzaca_od_uzytkownika &&
 6978               		.loc 2 1472 0
 6979 2516 9923      		tst r25
 6980 2518 01F0      		breq .L727
 6981               	.L729:
1474:main_sim900.h ****       {
 6982               		.loc 2 1474 0
 6983 251a 8091 0000 		lds r24,komenda_SIM900
1473:main_sim900.h ****                czy_jest_bezczynny_SIM900()) {
 6984               		.loc 2 1473 0
 6985 251e 8111      		cpse r24,__zero_reg__
 6986 2520 00C0      		rjmp .L727
 6987               	.LBB615:
1476:main_sim900.h ****         const uint l = liczba_odebranych_znakow_SIM900;
 6988               		.loc 2 1476 0
 6989               	/* #APP */
 6990               	 ;  1476 "main_sim900.h" 1
 6991 2522 F894      		cli
 6992               	 ;  0 "" 2
1477:main_sim900.h ****         sei();
 6993               		.loc 2 1477 0
 6994               	/* #NOAPP */
 6995 2524 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 6996 2528 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
 6997               	.LVL537:
1478:main_sim900.h ****         if (licznik_odebranych_znakow < l)
 6998               		.loc 2 1478 0
 6999               	/* #APP */
 7000               	 ;  1478 "main_sim900.h" 1
 7001 252c 7894      		sei
 7002               	 ;  0 "" 2
1479:main_sim900.h ****           licznik_odebranych_znakow = l;
 7003               		.loc 2 1479 0
 7004               	/* #NOAPP */
 7005 252e 2091 0000 		lds r18,licznik_odebranych_znakow.3485
 7006 2532 3091 0000 		lds r19,licznik_odebranych_znakow.3485+1
 7007 2536 2817      		cp r18,r24
 7008 2538 3907      		cpc r19,r25
 7009 253a 00F4      		brsh .L738
1480:main_sim900.h ****       }
 7010               		.loc 2 1480 0
 7011 253c 9093 0000 		sts licznik_odebranych_znakow.3485+1,r25
 7012 2540 8093 0000 		sts licznik_odebranych_znakow.3485,r24
 7013               	.L738:
 7014               	.LBE615:
1482:main_sim900.h ****           MIN_LICZBA_ODEBRANYCH_ZNAKOW_KONCZACYCH_ROZMOWE_W_TRAKCIE_PODSLUCHU) {
 7015               		.loc 2 1482 0
 7016 2544 8091 0000 		lds r24,licznik_odebranych_znakow.3485
 7017 2548 9091 0000 		lds r25,licznik_odebranych_znakow.3485+1
 7018               	.LVL538:
 7019 254c 0A97      		sbiw r24,10
 7020 254e 00F4      		brsh .+2
 7021 2550 00C0      		rjmp .L737
1484:main_sim900.h ****         {
 7022               		.loc 2 1484 0
 7023 2552 8091 0000 		lds r24,licznik_poprzednia_komenda.3484
 7024 2556 9091 0000 		lds r25,licznik_poprzednia_komenda.3484+1
 7025 255a 0196      		adiw r24,1
 7026 255c 843F      		cpi r24,-12
 7027 255e 21E0      		ldi r18,1
 7028 2560 9207      		cpc r25,r18
 7029 2562 00F4      		brsh .L740
 7030 2564 9093 0000 		sts licznik_poprzednia_komenda.3484+1,r25
 7031 2568 8093 0000 		sts licznik_poprzednia_komenda.3484,r24
 7032 256c 00C0      		rjmp .L737
 7033               	.L740:
1486:main_sim900.h ****           zakonczono_rozmowe_telefoniczna(
 7034               		.loc 2 1486 0
 7035 256e 1092 0000 		sts licznik_poprzednia_komenda.3484+1,__zero_reg__
 7036 2572 1092 0000 		sts licznik_poprzednia_komenda.3484,__zero_reg__
1487:main_sim900.h ****               powod_zakonczenia_rozmowy_zakonczenie);
 7037               		.loc 2 1487 0
 7038 2576 81E0      		ldi r24,lo8(1)
 7039 2578 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 7040               	.LVL539:
1489:main_sim900.h ****           POMOC_DODAJ2('#', 'q');
 7041               		.loc 2 1489 0
 7042 257c 1092 0000 		sts licznik_odebranych_znakow.3485+1,__zero_reg__
 7043 2580 1092 0000 		sts licznik_odebranych_znakow.3485,__zero_reg__
 7044               	.LVL540:
1491:main_sim900.h ****         }
 7045               		.loc 2 1491 0
 7046 2584 0E94 0000 		call reset_modulu_SIM900
 7047               	.LVL541:
 7048 2588 00C0      		rjmp .L737
 7049               	.LVL542:
 7050               	.L727:
1495:main_sim900.h ****       if (!trwa_rozmowa_przychodzaca_od_uzytkownika)
 7051               		.loc 2 1495 0
 7052 258a 1092 0000 		sts licznik_poprzednia_komenda.3484+1,__zero_reg__
 7053 258e 1092 0000 		sts licznik_poprzednia_komenda.3484,__zero_reg__
1496:main_sim900.h ****         licznik_odebranych_znakow = 0;
 7054               		.loc 2 1496 0
 7055 2592 9923      		tst r25
 7056 2594 01F4      		brne .+2
 7057 2596 00C0      		rjmp .L733
 7058 2598 00C0      		rjmp .L737
 7059               	.LBE617:
 7060               		.cfi_endproc
 7061               	.LFE56:
 7063               	.global	wykonanie_komend_powiadomien
 7065               	wykonanie_komend_powiadomien:
 7066               	.LFB60:
1357:main.c        ****   const komenda_typ aktualnie_wykonywana_komenda = komendy_kolejka[0];
 7067               		.loc 1 1357 0
 7068               		.cfi_startproc
 7069 259a BF92      		push r11
 7070               	.LCFI79:
 7071               		.cfi_def_cfa_offset 3
 7072               		.cfi_offset 11, -2
 7073 259c CF92      		push r12
 7074               	.LCFI80:
 7075               		.cfi_def_cfa_offset 4
 7076               		.cfi_offset 12, -3
 7077 259e DF92      		push r13
 7078               	.LCFI81:
 7079               		.cfi_def_cfa_offset 5
 7080               		.cfi_offset 13, -4
 7081 25a0 EF92      		push r14
 7082               	.LCFI82:
 7083               		.cfi_def_cfa_offset 6
 7084               		.cfi_offset 14, -5
 7085 25a2 FF92      		push r15
 7086               	.LCFI83:
 7087               		.cfi_def_cfa_offset 7
 7088               		.cfi_offset 15, -6
 7089 25a4 0F93      		push r16
 7090               	.LCFI84:
 7091               		.cfi_def_cfa_offset 8
 7092               		.cfi_offset 16, -7
 7093 25a6 1F93      		push r17
 7094               	.LCFI85:
 7095               		.cfi_def_cfa_offset 9
 7096               		.cfi_offset 17, -8
 7097 25a8 CF93      		push r28
 7098               	.LCFI86:
 7099               		.cfi_def_cfa_offset 10
 7100               		.cfi_offset 28, -9
 7101 25aa DF93      		push r29
 7102               	.LCFI87:
 7103               		.cfi_def_cfa_offset 11
 7104               		.cfi_offset 29, -10
 7105               	/* prologue: function */
 7106               	/* frame size = 0 */
 7107               	/* stack size = 9 */
 7108               	.L__stack_usage = 9
1358:main.c        **** 
 7109               		.loc 1 1358 0
 7110 25ac 8091 0000 		lds r24,komendy_kolejka
 7111               	.LVL543:
1365:main.c        **** 
 7112               		.loc 1 1365 0
 7113 25b0 9091 0000 		lds r25,flaga_odczytywanie_smsa
 7114 25b4 9111      		cpse r25,__zero_reg__
 7115 25b6 00C0      		rjmp .L769
1361:main.c        ****       wykonywanie_rozmowy_telefonicznej ||
 7116               		.loc 1 1361 0
 7117 25b8 9091 0000 		lds r25,flaga_wysylanie_smsa
 7118 25bc 9111      		cpse r25,__zero_reg__
 7119 25be 00C0      		rjmp .L769
1361:main.c        ****       wykonywanie_rozmowy_telefonicznej ||
 7120               		.loc 1 1361 0 is_stmt 0 discriminator 1
 7121 25c0 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 7122 25c4 9111      		cpse r25,__zero_reg__
 7123 25c6 00C0      		rjmp .L769
1362:main.c        ****       trwa_rozmowa_przychodzaca_od_uzytkownika ||
 7124               		.loc 1 1362 0 is_stmt 1
 7125 25c8 9091 0000 		lds r25,trwa_rozmowa_przychodzaca_od_uzytkownika
 7126 25cc 9111      		cpse r25,__zero_reg__
 7127 25ce 00C0      		rjmp .L769
1363:main.c        ****       aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
 7128               		.loc 1 1363 0
 7129 25d0 9091 0000 		lds r25,aktualnie_wysylane_polecenie_SIM900
 7130 25d4 9111      		cpse r25,__zero_reg__
 7131 25d6 00C0      		rjmp .L769
1364:main.c        ****       opoznienie_SIM900_100MS || czekanie_na_odebranie_zachety;
 7132               		.loc 1 1364 0
 7133 25d8 9091 0000 		lds r25,opoznienie_SIM900_100MS
 7134 25dc 9111      		cpse r25,__zero_reg__
 7135 25de 00C0      		rjmp .L769
1365:main.c        **** 
 7136               		.loc 1 1365 0 discriminator 2
 7137 25e0 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 7138 25e4 21E0      		ldi r18,lo8(1)
 7139 25e6 30E0      		ldi r19,0
 7140 25e8 9111      		cpse r25,__zero_reg__
 7141 25ea 00C0      		rjmp .L768
 7142 25ec 30E0      		ldi r19,0
 7143 25ee 20E0      		ldi r18,0
 7144               	.L768:
 7145               	.LVL544:
1368:main.c        ****       czy_jest_bezczynny_SIM900();
 7146               		.loc 1 1368 0 discriminator 2
 7147 25f0 232B      		or r18,r19
 7148 25f2 01F4      		brne .L769
 7149               	.LVL545:
1368:main.c        ****       czy_jest_bezczynny_SIM900();
 7150               		.loc 1 1368 0 is_stmt 0 discriminator 1
 7151 25f4 9091 C100 		lds r25,193
 7152 25f8 96FD      		sbrc r25,6
 7153 25fa 00C0      		rjmp .L769
1368:main.c        ****       czy_jest_bezczynny_SIM900();
 7154               		.loc 1 1368 0 discriminator 3
 7155 25fc 9091 0000 		lds r25,podlaczony_modul_gsm_SIM900
 7156 2600 9923      		tst r25
 7157 2602 01F0      		breq .L769
1369:main.c        **** 
 7158               		.loc 1 1369 0 is_stmt 1 discriminator 5
 7159 2604 9091 0000 		lds r25,komenda_SIM900
1368:main.c        ****       czy_jest_bezczynny_SIM900();
 7160               		.loc 1 1368 0 discriminator 5
 7161 2608 9923      		tst r25
 7162 260a 01F4      		brne .+2
 7163 260c 00C0      		rjmp .L770
 7164               	.LVL546:
 7165               	.L769:
1371:main.c        ****   case KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW: {
 7166               		.loc 1 1371 0
 7167 260e 8938      		cpi r24,lo8(-119)
 7168 2610 01F0      		breq .+2
 7169 2612 00C0      		rjmp .L805
 7170 2614 00C0      		rjmp .L771
 7171               	.LVL547:
 7172               	.L803:
 7173               	.LBB618:
1378:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
 7174               		.loc 1 1378 0
 7175 2616 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 7176 261a 8111      		cpse r24,__zero_reg__
 7177 261c 00C0      		rjmp .L771
1378:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
 7178               		.loc 1 1378 0 is_stmt 0 discriminator 2
 7179 261e 8091 0000 		lds r24,liczba_znakow_do_zapisu
 7180 2622 8111      		cpse r24,__zero_reg__
 7181 2624 00C0      		rjmp .L771
1378:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
 7182               		.loc 1 1378 0 discriminator 4
 7183 2626 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 7184 262a 8111      		cpse r24,__zero_reg__
 7185 262c 00C0      		rjmp .L771
1378:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
 7186               		.loc 1 1378 0 discriminator 6
 7187 262e F999      		sbic 0x1f,1
 7188 2630 00C0      		rjmp .L771
 7189               	.LVL548:
1380:main.c        ****     for (;;) {
 7190               		.loc 1 1380 0 is_stmt 1
 7191 2632 8AE2      		ldi r24,lo8(42)
 7192 2634 8093 0000 		sts tekst_wysylanego_smsa,r24
 7193 2638 00E0      		ldi r16,lo8(tekst_wysylanego_smsa+1)
 7194 263a 10E0      		ldi r17,hi8(tekst_wysylanego_smsa+1)
 7195               	.LVL549:
1382:main.c        ****               numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama)) {
 7196               		.loc 1 1382 0
 7197 263c 85E0      		ldi r24,lo8(5)
 7198 263e D82E      		mov r13,r24
1388:main.c        ****         *sms++ = '\n';
 7199               		.loc 1 1388 0
 7200 2640 93E2      		ldi r25,lo8(35)
 7201 2642 C92E      		mov r12,r25
1389:main.c        ****         ++numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama;
 7202               		.loc 1 1389 0
 7203 2644 2AE0      		ldi r18,lo8(10)
 7204 2646 B22E      		mov r11,r18
 7205               	.LVL550:
 7206               	.L773:
1382:main.c        ****               numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama)) {
 7207               		.loc 1 1382 0
 7208 2648 C091 0000 		lds r28,numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama
 7209 264c CD9D      		mul r28,r13
 7210 264e 7001      		movw r14,r0
 7211 2650 1124      		clr __zero_reg__
 7212 2652 88E0      		ldi r24,8
 7213 2654 E80E      		add r14,r24
 7214 2656 F11C      		adc r15,__zero_reg__
 7215 2658 C701      		movw r24,r14
 7216 265a 0E94 0000 		call eeprom_read_byte
 7217               	.LVL551:
 7218 265e 8F3F      		cpi r24,lo8(-1)
 7219 2660 01F0      		breq .L774
1384:main.c        ****             (void *)EEPROM_NUMER_TELEFONU_BRAMA(
 7220               		.loc 1 1384 0
 7221 2662 4FEF      		ldi r20,lo8(-1)
 7222 2664 B801      		movw r22,r16
 7223 2666 C701      		movw r24,r14
 7224 2668 0E94 0000 		call kopiuj_blok_eeprom_na_telefon
 7225               	.LVL552:
 7226 266c E801      		movw r28,r16
 7227 266e C80F      		add r28,r24
 7228 2670 D11D      		adc r29,__zero_reg__
 7229               	.LVL553:
1388:main.c        ****         *sms++ = '\n';
 7230               		.loc 1 1388 0
 7231 2672 C882      		st Y,r12
1389:main.c        ****         ++numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama;
 7232               		.loc 1 1389 0
 7233 2674 8E01      		movw r16,r28
 7234 2676 0E5F      		subi r16,-2
 7235 2678 1F4F      		sbci r17,-1
 7236               	.LVL554:
 7237 267a B982      		std Y+1,r11
1390:main.c        ****         if ((sms + MAX_LICZBA_ZNAKOW_TELEFON + 1 >=
 7238               		.loc 1 1390 0
 7239 267c 8091 0000 		lds r24,numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama
 7240 2680 8F5F      		subi r24,lo8(-(1))
 7241 2682 8093 0000 		sts numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama,r24
1391:main.c        ****              &tekst_wysylanego_smsa[MAX_LICZBA_ZNAKOW_SMS]) ||
 7242               		.loc 1 1391 0
 7243 2686 9E01      		movw r18,r28
 7244 2688 2D5E      		subi r18,-19
 7245 268a 3F4F      		sbci r19,-1
 7246 268c 2050      		subi r18,lo8(tekst_wysylanego_smsa+160)
 7247 268e 3040      		sbci r19,hi8(tekst_wysylanego_smsa+160)
 7248 2690 00F4      		brsh .L775
1392:main.c        ****             (numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama >=
 7249               		.loc 1 1392 0
 7250 2692 8F3F      		cpi r24,lo8(-1)
 7251 2694 01F4      		brne .L773
 7252               	.L776:
1398:main.c        ****           dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 7253               		.loc 1 1398 0
 7254 2696 1A82      		std Y+2,__zero_reg__
1399:main.c        ****           wysylanie_smsa_clipa = WYSYLANIE_SMSA_WYSYLANIE;
 7255               		.loc 1 1399 0
 7256 2698 83ED      		ldi r24,lo8(-45)
 7257 269a 0E94 0000 		call dodaj_komende
 7258               	.LVL555:
1400:main.c        ****           break;
 7259               		.loc 1 1400 0
 7260 269e 81E0      		ldi r24,lo8(1)
 7261 26a0 8093 0000 		sts wysylanie_smsa_clipa,r24
 7262 26a4 00C0      		rjmp .L806
 7263               	.L775:
1395:main.c        ****                MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER))
 7264               		.loc 1 1395 0
 7265 26a6 8F3F      		cpi r24,lo8(-1)
 7266 26a8 01F0      		breq .L776
1397:main.c        ****           *sms = '\0';
 7267               		.loc 1 1397 0
 7268 26aa 89E8      		ldi r24,lo8(-119)
 7269 26ac 0E94 0000 		call dodaj_komende
 7270               	.LVL556:
 7271 26b0 00C0      		rjmp .L776
 7272               	.L774:
1404:main.c        ****             MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER) {
 7273               		.loc 1 1404 0
 7274 26b2 CF5F      		subi r28,lo8(-(1))
 7275 26b4 C093 0000 		sts numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama,r28
 7276 26b8 CF3F      		cpi r28,lo8(-1)
 7277 26ba 01F4      		brne .L773
1406:main.c        ****             *sms = '\0';
 7278               		.loc 1 1406 0
 7279 26bc E0E0      		ldi r30,hi8(tekst_wysylanego_smsa)
 7280 26be 0030      		cpi r16,lo8(tekst_wysylanego_smsa)
 7281 26c0 1E07      		cpc r17,r30
 7282 26c2 01F0      		breq .L766
1407:main.c        ****             dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 7283               		.loc 1 1407 0
 7284 26c4 F801      		movw r30,r16
 7285 26c6 1082      		st Z,__zero_reg__
1408:main.c        ****             wysylanie_smsa_clipa = WYSYLANIE_SMSA_WYSYLANIE;
 7286               		.loc 1 1408 0
 7287 26c8 83ED      		ldi r24,lo8(-45)
 7288 26ca 0E94 0000 		call dodaj_komende
 7289               	.LVL557:
1409:main.c        ****           }
 7290               		.loc 1 1409 0
 7291 26ce 81E0      		ldi r24,lo8(1)
 7292 26d0 8093 0000 		sts wysylanie_smsa_clipa,r24
 7293 26d4 00C0      		rjmp .L766
 7294               	.LVL558:
 7295               	.L778:
1373:main.c        ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 7296               		.loc 1 1373 0
 7297 26d6 8091 0000 		lds r24,wysylanie_smsa_clipa
 7298               	.LVL559:
 7299 26da 8823      		tst r24
 7300 26dc 01F4      		brne .+2
 7301 26de 00C0      		rjmp .L803
 7302               	.LVL560:
 7303               	.L771:
1375:main.c        ****       break;
 7304               		.loc 1 1375 0
 7305 26e0 89E8      		ldi r24,lo8(-119)
 7306 26e2 0E94 0000 		call dodaj_komende
 7307               	.LVL561:
 7308               	.L806:
 7309               	.LBE618:
1420:main.c        **** }
 7310               		.loc 1 1420 0
 7311 26e6 CFEF      		ldi r28,lo8(-1)
 7312               	.L766:
1421:main.c        **** 
 7313               		.loc 1 1421 0
 7314 26e8 8C2F      		mov r24,r28
 7315               	/* epilogue start */
 7316 26ea DF91      		pop r29
 7317 26ec CF91      		pop r28
 7318 26ee 1F91      		pop r17
 7319 26f0 0F91      		pop r16
 7320 26f2 FF90      		pop r15
 7321 26f4 EF90      		pop r14
 7322 26f6 DF90      		pop r13
 7323 26f8 CF90      		pop r12
 7324 26fa BF90      		pop r11
 7325 26fc 0895      		ret
 7326               	.LVL562:
 7327               	.L770:
1371:main.c        ****   case KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW: {
 7328               		.loc 1 1371 0
 7329 26fe 8938      		cpi r24,lo8(-119)
 7330 2700 01F0      		breq .L778
 7331               	.LVL563:
 7332               	.L805:
1418:main.c        ****   }
 7333               		.loc 1 1418 0
 7334 2702 C0E0      		ldi r28,0
 7335 2704 00C0      		rjmp .L766
 7336               		.cfi_endproc
 7337               	.LFE60:
 7339               	.global	test_sms_clip_100ms
 7341               	test_sms_clip_100ms:
 7342               	.LFB62:
1435:main.c        ****   // static ulong licznik_sms;
 7343               		.loc 1 1435 0
 7344               		.cfi_startproc
 7345               	/* prologue: function */
 7346               	/* frame size = 0 */
 7347               	/* stack size = 0 */
 7348               	.L__stack_usage = 0
 7349               	/* epilogue start */
1454:main.c        **** 
 7350               		.loc 1 1454 0
 7351 2706 0895      		ret
 7352               		.cfi_endproc
 7353               	.LFE62:
 7355               	.global	steruj_wejscia_wyjscia_100ms
 7357               	steruj_wejscia_wyjscia_100ms:
 7358               	.LFB63:
1456:main.c        ****   aktualizuj_stan_wyzwolenia_wejsc_100ms();
 7359               		.loc 1 1456 0
 7360               		.cfi_startproc
 7361               	/* prologue: function */
 7362               	/* frame size = 0 */
 7363               	/* stack size = 0 */
 7364               	.L__stack_usage = 0
1457:main.c        ****   steruj_wejsciem_reset_100ms();
 7365               		.loc 1 1457 0
 7366 2708 0E94 0000 		call aktualizuj_stan_wyzwolenia_wejsc_100ms
 7367               	.LVL564:
1458:main.c        ****   steruj_wyjscia_100ms();
 7368               		.loc 1 1458 0
 7369 270c 0E94 0000 		call steruj_wejsciem_reset_100ms
 7370               	.LVL565:
1459:main.c        **** }
 7371               		.loc 1 1459 0
 7372 2710 0C94 0000 		jmp steruj_wyjscia_100ms
 7373               	.LVL566:
 7374               		.cfi_endproc
 7375               	.LFE63:
 7377               	.global	zapis_w_eeprom_stanu_wyjsc
 7379               	zapis_w_eeprom_stanu_wyjsc:
 7380               	.LFB64:
1462:main.c        ****   if (not czy_wolny_eeprom())
 7381               		.loc 1 1462 0
 7382               		.cfi_startproc
 7383 2714 CF93      		push r28
 7384               	.LCFI88:
 7385               		.cfi_def_cfa_offset 3
 7386               		.cfi_offset 28, -2
 7387 2716 DF93      		push r29
 7388               	.LCFI89:
 7389               		.cfi_def_cfa_offset 4
 7390               		.cfi_offset 29, -3
 7391 2718 1F92      		push __zero_reg__
 7392               	.LCFI90:
 7393               		.cfi_def_cfa_offset 5
 7394 271a CDB7      		in r28,__SP_L__
 7395 271c DEB7      		in r29,__SP_H__
 7396               	.LCFI91:
 7397               		.cfi_def_cfa_register 28
 7398               	/* prologue: function */
 7399               	/* frame size = 1 */
 7400               	/* stack size = 3 */
 7401               	.L__stack_usage = 3
1463:main.c        ****     return;
 7402               		.loc 1 1463 0
 7403 271e 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 7404 2722 8111      		cpse r24,__zero_reg__
 7405 2724 00C0      		rjmp .L809
1463:main.c        ****     return;
 7406               		.loc 1 1463 0 is_stmt 0 discriminator 1
 7407 2726 8091 0000 		lds r24,liczba_znakow_do_zapisu
 7408 272a 8111      		cpse r24,__zero_reg__
 7409 272c 00C0      		rjmp .L809
1463:main.c        ****     return;
 7410               		.loc 1 1463 0 discriminator 2
 7411 272e 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 7412 2732 8111      		cpse r24,__zero_reg__
 7413 2734 00C0      		rjmp .L809
1463:main.c        ****     return;
 7414               		.loc 1 1463 0 discriminator 3
 7415 2736 F999      		sbic 0x1f,1
 7416 2738 00C0      		rjmp .L809
 7417               	.LBB621:
 7418               	.LBB622:
1465:main.c        ****   if ((stan_wyjscie[0] != 0) ^ (licznik_przelacznik_wyjscia[0] != 0))
 7419               		.loc 1 1465 0 is_stmt 1
 7420 273a 1982      		std Y+1,__zero_reg__
1466:main.c        ****     par |= BIT(0);
 7421               		.loc 1 1466 0
 7422 273c 91E0      		ldi r25,lo8(1)
 7423 273e 8091 0000 		lds r24,stan_wyjscie
 7424 2742 8111      		cpse r24,__zero_reg__
 7425 2744 00C0      		rjmp .L812
 7426 2746 90E0      		ldi r25,0
 7427               	.L812:
 7428 2748 81E0      		ldi r24,lo8(1)
 7429 274a 4091 0000 		lds r20,licznik_przelacznik_wyjscia
 7430 274e 5091 0000 		lds r21,licznik_przelacznik_wyjscia+1
 7431 2752 6091 0000 		lds r22,licznik_przelacznik_wyjscia+2
 7432 2756 7091 0000 		lds r23,licznik_przelacznik_wyjscia+3
 7433 275a 452B      		or r20,r21
 7434 275c 462B      		or r20,r22
 7435 275e 472B      		or r20,r23
 7436 2760 01F4      		brne .L813
 7437 2762 80E0      		ldi r24,0
 7438               	.L813:
 7439 2764 9817      		cp r25,r24
 7440 2766 01F0      		breq .L811
1467:main.c        ****   if (par != eeprom_read_byte((void *)EEPROM_USTAWIENIE_STANOW_WYJSC))
 7441               		.loc 1 1467 0
 7442 2768 81E0      		ldi r24,lo8(1)
 7443 276a 8983      		std Y+1,r24
 7444               	.L811:
1468:main.c        ****     zapisz_znaki_w_eeprom(&par, (uint)EEPROM_USTAWIENIE_STANOW_WYJSC, 1);
 7445               		.loc 1 1468 0
 7446 276c 85E0      		ldi r24,lo8(5)
 7447 276e 90E0      		ldi r25,0
 7448 2770 0E94 0000 		call eeprom_read_byte
 7449               	.LVL567:
 7450 2774 9981      		ldd r25,Y+1
 7451 2776 8917      		cp r24,r25
 7452 2778 01F0      		breq .L809
1469:main.c        **** }
 7453               		.loc 1 1469 0
 7454 277a 41E0      		ldi r20,lo8(1)
 7455 277c 65E0      		ldi r22,lo8(5)
 7456 277e 70E0      		ldi r23,0
 7457 2780 CE01      		movw r24,r28
 7458 2782 0196      		adiw r24,1
 7459 2784 0E94 0000 		call zapisz_znaki_w_eeprom
 7460               	.LVL568:
 7461               	.L809:
 7462               	/* epilogue start */
 7463               	.LBE622:
 7464               	.LBE621:
1470:main.c        **** 
 7465               		.loc 1 1470 0
 7466 2788 0F90      		pop __tmp_reg__
 7467 278a DF91      		pop r29
 7468 278c CF91      		pop r28
 7469 278e 0895      		ret
 7470               		.cfi_endproc
 7471               	.LFE64:
 7473               	.global	steruj_urzadzeniem_100MS
 7475               	steruj_urzadzeniem_100MS:
 7476               	.LFB65:
1485:main.c        ****   steruj_wejscia_wyjscia_100ms();
 7477               		.loc 1 1485 0
 7478               		.cfi_startproc
 7479               	/* prologue: function */
 7480               	/* frame size = 0 */
 7481               	/* stack size = 0 */
 7482               	.L__stack_usage = 0
1486:main.c        ****   steruj_SIM900_100MS();
 7483               		.loc 1 1486 0
 7484 2790 0E94 0000 		call steruj_wejscia_wyjscia_100ms
 7485               	.LVL569:
1487:main.c        ****   if (licznik_100ms_dioda_led) {
 7486               		.loc 1 1487 0
 7487 2794 0E94 0000 		call steruj_SIM900_100MS
 7488               	.LVL570:
1488:main.c        ****     if (--licznik_100ms_dioda_led == 0)
 7489               		.loc 1 1488 0
 7490 2798 8091 0000 		lds r24,licznik_100ms_dioda_led
 7491 279c 8823      		tst r24
 7492 279e 01F0      		breq .L816
1489:main.c        ****       ustaw_stan_led(FALSE);
 7493               		.loc 1 1489 0
 7494 27a0 8150      		subi r24,lo8(-(-1))
 7495 27a2 8093 0000 		sts licznik_100ms_dioda_led,r24
 7496 27a6 8111      		cpse r24,__zero_reg__
 7497 27a8 00C0      		rjmp .L817
1490:main.c        ****     else
 7498               		.loc 1 1490 0 discriminator 1
 7499 27aa 409A      		sbi 0x8,0
 7500               	.L816:
1496:main.c        ****     --timer_report_user_100ms;
 7501               		.loc 1 1496 0
 7502 27ac 8091 0000 		lds r24,timer_report_user_100ms
 7503 27b0 9091 0000 		lds r25,timer_report_user_100ms+1
 7504 27b4 0097      		sbiw r24,0
 7505 27b6 01F0      		breq .L818
1497:main.c        ****     if (timer_report_user_100ms == 0) {
 7506               		.loc 1 1497 0
 7507 27b8 0197      		sbiw r24,1
 7508 27ba 9093 0000 		sts timer_report_user_100ms+1,r25
 7509 27be 8093 0000 		sts timer_report_user_100ms,r24
1498:main.c        ****       // Okno czasowe minelo - resetuj licznik
 7510               		.loc 1 1498 0
 7511 27c2 892B      		or r24,r25
 7512 27c4 01F4      		brne .L819
 7513               	.L818:
1500:main.c        ****     }
 7514               		.loc 1 1500 0
 7515 27c6 1092 0000 		sts licznik_report_user,__zero_reg__
 7516               	.L819:
1510:main.c        ****   if (pierwsza_komenda != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 7517               		.loc 1 1510 0
 7518 27ca 8091 0000 		lds r24,komendy_kolejka
 7519               	.LVL571:
1511:main.c        ****     // Sprawdz czy pierwsza komenda to SMS - jesli tak i stoi zbyt dlugo,
 7520               		.loc 1 1511 0
 7521 27ce 8823      		tst r24
 7522 27d0 01F4      		brne .+2
 7523 27d2 00C0      		rjmp .L820
1514:main.c        ****         pierwsza_komenda <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU) {
 7524               		.loc 1 1514 0
 7525 27d4 9DE2      		ldi r25,lo8(45)
 7526 27d6 980F      		add r25,r24
 7527 27d8 9230      		cpi r25,lo8(2)
 7528 27da 00F0      		brlo .+2
 7529 27dc 00C0      		rjmp .L821
1517:main.c        ****         // Ta sama komenda SMS jest na poczatku kolejki - kolejka moze stac
 7530               		.loc 1 1517 0
 7531 27de 9091 0000 		lds r25,ostatnia_pierwsza_komenda
 7532 27e2 9813      		cpse r25,r24
 7533 27e4 00C0      		rjmp .L821
1519:main.c        ****           ++licznik_kolejka_stoi_100ms;
 7534               		.loc 1 1519 0
 7535 27e6 8091 0000 		lds r24,licznik_kolejka_stoi_100ms
 7536 27ea 9091 0000 		lds r25,licznik_kolejka_stoi_100ms+1
 7537               	.LVL572:
 7538 27ee 8639      		cpi r24,-106
 7539 27f0 9105      		cpc r25,__zero_reg__
 7540 27f2 00F0      		brlo .+2
 7541 27f4 00C0      		rjmp .L823
1520:main.c        ****         else {
 7542               		.loc 1 1520 0
 7543 27f6 0196      		adiw r24,1
 7544 27f8 9093 0000 		sts licznik_kolejka_stoi_100ms+1,r25
 7545 27fc 8093 0000 		sts licznik_kolejka_stoi_100ms,r24
 7546               	.LVL573:
 7547               	.L824:
1559:main.c        ****     if (licznik_watchdog_wysylanie_smsa_100ms < WATCHDOG_WYSYLANIA_SMS_100MS) {
 7548               		.loc 1 1559 0
 7549 2800 8091 0000 		lds r24,flaga_wysylanie_smsa
 7550 2804 8823      		tst r24
 7551 2806 01F4      		brne .+2
 7552 2808 00C0      		rjmp .L826
1560:main.c        ****       ++licznik_watchdog_wysylanie_smsa_100ms;
 7553               		.loc 1 1560 0
 7554 280a 8091 0000 		lds r24,licznik_watchdog_wysylanie_smsa_100ms
 7555 280e 9091 0000 		lds r25,licznik_watchdog_wysylanie_smsa_100ms+1
 7556 2812 8C32      		cpi r24,44
 7557 2814 21E0      		ldi r18,1
 7558 2816 9207      		cpc r25,r18
 7559 2818 00F0      		brlo .+2
 7560 281a 00C0      		rjmp .L827
1561:main.c        ****     } else {
 7561               		.loc 1 1561 0
 7562 281c 0196      		adiw r24,1
 7563 281e 9093 0000 		sts licznik_watchdog_wysylanie_smsa_100ms+1,r25
 7564 2822 8093 0000 		sts licznik_watchdog_wysylanie_smsa_100ms,r24
 7565               	.L828:
1583:main.c        ****     if (watchdog_sms_licznik_100ms < WATCHDOG_SMS_TIMEOUT_100MS)
 7566               		.loc 1 1583 0
 7567 2826 8091 0000 		lds r24,watchdog_sms_aktywny
 7568 282a 8823      		tst r24
 7569 282c 01F4      		brne .+2
 7570 282e 00C0      		rjmp .L830
1584:main.c        ****       ++watchdog_sms_licznik_100ms;
 7571               		.loc 1 1584 0
 7572 2830 8091 0000 		lds r24,watchdog_sms_licznik_100ms
 7573 2834 9091 0000 		lds r25,watchdog_sms_licznik_100ms+1
 7574 2838 8436      		cpi r24,100
 7575 283a 9105      		cpc r25,__zero_reg__
 7576 283c 00F0      		brlo .+2
 7577 283e 00C0      		rjmp .L831
1585:main.c        ****     else {
 7578               		.loc 1 1585 0
 7579 2840 8091 0000 		lds r24,watchdog_sms_licznik_100ms
 7580 2844 9091 0000 		lds r25,watchdog_sms_licznik_100ms+1
 7581 2848 0196      		adiw r24,1
 7582 284a 9093 0000 		sts watchdog_sms_licznik_100ms+1,r25
 7583 284e 8093 0000 		sts watchdog_sms_licznik_100ms,r24
 7584               	.L832:
1598:main.c        ****     ++stan_cyklu_blysku;
 7585               		.loc 1 1598 0
 7586 2852 8091 0000 		lds r24,liczba_blyskow_led
 7587 2856 8823      		tst r24
 7588 2858 01F4      		brne .+2
 7589 285a 00C0      		rjmp .L834
1599:main.c        ****     if (stan_cyklu_blysku >= 6) {
 7590               		.loc 1 1599 0
 7591 285c 9091 0000 		lds r25,stan_cyklu_blysku
 7592 2860 9F5F      		subi r25,lo8(-(1))
 7593 2862 9093 0000 		sts stan_cyklu_blysku,r25
1600:main.c        ****       stan_cyklu_blysku = 0;
 7594               		.loc 1 1600 0
 7595 2866 9630      		cpi r25,lo8(6)
 7596 2868 00F0      		brlo .L835
1601:main.c        ****       --liczba_blyskow_led;
 7597               		.loc 1 1601 0
 7598 286a 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
1602:main.c        ****     }
 7599               		.loc 1 1602 0
 7600 286e 8150      		subi r24,lo8(-(-1))
 7601 2870 8093 0000 		sts liczba_blyskow_led,r24
 7602               	.L835:
1604:main.c        ****     return;
 7603               		.loc 1 1604 0
 7604 2874 8091 0000 		lds r24,stan_cyklu_blysku
 7605 2878 8230      		cpi r24,lo8(2)
 7606 287a 00F4      		brsh .+2
 7607 287c 00C0      		rjmp .L836
1604:main.c        ****     return;
 7608               		.loc 1 1604 0 is_stmt 0 discriminator 1
 7609 287e 409A      		sbi 0x8,0
 7610 2880 0895      		ret
 7611               	.L817:
1492:main.c        ****   }
 7612               		.loc 1 1492 0 is_stmt 1 discriminator 2
 7613 2882 4098      		cbi 0x8,0
 7614 2884 00C0      		rjmp .L816
 7615               	.LVL574:
 7616               	.L823:
1524:main.c        ****                                        KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
 7617               		.loc 1 1524 0
 7618 2886 64ED      		ldi r22,lo8(-44)
 7619 2888 83ED      		ldi r24,lo8(-45)
 7620 288a 0E94 0000 		call filtruj_komendy_z_przedzialu
 7621               	.LVL575:
1526:main.c        ****             ++licznik_awaryjnych_resetow_kolejki;
 7622               		.loc 1 1526 0
 7623 288e 8091 0000 		lds r24,licznik_awaryjnych_resetow_kolejki
 7624 2892 9091 0000 		lds r25,licznik_awaryjnych_resetow_kolejki+1
 7625 2896 8F3F      		cpi r24,-1
 7626 2898 9807      		cpc r25,r24
 7627 289a 01F0      		breq .L825
1527:main.c        **** 
 7628               		.loc 1 1527 0
 7629 289c 0196      		adiw r24,1
 7630 289e 9093 0000 		sts licznik_awaryjnych_resetow_kolejki+1,r25
 7631 28a2 8093 0000 		sts licznik_awaryjnych_resetow_kolejki,r24
 7632               	.L825:
1529:main.c        **** 
 7633               		.loc 1 1529 0
 7634 28a6 82E9      		ldi r24,lo8(-110)
 7635 28a8 0E94 0000 		call filtruj_i_dodaj_komende
 7636               	.LVL576:
1532:main.c        ****           timer_report_user_100ms = 0;
 7637               		.loc 1 1532 0
 7638 28ac 1092 0000 		sts licznik_report_user,__zero_reg__
1533:main.c        **** 
 7639               		.loc 1 1533 0
 7640 28b0 1092 0000 		sts timer_report_user_100ms+1,__zero_reg__
 7641 28b4 1092 0000 		sts timer_report_user_100ms,__zero_reg__
1536:main.c        ****           ostatnia_pierwsza_komenda = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 7642               		.loc 1 1536 0
 7643 28b8 1092 0000 		sts licznik_kolejka_stoi_100ms+1,__zero_reg__
 7644 28bc 1092 0000 		sts licznik_kolejka_stoi_100ms,__zero_reg__
1537:main.c        **** 
 7645               		.loc 1 1537 0
 7646 28c0 1092 0000 		sts ostatnia_pierwsza_komenda,__zero_reg__
1540:main.c        ****         }
 7647               		.loc 1 1540 0
 7648 28c4 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
 7649 28c8 00C0      		rjmp .L824
 7650               	.LVL577:
 7651               	.L821:
1549:main.c        ****       licznik_kolejka_stoi_100ms = 0;
 7652               		.loc 1 1549 0
 7653 28ca 8093 0000 		sts ostatnia_pierwsza_komenda,r24
 7654               	.L865:
1555:main.c        ****   }
 7655               		.loc 1 1555 0
 7656 28ce 1092 0000 		sts licznik_kolejka_stoi_100ms+1,__zero_reg__
 7657 28d2 1092 0000 		sts licznik_kolejka_stoi_100ms,__zero_reg__
 7658 28d6 00C0      		rjmp .L824
 7659               	.L820:
1554:main.c        ****     licznik_kolejka_stoi_100ms = 0;
 7660               		.loc 1 1554 0
 7661 28d8 1092 0000 		sts ostatnia_pierwsza_komenda,__zero_reg__
 7662 28dc 00C0      		rjmp .L865
 7663               	.LVL578:
 7664               	.L827:
1563:main.c        ****       // Awaryjne odblokowanie
 7665               		.loc 1 1563 0
 7666 28de 1092 0000 		sts licznik_watchdog_wysylanie_smsa_100ms+1,__zero_reg__
 7667 28e2 1092 0000 		sts licznik_watchdog_wysylanie_smsa_100ms,__zero_reg__
1565:main.c        ****       flaga_wysylanie_smsa = 0;
 7668               		.loc 1 1565 0
 7669 28e6 0E94 0000 		call watchdog_sms_disarm
 7670               	.LVL579:
1566:main.c        ****       liczba_prob_wyslania_smsa = 0;
 7671               		.loc 1 1566 0
 7672 28ea 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
1567:main.c        ****       czekanie_na_odebranie_zachety = FALSE;
 7673               		.loc 1 1567 0
 7674 28ee 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
1568:main.c        ****       wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
 7675               		.loc 1 1568 0
 7676 28f2 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
1569:main.c        **** 
 7677               		.loc 1 1569 0
 7678 28f6 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
1571:main.c        ****         ++liczba_kolejnych_watchdogow_wysylania;
 7679               		.loc 1 1571 0
 7680 28fa 8091 0000 		lds r24,liczba_kolejnych_watchdogow_wysylania
 7681 28fe 8F3F      		cpi r24,lo8(-1)
 7682 2900 01F0      		breq .L829
1572:main.c        ****       if (liczba_kolejnych_watchdogow_wysylania >= 3) {
 7683               		.loc 1 1572 0
 7684 2902 8F5F      		subi r24,lo8(-(1))
 7685 2904 8093 0000 		sts liczba_kolejnych_watchdogow_wysylania,r24
 7686               	.L829:
1573:main.c        ****         liczba_kolejnych_watchdogow_wysylania = 0;
 7687               		.loc 1 1573 0
 7688 2908 8091 0000 		lds r24,liczba_kolejnych_watchdogow_wysylania
 7689 290c 8330      		cpi r24,lo8(3)
 7690 290e 00F4      		brsh .+2
 7691 2910 00C0      		rjmp .L828
1574:main.c        ****         reset_modulu_SIM900();
 7692               		.loc 1 1574 0
 7693 2912 1092 0000 		sts liczba_kolejnych_watchdogow_wysylania,__zero_reg__
1575:main.c        ****       }
 7694               		.loc 1 1575 0
 7695 2916 0E94 0000 		call reset_modulu_SIM900
 7696               	.LVL580:
 7697 291a 00C0      		rjmp .L828
 7698               	.L826:
1579:main.c        ****     liczba_kolejnych_watchdogow_wysylania = 0;
 7699               		.loc 1 1579 0
 7700 291c 1092 0000 		sts licznik_watchdog_wysylanie_smsa_100ms+1,__zero_reg__
 7701 2920 1092 0000 		sts licznik_watchdog_wysylanie_smsa_100ms,__zero_reg__
1580:main.c        ****   }
 7702               		.loc 1 1580 0
 7703 2924 1092 0000 		sts liczba_kolejnych_watchdogow_wysylania,__zero_reg__
 7704 2928 00C0      		rjmp .L828
 7705               	.L831:
1587:main.c        ****       cli();
 7706               		.loc 1 1587 0
 7707 292a 8FEF      		ldi r24,lo8(-1)
 7708 292c 8093 0000 		sts watchdog_sms_trwa_reset,r24
1588:main.c        ****       wdt_enable(WDTO_15MS);
 7709               		.loc 1 1588 0
 7710               	/* #APP */
 7711               	 ;  1588 "main.c" 1
 7712 2930 F894      		cli
 7713               	 ;  0 "" 2
 7714               	.LVL581:
 7715               	/* #NOAPP */
 7716               	.LBB623:
 7717               	.LBB624:
 7718               		.file 7 "/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h"
   1:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
   5:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
   8:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  11:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      distribution.
  15:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  16:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  20:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  32:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /* $Id$ */
  33:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  34:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /*
  35:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****  */
  37:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  38:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  41:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  44:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /** \file */
  45:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  48:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  57:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  61:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     the following:
  68:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  69:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     \code
  70:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  73:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  75:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     {
  80:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     }
  84:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     \endcode
  85:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  86:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** */
  91:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  92:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /**
  93:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** */
  98:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  99:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 101:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #ifndef __DOXYGEN__
 102:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 103:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined(WDP3)
 104:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 105:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else
 106:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 107:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif
 108:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 109:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 110:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 111:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 112:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 113:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else
 114:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 115:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif
 116:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 117:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined(WDTOE)
 118:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 119:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else
 120:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 121:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif
 122:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 123:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif	/* !__DOXYGEN__ */
 124:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 125:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 126:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /**
 127:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 128:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 129:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 130:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 131:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 132:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 133:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 134:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 135:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** */
 136:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 137:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 138:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 139:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 140:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined (WDT_CTRLA) && !defined(RAMPD)
 141:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 142:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 143:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** do { \
 144:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** uint8_t temp; \
 145:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 146:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"wdr"									"\n\t" \
 147:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]"		"\n\t" \
 148:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"				"\n\t" \
 149:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"sbr %[tmp], %[wdt_enable_timeout]"		"\n\t" \
 150:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"				"\n\t" \
 151:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"1:lds %[tmp], %[wdt_status_reg]"		"\n\t" \
 152:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"sbrc %[tmp], %[wdt_syncbusy_bit]"		"\n\t" \
 153:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"rjmp 1b"								"\n\t" \
 154:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	: [tmp]					"=r" (temp) \
 155:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	: [ccp_reg]				"I"  (_SFR_IO_ADDR(CCP)), \
 156:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [ioreg_cen_mask]		"r"  ((uint8_t)CCP_IOREG_gc), \
 157:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [wdt_reg]				"n"  (_SFR_MEM_ADDR(WDT_CTRLA)), \
 158:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [wdt_enable_timeout]	"M"  (timeout), \
 159:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [wdt_status_reg]		"n"  (_SFR_MEM_ADDR(WDT_STATUS)), \
 160:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [wdt_syncbusy_bit]	"I"  (WDT_SYNCBUSY_bm) \
 161:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ); \
 162:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** } while(0)
 163:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 164:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_disable() \
 165:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** do { \
 166:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** uint8_t temp; \
 167:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 168:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"wdr"								"\n\t" \
 169:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 170:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"			"\n\t" \
 171:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"cbr %[tmp], %[timeout_mask]"       "\n\t" \
 172:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"			"\n\t" \
 173:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [tmp]            "=r" (temp) \
 174:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [ccp_reg]        "I" (_SFR_IO_ADDR(CCP)),       \
 175:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ioreg_cen_mask] "r" ((uint8_t)CCP_IOREG_gc),   \
 176:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_reg]        "n" (_SFR_MEM_ADDR(WDT_CTRLA)),\
 177:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [timeout_mask]   "I" (WDT_PERIOD_gm) \
 178:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ); \
 179:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** } while(0)
 180:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 181:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else // defined (WDT_CTRLA) && !defined(RAMPD)
 182:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 183:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /*
 184:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 185:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 186:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    registers to the CCP register
 187:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ** At the same time,
 188:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 189:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 190:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 191:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 192:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 193:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    sync is finished).
 194:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** */
 195:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 196:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** do { \
 197:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** uint8_t temp; \
 198:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 199:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 200:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 201:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 202:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 203:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 204:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 205:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 206:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 207:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 208:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 209:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 210:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 211:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 212:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 213:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 214:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 215:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : "r0" \
 216:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ); \
 217:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** } while(0)
 218:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 219:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_disable() \
 220:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 221:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 222:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 223:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 224:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 225:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 226:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : \
 227:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 228:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 229:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 230:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 231:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 232:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : "r0" \
 233:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** );
 234:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 235:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif // defined (WDT_CTRLA) && !defined(RAMPD)
 236:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 237:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 238:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 239:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 240:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 241:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 242:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 243:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 244:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 245:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 246:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 247:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : /* no outputs */  \
 248:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 249:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 250:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 251:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 252:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 253:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : "r16" \
 254:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** )
 255:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 256:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_disable() \
 257:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** do { \
 258:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 259:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 260:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 261:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 262:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 263:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 264:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 265:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 266:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 267:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 268:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : /*no output */ \
 269:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 270:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 271:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 272:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 273:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 274:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : "r16" \
 275:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ); \
 276:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** }while(0)
 277:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 278:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #elif defined(CCP)
 279:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 280:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** static __inline__
 281:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 282:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 283:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** {
 284:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 285:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 286:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 287:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 288:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 289:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 290:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 291:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 292:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 293:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: /* no outputs */
 294:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 295:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 296:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 297:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 298:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 299:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: "r0"
 300:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			);
 301:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 302:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 303:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 304:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 305:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 306:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 307:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 308:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 309:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 310:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 311:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: /* no outputs */
 312:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 313:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 314:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 315:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 316:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 317:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: "r0"
 318:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			);
 319:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 320:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 321:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 322:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 323:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 324:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 325:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 326:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 327:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 328:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 329:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: /* no outputs */
 330:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 331:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 332:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 333:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 334:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 335:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: "r0"
 336:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			);
 337:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 338:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else
 339:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****  	{
 340:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 341:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 342:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 343:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 344:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 345:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 346:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 347:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: /* no outputs */
 348:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 349:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 350:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 351:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 352:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 353:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: "r0"
 354:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			);
 355:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 356:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** }
 357:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 358:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** static __inline__
 359:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 360:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** void wdt_disable (void)
 361:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** {
 362:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 363:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 364:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 365:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 366:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 367:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 368:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 369:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 370:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 371:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 372:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 373:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 374:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /*no output */
 375:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 376:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 377:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 378:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 379:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 380:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 381:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				);
 382:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 383:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 384:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 385:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 386:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 387:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 388:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 389:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 390:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 391:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 392:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 393:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 394:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 395:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /*no output */
 396:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 397:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 398:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 399:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 400:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 401:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 402:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				);
 403:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 404:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 405:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 406:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 407:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 408:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 409:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 410:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 411:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 412:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 413:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 414:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 415:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 416:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /*no output */
 417:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 418:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 419:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 420:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 421:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 422:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 423:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				);
 424:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 425:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else
 426:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 427:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 428:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 429:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 430:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 431:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 432:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 433:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 434:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 435:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 436:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 437:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /*no output */
 438:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 439:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 440:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 441:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 442:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 443:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 444:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				);
 445:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 446:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** }
 447:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 448:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else
 449:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 450:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** static __inline__
 451:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 452:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 453:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** {
 454:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 455:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 456:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 457:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 458:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 459:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 460:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 461:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 462:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 463:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /* no outputs */
 464:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 465:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 466:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 467:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 468:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 469:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		);
 470:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 471:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else
 472:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 473:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 7719               		.loc 7 473 0
 7720 2932 88E1      		ldi r24,lo8(24)
 7721 2934 98E0      		ldi r25,lo8(8)
 7722               	/* #APP */
 7723               	 ;  473 "/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h" 1
 7724 2936 0FB6      		in __tmp_reg__,__SREG__
 7725 2938 F894      		cli
 7726 293a A895      		wdr
 7727 293c 8093 6000 		sts 96, r24
 7728 2940 0FBE      		out __SREG__,__tmp_reg__
 7729 2942 9093 6000 		sts 96, r25
 7730               	 	
 7731               	 ;  0 "" 2
 7732               	/* #NOAPP */
 7733               	.L833:
 7734 2946 00C0      		rjmp .L833
 7735               	.LVL582:
 7736               	.L830:
 7737               	.LBE624:
 7738               	.LBE623:
1593:main.c        ****     --watchdog_sms_safe_mode_100ms;
 7739               		.loc 1 1593 0
 7740 2948 8091 0000 		lds r24,watchdog_sms_safe_mode_100ms
 7741 294c 9091 0000 		lds r25,watchdog_sms_safe_mode_100ms+1
 7742 2950 892B      		or r24,r25
 7743 2952 01F4      		brne .+2
 7744 2954 00C0      		rjmp .L832
1594:main.c        ****   }
 7745               		.loc 1 1594 0
 7746 2956 8091 0000 		lds r24,watchdog_sms_safe_mode_100ms
 7747 295a 9091 0000 		lds r25,watchdog_sms_safe_mode_100ms+1
 7748 295e 0197      		sbiw r24,1
 7749 2960 9093 0000 		sts watchdog_sms_safe_mode_100ms+1,r25
 7750 2964 8093 0000 		sts watchdog_sms_safe_mode_100ms,r24
 7751 2968 00C0      		rjmp .L832
 7752               	.L836:
1604:main.c        ****     return;
 7753               		.loc 1 1604 0 discriminator 2
 7754 296a 4098      		cbi 0x8,0
 7755               	/* epilogue start */
1634:main.c        **** 
 7756               		.loc 1 1634 0 discriminator 2
 7757 296c 0895      		ret
 7758               	.L834:
1610:main.c        ****     // Nie zalogowany - dioda swiecei ciagle
 7759               		.loc 1 1610 0
 7760 296e 8091 0000 		lds r24,modul_zalogowany_w_sieci
 7761 2972 8111      		cpse r24,__zero_reg__
 7762 2974 00C0      		rjmp .L838
 7763               	.L843:
 7764               	.LBB625:
1627:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7765               		.loc 1 1627 0 discriminator 6
 7766 2976 4098      		cbi 0x8,0
 7767 2978 00C0      		rjmp .L839
 7768               	.L838:
 7769               	.LBE625:
1615:main.c        ****       // Mrugniecie (SMS, etc.)
 7770               		.loc 1 1615 0
 7771 297a 8091 0000 		lds r24,licznik_100ms_dioda_led
 7772 297e 8111      		cpse r24,__zero_reg__
 7773 2980 00C0      		rjmp .L843
 7774               	.LBB626:
1621:main.c        ****         if (++licznik_dioda_led_poziom_sieci >= 50)
 7775               		.loc 1 1621 0
 7776 2982 8091 0000 		lds r24,poziom_sieci_gsm
 7777 2986 8031      		cpi r24,lo8(16)
 7778 2988 00F4      		brsh .L841
1622:main.c        ****           licznik_dioda_led_poziom_sieci = 1;
 7779               		.loc 1 1622 0
 7780 298a 8091 0000 		lds r24,licznik_dioda_led_poziom_sieci.3737
 7781 298e 8F5F      		subi r24,lo8(-(1))
 7782 2990 8093 0000 		sts licznik_dioda_led_poziom_sieci.3737,r24
 7783 2994 8233      		cpi r24,lo8(50)
 7784 2996 00F0      		brlo .L842
1623:main.c        ****       } else
 7785               		.loc 1 1623 0
 7786 2998 81E0      		ldi r24,lo8(1)
 7787 299a 8093 0000 		sts licznik_dioda_led_poziom_sieci.3737,r24
 7788               	.L842:
1627:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7789               		.loc 1 1627 0
 7790 299e 8091 0000 		lds r24,licznik_dioda_led_poziom_sieci.3737
 7791 29a2 8832      		cpi r24,lo8(40)
 7792 29a4 01F0      		breq .L843
1627:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7793               		.loc 1 1627 0 is_stmt 0 discriminator 1
 7794 29a6 8B32      		cpi r24,lo8(43)
 7795 29a8 01F0      		breq .L843
1627:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7796               		.loc 1 1627 0 discriminator 3
 7797 29aa 8E52      		subi r24,lo8(-(-46))
 7798 29ac 8430      		cpi r24,lo8(4)
 7799 29ae 00F0      		brlo .L843
1627:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7800               		.loc 1 1627 0 discriminator 5
 7801 29b0 409A      		sbi 0x8,0
 7802               	.L839:
 7803               	.LBE626:
1633:main.c        **** }
 7804               		.loc 1 1633 0 is_stmt 1
 7805 29b2 0C94 0000 		jmp zapis_w_eeprom_stanu_wyjsc
 7806               	.LVL583:
 7807               	.L841:
 7808               	.LBB627:
1625:main.c        **** 
 7809               		.loc 1 1625 0
 7810 29b6 1092 0000 		sts licznik_dioda_led_poziom_sieci.3737,__zero_reg__
 7811 29ba 00C0      		rjmp .L842
 7812               	.LBE627:
 7813               		.cfi_endproc
 7814               	.LFE65:
 7816               	.global	steruj_urzadzeniem_10MS
 7818               	steruj_urzadzeniem_10MS:
 7819               	.LFB66:
1636:main.c        ****   steruj_wejscia_10ms();
 7820               		.loc 1 1636 0
 7821               		.cfi_startproc
 7822               	/* prologue: function */
 7823               	/* frame size = 0 */
 7824               	/* stack size = 0 */
 7825               	.L__stack_usage = 0
1637:main.c        ****   steruj_SIM900_10MS();
 7826               		.loc 1 1637 0
 7827 29bc 0E94 0000 		call steruj_wejscia_10ms
 7828               	.LVL584:
1638:main.c        ****   zapisz_bajt_w_EEPROM();
 7829               		.loc 1 1638 0
 7830 29c0 0E94 0000 		call steruj_SIM900_10MS
 7831               	.LVL585:
1639:main.c        ****   // test_dioda_wyjscia();
 7832               		.loc 1 1639 0
 7833 29c4 0C94 0000 		jmp zapisz_bajt_w_EEPROM
 7834               	.LVL586:
 7835               		.cfi_endproc
 7836               	.LFE66:
 7838               	.global	wolne_zdarzenie_timer
 7840               	wolne_zdarzenie_timer:
 7841               	.LFB67:
1644:main.c        ****   WYKONAJ_CLI_SEI(WYLACZ_PRZERWANIE_TIMER());
 7842               		.loc 1 1644 0
 7843               		.cfi_startproc
 7844               	/* prologue: function */
 7845               	/* frame size = 0 */
 7846               	/* stack size = 0 */
 7847               	.L__stack_usage = 0
1645:main.c        ****   if (!CZY_WYKONAC_ZDARZENIE_TIMER()) {
 7848               		.loc 1 1645 0
 7849               	/* #APP */
 7850               	 ;  1645 "main.c" 1
 7851 29c8 F894      		cli
 7852               	 ;  0 "" 2
 7853               	/* #NOAPP */
 7854 29ca 8091 6E00 		lds r24,110
 7855 29ce 8D7F      		andi r24,lo8(-3)
 7856 29d0 8093 6E00 		sts 110,r24
 7857               	/* #APP */
 7858               	 ;  1645 "main.c" 1
 7859 29d4 7894      		sei
 7860               	 ;  0 "" 2
 7861               	 ;  1645 "main.c" 1
 7862 29d6 0000      		nop
 7863               	 ;  0 "" 2
1646:main.c        ****     WYKONAJ_CLI_SEI(WLACZ_PRZERWANIE_TIMER());
 7864               		.loc 1 1646 0
 7865               	/* #NOAPP */
 7866 29d8 8091 0000 		lds r24,wykonaj_zdarzenie_timer
 7867 29dc 8111      		cpse r24,__zero_reg__
 7868 29de 00C0      		rjmp .L868
1647:main.c        ****     return;
 7869               		.loc 1 1647 0
 7870               	/* #APP */
 7871               	 ;  1647 "main.c" 1
 7872 29e0 F894      		cli
 7873               	 ;  0 "" 2
 7874               	/* #NOAPP */
 7875 29e2 8091 6E00 		lds r24,110
 7876 29e6 8260      		ori r24,lo8(2)
 7877 29e8 8093 6E00 		sts 110,r24
 7878               	/* #APP */
 7879               	 ;  1647 "main.c" 1
 7880 29ec 7894      		sei
 7881               	 ;  0 "" 2
 7882               	 ;  1647 "main.c" 1
 7883 29ee 0000      		nop
 7884               	 ;  0 "" 2
1648:main.c        ****   }
 7885               		.loc 1 1648 0
 7886               	/* #NOAPP */
 7887 29f0 0895      		ret
 7888               	.L868:
1650:main.c        ****   if (wykonac_watki_10MS) {
 7889               		.loc 1 1650 0
 7890 29f2 1092 0000 		sts wykonaj_zdarzenie_timer,__zero_reg__
1651:main.c        ****     wykonac_watki = WYKONAJ_WATKI_10MS;
 7891               		.loc 1 1651 0
 7892 29f6 8091 0000 		lds r24,wykonac_watki_10MS
 7893 29fa 8823      		tst r24
 7894 29fc 01F0      		breq .L870
1652:main.c        ****     wykonac_watki_10MS = FALSE;
 7895               		.loc 1 1652 0
 7896 29fe 81E0      		ldi r24,lo8(1)
 7897 2a00 8093 0000 		sts wykonac_watki,r24
1653:main.c        ****   }
 7898               		.loc 1 1653 0
 7899 2a04 1092 0000 		sts wykonac_watki_10MS,__zero_reg__
 7900               	.L870:
1655:main.c        ****   if (CZY_WYKONAC_WATKI_10MS()) {
 7901               		.loc 1 1655 0
 7902               	/* #APP */
 7903               	 ;  1655 "main.c" 1
 7904 2a08 F894      		cli
 7905               	 ;  0 "" 2
 7906               	/* #NOAPP */
 7907 2a0a 8091 6E00 		lds r24,110
 7908 2a0e 8260      		ori r24,lo8(2)
 7909 2a10 8093 6E00 		sts 110,r24
 7910               	/* #APP */
 7911               	 ;  1655 "main.c" 1
 7912 2a14 7894      		sei
 7913               	 ;  0 "" 2
 7914               	 ;  1655 "main.c" 1
 7915 2a16 0000      		nop
 7916               	 ;  0 "" 2
1656:main.c        ****     static uchar licznik_wybuc_watki_100MS = 0;
 7917               		.loc 1 1656 0
 7918               	/* #NOAPP */
 7919 2a18 8091 0000 		lds r24,wykonac_watki
 7920 2a1c 80FF      		sbrs r24,0
 7921 2a1e 00C0      		rjmp .L867
 7922               	.LBB631:
1659:main.c        ****       licznik_wybuc_watki_100MS = 0;
 7923               		.loc 1 1659 0
 7924 2a20 8091 0000 		lds r24,licznik_wybuc_watki_100MS.3744
 7925 2a24 8F5F      		subi r24,lo8(-(1))
 7926 2a26 8A30      		cpi r24,lo8(10)
 7927 2a28 01F0      		breq .L871
 7928 2a2a 8093 0000 		sts licznik_wybuc_watki_100MS.3744,r24
 7929               	.L872:
1663:main.c        ****     cli();
 7930               		.loc 1 1663 0
 7931               	/* #APP */
 7932               	 ;  1663 "main.c" 1
 7933 2a2e 0000      		nop
 7934               	 ;  0 "" 2
1664:main.c        ****     if (CZY_ODBIERANIE_DANYCH_SIM900()) {
 7935               		.loc 1 1664 0
 7936               	 ;  1664 "main.c" 1
 7937 2a30 F894      		cli
 7938               	 ;  0 "" 2
1665:main.c        ****       WYLACZ_PRZERWANIE_ODBIORU_DANYCH_SIM900();
 7939               		.loc 1 1665 0
 7940               	/* #NOAPP */
 7941 2a32 00B6      		in __tmp_reg__,0x30
 7942 2a34 01FE      		sbrs __tmp_reg__,1
 7943 2a36 00C0      		rjmp .L873
1666:main.c        ****       sei();
 7944               		.loc 1 1666 0
 7945 2a38 8091 C100 		lds r24,193
 7946 2a3c 8F77      		andi r24,lo8(127)
 7947 2a3e 8093 C100 		sts 193,r24
1667:main.c        ****       if (liczba_odebranych_znakow_SIM900 != 0 &&
 7948               		.loc 1 1667 0
 7949               	/* #APP */
 7950               	 ;  1667 "main.c" 1
 7951 2a42 7894      		sei
 7952               	 ;  0 "" 2
1668:main.c        ****           ++licznik_opoznienie_oczekiwania_na_bajt_SIM900 >
 7953               		.loc 1 1668 0
 7954               	/* #NOAPP */
 7955 2a44 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 7956 2a48 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
 7957 2a4c 892B      		or r24,r25
 7958 2a4e 01F0      		breq .L874
1669:main.c        ****               MAX_OPOZNIENIE_OCZEKIWANIA_NA_BAJT_SIM900_500_MS) {
 7959               		.loc 1 1669 0
 7960 2a50 8091 0000 		lds r24,licznik_opoznienie_oczekiwania_na_bajt_SIM900
 7961 2a54 8F5F      		subi r24,lo8(-(1))
1668:main.c        ****           ++licznik_opoznienie_oczekiwania_na_bajt_SIM900 >
 7962               		.loc 1 1668 0
 7963 2a56 8093 0000 		sts licznik_opoznienie_oczekiwania_na_bajt_SIM900,r24
 7964 2a5a 8333      		cpi r24,lo8(51)
 7965 2a5c 00F0      		brlo .L874
1671:main.c        ****       } else {
 7966               		.loc 1 1671 0
 7967 2a5e 459A      		sbi 0x8,5
 7968 2a60 8091 C100 		lds r24,193
 7969 2a64 8F77      		andi r24,lo8(127)
 7970 2a66 8093 C100 		sts 193,r24
 7971 2a6a 80B7      		in r24,0x30
 7972 2a6c 8D7F      		andi r24,lo8(-3)
 7973 2a6e 80BF      		out 0x30,r24
 7974 2a70 1092 0000 		sts poczatek_polecenia_SIM900+1,__zero_reg__
 7975 2a74 1092 0000 		sts poczatek_polecenia_SIM900,__zero_reg__
 7976 2a78 1092 0000 		sts zakonczenie_polecenia_SIM900+1,__zero_reg__
 7977 2a7c 1092 0000 		sts zakonczenie_polecenia_SIM900,__zero_reg__
 7978 2a80 1092 0000 		sts czy_jest_nowe_polecenie_SIM900,__zero_reg__
 7979               	.L873:
1676:main.c        ****   }
 7980               		.loc 1 1676 0
 7981               	/* #APP */
 7982               	 ;  1676 "main.c" 1
 7983 2a84 7894      		sei
 7984               	 ;  0 "" 2
 7985               	/* #NOAPP */
 7986               	.L867:
 7987               	/* epilogue start */
 7988               	.LBE631:
1678:main.c        **** 
 7989               		.loc 1 1678 0
 7990 2a86 0895      		ret
 7991               	.L871:
 7992               	.LBB632:
1660:main.c        ****       wykonac_watki = WYKONAJ_WATKI_100MS | WYKONAJ_WATKI_10MS;
 7993               		.loc 1 1660 0
 7994 2a88 1092 0000 		sts licznik_wybuc_watki_100MS.3744,__zero_reg__
1661:main.c        ****     }
 7995               		.loc 1 1661 0
 7996 2a8c 83E0      		ldi r24,lo8(3)
 7997 2a8e 8093 0000 		sts wykonac_watki,r24
 7998 2a92 00C0      		rjmp .L872
 7999               	.L874:
1673:main.c        ****       }
 8000               		.loc 1 1673 0
 8001               	/* #APP */
 8002               	 ;  1673 "main.c" 1
 8003 2a94 F894      		cli
 8004               	 ;  0 "" 2
 8005               	/* #NOAPP */
 8006 2a96 8091 C100 		lds r24,193
 8007 2a9a 8068      		ori r24,lo8(-128)
 8008 2a9c 8093 C100 		sts 193,r24
 8009               	/* #APP */
 8010               	 ;  1673 "main.c" 1
 8011 2aa0 7894      		sei
 8012               	 ;  0 "" 2
 8013               	 ;  1673 "main.c" 1
 8014 2aa2 0000      		nop
 8015               	 ;  0 "" 2
 8016               	/* #NOAPP */
 8017 2aa4 00C0      		rjmp .L873
 8018               	.LBE632:
 8019               		.cfi_endproc
 8020               	.LFE67:
 8022               	.global	ustaw_parametry_dla_bezpieczenstwa
 8024               	ustaw_parametry_dla_bezpieczenstwa:
 8025               	.LFB68:
1680:main.c        ****   wdt_reset();
 8026               		.loc 1 1680 0
 8027               		.cfi_startproc
 8028               	/* prologue: function */
 8029               	/* frame size = 0 */
 8030               	/* stack size = 0 */
 8031               	.L__stack_usage = 0
1681:main.c        ****   ustaw_parametry_dla_bezpieczenstwa_rejestry();
 8032               		.loc 1 1681 0
 8033               	/* #APP */
 8034               	 ;  1681 "main.c" 1
 8035 2aa6 A895      		wdr
 8036               	 ;  0 "" 2
1682:main.c        ****   set_sleep_mode(SLEEP_MODE_IDLE);
 8037               		.loc 1 1682 0
 8038               	/* #NOAPP */
 8039 2aa8 82E0      		ldi r24,lo8(2)
 8040 2aaa 84BD      		out 0x24,r24
 8041 2aac 83E0      		ldi r24,lo8(3)
 8042 2aae 85BD      		out 0x25,r24
 8043 2ab0 8FE3      		ldi r24,lo8(63)
 8044 2ab2 87BD      		out 0x27,r24
 8045 2ab4 EEE6      		ldi r30,lo8(110)
 8046 2ab6 F0E0      		ldi r31,0
 8047 2ab8 8081      		ld r24,Z
 8048 2aba 8260      		ori r24,lo8(2)
 8049 2abc 8083      		st Z,r24
1683:main.c        **** }
 8050               		.loc 1 1683 0
 8051 2abe 83B7      		in r24,0x33
 8052 2ac0 817F      		andi r24,lo8(-15)
 8053 2ac2 83BF      		out 0x33,r24
 8054               	/* epilogue start */
1684:main.c        **** 
 8055               		.loc 1 1684 0
 8056 2ac4 0895      		ret
 8057               		.cfi_endproc
 8058               	.LFE68:
 8060               	.global	inicjalizuj_parametry_modulu
 8062               	inicjalizuj_parametry_modulu:
 8063               	.LFB69:
1686:main.c        ****   memcpy_E(kod_modulu, ADRES_EEPROM_KOD_DOSTEPU, LICZBA_BAJTOW_KODU_DOSTEPU);
 8064               		.loc 1 1686 0
 8065               		.cfi_startproc
 8066 2ac6 CF93      		push r28
 8067               	.LCFI92:
 8068               		.cfi_def_cfa_offset 3
 8069               		.cfi_offset 28, -2
 8070 2ac8 DF93      		push r29
 8071               	.LCFI93:
 8072               		.cfi_def_cfa_offset 4
 8073               		.cfi_offset 29, -3
 8074               	/* prologue: function */
 8075               	/* frame size = 0 */
 8076               	/* stack size = 2 */
 8077               	.L__stack_usage = 2
1687:main.c        **** 
 8078               		.loc 1 1687 0
 8079 2aca 44E0      		ldi r20,lo8(4)
 8080 2acc 50E0      		ldi r21,0
 8081 2ace 61E0      		ldi r22,lo8(1)
 8082 2ad0 70E0      		ldi r23,0
 8083 2ad2 80E0      		ldi r24,lo8(kod_modulu)
 8084 2ad4 90E0      		ldi r25,hi8(kod_modulu)
 8085 2ad6 0E94 0000 		call eeprom_read_block
 8086               	.LVL587:
1690:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8087               		.loc 1 1690 0
 8088 2ada 8091 0000 		lds r24,kod_modulu
 8089 2ade 8150      		subi r24,lo8(-(-1))
 8090 2ae0 8E3F      		cpi r24,lo8(-2)
 8091 2ae2 00F0      		brlo .L889
1691:main.c        ****     kod_modulu[1] = bufor_eeprom[1] = 'B';
 8092               		.loc 1 1691 0
 8093 2ae4 81E4      		ldi r24,lo8(65)
 8094 2ae6 8093 0000 		sts bufor_eeprom,r24
 8095 2aea 8093 0000 		sts kod_modulu,r24
1692:main.c        ****     kod_modulu[2] = bufor_eeprom[2] = 'C';
 8096               		.loc 1 1692 0
 8097 2aee 82E4      		ldi r24,lo8(66)
 8098 2af0 8093 0000 		sts bufor_eeprom+1,r24
 8099 2af4 8093 0000 		sts kod_modulu+1,r24
1693:main.c        ****     kod_modulu[3] = bufor_eeprom[3] = 'D';
 8100               		.loc 1 1693 0
 8101 2af8 83E4      		ldi r24,lo8(67)
 8102 2afa 8093 0000 		sts bufor_eeprom+2,r24
 8103 2afe 8093 0000 		sts kod_modulu+2,r24
1694:main.c        ****     // Zapisz do EEPROM natychmiast (BLOCKING)
 8104               		.loc 1 1694 0
 8105 2b02 84E4      		ldi r24,lo8(68)
 8106 2b04 8093 0000 		sts bufor_eeprom+3,r24
 8107 2b08 8093 0000 		sts kod_modulu+3,r24
 8108               	.L890:
1696:main.c        ****       ;
 8109               		.loc 1 1696 0 discriminator 1
 8110 2b0c F999      		sbic 0x1f,1
 8111 2b0e 00C0      		rjmp .L890
1698:main.c        ****                         LICZBA_BAJTOW_KODU_DOSTEPU);
 8112               		.loc 1 1698 0
 8113 2b10 44E0      		ldi r20,lo8(4)
 8114 2b12 50E0      		ldi r21,0
 8115 2b14 61E0      		ldi r22,lo8(1)
 8116 2b16 70E0      		ldi r23,0
 8117 2b18 80E0      		ldi r24,lo8(kod_modulu)
 8118 2b1a 90E0      		ldi r25,hi8(kod_modulu)
 8119 2b1c 0E94 0000 		call eeprom_update_block
 8120               	.LVL588:
 8121               	.L889:
1704:main.c        ****   if (tryb_pracy == 0xFF) {
 8122               		.loc 1 1704 0
 8123 2b20 8EEF      		ldi r24,lo8(-2)
 8124 2b22 9FE0      		ldi r25,lo8(15)
 8125 2b24 0E94 0000 		call eeprom_read_byte
 8126               	.LVL589:
1705:main.c        ****     tryb_pracy = 1; // Domyślnie Publiczny
 8127               		.loc 1 1705 0
 8128 2b28 8F3F      		cpi r24,lo8(-1)
 8129 2b2a 01F4      		brne .+2
 8130 2b2c 00C0      		rjmp .L891
1704:main.c        ****   if (tryb_pracy == 0xFF) {
 8131               		.loc 1 1704 0
 8132 2b2e 8093 0000 		sts tryb_pracy,r24
 8133               	.L892:
1713:main.c        ****   if (tryb_clip == 0xFF) {
 8134               		.loc 1 1713 0
 8135 2b32 8FEF      		ldi r24,lo8(-1)
 8136 2b34 9FE0      		ldi r25,lo8(15)
 8137 2b36 0E94 0000 		call eeprom_read_byte
 8138               	.LVL590:
1714:main.c        ****     tryb_clip = 1; // Domyślnie CLIP (1)
 8139               		.loc 1 1714 0
 8140 2b3a 8F3F      		cpi r24,lo8(-1)
 8141 2b3c 01F4      		brne .+2
 8142 2b3e 00C0      		rjmp .L894
1713:main.c        ****   if (tryb_clip == 0xFF) {
 8143               		.loc 1 1713 0
 8144 2b40 8093 0000 		sts tryb_clip,r24
 8145               	.L895:
1722:main.c        ****   czas_start_m = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_START_M);
 8146               		.loc 1 1722 0
 8147 2b44 8AEF      		ldi r24,lo8(-6)
 8148 2b46 9FE0      		ldi r25,lo8(15)
 8149 2b48 0E94 0000 		call eeprom_read_byte
 8150               	.LVL591:
 8151 2b4c 8093 0000 		sts czas_start_h,r24
1723:main.c        ****   czas_stop_h = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_STOP_H);
 8152               		.loc 1 1723 0
 8153 2b50 8BEF      		ldi r24,lo8(-5)
 8154 2b52 9FE0      		ldi r25,lo8(15)
 8155 2b54 0E94 0000 		call eeprom_read_byte
 8156               	.LVL592:
 8157 2b58 8093 0000 		sts czas_start_m,r24
1724:main.c        ****   czas_stop_m = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_STOP_M);
 8158               		.loc 1 1724 0
 8159 2b5c 8CEF      		ldi r24,lo8(-4)
 8160 2b5e 9FE0      		ldi r25,lo8(15)
 8161 2b60 0E94 0000 		call eeprom_read_byte
 8162               	.LVL593:
 8163 2b64 8093 0000 		sts czas_stop_h,r24
1725:main.c        **** 
 8164               		.loc 1 1725 0
 8165 2b68 8DEF      		ldi r24,lo8(-3)
 8166 2b6a 9FE0      		ldi r25,lo8(15)
 8167 2b6c 0E94 0000 		call eeprom_read_byte
 8168               	.LVL594:
 8169 2b70 8093 0000 		sts czas_stop_m,r24
1728:main.c        ****   if (skryba_wlaczona == 0xFF)
 8170               		.loc 1 1728 0
 8171 2b74 89EF      		ldi r24,lo8(-7)
 8172 2b76 9FE0      		ldi r25,lo8(15)
 8173 2b78 0E94 0000 		call eeprom_read_byte
 8174               	.LVL595:
1729:main.c        ****     skryba_wlaczona = FALSE;
 8175               		.loc 1 1729 0
 8176 2b7c 8F3F      		cpi r24,lo8(-1)
 8177 2b7e 01F4      		brne .+2
 8178 2b80 00C0      		rjmp .L897
1728:main.c        ****   if (skryba_wlaczona == 0xFF)
 8179               		.loc 1 1728 0
 8180 2b82 8093 0000 		sts skryba_wlaczona,r24
 8181               	.L898:
1733:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA_LIMIT_L);
 8182               		.loc 1 1733 0
 8183 2b86 85EF      		ldi r24,lo8(-11)
 8184 2b88 9FE0      		ldi r25,lo8(15)
 8185 2b8a 0E94 0000 		call eeprom_read_byte
 8186               	.LVL596:
 8187 2b8e C82F      		mov r28,r24
 8188               	.LVL597:
1735:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA_LIMIT_H);
 8189               		.loc 1 1735 0
 8190 2b90 86EF      		ldi r24,lo8(-10)
 8191 2b92 9FE0      		ldi r25,lo8(15)
 8192               	.LVL598:
 8193 2b94 0E94 0000 		call eeprom_read_byte
 8194               	.LVL599:
1737:main.c        ****     // Nie ustawiono - domyslnie 800
 8195               		.loc 1 1737 0
 8196 2b98 CF3F      		cpi r28,lo8(-1)
 8197 2b9a 01F0      		breq .+2
 8198 2b9c 00C0      		rjmp .L899
1737:main.c        ****     // Nie ustawiono - domyslnie 800
 8199               		.loc 1 1737 0 is_stmt 0 discriminator 1
 8200 2b9e 8F3F      		cpi r24,lo8(-1)
 8201 2ba0 01F0      		breq .+2
 8202 2ba2 00C0      		rjmp .L899
 8203               	.LVL600:
 8204               	.L901:
1739:main.c        ****   } else {
 8205               		.loc 1 1739 0 is_stmt 1
 8206 2ba4 80E2      		ldi r24,lo8(32)
 8207 2ba6 93E0      		ldi r25,lo8(3)
 8208 2ba8 9093 0000 		sts skryba_limit+1,r25
 8209 2bac 8093 0000 		sts skryba_limit,r24
 8210               	.L900:
1748:main.c        **** 
 8211               		.loc 1 1748 0
 8212 2bb0 81E0      		ldi r24,lo8(1)
 8213 2bb2 9091 0000 		lds r25,skryba_wlaczona
 8214 2bb6 9111      		cpse r25,__zero_reg__
 8215 2bb8 00C0      		rjmp .L902
 8216 2bba 80E0      		ldi r24,0
 8217               	.L902:
 8218 2bbc 6091 0000 		lds r22,skryba_limit
 8219 2bc0 0E94 0000 		call zapisz_debug_do_eeprom
 8220               	.LVL601:
1752:main.c        ****       (czas_start_m > 59 && czas_start_m != 0xFF) ||
 8221               		.loc 1 1752 0
 8222 2bc4 8091 0000 		lds r24,czas_start_h
 8223 2bc8 8851      		subi r24,lo8(-(-24))
 8224 2bca 873E      		cpi r24,lo8(-25)
 8225 2bcc 00F0      		brlo .L921
1753:main.c        ****       (czas_stop_h > 23 && czas_stop_h != 0xFF) ||
 8226               		.loc 1 1753 0 discriminator 1
 8227 2bce 8091 0000 		lds r24,czas_start_m
 8228 2bd2 8C53      		subi r24,lo8(-(-60))
1752:main.c        ****       (czas_start_m > 59 && czas_start_m != 0xFF) ||
 8229               		.loc 1 1752 0 discriminator 1
 8230 2bd4 833C      		cpi r24,lo8(-61)
 8231 2bd6 00F0      		brlo .L921
1754:main.c        ****       (czas_stop_m > 59 && czas_stop_m != 0xFF)) {
 8232               		.loc 1 1754 0
 8233 2bd8 8091 0000 		lds r24,czas_stop_h
 8234 2bdc 8851      		subi r24,lo8(-(-24))
1753:main.c        ****       (czas_stop_h > 23 && czas_stop_h != 0xFF) ||
 8235               		.loc 1 1753 0
 8236 2bde 873E      		cpi r24,lo8(-25)
 8237 2be0 00F0      		brlo .L921
1755:main.c        ****     // Zapisz wartosci wylaczajace (0xFF) - BLOCKING
 8238               		.loc 1 1755 0
 8239 2be2 8091 0000 		lds r24,czas_stop_m
 8240 2be6 8C53      		subi r24,lo8(-(-60))
1754:main.c        ****       (czas_stop_m > 59 && czas_stop_m != 0xFF)) {
 8241               		.loc 1 1754 0
 8242 2be8 833C      		cpi r24,lo8(-61)
 8243 2bea 00F4      		brsh .L904
 8244               	.L921:
1757:main.c        ****       ;
 8245               		.loc 1 1757 0 discriminator 1
 8246 2bec F999      		sbic 0x1f,1
 8247 2bee 00C0      		rjmp .L921
1759:main.c        ****     while (!eeprom_is_ready())
 8248               		.loc 1 1759 0
 8249 2bf0 6FEF      		ldi r22,lo8(-1)
 8250 2bf2 8AEF      		ldi r24,lo8(-6)
 8251 2bf4 9FE0      		ldi r25,lo8(15)
 8252 2bf6 0E94 0000 		call eeprom_update_byte
 8253               	.LVL602:
 8254               	.L905:
1760:main.c        ****       ;
 8255               		.loc 1 1760 0 discriminator 1
 8256 2bfa F999      		sbic 0x1f,1
 8257 2bfc 00C0      		rjmp .L905
1762:main.c        ****     while (!eeprom_is_ready())
 8258               		.loc 1 1762 0
 8259 2bfe 6FEF      		ldi r22,lo8(-1)
 8260 2c00 8BEF      		ldi r24,lo8(-5)
 8261 2c02 9FE0      		ldi r25,lo8(15)
 8262 2c04 0E94 0000 		call eeprom_update_byte
 8263               	.LVL603:
 8264               	.L906:
1763:main.c        ****       ;
 8265               		.loc 1 1763 0 discriminator 1
 8266 2c08 F999      		sbic 0x1f,1
 8267 2c0a 00C0      		rjmp .L906
1765:main.c        ****     while (!eeprom_is_ready())
 8268               		.loc 1 1765 0
 8269 2c0c 6FEF      		ldi r22,lo8(-1)
 8270 2c0e 8CEF      		ldi r24,lo8(-4)
 8271 2c10 9FE0      		ldi r25,lo8(15)
 8272 2c12 0E94 0000 		call eeprom_update_byte
 8273               	.LVL604:
 8274               	.L907:
1766:main.c        ****       ;
 8275               		.loc 1 1766 0 discriminator 1
 8276 2c16 F999      		sbic 0x1f,1
 8277 2c18 00C0      		rjmp .L907
1768:main.c        **** 
 8278               		.loc 1 1768 0
 8279 2c1a 6FEF      		ldi r22,lo8(-1)
 8280 2c1c 8DEF      		ldi r24,lo8(-3)
 8281 2c1e 9FE0      		ldi r25,lo8(15)
 8282 2c20 0E94 0000 		call eeprom_update_byte
 8283               	.LVL605:
1770:main.c        ****     czas_start_m = 0xFF;
 8284               		.loc 1 1770 0
 8285 2c24 8FEF      		ldi r24,lo8(-1)
 8286 2c26 8093 0000 		sts czas_start_h,r24
1771:main.c        ****     czas_stop_h = 0xFF;
 8287               		.loc 1 1771 0
 8288 2c2a 8093 0000 		sts czas_start_m,r24
1772:main.c        ****     czas_stop_m = 0xFF;
 8289               		.loc 1 1772 0
 8290 2c2e 8093 0000 		sts czas_stop_h,r24
1773:main.c        ****   }
 8291               		.loc 1 1773 0
 8292 2c32 8093 0000 		sts czas_stop_m,r24
 8293               	.L904:
1776:main.c        ****       FALSE; // Domyślnie odblokowane, zaktualizuje sie przy odczycie czasu
 8294               		.loc 1 1776 0
 8295 2c36 1092 0000 		sts blokada_sterowania_czasowa,__zero_reg__
1781:main.c        ****   if (blokada_systemu == 0xFF) {
 8296               		.loc 1 1781 0
 8297 2c3a 87EF      		ldi r24,lo8(-9)
 8298 2c3c 9FE0      		ldi r25,lo8(15)
 8299 2c3e 0E94 0000 		call eeprom_read_byte
 8300               	.LVL606:
1782:main.c        ****     blokada_systemu = FALSE; // Domyślnie odblokowany
 8301               		.loc 1 1782 0
 8302 2c42 8F3F      		cpi r24,lo8(-1)
 8303 2c44 01F4      		brne .+2
 8304 2c46 00C0      		rjmp .L908
1780:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_BLOKADA_SYSTEMU);
 8305               		.loc 1 1780 0
 8306 2c48 8093 0000 		sts blokada_systemu,r24
 8307               	.L909:
1686:main.c        ****   memcpy_E(kod_modulu, ADRES_EEPROM_KOD_DOSTEPU, LICZBA_BAJTOW_KODU_DOSTEPU);
 8308               		.loc 1 1686 0
 8309 2c4c C0EF      		ldi r28,lo8(-16)
 8310 2c4e DFE0      		ldi r29,lo8(15)
 8311               	.LVL607:
 8312               	.L912:
 8313               	.LBB633:
1789:main.c        ****       while (!eeprom_is_ready())
 8314               		.loc 1 1789 0
 8315 2c50 CE01      		movw r24,r28
 8316 2c52 0E94 0000 		call eeprom_read_byte
 8317               	.LVL608:
 8318 2c56 8F3F      		cpi r24,lo8(-1)
 8319 2c58 01F4      		brne .L910
 8320               	.L911:
1790:main.c        ****         ;
 8321               		.loc 1 1790 0 discriminator 1
 8322 2c5a F999      		sbic 0x1f,1
 8323 2c5c 00C0      		rjmp .L911
1792:main.c        ****     }
 8324               		.loc 1 1792 0
 8325 2c5e 60E0      		ldi r22,0
 8326 2c60 CE01      		movw r24,r28
 8327 2c62 0E94 0000 		call eeprom_update_byte
 8328               	.LVL609:
 8329               	.L910:
1788:main.c        ****     if (eeprom_read_byte((const uint8_t *)addr) == 0xFF) {
 8330               		.loc 1 1788 0
 8331 2c66 2196      		adiw r28,1
 8332               	.LVL610:
1787:main.c        ****        addr <= ADRES_EEPROM_DEBUG_SKRYBA_5; ++addr) {
 8333               		.loc 1 1787 0
 8334 2c68 C53F      		cpi r28,-11
 8335 2c6a 8FE0      		ldi r24,15
 8336 2c6c D807      		cpc r29,r24
 8337 2c6e 01F4      		brne .L912
 8338               	.LBE633:
 8339               	.LBB634:
1797:main.c        ****        addr <= ADRES_EEPROM_DEBUG_USER_7; ++addr) {
 8340               		.loc 1 1797 0
 8341 2c70 C6EE      		ldi r28,lo8(-26)
 8342 2c72 DFE0      		ldi r29,lo8(15)
 8343               	.LVL611:
 8344               	.L915:
1799:main.c        ****       while (!eeprom_is_ready())
 8345               		.loc 1 1799 0
 8346 2c74 CE01      		movw r24,r28
 8347 2c76 0E94 0000 		call eeprom_read_byte
 8348               	.LVL612:
 8349 2c7a 8F3F      		cpi r24,lo8(-1)
 8350 2c7c 01F4      		brne .L913
 8351               	.L914:
1800:main.c        ****         ;
 8352               		.loc 1 1800 0 discriminator 1
 8353 2c7e F999      		sbic 0x1f,1
 8354 2c80 00C0      		rjmp .L914
1802:main.c        ****     }
 8355               		.loc 1 1802 0
 8356 2c82 60E0      		ldi r22,0
 8357 2c84 CE01      		movw r24,r28
 8358 2c86 0E94 0000 		call eeprom_update_byte
 8359               	.LVL613:
 8360               	.L913:
1798:main.c        ****     if (eeprom_read_byte((const uint8_t *)addr) == 0xFF) {
 8361               		.loc 1 1798 0
 8362 2c8a 2196      		adiw r28,1
 8363               	.LVL614:
1797:main.c        ****        addr <= ADRES_EEPROM_DEBUG_USER_7; ++addr) {
 8364               		.loc 1 1797 0
 8365 2c8c CD3E      		cpi r28,-19
 8366 2c8e 2FE0      		ldi r18,15
 8367 2c90 D207      		cpc r29,r18
 8368 2c92 01F4      		brne .L915
 8369               	.LBE634:
1808:main.c        ****   timer_report_user_100ms = 0;
 8370               		.loc 1 1808 0
 8371 2c94 1092 0000 		sts licznik_report_user,__zero_reg__
1809:main.c        **** 
 8372               		.loc 1 1809 0
 8373 2c98 1092 0000 		sts timer_report_user_100ms+1,__zero_reg__
 8374 2c9c 1092 0000 		sts timer_report_user_100ms,__zero_reg__
1812:main.c        **** 
 8375               		.loc 1 1812 0
 8376 2ca0 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
1816:main.c        ****     ++licznik_resetow;
 8377               		.loc 1 1816 0
 8378 2ca4 8091 0000 		lds r24,licznik_resetow.3788
 8379 2ca8 8F3F      		cpi r24,lo8(-1)
 8380 2caa 01F0      		breq .L917
1817:main.c        ****   while (!eeprom_is_ready())
 8381               		.loc 1 1817 0
 8382 2cac 8F5F      		subi r24,lo8(-(1))
 8383 2cae 8093 0000 		sts licznik_resetow.3788,r24
 8384               	.L917:
1818:main.c        ****     ;
 8385               		.loc 1 1818 0 discriminator 1
 8386 2cb2 F999      		sbic 0x1f,1
 8387 2cb4 00C0      		rjmp .L917
1820:main.c        ****   while (!eeprom_is_ready())
 8388               		.loc 1 1820 0
 8389 2cb6 6091 0000 		lds r22,licznik_resetow.3788
 8390 2cba 8CED      		ldi r24,lo8(-36)
 8391 2cbc 9FE0      		ldi r25,lo8(15)
 8392 2cbe 0E94 0000 		call eeprom_update_byte
 8393               	.LVL615:
 8394               	.L918:
1821:main.c        ****     ;
 8395               		.loc 1 1821 0 discriminator 1
 8396 2cc2 F999      		sbic 0x1f,1
 8397 2cc4 00C0      		rjmp .L918
1823:main.c        **** }
 8398               		.loc 1 1823 0
 8399 2cc6 62E0      		ldi r22,lo8(2)
 8400 2cc8 80E0      		ldi r24,0
 8401               	/* epilogue start */
1824:main.c        **** 
 8402               		.loc 1 1824 0
 8403 2cca DF91      		pop r29
 8404 2ccc CF91      		pop r28
 8405               	.LVL616:
1823:main.c        **** }
 8406               		.loc 1 1823 0
 8407 2cce 0C94 0000 		jmp zapisz_debug_do_eeprom
 8408               	.LVL617:
 8409               	.L891:
1706:main.c        ****     while (!eeprom_is_ready())
 8410               		.loc 1 1706 0
 8411 2cd2 81E0      		ldi r24,lo8(1)
 8412 2cd4 8093 0000 		sts tryb_pracy,r24
 8413               	.L893:
1707:main.c        ****       ;
 8414               		.loc 1 1707 0 discriminator 1
 8415 2cd8 F999      		sbic 0x1f,1
 8416 2cda 00C0      		rjmp .L893
1709:main.c        ****   }
 8417               		.loc 1 1709 0
 8418 2cdc 61E0      		ldi r22,lo8(1)
 8419 2cde 8EEF      		ldi r24,lo8(-2)
 8420 2ce0 9FE0      		ldi r25,lo8(15)
 8421 2ce2 0E94 0000 		call eeprom_update_byte
 8422               	.LVL618:
 8423 2ce6 00C0      		rjmp .L892
 8424               	.L894:
1715:main.c        ****     while (!eeprom_is_ready())
 8425               		.loc 1 1715 0
 8426 2ce8 81E0      		ldi r24,lo8(1)
 8427 2cea 8093 0000 		sts tryb_clip,r24
 8428               	.L896:
1716:main.c        ****       ;
 8429               		.loc 1 1716 0 discriminator 1
 8430 2cee F999      		sbic 0x1f,1
 8431 2cf0 00C0      		rjmp .L896
1718:main.c        ****   }
 8432               		.loc 1 1718 0
 8433 2cf2 61E0      		ldi r22,lo8(1)
 8434 2cf4 8FEF      		ldi r24,lo8(-1)
 8435 2cf6 9FE0      		ldi r25,lo8(15)
 8436 2cf8 0E94 0000 		call eeprom_update_byte
 8437               	.LVL619:
 8438 2cfc 00C0      		rjmp .L895
 8439               	.L897:
1730:main.c        **** 
 8440               		.loc 1 1730 0
 8441 2cfe 1092 0000 		sts skryba_wlaczona,__zero_reg__
 8442 2d02 00C0      		rjmp .L898
 8443               	.LVL620:
 8444               	.L899:
1741:main.c        ****     // Walidacja zakresu
 8445               		.loc 1 1741 0
 8446 2d04 982F      		mov r25,r24
 8447 2d06 8C2F      		mov r24,r28
 8448               	.LVL621:
 8449 2d08 9093 0000 		sts skryba_limit+1,r25
 8450 2d0c 8093 0000 		sts skryba_limit,r24
1743:main.c        ****       skryba_limit = 800;
 8451               		.loc 1 1743 0
 8452 2d10 0197      		sbiw r24,1
 8453 2d12 8032      		cpi r24,32
 8454 2d14 9340      		sbci r25,3
 8455 2d16 00F0      		brlo .+2
 8456 2d18 00C0      		rjmp .L901
 8457 2d1a 00C0      		rjmp .L900
 8458               	.LVL622:
 8459               	.L908:
1783:main.c        ****   }
 8460               		.loc 1 1783 0
 8461 2d1c 1092 0000 		sts blokada_systemu,__zero_reg__
 8462 2d20 00C0      		rjmp .L909
 8463               		.cfi_endproc
 8464               	.LFE69:
 8466               		.section	.rodata.str1.1
 8467               	.LC7:
 8468 00a8 5375 7065 		.string	"Super User dodany na pozycji %u"
 8468      7220 5573 
 8468      6572 2064 
 8468      6F64 616E 
 8468      7920 6E61 
 8469               		.text
 8470               	.global	wykonanie_komend_ukladow
 8472               	wykonanie_komend_ukladow:
 8473               	.LFB59:
 868:main.c        ****   const komenda_typ aktualnie_wykonywana_komenda = komendy_kolejka[0];
 8474               		.loc 1 868 0
 8475               		.cfi_startproc
 8476 2d22 CF92      		push r12
 8477               	.LCFI94:
 8478               		.cfi_def_cfa_offset 3
 8479               		.cfi_offset 12, -2
 8480 2d24 DF92      		push r13
 8481               	.LCFI95:
 8482               		.cfi_def_cfa_offset 4
 8483               		.cfi_offset 13, -3
 8484 2d26 EF92      		push r14
 8485               	.LCFI96:
 8486               		.cfi_def_cfa_offset 5
 8487               		.cfi_offset 14, -4
 8488 2d28 FF92      		push r15
 8489               	.LCFI97:
 8490               		.cfi_def_cfa_offset 6
 8491               		.cfi_offset 15, -5
 8492 2d2a 0F93      		push r16
 8493               	.LCFI98:
 8494               		.cfi_def_cfa_offset 7
 8495               		.cfi_offset 16, -6
 8496 2d2c 1F93      		push r17
 8497               	.LCFI99:
 8498               		.cfi_def_cfa_offset 8
 8499               		.cfi_offset 17, -7
 8500 2d2e CF93      		push r28
 8501               	.LCFI100:
 8502               		.cfi_def_cfa_offset 9
 8503               		.cfi_offset 28, -8
 8504 2d30 DF93      		push r29
 8505               	.LCFI101:
 8506               		.cfi_def_cfa_offset 10
 8507               		.cfi_offset 29, -9
 8508 2d32 CDB7      		in r28,__SP_L__
 8509 2d34 DEB7      		in r29,__SP_H__
 8510               	.LCFI102:
 8511               		.cfi_def_cfa_register 28
 8512 2d36 A597      		sbiw r28,37
 8513               	.LCFI103:
 8514               		.cfi_def_cfa_offset 47
 8515 2d38 0FB6      		in __tmp_reg__,__SREG__
 8516 2d3a F894      		cli
 8517 2d3c DEBF      		out __SP_H__,r29
 8518 2d3e 0FBE      		out __SREG__,__tmp_reg__
 8519 2d40 CDBF      		out __SP_L__,r28
 8520               	/* prologue: function */
 8521               	/* frame size = 37 */
 8522               	/* stack size = 45 */
 8523               	.L__stack_usage = 45
 869:main.c        **** 
 8524               		.loc 1 869 0
 8525 2d42 1091 0000 		lds r17,komendy_kolejka
 8526               	.LVL623:
 871:main.c        ****   case KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU: {
 8527               		.loc 1 871 0
 8528 2d46 1438      		cpi r17,lo8(-124)
 8529 2d48 01F4      		brne .+2
 8530 2d4a 00C0      		rjmp .L938
 8531 2d4c 00F4      		brsh .L939
 8532 2d4e 1338      		cpi r17,lo8(-125)
 8533 2d50 00F0      		brlo .+2
 8534 2d52 00C0      		rjmp .L940
 8535 2d54 1330      		cpi r17,lo8(3)
 8536 2d56 00F0      		brlo .+2
 8537 2d58 00C0      		rjmp .L941
 8538 2d5a 1230      		cpi r17,lo8(2)
 8539 2d5c 01F0      		breq .L942
 8540               	.L1012:
1352:main.c        ****   }
 8541               		.loc 1 1352 0
 8542 2d5e 80E0      		ldi r24,0
 8543 2d60 00C0      		rjmp .L936
 8544               	.L939:
 871:main.c        ****   case KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU: {
 8545               		.loc 1 871 0
 8546 2d62 1638      		cpi r17,lo8(-122)
 8547 2d64 01F4      		brne .+2
 8548 2d66 00C0      		rjmp .L943
 8549 2d68 00F4      		brsh .+2
 8550 2d6a 00C0      		rjmp .L944
 8551 2d6c 1738      		cpi r17,lo8(-121)
 8552 2d6e 01F4      		brne .+2
 8553 2d70 00C0      		rjmp .L945
 8554 2d72 1838      		cpi r17,lo8(-120)
 8555 2d74 01F4      		brne .L1012
1326:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8556               		.loc 1 1326 0
 8557 2d76 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8558 2d7a 8111      		cpse r24,__zero_reg__
 8559 2d7c 00C0      		rjmp .L1008
1326:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8560               		.loc 1 1326 0 is_stmt 0 discriminator 2
 8561 2d7e 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8562 2d82 8111      		cpse r24,__zero_reg__
 8563 2d84 00C0      		rjmp .L1008
1326:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8564               		.loc 1 1326 0 discriminator 4
 8565 2d86 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 8566 2d8a 8111      		cpse r24,__zero_reg__
 8567 2d8c 00C0      		rjmp .L1008
1326:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8568               		.loc 1 1326 0 discriminator 6
 8569 2d8e F99B      		sbis 0x1f,1
 8570 2d90 00C0      		rjmp .L1009
 8571               	.L1008:
1326:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8572               		.loc 1 1326 0 discriminator 7
 8573 2d92 88E8      		ldi r24,lo8(-120)
 8574 2d94 00C0      		rjmp .L1049
 8575               	.L942:
 873:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8576               		.loc 1 873 0 is_stmt 1
 8577 2d96 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8578 2d9a 8111      		cpse r24,__zero_reg__
 8579 2d9c 00C0      		rjmp .L947
 873:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8580               		.loc 1 873 0 is_stmt 0 discriminator 2
 8581 2d9e 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8582 2da2 8111      		cpse r24,__zero_reg__
 8583 2da4 00C0      		rjmp .L947
 873:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8584               		.loc 1 873 0 discriminator 4
 8585 2da6 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 8586 2daa 8111      		cpse r24,__zero_reg__
 8587 2dac 00C0      		rjmp .L947
 873:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8588               		.loc 1 873 0 discriminator 6
 8589 2dae F99B      		sbis 0x1f,1
 8590 2db0 00C0      		rjmp .L948
 8591               	.L947:
 873:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8592               		.loc 1 873 0 discriminator 7
 8593 2db2 82E0      		ldi r24,lo8(2)
 8594               	.LVL624:
 8595               	.L1049:
1326:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8596               		.loc 1 1326 0 is_stmt 1 discriminator 7
 8597 2db4 0E94 0000 		call dodaj_komende
 8598               	.LVL625:
 8599 2db8 00C0      		rjmp .L1048
 8600               	.LVL626:
 8601               	.L948:
 874:main.c        ****     kod_modulu[1] = bufor_eeprom[1] = 'B';
 8602               		.loc 1 874 0
 8603 2dba 81E4      		ldi r24,lo8(65)
 8604 2dbc 8093 0000 		sts bufor_eeprom,r24
 8605 2dc0 8093 0000 		sts kod_modulu,r24
 875:main.c        ****     kod_modulu[2] = bufor_eeprom[2] = 'C';
 8606               		.loc 1 875 0
 8607 2dc4 82E4      		ldi r24,lo8(66)
 8608 2dc6 8093 0000 		sts bufor_eeprom+1,r24
 8609 2dca 8093 0000 		sts kod_modulu+1,r24
 876:main.c        ****     kod_modulu[3] = bufor_eeprom[3] = 'D';
 8610               		.loc 1 876 0
 8611 2dce 83E4      		ldi r24,lo8(67)
 8612 2dd0 8093 0000 		sts bufor_eeprom+2,r24
 8613 2dd4 8093 0000 		sts kod_modulu+2,r24
 877:main.c        ****     zapisz_znaki_w_eeprom_bez_kopiowania(ADRES_EEPROM_KOD_DOSTEPU,
 8614               		.loc 1 877 0
 8615 2dd8 84E4      		ldi r24,lo8(68)
 8616 2dda 8093 0000 		sts bufor_eeprom+3,r24
 8617 2dde 8093 0000 		sts kod_modulu+3,r24
 878:main.c        ****                                          LICZBA_BAJTOW_KODU_DOSTEPU);
 8618               		.loc 1 878 0
 8619 2de2 64E0      		ldi r22,lo8(4)
 8620 2de4 81E0      		ldi r24,lo8(1)
 8621 2de6 90E0      		ldi r25,0
 8622 2de8 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 8623               	.LVL627:
 8624               	.L1051:
 8625               	.LBB659:
1029:main.c        ****     break;
 8626               		.loc 1 1029 0
 8627 2dec 83E3      		ldi r24,lo8(51)
 8628 2dee 8093 0000 		sts licznik_100ms_dioda_led,r24
 8629               	.LVL628:
 8630               	.L1048:
 8631               	.LBE659:
1354:main.c        **** }
 8632               		.loc 1 1354 0
 8633 2df2 8FEF      		ldi r24,lo8(-1)
 8634               	.L936:
 8635               	/* epilogue start */
1355:main.c        **** 
 8636               		.loc 1 1355 0
 8637 2df4 A596      		adiw r28,37
 8638 2df6 0FB6      		in __tmp_reg__,__SREG__
 8639 2df8 F894      		cli
 8640 2dfa DEBF      		out __SP_H__,r29
 8641 2dfc 0FBE      		out __SREG__,__tmp_reg__
 8642 2dfe CDBF      		out __SP_L__,r28
 8643 2e00 DF91      		pop r29
 8644 2e02 CF91      		pop r28
 8645 2e04 1F91      		pop r17
 8646 2e06 0F91      		pop r16
 8647 2e08 FF90      		pop r15
 8648 2e0a EF90      		pop r14
 8649 2e0c DF90      		pop r13
 8650 2e0e CF90      		pop r12
 8651 2e10 0895      		ret
 8652               	.LVL629:
 8653               	.L941:
 8654               	.LBB660:
1011:main.c        ****     const uchar nr_bloku =
 8655               		.loc 1 1011 0
 8656 2e12 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8657 2e16 8111      		cpse r24,__zero_reg__
 8658 2e18 00C0      		rjmp .L949
1011:main.c        ****     const uchar nr_bloku =
 8659               		.loc 1 1011 0 is_stmt 0 discriminator 2
 8660 2e1a 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8661 2e1e 8111      		cpse r24,__zero_reg__
 8662 2e20 00C0      		rjmp .L949
1011:main.c        ****     const uchar nr_bloku =
 8663               		.loc 1 1011 0 discriminator 4
 8664 2e22 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 8665 2e26 8111      		cpse r24,__zero_reg__
 8666 2e28 00C0      		rjmp .L949
1011:main.c        ****     const uchar nr_bloku =
 8667               		.loc 1 1011 0 discriminator 6
 8668 2e2a F99B      		sbis 0x1f,1
 8669 2e2c 00C0      		rjmp .L950
 8670               	.L949:
1011:main.c        ****     const uchar nr_bloku =
 8671               		.loc 1 1011 0 discriminator 7
 8672 2e2e 812F      		mov r24,r17
 8673 2e30 00C0      		rjmp .L1049
 8674               	.L950:
1012:main.c        ****         aktualnie_wykonywana_komenda - KOMENDA_KOLEJKI_RESET_USTAWIEN_0;
 8675               		.loc 1 1012 0 is_stmt 1
 8676 2e32 0DEF      		ldi r16,lo8(-3)
 8677 2e34 010F      		add r16,r17
 8678               	.LVL630:
1015:main.c        ****     if (nr_bloku == 0) {
 8679               		.loc 1 1015 0
 8680 2e36 40E2      		ldi r20,lo8(32)
 8681 2e38 50E0      		ldi r21,0
 8682 2e3a 6FEF      		ldi r22,lo8(-1)
 8683 2e3c 70E0      		ldi r23,0
 8684 2e3e 80E0      		ldi r24,lo8(bufor_eeprom)
 8685 2e40 90E0      		ldi r25,hi8(bufor_eeprom)
 8686 2e42 0E94 0000 		call memset
 8687               	.LVL631:
1016:main.c        ****       kod_modulu[0] = bufor_eeprom[1] = 'A';
 8688               		.loc 1 1016 0
 8689 2e46 0111      		cpse r16,__zero_reg__
 8690 2e48 00C0      		rjmp .L951
1017:main.c        ****       kod_modulu[1] = bufor_eeprom[2] = 'B';
 8691               		.loc 1 1017 0
 8692 2e4a 81E4      		ldi r24,lo8(65)
 8693 2e4c 8093 0000 		sts bufor_eeprom+1,r24
 8694 2e50 8093 0000 		sts kod_modulu,r24
1018:main.c        ****       kod_modulu[2] = bufor_eeprom[3] = 'C';
 8695               		.loc 1 1018 0
 8696 2e54 82E4      		ldi r24,lo8(66)
 8697 2e56 8093 0000 		sts bufor_eeprom+2,r24
 8698 2e5a 8093 0000 		sts kod_modulu+1,r24
1019:main.c        ****       kod_modulu[3] = bufor_eeprom[4] = 'D';
 8699               		.loc 1 1019 0
 8700 2e5e 83E4      		ldi r24,lo8(67)
 8701 2e60 8093 0000 		sts bufor_eeprom+3,r24
 8702 2e64 8093 0000 		sts kod_modulu+2,r24
1020:main.c        ****       bufor_eeprom[5] = 0;
 8703               		.loc 1 1020 0
 8704 2e68 84E4      		ldi r24,lo8(68)
 8705 2e6a 8093 0000 		sts bufor_eeprom+4,r24
 8706 2e6e 8093 0000 		sts kod_modulu+3,r24
1021:main.c        ****       stan_wyjscie[0] = 0;
 8707               		.loc 1 1021 0
 8708 2e72 1092 0000 		sts bufor_eeprom+5,__zero_reg__
1022:main.c        ****       licznik_przelacznik_wyjscia[0] = 0;
 8709               		.loc 1 1022 0
 8710 2e76 1092 0000 		sts stan_wyjscie,__zero_reg__
1023:main.c        ****     }
 8711               		.loc 1 1023 0
 8712 2e7a 1092 0000 		sts licznik_przelacznik_wyjscia,__zero_reg__
 8713 2e7e 1092 0000 		sts licznik_przelacznik_wyjscia+1,__zero_reg__
 8714 2e82 1092 0000 		sts licznik_przelacznik_wyjscia+2,__zero_reg__
 8715 2e86 1092 0000 		sts licznik_przelacznik_wyjscia+3,__zero_reg__
 8716               	.L951:
1025:main.c        ****         nr_bloku * LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE,
 8717               		.loc 1 1025 0
 8718 2e8a 60E2      		ldi r22,lo8(32)
 8719 2e8c 20E2      		ldi r18,lo8(32)
 8720 2e8e 029F      		mul r16,r18
 8721 2e90 C001      		movw r24,r0
 8722 2e92 1124      		clr __zero_reg__
 8723 2e94 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 8724               	.LVL632:
1028:main.c        ****     zapal_diode_led(50);
 8725               		.loc 1 1028 0
 8726 2e98 81E0      		ldi r24,lo8(1)
 8727 2e9a 810F      		add r24,r17
 8728 2e9c 0E94 0000 		call dodaj_komende
 8729               	.LVL633:
 8730 2ea0 00C0      		rjmp .L1051
 8731               	.LVL634:
 8732               	.L940:
 8733               	.LBE660:
 8734               	.LBB661:
1033:main.c        ****     uchar bledny_zapis = FALSE;
 8735               		.loc 1 1033 0
 8736 2ea2 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8737 2ea6 8111      		cpse r24,__zero_reg__
 8738 2ea8 00C0      		rjmp .L952
1033:main.c        ****     uchar bledny_zapis = FALSE;
 8739               		.loc 1 1033 0 is_stmt 0 discriminator 2
 8740 2eaa 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8741 2eae 8111      		cpse r24,__zero_reg__
 8742 2eb0 00C0      		rjmp .L952
1033:main.c        ****     uchar bledny_zapis = FALSE;
 8743               		.loc 1 1033 0 discriminator 4
 8744 2eb2 F090 0000 		lds r15,czy_zajety_bufor_eeprom
 8745 2eb6 F110      		cpse r15,__zero_reg__
 8746 2eb8 00C0      		rjmp .L952
1033:main.c        ****     uchar bledny_zapis = FALSE;
 8747               		.loc 1 1033 0 discriminator 6
 8748 2eba F99B      		sbis 0x1f,1
 8749 2ebc 00C0      		rjmp .L1013
 8750               	.L952:
1033:main.c        ****     uchar bledny_zapis = FALSE;
 8751               		.loc 1 1033 0 discriminator 7
 8752 2ebe 83E8      		ldi r24,lo8(-125)
 8753 2ec0 00C0      		rjmp .L1049
 8754               	.L1013:
 8755               	.LBB662:
1038:main.c        ****       if (eeprom_read_byte((void *)i) !=
 8756               		.loc 1 1038 0 is_stmt 1
 8757 2ec2 10E0      		ldi r17,0
 8758               	.LVL635:
 8759 2ec4 00E0      		ldi r16,0
 8760               	.LVL636:
 8761               	.L953:
1039:main.c        ****           pgm_read_byte(tab_eeprom_fabryczny + i))
 8762               		.loc 1 1039 0
 8763 2ec6 C801      		movw r24,r16
 8764 2ec8 0E94 0000 		call eeprom_read_byte
 8765               	.LVL637:
 8766               	.LBB663:
1040:main.c        ****         bledny_zapis = TRUE;
 8767               		.loc 1 1040 0
 8768 2ecc F801      		movw r30,r16
 8769 2ece E050      		subi r30,lo8(-(tab_eeprom_fabryczny.3640))
 8770 2ed0 F040      		sbci r31,hi8(-(tab_eeprom_fabryczny.3640))
 8771               	.LVL638:
 8772               	/* #APP */
 8773               	 ;  1040 "main.c" 1
 8774 2ed2 E491      		lpm r30, Z
 8775               		
 8776               	 ;  0 "" 2
 8777               	.LVL639:
 8778               	/* #NOAPP */
 8779               	.LBE663:
1039:main.c        ****           pgm_read_byte(tab_eeprom_fabryczny + i))
 8780               		.loc 1 1039 0
 8781 2ed4 8E17      		cp r24,r30
 8782 2ed6 01F0      		breq .L954
1041:main.c        ****     }
 8783               		.loc 1 1041 0
 8784 2ed8 FF24      		clr r15
 8785 2eda FA94      		dec r15
 8786               	.LVL640:
 8787               	.L954:
1038:main.c        ****       if (eeprom_read_byte((void *)i) !=
 8788               		.loc 1 1038 0 discriminator 2
 8789 2edc 0F5F      		subi r16,-1
 8790 2ede 1F4F      		sbci r17,-1
 8791               	.LVL641:
 8792 2ee0 0630      		cpi r16,6
 8793 2ee2 1105      		cpc r17,__zero_reg__
 8794 2ee4 01F4      		brne .L953
 8795               	.LBE662:
 8796               	.LBB664:
1043:main.c        ****          i < EEPROM_NUMER_TELEFONU_BRAMA_0 +
 8797               		.loc 1 1043 0
 8798 2ee6 08E0      		ldi r16,lo8(8)
 8799 2ee8 10E0      		ldi r17,0
 8800               	.LVL642:
 8801               	.L956:
1048:main.c        ****         bledny_zapis = TRUE;
 8802               		.loc 1 1048 0
 8803 2eea C801      		movw r24,r16
 8804 2eec 0E94 0000 		call eeprom_read_byte
 8805               	.LVL643:
 8806 2ef0 8F3F      		cpi r24,lo8(-1)
 8807 2ef2 01F4      		brne .L955
1047:main.c        ****       if (eeprom_read_byte((void *)i) != 0xff) {
 8808               		.loc 1 1047 0
 8809 2ef4 0F5F      		subi r16,-1
 8810 2ef6 1F4F      		sbci r17,-1
 8811               	.LVL644:
1043:main.c        ****          i < EEPROM_NUMER_TELEFONU_BRAMA_0 +
 8812               		.loc 1 1043 0
 8813 2ef8 083A      		cpi r16,-88
 8814 2efa 8FE0      		ldi r24,15
 8815 2efc 1807      		cpc r17,r24
 8816 2efe 01F4      		brne .L956
 8817               	.LBE664:
1053:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
 8818               		.loc 1 1053 0
 8819 2f00 FF20      		tst r15
 8820 2f02 01F0      		breq .L957
 8821               	.L955:
 8822               	.LVL645:
1054:main.c        ****       break;
 8823               		.loc 1 1054 0
 8824 2f04 83E0      		ldi r24,lo8(3)
 8825 2f06 00C0      		rjmp .L1049
 8826               	.LVL646:
 8827               	.L957:
1057:main.c        ****     ustaw_stan_led(FALSE); // Wylacz diode po zakonczeniu resetu
 8828               		.loc 1 1057 0
 8829 2f08 0E94 0000 		call inicjalizuj_parametry_modulu
 8830               	.LVL647:
1058:main.c        ****     break;
 8831               		.loc 1 1058 0
 8832 2f0c 409A      		sbi 0x8,0
 8833 2f0e 00C0      		rjmp .L1048
 8834               	.LVL648:
 8835               	.L938:
 8836               	.LBE661:
 8837               	.LBB665:
1062:main.c        **** 
 8838               		.loc 1 1062 0
 8839 2f10 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8840 2f14 8111      		cpse r24,__zero_reg__
 8841 2f16 00C0      		rjmp .L958
1062:main.c        **** 
 8842               		.loc 1 1062 0 is_stmt 0 discriminator 2
 8843 2f18 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8844 2f1c 8111      		cpse r24,__zero_reg__
 8845 2f1e 00C0      		rjmp .L958
1062:main.c        **** 
 8846               		.loc 1 1062 0 discriminator 4
 8847 2f20 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 8848 2f24 8111      		cpse r24,__zero_reg__
 8849 2f26 00C0      		rjmp .L958
1062:main.c        **** 
 8850               		.loc 1 1062 0 discriminator 6
 8851 2f28 F99B      		sbis 0x1f,1
 8852 2f2a 00C0      		rjmp .L959
 8853               	.L958:
1062:main.c        **** 
 8854               		.loc 1 1062 0 discriminator 7
 8855 2f2c 84E8      		ldi r24,lo8(-124)
 8856 2f2e 00C0      		rjmp .L1049
 8857               	.L959:
1064:main.c        ****       // Poza dozwolonym czasem - ignoruj
 8858               		.loc 1 1064 0 is_stmt 1
 8859 2f30 D090 0000 		lds r13,blokada_sterowania_czasowa
 8860 2f34 D110      		cpse r13,__zero_reg__
 8861 2f36 00C0      		rjmp .L1048
1072:main.c        **** 
 8862               		.loc 1 1072 0
 8863 2f38 8E01      		movw r16,r28
 8864 2f3a 0B5E      		subi r16,-21
 8865 2f3c 1F4F      		sbci r17,-1
 8866 2f3e 60E0      		ldi r22,lo8(numer_telefonu_ktory_dzwoni)
 8867 2f40 70E0      		ldi r23,hi8(numer_telefonu_ktory_dzwoni)
 8868 2f42 C801      		movw r24,r16
 8869 2f44 0E94 0000 		call strcpy
 8870               	.LVL649:
1076:main.c        ****         &bufor_eeprom[0]);
 8871               		.loc 1 1076 0
 8872 2f48 F801      		movw r30,r16
 8873               		0:
 8874 2f4a 0190      		ld __tmp_reg__,Z+
 8875 2f4c 0020      		tst __tmp_reg__
 8876 2f4e 01F4      		brne 0b
 8877 2f50 BF01      		movw r22,r30
 8878 2f52 6150      		subi r22,1
 8879 2f54 7109      		sbc r23,__zero_reg__
1075:main.c        ****         &numer_lokalny[0], &numer_lokalny[strlen((char *)numer_lokalny)],
 8880               		.loc 1 1075 0
 8881 2f56 40E0      		ldi r20,lo8(bufor_eeprom)
 8882 2f58 50E0      		ldi r21,hi8(bufor_eeprom)
 8883 2f5a C801      		movw r24,r16
 8884 2f5c 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 8885               	.LVL650:
1081:main.c        ****       // Tylko w trybie prywatnym sprawdzamy listę
 8886               		.loc 1 1081 0
 8887 2f60 8091 0000 		lds r24,tryb_pracy
 8888 2f64 8130      		cpi r24,lo8(1)
 8889 2f66 01F0      		breq .L963
 8890 2f68 38E0      		ldi r19,lo8(8)
 8891 2f6a E32E      		mov r14,r19
 8892 2f6c F12C      		mov r15,__zero_reg__
 8893               	.L964:
 8894               	.LBB666:
1085:main.c        ****                 &bufor_eeprom[0],
 8895               		.loc 1 1085 0
 8896 2f6e B701      		movw r22,r14
 8897 2f70 80E0      		ldi r24,lo8(bufor_eeprom)
 8898 2f72 90E0      		ldi r25,hi8(bufor_eeprom)
 8899 2f74 0E94 0000 		call porownaj_numer_telefonu_blok
 8900               	.LVL651:
 8901 2f78 8111      		cpse r24,__zero_reg__
 8902 2f7a 00C0      		rjmp .L1015
 8903               	.LVL652:
 8904 2f7c F5E0      		ldi r31,5
 8905 2f7e EF0E      		add r14,r31
 8906 2f80 F11C      		adc r15,__zero_reg__
1083:main.c        ****            nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 8907               		.loc 1 1083 0
 8908 2f82 28EA      		ldi r18,-88
 8909 2f84 E216      		cp r14,r18
 8910 2f86 2FE0      		ldi r18,15
 8911 2f88 F206      		cpc r15,r18
 8912 2f8a 01F4      		brne .L964
 8913               	.L963:
 8914               	.LVL653:
 8915               	.LBE666:
1096:main.c        ****       wyciagnij_ostatnie_cyfry(numer_lokalny, numer_skrocony, 9);
 8916               		.loc 1 1096 0
 8917 2f8c 8091 0000 		lds r24,skryba_wlaczona
 8918 2f90 8823      		tst r24
 8919 2f92 01F0      		breq .L965
1096:main.c        ****       wyciagnij_ostatnie_cyfry(numer_lokalny, numer_skrocony, 9);
 8920               		.loc 1 1096 0 is_stmt 0 discriminator 1
 8921 2f94 DD20      		tst r13
 8922 2f96 01F4      		brne .+2
 8923 2f98 00C0      		rjmp .L966
 8924               	.L970:
 8925 2f9a DD24      		clr r13
 8926 2f9c DA94      		dec r13
 8927               	.LVL654:
 8928               	.L965:
1119:main.c        ****                          ADRES_EEPROM_DEBUG_SKRYBA_2); // DEBUG
 8929               		.loc 1 1119 0 is_stmt 1
 8930 2f9e 81E0      		ldi r24,lo8(1)
 8931 2fa0 9091 0000 		lds r25,skryba_wlaczona
 8932 2fa4 9111      		cpse r25,__zero_reg__
 8933 2fa6 00C0      		rjmp .L972
 8934 2fa8 80E0      		ldi r24,0
 8935               	.L972:
 8936 2faa 61EF      		ldi r22,lo8(-15)
 8937 2fac 7FE0      		ldi r23,lo8(15)
 8938 2fae 0E94 0000 		call zapisz_znak_w_eeprom
 8939               	.LVL655:
1121:main.c        ****                          ADRES_EEPROM_DEBUG_SKRYBA_3); // DEBUG
 8940               		.loc 1 1121 0
 8941 2fb2 81E0      		ldi r24,lo8(1)
 8942 2fb4 D110      		cpse r13,__zero_reg__
 8943 2fb6 80E0      		ldi r24,0
 8944               	.L973:
 8945 2fb8 62EF      		ldi r22,lo8(-14)
 8946 2fba 7FE0      		ldi r23,lo8(15)
 8947 2fbc 0E94 0000 		call zapisz_znak_w_eeprom
 8948               	.LVL656:
1124:main.c        ****       uchar len_full = strlen((char *)numer_lokalny);
 8949               		.loc 1 1124 0
 8950 2fc0 8091 0000 		lds r24,skryba_wlaczona
 8951 2fc4 8823      		tst r24
 8952 2fc6 01F0      		breq .L975
1124:main.c        ****       uchar len_full = strlen((char *)numer_lokalny);
 8953               		.loc 1 1124 0 is_stmt 0 discriminator 1
 8954 2fc8 D110      		cpse r13,__zero_reg__
 8955 2fca 00C0      		rjmp .L975
 8956               	.LBB667:
1125:main.c        **** 
 8957               		.loc 1 1125 0 is_stmt 1
 8958 2fcc F801      		movw r30,r16
 8959               		0:
 8960 2fce 0190      		ld __tmp_reg__,Z+
 8961 2fd0 0020      		tst __tmp_reg__
 8962 2fd2 01F4      		brne 0b
 8963 2fd4 3197      		sbiw r30,1
 8964 2fd6 CF01      		movw r24,r30
 8965 2fd8 801B      		sub r24,r16
 8966 2fda 910B      		sbc r25,r17
 8967 2fdc 182F      		mov r17,r24
 8968               	.LVL657:
1128:main.c        **** 
 8969               		.loc 1 1128 0
 8970 2fde 64EF      		ldi r22,lo8(-12)
 8971 2fe0 7FE0      		ldi r23,lo8(15)
 8972 2fe2 0E94 0000 		call zapisz_znak_w_eeprom
 8973               	.LVL658:
1130:main.c        ****         // Skopiuj skrócony numer do numer_telefonu_skryba
 8974               		.loc 1 1130 0
 8975 2fe6 1330      		cpi r17,lo8(3)
 8976 2fe8 00F0      		brlo .L975
1132:main.c        **** 
 8977               		.loc 1 1132 0
 8978 2fea BE01      		movw r22,r28
 8979 2fec 6F5F      		subi r22,-1
 8980 2fee 7F4F      		sbci r23,-1
 8981 2ff0 80E0      		ldi r24,lo8(numer_telefonu_skryba)
 8982 2ff2 90E0      		ldi r25,hi8(numer_telefonu_skryba)
 8983 2ff4 0E94 0000 		call strcpy
 8984               	.LVL659:
1135:main.c        ****           zapisz_znak_w_eeprom(
 8985               		.loc 1 1135 0
 8986 2ff8 80E0      		ldi r24,lo8(numer_telefonu_skryba)
 8987 2ffa 90E0      		ldi r25,hi8(numer_telefonu_skryba)
 8988 2ffc FC01      		movw r30,r24
 8989               		0:
 8990 2ffe 0190      		ld __tmp_reg__,Z+
 8991 3000 0020      		tst __tmp_reg__
 8992 3002 01F4      		brne 0b
 8993 3004 CF01      		movw r24,r30
 8994 3006 8050      		subi r24,lo8(numer_telefonu_skryba+1)
 8995 3008 9040      		sbci r25,hi8(numer_telefonu_skryba+1)
 8996 300a 0397      		sbiw r24,3
 8997 300c 00F0      		brlo .L975
1136:main.c        ****               1, ADRES_EEPROM_DEBUG_SKRYBA_4); // DEBUG: komenda dodana
 8998               		.loc 1 1136 0
 8999 300e 63EF      		ldi r22,lo8(-13)
 9000 3010 7FE0      		ldi r23,lo8(15)
 9001 3012 81E0      		ldi r24,lo8(1)
 9002 3014 0E94 0000 		call zapisz_znak_w_eeprom
 9003               	.LVL660:
1140:main.c        ****         }
 9004               		.loc 1 1140 0
 9005 3018 86E8      		ldi r24,lo8(-122)
 9006 301a 0E94 0000 		call dodaj_komende
 9007               	.LVL661:
 9008               	.L975:
 9009               	.LBE667:
1146:main.c        ****       if (tryb_pracy == 1) {
 9010               		.loc 1 1146 0
 9011 301e 8091 0000 		lds r24,tryb_clip
 9012 3022 8823      		tst r24
 9013 3024 01F4      		brne .+2
 9014 3026 00C0      		rjmp .L1048
1147:main.c        ****         // Tryb publiczny - otwórz dla każdego
 9015               		.loc 1 1147 0
 9016 3028 8091 0000 		lds r24,tryb_pracy
 9017 302c 8130      		cpi r24,lo8(1)
 9018 302e 01F0      		breq .+2
 9019 3030 00C0      		rjmp .L978
 9020               	.L979:
1149:main.c        ****       } else if (znaleziono) {
 9021               		.loc 1 1149 0
 9022 3032 0E94 0000 		call ustaw_wyjscie_clip
 9023               	.LVL662:
 9024 3036 00C0      		rjmp .L1048
 9025               	.LVL663:
 9026               	.L1015:
 9027               	.LBB668:
1088:main.c        ****           break;
 9028               		.loc 1 1088 0
 9029 3038 DD24      		clr r13
 9030 303a DA94      		dec r13
 9031 303c 00C0      		rjmp .L963
 9032               	.LVL664:
 9033               	.L966:
 9034               	.LBE668:
 9035               	.LBB669:
 9036               	.LBB670:
 835:main.c        **** 
 9037               		.loc 1 835 0
 9038 303e F801      		movw r30,r16
 9039               		0:
 9040 3040 0190      		ld __tmp_reg__,Z+
 9041 3042 0020      		tst __tmp_reg__
 9042 3044 01F4      		brne 0b
 9043 3046 3197      		sbiw r30,1
 9044 3048 E01B      		sub r30,r16
 9045 304a F10B      		sbc r31,r17
 9046               	.LVL665:
 9047 304c CE01      		movw r24,r28
 9048 304e 0196      		adiw r24,1
 9049 3050 7C01      		movw r14,r24
 837:main.c        ****     // Take last max_digits
 9050               		.loc 1 837 0
 9051 3052 EA30      		cpi r30,lo8(10)
 9052 3054 00F0      		brlo .L967
 839:main.c        ****   } else {
 9053               		.loc 1 839 0
 9054 3056 E950      		subi r30,9
 9055 3058 FF0B      		sbc r31,r31
 9056               	.LVL666:
 9057 305a B801      		movw r22,r16
 9058 305c 6E0F      		add r22,r30
 9059 305e 7F1F      		adc r23,r31
 9060               	.L1046:
 842:main.c        ****   }
 9061               		.loc 1 842 0
 9062 3060 0E94 0000 		call strcpy
 9063               	.LVL667:
 9064               	.LBE670:
 9065               	.LBE669:
1101:main.c        ****           &bufor_eeprom[0]);
 9066               		.loc 1 1101 0
 9067 3064 F701      		movw r30,r14
 9068               		0:
 9069 3066 0190      		ld __tmp_reg__,Z+
 9070 3068 0020      		tst __tmp_reg__
 9071 306a 01F4      		brne 0b
 9072 306c BF01      		movw r22,r30
 9073 306e 6150      		subi r22,1
 9074 3070 7109      		sbc r23,__zero_reg__
1100:main.c        ****           &numer_skrocony[0], &numer_skrocony[strlen((char *)numer_skrocony)],
 9075               		.loc 1 1100 0
 9076 3072 40E0      		ldi r20,lo8(bufor_eeprom)
 9077 3074 50E0      		ldi r21,hi8(bufor_eeprom)
 9078 3076 C701      		movw r24,r14
 9079 3078 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9080               	.LVL668:
1104:main.c        ****         for (uint nr_uzyt_clip = 0;
 9081               		.loc 1 1104 0
 9082 307c 8091 0000 		lds r24,tryb_pracy
 9083 3080 8130      		cpi r24,lo8(1)
 9084 3082 01F4      		brne .+2
 9085 3084 00C0      		rjmp .L965
 9086 3086 28E0      		ldi r18,lo8(8)
 9087 3088 E22E      		mov r14,r18
 9088 308a F12C      		mov r15,__zero_reg__
 9089               	.L969:
 9090               	.LBB672:
1108:main.c        ****                   &bufor_eeprom[0],
 9091               		.loc 1 1108 0
 9092 308c B701      		movw r22,r14
 9093 308e 80E0      		ldi r24,lo8(bufor_eeprom)
 9094 3090 90E0      		ldi r25,hi8(bufor_eeprom)
 9095 3092 0E94 0000 		call porownaj_numer_telefonu_blok
 9096               	.LVL669:
 9097 3096 8111      		cpse r24,__zero_reg__
 9098 3098 00C0      		rjmp .L970
 9099               	.LVL670:
 9100 309a F5E0      		ldi r31,5
 9101 309c EF0E      		add r14,r31
 9102 309e F11C      		adc r15,__zero_reg__
1105:main.c        ****              nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 9103               		.loc 1 1105 0
 9104 30a0 28EA      		ldi r18,-88
 9105 30a2 E216      		cp r14,r18
 9106 30a4 2FE0      		ldi r18,15
 9107 30a6 F206      		cpc r15,r18
 9108 30a8 01F4      		brne .L969
 9109 30aa 00C0      		rjmp .L965
 9110               	.LVL671:
 9111               	.L967:
 9112               	.LBE672:
 9113               	.LBB673:
 9114               	.LBB671:
 842:main.c        ****   }
 9115               		.loc 1 842 0
 9116 30ac B801      		movw r22,r16
 9117 30ae 00C0      		rjmp .L1046
 9118               	.LVL672:
 9119               	.L978:
 9120               	.LBE671:
 9121               	.LBE673:
1150:main.c        ****         // Tryb prywatny - otwórz tylko dla znalezionych
 9122               		.loc 1 1150 0
 9123 30b0 DD20      		tst r13
 9124 30b2 01F4      		brne .+2
 9125 30b4 00C0      		rjmp .L1048
 9126 30b6 00C0      		rjmp .L979
 9127               	.LVL673:
 9128               	.L944:
 9129               	.LBE665:
 9130               	.LBB674:
1160:main.c        **** 
 9131               		.loc 1 1160 0
 9132 30b8 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 9133 30bc 8111      		cpse r24,__zero_reg__
 9134 30be 00C0      		rjmp .L980
1160:main.c        **** 
 9135               		.loc 1 1160 0 is_stmt 0 discriminator 2
 9136 30c0 8091 0000 		lds r24,liczba_znakow_do_zapisu
 9137 30c4 8111      		cpse r24,__zero_reg__
 9138 30c6 00C0      		rjmp .L980
1160:main.c        **** 
 9139               		.loc 1 1160 0 discriminator 4
 9140 30c8 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 9141 30cc 8111      		cpse r24,__zero_reg__
 9142 30ce 00C0      		rjmp .L980
1160:main.c        **** 
 9143               		.loc 1 1160 0 discriminator 6
 9144 30d0 F99B      		sbis 0x1f,1
 9145 30d2 00C0      		rjmp .L981
 9146               	.L980:
1160:main.c        **** 
 9147               		.loc 1 1160 0 discriminator 7
 9148 30d4 85E8      		ldi r24,lo8(-123)
 9149 30d6 00C0      		rjmp .L1049
 9150               	.L981:
1163:main.c        ****       return TRUE; // Duplicate found, abort
 9151               		.loc 1 1163 0 is_stmt 1
 9152 30d8 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 9153 30da 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 9154 30dc 0E94 0000 		call czy_numer_istnieje
 9155               	.LVL674:
 9156 30e0 8111      		cpse r24,__zero_reg__
 9157 30e2 00C0      		rjmp .L1048
1172:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
 9158               		.loc 1 1172 0
 9159 30e4 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 9160 30e6 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 9161 30e8 FB01      		movw r30,r22
 9162               		0:
 9163 30ea 0190      		ld __tmp_reg__,Z+
 9164 30ec 0020      		tst __tmp_reg__
 9165 30ee 01F4      		brne 0b
 9166 30f0 BF01      		movw r22,r30
 9167 30f2 6150      		subi r22,1
 9168 30f4 7109      		sbc r23,__zero_reg__
1170:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
 9169               		.loc 1 1170 0
 9170 30f6 40E0      		ldi r20,lo8(bufor_eeprom)
 9171 30f8 50E0      		ldi r21,hi8(bufor_eeprom)
 9172 30fa 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 9173 30fc 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 9174 30fe 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9175               	.LVL675:
1179:main.c        ****     for (uint nr_uzyt_clip = 0; nr_uzyt_clip < max_pozycja; ++nr_uzyt_clip) {
 9176               		.loc 1 1179 0
 9177 3102 E090 0000 		lds r14,skryba_limit
 9178 3106 F090 0000 		lds r15,skryba_limit+1
 9179 310a FCE1      		ldi r31,28
 9180 310c EF16      		cp r14,r31
 9181 310e F3E0      		ldi r31,3
 9182 3110 FF06      		cpc r15,r31
 9183 3112 00F0      		brlo .L983
 9184 3114 9BE1      		ldi r25,lo8(27)
 9185 3116 E92E      		mov r14,r25
 9186 3118 93E0      		ldi r25,lo8(3)
 9187 311a F92E      		mov r15,r25
 9188               	.L983:
 9189               	.LVL676:
 9190               	.LBB675:
1180:main.c        ****       if (not czy_aktywny_numer_telefonu_brama(nr_uzyt_clip)) {
 9191               		.loc 1 1180 0
 9192 311c 08E0      		ldi r16,lo8(8)
 9193 311e 10E0      		ldi r17,0
 9194 3120 D12C      		mov r13,__zero_reg__
 9195 3122 C12C      		mov r12,__zero_reg__
 9196               	.LVL677:
 9197               	.L984:
1180:main.c        ****       if (not czy_aktywny_numer_telefonu_brama(nr_uzyt_clip)) {
 9198               		.loc 1 1180 0 is_stmt 0 discriminator 1
 9199 3124 CE14      		cp r12,r14
 9200 3126 DF04      		cpc r13,r15
 9201 3128 01F4      		brne .+2
 9202 312a 00C0      		rjmp .L1048
1181:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
 9203               		.loc 1 1181 0 is_stmt 1
 9204 312c C801      		movw r24,r16
 9205 312e 0E94 0000 		call eeprom_read_byte
 9206               	.LVL678:
 9207 3132 9801      		movw r18,r16
 9208 3134 2B5F      		subi r18,-5
 9209 3136 3F4F      		sbci r19,-1
 9210 3138 8F3F      		cpi r24,lo8(-1)
 9211 313a 01F4      		brne .L985
1182:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
 9212               		.loc 1 1182 0
 9213 313c 65E0      		ldi r22,lo8(5)
 9214 313e C801      		movw r24,r16
 9215 3140 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 9216               	.LVL679:
 9217               	.LBE675:
1191:main.c        ****       // Policz aktywnych uzytkownikow
 9218               		.loc 1 1191 0
 9219 3144 8091 0000 		lds r24,skryba_wlaczona
 9220 3148 08E0      		ldi r16,lo8(8)
 9221 314a 10E0      		ldi r17,0
 9222               	.LBB676:
1193:main.c        ****       for (uint i = 0; i < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++i) {
 9223               		.loc 1 1193 0
 9224 314c F12C      		mov r15,__zero_reg__
 9225 314e E12C      		mov r14,__zero_reg__
 9226               	.LVL680:
 9227               	.LBE676:
1191:main.c        ****       // Policz aktywnych uzytkownikow
 9228               		.loc 1 1191 0
 9229 3150 8823      		tst r24
 9230 3152 01F4      		brne .+2
 9231 3154 00C0      		rjmp .L1048
 9232               	.L986:
 9233               	.LVL681:
 9234               	.LBB678:
 9235               	.LBB677:
1195:main.c        ****           ++aktywne_numery;
 9236               		.loc 1 1195 0
 9237 3156 C801      		movw r24,r16
 9238 3158 0E94 0000 		call eeprom_read_byte
 9239               	.LVL682:
 9240 315c 8F3F      		cpi r24,lo8(-1)
 9241 315e 01F0      		breq .L989
1196:main.c        ****         }
 9242               		.loc 1 1196 0
 9243 3160 9FEF      		ldi r25,-1
 9244 3162 E91A      		sub r14,r25
 9245 3164 F90A      		sbc r15,r25
 9246               	.LVL683:
 9247               	.L989:
 9248 3166 0B5F      		subi r16,-5
 9249 3168 1F4F      		sbci r17,-1
1194:main.c        ****         if (czy_aktywny_numer_telefonu_brama(i)) {
 9250               		.loc 1 1194 0 discriminator 2
 9251 316a 083A      		cpi r16,-88
 9252 316c EFE0      		ldi r30,15
 9253 316e 1E07      		cpc r17,r30
 9254 3170 01F4      		brne .L986
 9255               	.LVL684:
 9256               	.L1053:
 9257               	.LBE677:
 9258               	.LBE678:
 9259               	.LBE674:
 9260               	.LBB680:
 9261               	.LBB681:
1257:main.c        ****         skryba_wlaczona = FALSE;
 9262               		.loc 1 1257 0
 9263 3172 8091 0000 		lds r24,skryba_limit
 9264 3176 9091 0000 		lds r25,skryba_limit+1
 9265 317a E816      		cp r14,r24
 9266 317c F906      		cpc r15,r25
 9267 317e 00F4      		brsh .+2
 9268 3180 00C0      		rjmp .L1048
1258:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_SKRYBA);
 9269               		.loc 1 1258 0
 9270 3182 1092 0000 		sts skryba_wlaczona,__zero_reg__
1259:main.c        **** 
 9271               		.loc 1 1259 0
 9272 3186 69EF      		ldi r22,lo8(-7)
 9273 3188 7FE0      		ldi r23,lo8(15)
 9274 318a 80E0      		ldi r24,0
 9275 318c 0E94 0000 		call zapisz_znak_w_eeprom
 9276               	.LVL685:
1261:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_TRYB_PRACY);
 9277               		.loc 1 1261 0
 9278 3190 1092 0000 		sts tryb_pracy,__zero_reg__
1262:main.c        ****       }
 9279               		.loc 1 1262 0
 9280 3194 6EEF      		ldi r22,lo8(-2)
 9281 3196 7FE0      		ldi r23,lo8(15)
 9282 3198 80E0      		ldi r24,0
 9283 319a 0E94 0000 		call zapisz_znak_w_eeprom
 9284               	.LVL686:
 9285 319e 00C0      		rjmp .L1048
 9286               	.LVL687:
 9287               	.L985:
 9288               	.LBE681:
 9289               	.LBE680:
 9290               	.LBB687:
 9291               	.LBB679:
1180:main.c        ****       if (not czy_aktywny_numer_telefonu_brama(nr_uzyt_clip)) {
 9292               		.loc 1 1180 0 discriminator 2
 9293 31a0 8FEF      		ldi r24,-1
 9294 31a2 C81A      		sub r12,r24
 9295 31a4 D80A      		sbc r13,r24
 9296               	.LVL688:
 9297 31a6 8901      		movw r16,r18
 9298 31a8 00C0      		rjmp .L984
 9299               	.LVL689:
 9300               	.L943:
 9301               	.LBE679:
 9302               	.LBE687:
 9303               	.LBB688:
1212:main.c        **** 
 9304               		.loc 1 1212 0
 9305 31aa 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 9306 31ae 8111      		cpse r24,__zero_reg__
 9307 31b0 00C0      		rjmp .L990
1212:main.c        **** 
 9308               		.loc 1 1212 0 is_stmt 0 discriminator 2
 9309 31b2 8091 0000 		lds r24,liczba_znakow_do_zapisu
 9310 31b6 8111      		cpse r24,__zero_reg__
 9311 31b8 00C0      		rjmp .L990
1212:main.c        **** 
 9312               		.loc 1 1212 0 discriminator 4
 9313 31ba 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 9314 31be 8111      		cpse r24,__zero_reg__
 9315 31c0 00C0      		rjmp .L990
1212:main.c        **** 
 9316               		.loc 1 1212 0 discriminator 6
 9317 31c2 F99B      		sbis 0x1f,1
 9318 31c4 00C0      		rjmp .L991
 9319               	.L990:
1212:main.c        **** 
 9320               		.loc 1 1212 0 discriminator 7
 9321 31c6 86E8      		ldi r24,lo8(-122)
 9322 31c8 00C0      		rjmp .L1049
 9323               	.L991:
1220:main.c        ****         bufor_skryba);
 9324               		.loc 1 1220 0 is_stmt 1
 9325 31ca 60E0      		ldi r22,lo8(numer_telefonu_skryba)
 9326 31cc 70E0      		ldi r23,hi8(numer_telefonu_skryba)
 9327 31ce FB01      		movw r30,r22
 9328               		0:
 9329 31d0 0190      		ld __tmp_reg__,Z+
 9330 31d2 0020      		tst __tmp_reg__
 9331 31d4 01F4      		brne 0b
 9332 31d6 BF01      		movw r22,r30
 9333 31d8 6150      		subi r22,1
 9334 31da 7109      		sbc r23,__zero_reg__
1218:main.c        ****         &numer_telefonu_skryba[0],
 9335               		.loc 1 1218 0
 9336 31dc AE01      		movw r20,r28
 9337 31de 4F5F      		subi r20,-1
 9338 31e0 5F4F      		sbci r21,-1
 9339 31e2 80E0      		ldi r24,lo8(numer_telefonu_skryba)
 9340 31e4 90E0      		ldi r25,hi8(numer_telefonu_skryba)
 9341 31e6 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9342               	.LVL690:
1226:main.c        ****       return TRUE; // Duplicate found, abort
 9343               		.loc 1 1226 0
 9344 31ea 80E0      		ldi r24,lo8(numer_telefonu_skryba)
 9345 31ec 90E0      		ldi r25,hi8(numer_telefonu_skryba)
 9346 31ee 0E94 0000 		call czy_numer_istnieje
 9347               	.LVL691:
 9348 31f2 8111      		cpse r24,__zero_reg__
 9349 31f4 00C0      		rjmp .L1048
1231:main.c        **** 
 9350               		.loc 1 1231 0
 9351 31f6 85E0      		ldi r24,lo8(5)
 9352 31f8 FE01      		movw r30,r28
 9353 31fa 3196      		adiw r30,1
 9354 31fc A0E0      		ldi r26,lo8(bufor_eeprom)
 9355 31fe B0E0      		ldi r27,hi8(bufor_eeprom)
 9356               		0:
 9357 3200 0190      		ld r0,Z+
 9358 3202 0D92      		st X+,r0
 9359 3204 8A95      		dec r24
 9360 3206 01F4      		brne 0b
 9361               	.LVL692:
 9362 3208 08E0      		ldi r16,lo8(8)
 9363 320a 10E0      		ldi r17,0
 9364               	.LVL693:
 9365               	.L996:
 9366               	.LBB683:
1236:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
 9367               		.loc 1 1236 0
 9368 320c C801      		movw r24,r16
 9369 320e 0E94 0000 		call eeprom_read_byte
 9370               	.LVL694:
 9371 3212 8F3F      		cpi r24,lo8(-1)
 9372 3214 01F4      		brne .L994
1237:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
 9373               		.loc 1 1237 0
 9374 3216 65E0      		ldi r22,lo8(5)
 9375 3218 C801      		movw r24,r16
 9376 321a 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 9377               	.LVL695:
 9378               	.LBE683:
1247:main.c        ****       // Policz aktywnych uzytkownikow
 9379               		.loc 1 1247 0
 9380 321e 8091 0000 		lds r24,skryba_wlaczona
 9381 3222 08E0      		ldi r16,lo8(8)
 9382 3224 10E0      		ldi r17,0
 9383               	.LBB684:
1249:main.c        ****       for (uint i = 0; i < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++i) {
 9384               		.loc 1 1249 0
 9385 3226 F12C      		mov r15,__zero_reg__
 9386 3228 E12C      		mov r14,__zero_reg__
 9387               	.LBE684:
1247:main.c        ****       // Policz aktywnych uzytkownikow
 9388               		.loc 1 1247 0
 9389 322a 8823      		tst r24
 9390 322c 01F4      		brne .+2
 9391 322e 00C0      		rjmp .L1048
 9392               	.L995:
 9393               	.LVL696:
 9394               	.LBB685:
 9395               	.LBB682:
1251:main.c        ****           ++aktywne_numery;
 9396               		.loc 1 1251 0
 9397 3230 C801      		movw r24,r16
 9398 3232 0E94 0000 		call eeprom_read_byte
 9399               	.LVL697:
 9400 3236 8F3F      		cpi r24,lo8(-1)
 9401 3238 01F0      		breq .L998
1252:main.c        ****         }
 9402               		.loc 1 1252 0
 9403 323a 2FEF      		ldi r18,-1
 9404 323c E21A      		sub r14,r18
 9405 323e F20A      		sbc r15,r18
 9406               	.LVL698:
 9407               	.L998:
 9408 3240 0B5F      		subi r16,-5
 9409 3242 1F4F      		sbci r17,-1
1250:main.c        ****         if (czy_aktywny_numer_telefonu_brama(i)) {
 9410               		.loc 1 1250 0 discriminator 2
 9411 3244 083A      		cpi r16,-88
 9412 3246 8FE0      		ldi r24,15
 9413 3248 1807      		cpc r17,r24
 9414 324a 01F4      		brne .L995
 9415 324c 00C0      		rjmp .L1053
 9416               	.LVL699:
 9417               	.L994:
 9418 324e 0B5F      		subi r16,-5
 9419 3250 1F4F      		sbci r17,-1
 9420               	.LBE682:
 9421               	.LBE685:
 9422               	.LBB686:
1234:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 9423               		.loc 1 1234 0
 9424 3252 083A      		cpi r16,-88
 9425 3254 FFE0      		ldi r31,15
 9426 3256 1F07      		cpc r17,r31
 9427 3258 01F4      		brne .L996
 9428 325a 00C0      		rjmp .L1048
 9429               	.LVL700:
 9430               	.L945:
 9431               	.LBE686:
 9432               	.LBE688:
 9433               	.LBB689:
1268:main.c        **** 
 9434               		.loc 1 1268 0
 9435 325c 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 9436 3260 8111      		cpse r24,__zero_reg__
 9437 3262 00C0      		rjmp .L999
1268:main.c        **** 
 9438               		.loc 1 1268 0 is_stmt 0 discriminator 2
 9439 3264 8091 0000 		lds r24,liczba_znakow_do_zapisu
 9440 3268 8111      		cpse r24,__zero_reg__
 9441 326a 00C0      		rjmp .L999
1268:main.c        **** 
 9442               		.loc 1 1268 0 discriminator 4
 9443 326c 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 9444 3270 8111      		cpse r24,__zero_reg__
 9445 3272 00C0      		rjmp .L999
1268:main.c        **** 
 9446               		.loc 1 1268 0 discriminator 6
 9447 3274 F99B      		sbis 0x1f,1
 9448 3276 00C0      		rjmp .L1000
 9449               	.L999:
1268:main.c        **** 
 9450               		.loc 1 1268 0 discriminator 7
 9451 3278 87E8      		ldi r24,lo8(-121)
 9452 327a 00C0      		rjmp .L1049
 9453               	.L1000:
1276:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
 9454               		.loc 1 1276 0 is_stmt 1
 9455 327c 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 9456 327e 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 9457 3280 FB01      		movw r30,r22
 9458               		0:
 9459 3282 0190      		ld __tmp_reg__,Z+
 9460 3284 0020      		tst __tmp_reg__
 9461 3286 01F4      		brne 0b
 9462 3288 BF01      		movw r22,r30
 9463 328a 6150      		subi r22,1
 9464 328c 7109      		sbc r23,__zero_reg__
1274:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
 9465               		.loc 1 1274 0
 9466 328e AE01      		movw r20,r28
 9467 3290 4F5F      		subi r20,-1
 9468 3292 5F4F      		sbci r21,-1
 9469 3294 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 9470 3296 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 9471 3298 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9472               	.LVL701:
1283:main.c        ****       // Numer juz istnieje - wyslij komunikat
 9473               		.loc 1 1283 0
 9474 329c 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 9475 329e 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 9476 32a0 0E94 0000 		call czy_numer_istnieje
 9477               	.LVL702:
 9478 32a4 D82E      		mov r13,r24
 9479 32a6 8823      		tst r24
 9480 32a8 01F0      		breq .L1001
1285:main.c        ****              (char *)numer_telefonu_odebranego_smsa);
 9481               		.loc 1 1285 0
 9482 32aa 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 9483 32ac 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 9484 32ae 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 9485 32b0 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 9486 32b2 0E94 0000 		call strcpy
 9487               	.LVL703:
1287:main.c        ****                PSTR("Numer juz istnieje w systemie"));
 9488               		.loc 1 1287 0
 9489 32b6 60E0      		ldi r22,lo8(__c.3691)
 9490 32b8 70E0      		ldi r23,hi8(__c.3691)
 9491               	.LVL704:
 9492               	.L1047:
1318:main.c        ****                PSTR("Brak wolnych pozycji Super User (795-800)"));
 9493               		.loc 1 1318 0
 9494 32ba 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 9495 32bc 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 9496 32be 0E94 0000 		call strcpy_P
 9497               	.LVL705:
 9498 32c2 00C0      		rjmp .L1007
 9499               	.LVL706:
 9500               	.L1001:
1294:main.c        **** 
 9501               		.loc 1 1294 0
 9502 32c4 85E0      		ldi r24,lo8(5)
 9503 32c6 FE01      		movw r30,r28
 9504 32c8 3196      		adiw r30,1
 9505 32ca A0E0      		ldi r26,lo8(bufor_eeprom)
 9506 32cc B0E0      		ldi r27,hi8(bufor_eeprom)
 9507               		0:
 9508 32ce 0190      		ld r0,Z+
 9509 32d0 0D92      		st X+,r0
 9510 32d2 8A95      		dec r24
 9511 32d4 01F4      		brne 0b
 9512               	.LVL707:
 9513 32d6 8AE8      		ldi r24,lo8(-118)
 9514 32d8 E82E      		mov r14,r24
 9515 32da 8FE0      		ldi r24,lo8(15)
 9516 32dc F82E      		mov r15,r24
 9517               	.LBB690:
1299:main.c        ****          ++nr_uzyt) {
 9518               		.loc 1 1299 0
 9519 32de 0AE1      		ldi r16,lo8(26)
 9520 32e0 13E0      		ldi r17,lo8(3)
 9521               	.LVL708:
 9522               	.L1005:
1301:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
 9523               		.loc 1 1301 0
 9524 32e2 C701      		movw r24,r14
 9525 32e4 0E94 0000 		call eeprom_read_byte
 9526               	.LVL709:
 9527 32e8 0F5F      		subi r16,-1
 9528 32ea 1F4F      		sbci r17,-1
 9529               	.LVL710:
 9530 32ec 8F3F      		cpi r24,lo8(-1)
 9531 32ee 01F4      		brne .L1003
1302:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt),
 9532               		.loc 1 1302 0
 9533 32f0 65E0      		ldi r22,lo8(5)
 9534 32f2 C701      		movw r24,r14
 9535 32f4 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 9536               	.LVL711:
1305:main.c        ****         pozycja_dodana = nr_uzyt + 1; // User-facing (1-indexed)
 9537               		.loc 1 1305 0
 9538 32f8 DD24      		clr r13
 9539 32fa DA94      		dec r13
 9540               	.LVL712:
 9541               	.L1004:
 9542               	.LBE690:
1312:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 9543               		.loc 1 1312 0
 9544 32fc 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 9545 32fe 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 9546 3300 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 9547 3302 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 9548 3304 0E94 0000 		call strcpy
 9549               	.LVL713:
1314:main.c        ****       sprintf((char *)tekst_wysylanego_smsa, "Super User dodany na pozycji %u",
 9550               		.loc 1 1314 0
 9551 3308 DD20      		tst r13
 9552 330a 01F0      		breq .L1006
1315:main.c        ****               pozycja_dodana);
 9553               		.loc 1 1315 0
 9554 330c 1F93      		push r17
 9555 330e 0F93      		push r16
 9556 3310 80E0      		ldi r24,lo8(.LC7)
 9557 3312 90E0      		ldi r25,hi8(.LC7)
 9558 3314 9F93      		push r25
 9559 3316 8F93      		push r24
 9560 3318 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 9561 331a 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 9562 331c 9F93      		push r25
 9563 331e 8F93      		push r24
 9564 3320 0E94 0000 		call sprintf
 9565               	.LVL714:
 9566 3324 0F90      		pop __tmp_reg__
 9567 3326 0F90      		pop __tmp_reg__
 9568 3328 0F90      		pop __tmp_reg__
 9569 332a 0F90      		pop __tmp_reg__
 9570 332c 0F90      		pop __tmp_reg__
 9571 332e 0F90      		pop __tmp_reg__
 9572               	.L1007:
1321:main.c        **** 
 9573               		.loc 1 1321 0
 9574 3330 83ED      		ldi r24,lo8(-45)
 9575 3332 00C0      		rjmp .L1049
 9576               	.LVL715:
 9577               	.L1003:
 9578 3334 F5E0      		ldi r31,5
 9579 3336 EF0E      		add r14,r31
 9580 3338 F11C      		adc r15,__zero_reg__
 9581               	.LBB691:
1299:main.c        ****          ++nr_uzyt) {
 9582               		.loc 1 1299 0
 9583 333a 0032      		cpi r16,32
 9584 333c 23E0      		ldi r18,3
 9585 333e 1207      		cpc r17,r18
 9586 3340 01F4      		brne .L1005
 9587               	.LVL716:
 9588               	.LBE691:
1298:main.c        ****     for (uint nr_uzyt = 794; nr_uzyt < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 9589               		.loc 1 1298 0
 9590 3342 10E0      		ldi r17,0
 9591               	.LVL717:
 9592 3344 00E0      		ldi r16,0
 9593 3346 00C0      		rjmp .L1004
 9594               	.LVL718:
 9595               	.L1006:
1318:main.c        ****                PSTR("Brak wolnych pozycji Super User (795-800)"));
 9596               		.loc 1 1318 0
 9597 3348 60E0      		ldi r22,lo8(__c.3699)
 9598 334a 70E0      		ldi r23,hi8(__c.3699)
 9599 334c 00C0      		rjmp .L1047
 9600               	.LVL719:
 9601               	.L1009:
 9602               	.LBE689:
1328:main.c        ****                                          numer_telefonu_do_ktorego_dzwonic)],
 9603               		.loc 1 1328 0
 9604 334e 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 9605 3350 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 9606 3352 FB01      		movw r30,r22
 9607               		0:
 9608 3354 0190      		ld __tmp_reg__,Z+
 9609 3356 0020      		tst __tmp_reg__
 9610 3358 01F4      		brne 0b
 9611 335a BF01      		movw r22,r30
 9612 335c 6150      		subi r22,1
 9613 335e 7109      		sbc r23,__zero_reg__
1327:main.c        ****                                      &numer_telefonu_do_ktorego_dzwonic[strlen(
 9614               		.loc 1 1327 0
 9615 3360 40E0      		ldi r20,lo8(bufor_eeprom)
 9616 3362 50E0      		ldi r21,hi8(bufor_eeprom)
 9617 3364 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 9618 3366 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 9619 3368 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9620               	.LVL720:
 9621 336c 08E0      		ldi r16,lo8(8)
 9622 336e 10E0      		ldi r17,0
 9623               	.LVL721:
 9624               	.L1011:
 9625               	.LBB692:
1335:main.c        ****               &bufor_eeprom[0], // 1 porwnanie zajmuje ~10us, czyli 170 numerw ~
 9626               		.loc 1 1335 0
 9627 3370 B801      		movw r22,r16
 9628 3372 80E0      		ldi r24,lo8(bufor_eeprom)
 9629 3374 90E0      		ldi r25,hi8(bufor_eeprom)
 9630 3376 0E94 0000 		call porownaj_numer_telefonu_blok
 9631               	.LVL722:
 9632 337a 8823      		tst r24
 9633 337c 01F0      		breq .L1010
1339:main.c        ****         konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 9634               		.loc 1 1339 0
 9635 337e 1092 0000 		sts numer_telefonu_do_ktorego_dzwonic,__zero_reg__
1340:main.c        ****                                          &numer_telefonu_do_ktorego_dzwonic[1],
 9636               		.loc 1 1340 0
 9637 3382 40E0      		ldi r20,lo8(bufor_eeprom)
 9638 3384 50E0      		ldi r21,hi8(bufor_eeprom)
 9639 3386 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic+1)
 9640 3388 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic+1)
 9641 338a 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 9642 338c 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 9643 338e 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9644               	.LVL723:
1343:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
 9645               		.loc 1 1343 0
 9646 3392 65E0      		ldi r22,lo8(5)
 9647 3394 C801      		movw r24,r16
 9648 3396 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 9649               	.LVL724:
 9650 339a 00C0      		rjmp .L1048
 9651               	.L1010:
 9652 339c 0B5F      		subi r16,-5
 9653 339e 1F4F      		sbci r17,-1
1333:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 9654               		.loc 1 1333 0
 9655 33a0 083A      		cpi r16,-88
 9656 33a2 FFE0      		ldi r31,15
 9657 33a4 1F07      		cpc r17,r31
 9658 33a6 01F4      		brne .L1011
 9659 33a8 00C0      		rjmp .L1048
 9660               	.LBE692:
 9661               		.cfi_endproc
 9662               	.LFE59:
 9664               	.global	wykonanie_komend
 9666               	wykonanie_komend:
 9667               	.LFB61:
1423:main.c        ****   if (wykonanie_komend_SIM900())
 9668               		.loc 1 1423 0
 9669               		.cfi_startproc
 9670               	/* prologue: function */
 9671               	/* frame size = 0 */
 9672               	/* stack size = 0 */
 9673               	.L__stack_usage = 0
1424:main.c        ****     ;
 9674               		.loc 1 1424 0
 9675 33aa 0E94 0000 		call wykonanie_komend_SIM900
 9676               	.LVL725:
 9677 33ae 8111      		cpse r24,__zero_reg__
 9678 33b0 00C0      		rjmp .L1056
1426:main.c        ****     ;
 9679               		.loc 1 1426 0
 9680 33b2 0E94 0000 		call wykonanie_komend_ukladow
 9681               	.LVL726:
 9682 33b6 8111      		cpse r24,__zero_reg__
 9683 33b8 00C0      		rjmp .L1056
1428:main.c        ****     ;
 9684               		.loc 1 1428 0
 9685 33ba 0E94 0000 		call wykonanie_komend_powiadomien
 9686               	.LVL727:
 9687               	.L1056:
1432:main.c        **** }
 9688               		.loc 1 1432 0
 9689 33be 0C94 0000 		jmp usun_komende
 9690               	.LVL728:
 9691               		.cfi_endproc
 9692               	.LFE61:
 9694               		.section	.text.startup,"ax",@progbits
 9695               	.global	main
 9697               	main:
 9698               	.LFB71:
1831:main.c        **** 
1832:main.c        **** #include "test_debug.h"
1833:main.c        **** 
1834:main.c        **** int main(void) {
 9699               		.loc 1 1834 0
 9700               		.cfi_startproc
 9701               	/* prologue: function */
 9702               	/* frame size = 0 */
 9703               	/* stack size = 0 */
 9704               	.L__stack_usage = 0
 9705               	.LVL729:
 9706               	.LBB693:
 9707               	.LBB694:
 9708               		.loc 7 473 0
 9709 0000 88E1      		ldi r24,lo8(24)
 9710 0002 9BE0      		ldi r25,lo8(11)
 9711               	/* #APP */
 9712               	 ;  473 "/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h" 1
 9713 0004 0FB6      		in __tmp_reg__,__SREG__
 9714 0006 F894      		cli
 9715 0008 A895      		wdr
 9716 000a 8093 6000 		sts 96, r24
 9717 000e 0FBE      		out __SREG__,__tmp_reg__
 9718 0010 9093 6000 		sts 96, r25
 9719               	 	
 9720               	 ;  0 "" 2
 9721               	.LVL730:
 9722               	/* #NOAPP */
 9723               	.LBE694:
 9724               	.LBE693:
1835:main.c        ****   // POMOC_DODAJ2('*', 'u');
1836:main.c        ****   { // inicjalizacja
1837:main.c        **** #ifndef DEBUG
1838:main.c        ****     wdt_enable(WDTO_120MS);
1839:main.c        ****     opoznienie_startowe();
 9725               		.loc 1 1839 0
 9726 0014 0E94 0000 		call opoznienie_startowe
 9727               	.LVL731:
1840:main.c        ****     opoznienie_startowe();
 9728               		.loc 1 1840 0
 9729 0018 0E94 0000 		call opoznienie_startowe
 9730               	.LVL732:
1841:main.c        ****     opoznienie_startowe();
 9731               		.loc 1 1841 0
 9732 001c 0E94 0000 		call opoznienie_startowe
 9733               	.LVL733:
1842:main.c        ****     opoznienie_startowe();
 9734               		.loc 1 1842 0
 9735 0020 0E94 0000 		call opoznienie_startowe
 9736               	.LVL734:
1843:main.c        **** #endif
1844:main.c        ****     inicjalizacja_portow();
 9737               		.loc 1 1844 0
 9738 0024 81E0      		ldi r24,lo8(1)
 9739 0026 87B9      		out 0x7,r24
 9740 0028 88B9      		out 0x8,r24
 9741 002a 80E2      		ldi r24,lo8(32)
 9742 002c 8AB9      		out 0xa,r24
1845:main.c        ****     inicjalizuj_parametry_modulu();
 9743               		.loc 1 1845 0
 9744 002e 0E94 0000 		call inicjalizuj_parametry_modulu
 9745               	.LVL735:
1846:main.c        ****     inicjalizacja_SIM900();
 9746               		.loc 1 1846 0
 9747 0032 0E94 0000 		call inicjalizacja_SIM900
 9748               	.LVL736:
1847:main.c        **** #ifdef DEBUG
1848:main.c        ****     debug_main();
1849:main.c        **** #endif
1850:main.c        ****     ustaw_parametry_dla_bezpieczenstwa();
 9749               		.loc 1 1850 0
 9750 0036 0E94 0000 		call ustaw_parametry_dla_bezpieczenstwa
 9751               	.LVL737:
1851:main.c        ****   }
1852:main.c        **** 
1853:main.c        ****   sei();
 9752               		.loc 1 1853 0
 9753               	/* #APP */
 9754               	 ;  1853 "main.c" 1
 9755 003a 7894      		sei
 9756               	 ;  0 "" 2
 9757               	/* #NOAPP */
 9758               	.L1063:
1854:main.c        **** 
1855:main.c        ****   for (;;) {
1856:main.c        ****     // wykonanie watkw moe trwa maksymalnie 10 ms
1857:main.c        ****     if (CZY_WYKONAC_WATKI_10MS())
 9759               		.loc 1 1857 0
 9760 003c 8091 0000 		lds r24,wykonac_watki
 9761 0040 80FD      		sbrc r24,0
1858:main.c        ****       ustaw_parametry_dla_bezpieczenstwa();
 9762               		.loc 1 1858 0
 9763 0042 0E94 0000 		call ustaw_parametry_dla_bezpieczenstwa
 9764               	.LVL738:
 9765               	.L1059:
1859:main.c        ****     if (CZY_WYKONAC_WATKI_100MS()) {
 9766               		.loc 1 1859 0
 9767 0046 8091 0000 		lds r24,wykonac_watki
 9768 004a 81FD      		sbrc r24,1
1860:main.c        ****       steruj_urzadzeniem_100MS();
 9769               		.loc 1 1860 0
 9770 004c 0E94 0000 		call steruj_urzadzeniem_100MS
 9771               	.LVL739:
 9772               	.L1060:
1861:main.c        **** #ifdef TEST_PCB
1862:main.c        ****       testPCB();
1863:main.c        **** #endif
1864:main.c        ****     }
1865:main.c        ****     if (CZY_WYKONAC_WATKI_10MS()) {
 9773               		.loc 1 1865 0
 9774 0050 8091 0000 		lds r24,wykonac_watki
 9775 0054 80FF      		sbrs r24,0
 9776 0056 00C0      		rjmp .L1061
1866:main.c        ****       steruj_urzadzeniem_10MS();
 9777               		.loc 1 1866 0
 9778 0058 0E94 0000 		call steruj_urzadzeniem_10MS
 9779               	.LVL740:
1867:main.c        ****       wykonanie_komend();
 9780               		.loc 1 1867 0
 9781 005c 0E94 0000 		call wykonanie_komend
 9782               	.LVL741:
1868:main.c        **** 
1869:main.c        ****       RESETUJ_WYKONANIE_WATKOW();
 9783               		.loc 1 1869 0
 9784 0060 1092 0000 		sts wykonac_watki,__zero_reg__
 9785               	.L1061:
1870:main.c        ****     }
1871:main.c        **** 
1872:main.c        ****     { // tryb SLEEP
1873:main.c        ****       cli();
 9786               		.loc 1 1873 0
 9787               	/* #APP */
 9788               	 ;  1873 "main.c" 1
 9789 0064 F894      		cli
 9790               	 ;  0 "" 2
1874:main.c        ****       if (!wykonaj_zdarzenie_timer) {
 9791               		.loc 1 1874 0
 9792               	/* #NOAPP */
 9793 0066 8091 0000 		lds r24,wykonaj_zdarzenie_timer
 9794 006a 8111      		cpse r24,__zero_reg__
 9795 006c 00C0      		rjmp .L1062
1875:main.c        ****         sleep_enable();
 9796               		.loc 1 1875 0
 9797 006e 83B7      		in r24,0x33
 9798 0070 8160      		ori r24,lo8(1)
 9799 0072 83BF      		out 0x33,r24
1876:main.c        ****         sei();
 9800               		.loc 1 1876 0
 9801               	/* #APP */
 9802               	 ;  1876 "main.c" 1
 9803 0074 7894      		sei
 9804               	 ;  0 "" 2
1877:main.c        ****         sleep_cpu();
 9805               		.loc 1 1877 0
 9806               	 ;  1877 "main.c" 1
 9807 0076 8895      		sleep
 9808               		
 9809               	 ;  0 "" 2
1878:main.c        ****         cli();
 9810               		.loc 1 1878 0
 9811               	 ;  1878 "main.c" 1
 9812 0078 F894      		cli
 9813               	 ;  0 "" 2
1879:main.c        ****         sleep_disable();
 9814               		.loc 1 1879 0
 9815               	/* #NOAPP */
 9816 007a 83B7      		in r24,0x33
 9817 007c 8E7F      		andi r24,lo8(-2)
 9818 007e 83BF      		out 0x33,r24
 9819               	.L1062:
1880:main.c        ****       }
1881:main.c        ****       sei();
 9820               		.loc 1 1881 0
 9821               	/* #APP */
 9822               	 ;  1881 "main.c" 1
 9823 0080 7894      		sei
 9824               	 ;  0 "" 2
1882:main.c        ****       wolne_zdarzenie_timer();
 9825               		.loc 1 1882 0
 9826               	/* #NOAPP */
 9827 0082 0E94 0000 		call wolne_zdarzenie_timer
 9828               	.LVL742:
1857:main.c        ****       ustaw_parametry_dla_bezpieczenstwa();
 9829               		.loc 1 1857 0
 9830 0086 00C0      		rjmp .L1063
 9831               		.cfi_endproc
 9832               	.LFE71:
 9834               		.local	licznik_resetow.3788
 9835               		.comm	licznik_resetow.3788,1,1
 9836               		.local	licznik_wybuc_watki_100MS.3744
 9837               		.comm	licznik_wybuc_watki_100MS.3744,1,1
 9838               		.local	licznik_dioda_led_poziom_sieci.3737
 9839               		.comm	licznik_dioda_led_poziom_sieci.3737,1,1
 9840               		.section	.progmem.data,"a",@progbits
 9843               	__c.3699:
 9844 0000 4272 616B 		.string	"Brak wolnych pozycji Super User (795-800)"
 9844      2077 6F6C 
 9844      6E79 6368 
 9844      2070 6F7A 
 9844      7963 6A69 
 9847               	__c.3691:
 9848 002a 4E75 6D65 		.string	"Numer juz istnieje w systemie"
 9848      7220 6A75 
 9848      7A20 6973 
 9848      746E 6965 
 9848      6A65 2077 
 9851               	tab_eeprom_fabryczny.3640:
 9852 0048 FF        		.byte	-1
 9853 0049 41        		.byte	65
 9854 004a 42        		.byte	66
 9855 004b 43        		.byte	67
 9856 004c 44        		.byte	68
 9857 004d 00        		.byte	0
 9858               		.local	licznik_odebranych_znakow.3485
 9859               		.comm	licznik_odebranych_znakow.3485,2,1
 9860               		.local	licznik_poprzednia_komenda.3484
 9861               		.comm	licznik_poprzednia_komenda.3484,2,1
 9862               		.local	poprzednia_komenda.3483
 9863               		.comm	poprzednia_komenda.3483,1,1
 9864               		.local	licznik_bezpieczenstwa.3482
 9865               		.comm	licznik_bezpieczenstwa.3482,2,1
 9866               		.local	licznik_cyklu_8_sek.3478
 9867               		.comm	licznik_cyklu_8_sek.3478,1,1
 9870               	nastepna_komenda.3469:
 9871 004e 00        		.byte	0
 9872 004f 00        		.byte	0
 9873 0050 A2        		.byte	-94
 9874 0051 A3        		.byte	-93
 9875 0052 A4        		.byte	-92
 9876 0053 A6        		.byte	-90
 9877 0054 A7        		.byte	-89
 9878 0055 A8        		.byte	-88
 9879 0056 A9        		.byte	-87
 9880 0057 94        		.byte	-108
 9883               	instrukcje.3468:
 9884 0058 2B63 7069 		.string	"+cpin?"
 9884      6E3F 00
 9885 005f 0000 0000 		.zero	7
 9885      0000 00
 9886 0066 2B63 6E6D 		.string	"+cnmi=2,1,2,1"
 9886      693D 322C 
 9886      312C 322C 
 9886      3100 
 9887 0074 2B6D 6F72 		.string	"+moring=1"
 9887      696E 673D 
 9887      3100 
 9888 007e 0000 0000 		.zero	4
 9889 0082 2B63 6C69 		.string	"+clip=1"
 9889      703D 3100 
 9890 008a 0000 0000 		.zero	6
 9890      0000 
 9891 0090 2B64 6465 		.string	"+ddet=1,10,1"
 9891      743D 312C 
 9891      3130 2C31 
 9891      00
 9892 009d 00        		.zero	1
 9893 009e 2B63 616C 		.string	"+calm=1"
 9893      6D3D 3100 
 9894 00a6 0000 0000 		.zero	6
 9894      0000 
 9895 00ac 2B63 7273 		.string	"+crsl=1"
 9895      6C3D 3100 
 9896 00b4 0000 0000 		.zero	6
 9896      0000 
 9897 00ba 2B63 7573 		.string	"+cusd=1"
 9897      643D 3100 
 9898 00c2 0000 0000 		.zero	6
 9898      0000 
 9899 00c8 2B63 7062 		.string	"+cpbw=26,\"1\""
 9899      773D 3236 
 9899      2C22 3122 
 9899      00
 9900 00d5 00        		.zero	1
 9901 00d6 2B63 6C74 		.string	"+clts=0"
 9901      733D 3000 
 9902 00de 0000 0000 		.zero	6
 9902      0000 
 9905               	instrukcja.3454:
 9906 00e4 2B63 6D69 		.string	"+cmic=0,15"
 9906      633D 302C 
 9906      3135 00
 9909               	instrukcja_usun_wszystkie_smsy.3451:
 9910 00ef 2B63 6D67 		.string	"+cmgda=6"
 9910      6461 3D36 
 9910      00
 9911               		.local	drugi_raz.3450
 9912               		.comm	drugi_raz.3450,1,1
 9915               	instrukcja_podaj_pin.3448:
 9916 00f8 2B63 7069 		.string	"+cpin=\"1976\""
 9916      6E3D 2231 
 9916      3937 3622 
 9916      00
 9919               	instrukcja_at.3445:
 9920 0105 2B69 6663 		.string	"+ifc=2,2"
 9920      3D32 2C32 
 9920      00
 9923               	instrukcja_ustawienie_pamieci.3442:
 9924 010e 2B63 706D 		.string	"+cpms=\"SM\",\"SM\",\"SM\""
 9924      733D 2253 
 9924      4D22 2C22 
 9924      534D 222C 
 9924      2253 4D22 
 9927               	instrukcja_ustawienie_pamieci.3440:
 9928 0123 2B63 6473 		.string	"+cdscb"
 9928      6362 00
 9931               	instrukcja_cclk.3438:
 9932 012a 2B63 636C 		.string	"+cclk?"
 9932      6B3F 00
 9935               	instrukcja_sprawdz_operatora.3436:
 9936 0131 2B63 6F70 		.string	"+cops?"
 9936      733F 00
 9939               	instrukcja_odczyt_ksiazki.3434:
 9940 0138 2B63 7062 		.string	"+cpbr=26"
 9940      723D 3236 
 9940      00
 9943               	instrukcja_creg.3432:
 9944 0141 2B63 7265 		.string	"+creg?"
 9944      673F 00
 9947               	instrukcja_poziom_sieci.3430:
 9948 0148 2B63 7371 		.string	"+csq"
 9948      00
 9951               	instrukcja_vts.3426:
 9952 014d 2B76 7473 		.string	"+vts=1"
 9952      3D31 00
 9955               	instrukcja_odbierz_rozmowe.3424:
 9956 0154 6100      		.string	"a"
 9959               	instrukcja_odrzuc_rozmowe.3422:
 9960 0156 6800      		.string	"h"
 9963               	__c.3419:
 9964 0158 2B43 4D54 		.string	"+CMTI:"
 9964      493A 00
 9967               	instrukcja_usun_smsa.3415:
 9968 015f 2B63 6D67 		.string	"+cmgd="
 9968      643D 00
 9971               	instrukcja_odczytaj_smsa.3382:
 9972 0166 2B63 6D67 		.string	"+cmgr="
 9972      723D 00
 9975               	instrukcja_wyslij_smsa.3350:
 9976 016d 2B63 6D67 		.string	"+cmgs="
 9976      733D 00
 9979               	__c.3330:
 9980 0174 2B43 4D54 		.string	"+CMTI:"
 9980      493A 00
 9983               	__c.3323:
 9984 017b 2B44 544D 		.string	"+DTMF:"
 9984      463A 00
 9987               	__c.3318:
 9988 0182 2B43 4C49 		.string	"+CLIP:"
 9988      503A 00
 9991               	__c.3305:
 9992 0189 3E00      		.string	">"
 9995               	__c.3276:
 9996 018b 2B43 4D47 		.string	"+CMGR:"
 9996      523A 00
 9999               	polecenie_operator.3247:
 10000 0192 2B43 4F50 		.string	"+COPS:"
 10000      533A 00
 10003               	urc.3242:
 10004 0199 2B43 5245 		.string	"+CREG:"
 10004      473A 00
 10007               	urc.3239:
 10008 01a0 2B43 5351 		.string	"+CSQ:"
 10008      3A00 
 10009               		.local	nr_zapytania_o_pin.3233
 10010               		.comm	nr_zapytania_o_pin.3233,1,1
 10013               	polecenie_pin_ready.3232:
 10014 01a6 2B43 5049 		.string	"+CPIN: READY"
 10014      4E3A 2052 
 10014      4541 4459 
 10014      00
 10017               	polecenie_zegar.3221:
 10018 01b3 2B43 434C 		.string	"+CCLK:"
 10018      4B3A 00
 10019               		.local	licznik_reset.3167
 10020               		.comm	licznik_reset.3167,1,1
 10023               	__c.3146:
 10024 01ba 313D 5243 		.string	"1=RCV 2=BSY 3=CNT 4=QSM 5=QAL 6=FND 7=ADD"
 10024      5620 323D 
 10024      4253 5920 
 10024      333D 434E 
 10024      5420 343D 
 10027               	__c.3144:
 10028 01e4 2055 373D 		.string	" U7="
 10028      00
 10031               	__c.3142:
 10032 01e9 2055 363D 		.string	" U6="
 10032      00
 10035               	__c.3140:
 10036 01ee 2055 353D 		.string	" U5="
 10036      00
 10039               	__c.3138:
 10040 01f3 5534 3D00 		.string	"U4="
 10043               	__c.3136:
 10044 01f7 2055 333D 		.string	" U3="
 10044      00
 10047               	__c.3134:
 10048 01fc 2055 323D 		.string	" U2="
 10048      00
 10051               	__c.3132:
 10052 0201 5531 3D00 		.string	"U1="
 10055               	__c.3130:
 10056 0205 534B 5259 		.string	"SKRYBA:"
 10056      4241 3A00 
 10059               	__c.3127:
 10060 020d 4445 4255 		.string	"DEBUG\n"
 10060      470A 00
 10063               	tekst_demo.3053:
 10064 0214 7777 772E 		.string	"www.sonfy.pl"
 10064      736F 6E66 
 10064      792E 706C 
 10064      00
 10067               	__c.3051:
 10068 0221 536B 7279 		.string	"Skryba: Wylaczona"
 10068      6261 3A20 
 10068      5779 6C61 
 10068      637A 6F6E 
 10068      6100 
 10071               	__c.3049:
 10072 0233 536B 7279 		.string	"Skryba: Wlaczona"
 10072      6261 3A20 
 10072      576C 6163 
 10072      7A6F 6E61 
 10072      00
 10075               	__c.3047:
 10076 0244 4861 726D 		.string	"Harmonogram: Wylaczony"
 10076      6F6E 6F67 
 10076      7261 6D3A 
 10076      2057 796C 
 10076      6163 7A6F 
 10079               	__c.3045:
 10080 025b 2044 544D 		.string	" DTMF"
 10080      4600 
 10083               	__c.3043:
 10084 0261 2043 4C49 		.string	" CLIP"
 10084      5000 
 10087               	__c.3041:
 10088 0267 5472 7962 		.string	"Tryb: Publiczny"
 10088      3A20 5075 
 10088      626C 6963 
 10088      7A6E 7900 
 10091               	__c.3039:
 10092 0277 5472 7962 		.string	"Tryb: Prywatny"
 10092      3A20 5072 
 10092      7977 6174 
 10092      6E79 00
 10095               	__c.3037:
 10096 0286 5374 6174 		.string	"Status: Aktywny"
 10096      7573 3A20 
 10096      416B 7479 
 10096      776E 7900 
 10099               	__c.3035:
 10100 0296 5374 6174 		.string	"Status: Zablokowany"
 10100      7573 3A20 
 10100      5A61 626C 
 10100      6F6B 6F77 
 10100      616E 7900 
 10103               	tekst_gsm.3021:
 10104 02aa 557A 7974 		.string	"Uzytkownicy "
 10104      6B6F 776E 
 10104      6963 7920 
 10104      00
 10107               	tekst_gsm.3010:
 10108 02b7 557A 7974 		.string	"Uzytkownicy "
 10108      6B6F 776E 
 10108      6963 7920 
 10108      00
 10111               	text_sygnal.3006:
 10112 02c4 5379 676E 		.string	"Sygnal GSM "
 10112      616C 2047 
 10112      534D 2000 
 10115               	__c.3004:
 10116 02d0 437A 6173 		.string	"Czas: "
 10116      3A20 00
 10119               	tekst_gsm.3002:
 10120 02d7 4143 3830 		.string	"AC800-DTM-TS"
 10120      302D 4454 
 10120      4D2D 5453 
 10120      00
 10121               		.local	stan.2971
 10122               		.comm	stan.2971,1,1
 10123               		.local	opoznienie_1s.2970
 10124               		.comm	opoznienie_1s.2970,1,1
 10125               	.global	wysylanie_smsa_clipa
 10126               		.section .bss
 10129               	wysylanie_smsa_clipa:
 10130 0000 00        		.zero	1
 10131               		.comm	ptr_start_pdu_z_wiadomoscia,2,1
 10132               	.global	wysylanie_echa_przez_pdu
 10135               	wysylanie_echa_przez_pdu:
 10136 0001 00        		.zero	1
 10137               		.local	liczba_kolejnych_watchdogow_wysylania
 10138               		.comm	liczba_kolejnych_watchdogow_wysylania,1,1
 10139               		.local	licznik_watchdog_wysylanie_smsa_100ms
 10140               		.comm	licznik_watchdog_wysylanie_smsa_100ms,2,1
 10141               		.local	licznik_awaryjnych_resetow_kolejki
 10142               		.comm	licznik_awaryjnych_resetow_kolejki,2,1
 10143               		.local	licznik_usunietych_sms_przez_limit
 10144               		.comm	licznik_usunietych_sms_przez_limit,2,1
 10145               		.local	licznik_kolejka_stoi_100ms
 10146               		.comm	licznik_kolejka_stoi_100ms,2,1
 10147               		.local	ostatnia_pierwsza_komenda
 10148               		.comm	ostatnia_pierwsza_komenda,1,1
 10149               		.local	timer_report_user_100ms
 10150               		.comm	timer_report_user_100ms,2,1
 10151               		.local	licznik_report_user
 10152               		.comm	licznik_report_user,1,1
 10153               		.comm	numer_telefonu_skryba,20,1
 10154               		.comm	numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama,1,1
 10155               		.comm	nie_wysylaj_echa_z_powodu_nietypowego_smsa,1,1
 10156               		.comm	kod_modulu,4,1
 10157               	.global	tryb_pracy
 10158               		.data
 10161               	tryb_pracy:
 10162 0000 01        		.byte	1
 10163               	.global	blokada_systemu
 10164               		.section .bss
 10167               	blokada_systemu:
 10168 0002 00        		.zero	1
 10169               	.global	opoznienie_wysylania_clipow_100MS
 10172               	opoznienie_wysylania_clipow_100MS:
 10173 0003 0000      		.zero	2
 10174               	.global	licznik_reset_urzadzenia
 10177               	licznik_reset_urzadzenia:
 10178 0005 00        		.zero	1
 10179               	.global	licznik_reset_modulu_SIM900
 10182               	licznik_reset_modulu_SIM900:
 10183 0006 00        		.zero	1
 10184               	.global	modul_zalogowany_w_sieci
 10187               	modul_zalogowany_w_sieci:
 10188 0007 00        		.zero	1
 10189               	.global	licznik_wybudz_watki_10MS
 10192               	licznik_wybudz_watki_10MS:
 10193 0008 00        		.zero	1
 10194               	.global	wykonac_watki
 10197               	wykonac_watki:
 10198 0009 00        		.zero	1
 10199               	.global	wykonac_watki_10MS
 10202               	wykonac_watki_10MS:
 10203 000a 00        		.zero	1
 10204               	.global	wykonaj_zdarzenie_timer
 10207               	wykonaj_zdarzenie_timer:
 10208 000b 00        		.zero	1
 10209               	.global	stan_cyklu_blysku
 10212               	stan_cyklu_blysku:
 10213 000c 00        		.zero	1
 10214               	.global	liczba_blyskow_led
 10217               	liczba_blyskow_led:
 10218 000d 00        		.zero	1
 10219               		.comm	licznik_100ms_dioda_led,1,1
 10220               	.global	g_czas_systemowy_100ms
 10223               	g_czas_systemowy_100ms:
 10224 000e 0000 0000 		.zero	4
 10225               	.global	licznik_timeout_rozmowy_100ms
 10228               	licznik_timeout_rozmowy_100ms:
 10229 0012 0000      		.zero	2
 10230               	.global	tryb_clip
 10231               		.data
 10234               	tryb_clip:
 10235 0001 FF        		.byte	-1
 10236               	.global	skryba_limit
 10239               	skryba_limit:
 10240 0002 1B03      		.word	795
 10241               	.global	skryba_wlaczona
 10242               		.section .bss
 10245               	skryba_wlaczona:
 10246 0014 00        		.zero	1
 10247               		.comm	stan_wyjscie,1,1
 10248               	.global	sms_pomijaj_aktualizacje_czasu
 10251               	sms_pomijaj_aktualizacje_czasu:
 10252 0015 00        		.zero	1
 10253               	.global	sms_timestamp_sekunda
 10256               	sms_timestamp_sekunda:
 10257 0016 00        		.zero	1
 10258               	.global	sms_timestamp_minuta
 10261               	sms_timestamp_minuta:
 10262 0017 00        		.zero	1
 10263               	.global	sms_timestamp_godzina
 10266               	sms_timestamp_godzina:
 10267 0018 00        		.zero	1
 10268               	.global	watchdog_sms_safe_mode_100ms
 10271               	watchdog_sms_safe_mode_100ms:
 10272 0019 0000      		.zero	2
 10273               	.global	watchdog_sms_trwa_reset
 10276               	watchdog_sms_trwa_reset:
 10277 001b 00        		.zero	1
 10278               	.global	watchdog_sms_licznik_100ms
 10281               	watchdog_sms_licznik_100ms:
 10282 001c 0000      		.zero	2
 10283               	.global	watchdog_sms_aktywny
 10286               	watchdog_sms_aktywny:
 10287 001e 00        		.zero	1
 10288               		.comm	opoznienie_zatrzymaj_odpytywanie_urzadzenia,1,1
 10289               	.global	blokada_clip
 10292               	blokada_clip:
 10293 001f 00        		.zero	1
 10294               	.global	max_oczekiwanie_na_odpowiedz_at
 10297               	max_oczekiwanie_na_odpowiedz_at:
 10298 0020 00        		.zero	1
 10299               		.comm	licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow,1,1
 10300               	.global	licznik_bezpieczenstwa_opoznienie_wysylania_sms
 10303               	licznik_bezpieczenstwa_opoznienie_wysylania_sms:
 10304 0021 0000      		.zero	2
 10305               	.global	licznik_ogolny_blad_zalogowania
 10308               	licznik_ogolny_blad_zalogowania:
 10309 0023 0000      		.zero	2
 10310               	.global	licznik_blad_zalogowania_u_operatora
 10313               	licznik_blad_zalogowania_u_operatora:
 10314 0025 00        		.zero	1
 10315               	.global	licznik_blad_stanu_karty_SIM
 10318               	licznik_blad_stanu_karty_SIM:
 10319 0026 00        		.zero	1
 10320               	.global	licznik_awaria_brak_zasiegu
 10323               	licznik_awaria_brak_zasiegu:
 10324 0027 0000      		.zero	2
 10325               	.global	liczba_smsow_ech_do_wyslania
 10328               	liczba_smsow_ech_do_wyslania:
 10329 0029 00        		.zero	1
 10330               	.global	ustaw_maksymalny_czas_dzwonienia
 10333               	ustaw_maksymalny_czas_dzwonienia:
 10334 002a 00        		.zero	1
 10335               	.global	maksymalny_czas_dzwonienia
 10338               	maksymalny_czas_dzwonienia:
 10339 002b 00        		.zero	1
 10340               		.comm	numer_telefonu_do_ktorego_dzwonic,33,1
 10341               		.comm	numer_telefonu_ktory_dzwoni,17,1
 10342               	.global	liczba_prob_wyslania_smsa
 10345               	liczba_prob_wyslania_smsa:
 10346 002c 00        		.zero	1
 10347               	.global	flaga_wysylanie_smsa
 10350               	flaga_wysylanie_smsa:
 10351 002d 00        		.zero	1
 10352               		.comm	numer_telefonu_wysylanego_smsa,33,1
 10353               	.global	flaga_odczytywanie_smsa
 10356               	flaga_odczytywanie_smsa:
 10357 002e 00        		.zero	1
 10358               		.comm	numer_telefonu_odebranego_smsa,17,1
 10359               	.global	dlugosc_pdu
 10362               	dlugosc_pdu:
 10363 002f 00        		.zero	1
 10364               		.comm	bufor_pdu,200,1
 10365               	.global	licznik_bezpieczenstwa_wykonywana_rozmowa
 10368               	licznik_bezpieczenstwa_wykonywana_rozmowa:
 10369 0030 0000      		.zero	2
 10370               	.global	trwa_rozmowa_przychodzaca_od_uzytkownika
 10373               	trwa_rozmowa_przychodzaca_od_uzytkownika:
 10374 0032 00        		.zero	1
 10375               	.global	max_oczekiwanie_na_odpowiedz
 10376               		.data
 10379               	max_oczekiwanie_na_odpowiedz:
 10380 0004 03        		.byte	3
 10381               		.comm	liczba_wykonanych_komend_identycznego_polecenia,1,1
 10382               	.global	nastepne_wysylane_polecenie_SIM900
 10383               		.section .bss
 10386               	nastepne_wysylane_polecenie_SIM900:
 10387 0033 00        		.zero	1
 10388               	.global	licznik_wysylane_polecenie_SIM900
 10391               	licznik_wysylane_polecenie_SIM900:
 10392 0034 0000      		.zero	2
 10393               	.global	aktualnie_wysylane_polecenie_SIM900
 10396               	aktualnie_wysylane_polecenie_SIM900:
 10397 0036 00        		.zero	1
 10398               		.comm	nazwa_operatora,11,1
 10399               	.global	oproznij_bufor_SIM900_po_bledzie
 10402               	oproznij_bufor_SIM900_po_bledzie:
 10403 0037 00        		.zero	1
 10404               	.global	opoznienie_SIM900_100MS
 10407               	opoznienie_SIM900_100MS:
 10408 0038 00        		.zero	1
 10409               		.text
 10410               	.Letext0:
 10411               		.file 8 "narzedzia.h"
 10412               		.file 9 "/usr/local/avr8-gnu-toolchain/avr/include/stdint.h"
 10413               		.file 10 "/usr/local/avr8-gnu-toolchain/lib/gcc/avr/7.3.0/include/stddef.h"
 10414               		.file 11 "/usr/local/avr8-gnu-toolchain/avr/include/stdio.h"
 10415               		.file 12 "enumkomendy.h"
 10416               		.file 13 "data_sim900.h"
 10417               		.file 14 "pamiec_ram.h"
 10418               		.file 15 "interpretacjaSMS.h"
 10419               		.file 16 "komendy.h"
 10420               		.file 17 "poleceniagsm.h"
 10421               		.file 18 "sim900.h"
 10422               		.file 19 "zapiseeprom.h"
 10423               		.file 20 "bufpomoc.h"
 10424               		.file 21 "/usr/local/avr8-gnu-toolchain/avr/include/avr/eeprom.h"
 10425               		.file 22 "konfiguracja.h"
 10426               		.file 23 "/usr/local/avr8-gnu-toolchain/avr/include/string.h"
 10427               		.file 24 "/usr/local/avr8-gnu-toolchain/avr/include/avr/pgmspace.h"
 10428               		.file 25 "pdu.h"
 10429               		.file 26 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:4      *ABS*:000000000000003f __SREG__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:5      *ABS*:000000000000003b __RAMPZ__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:6      *ABS*:0000000000000000 __tmp_reg__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:7      *ABS*:0000000000000001 __zero_reg__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:12     .text:0000000000000000 watchdog_sms_disarm
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10286  .bss:000000000000001e watchdog_sms_aktywny
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10281  .bss:000000000000001c watchdog_sms_licznik_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:33     .text:000000000000000e czy_numer_istnieje
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:100    .text:000000000000004e usun_zablokowany_sms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10396  .bss:0000000000000036 aktualnie_wysylane_polecenie_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:128    .text:0000000000000062 zareaguj_na_usuniety_sms_z_powodu_limitu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10142  .bss:000000000000004e licznik_usunietych_sms_przez_limit
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10217  .bss:000000000000000d liczba_blyskow_led
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10212  .bss:000000000000000c stan_cyklu_blysku
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:166    .text:000000000000008e polozenie_polecenia_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:187    .text:0000000000000098 opoznienie_startowe
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:252    .text:00000000000000d8 zapisz_debug_do_eeprom
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10150  .bss:0000000000000055 licznik_report_user
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10148  .bss:0000000000000053 timer_report_user_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10350  .bss:000000000000002d flaga_wysylanie_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:368    .text:000000000000015c test_dioda_wyjscia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10122  .bss:0000000000000048 opoznienie_1s.2970
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10020  .bss:0000000000000047 stan.2971
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:411    .text:000000000000018a test_wejscie
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:443    .text:000000000000019a __vector_16
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10192  .bss:0000000000000008 licznik_wybudz_watki_10MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10202  .bss:000000000000000a wykonac_watki_10MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10207  .bss:000000000000000b wykonaj_zdarzenie_timer
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:658    .text:000000000000029c generuj_raport_sieci
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10119  .progmem.data:00000000000002d7 tekst_gsm.3002
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10115  .progmem.data:00000000000002d0 __c.3004
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10111  .progmem.data:00000000000002c4 text_sygnal.3006
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10187  .bss:0000000000000007 modul_zalogowany_w_sieci
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:840    .text:0000000000000364 generuj_raport_uzytkownikow_1
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10107  .progmem.data:00000000000002b7 tekst_gsm.3010
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:1026   .text:0000000000000416 generuj_raport_uzytkownikow
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10103  .progmem.data:00000000000002aa tekst_gsm.3021
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:1202   .text:00000000000004b8 generuj_raport_stanu_urzadzenia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10167  .bss:0000000000000002 blokada_systemu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10099  .progmem.data:0000000000000296 __c.3035
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10095  .progmem.data:0000000000000286 __c.3037
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10161  .data:0000000000000000 tryb_pracy
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10091  .progmem.data:0000000000000277 __c.3039
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10087  .progmem.data:0000000000000267 __c.3041
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10234  .data:0000000000000001 tryb_clip
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10083  .progmem.data:0000000000000261 __c.3043
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10079  .progmem.data:000000000000025b __c.3045
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10075  .progmem.data:0000000000000244 __c.3047
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10245  .bss:0000000000000014 skryba_wlaczona
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10071  .progmem.data:0000000000000233 __c.3049
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10067  .progmem.data:0000000000000221 __c.3051
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10063  .progmem.data:0000000000000214 tekst_demo.3053
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:1456   .text:0000000000000634 czy_numer_jest_super_userem
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:1550   .text:0000000000000694 ustaw_wyjscie_clip
                            *COM*:0000000000000001 stan_wyjscie
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:1592   .text:00000000000006b4 wykonanie_polecenia_sms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10251  .bss:0000000000000015 sms_pomijaj_aktualizacje_czasu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10256  .bss:0000000000000016 sms_timestamp_sekunda
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10261  .bss:0000000000000017 sms_timestamp_minuta
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10266  .bss:0000000000000018 sms_timestamp_godzina
                            *COM*:0000000000000011 numer_telefonu_odebranego_smsa
                            *COM*:0000000000000021 numer_telefonu_wysylanego_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10059  .progmem.data:000000000000020d __c.3127
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10055  .progmem.data:0000000000000205 __c.3130
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10051  .progmem.data:0000000000000201 __c.3132
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10047  .progmem.data:00000000000001fc __c.3134
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10043  .progmem.data:00000000000001f7 __c.3136
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10039  .progmem.data:00000000000001f3 __c.3138
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10035  .progmem.data:00000000000001ee __c.3140
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10031  .progmem.data:00000000000001e9 __c.3142
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10027  .progmem.data:00000000000001e4 __c.3144
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10023  .progmem.data:00000000000001ba __c.3146
                            *COM*:0000000000000021 numer_telefonu_do_ktorego_dzwonic
                            *COM*:0000000000000001 numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:2601   .text:0000000000000c42 steruj_wejsciem_reset_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10010  .bss:0000000000000046 licznik_reset.3167
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:2672   .text:0000000000000c8a sprawdz_przychodzaca_rozmowe
                            *COM*:0000000000000011 numer_telefonu_ktory_dzwoni
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:2809   .text:0000000000000d2e zakonczono_rozmowe_telefoniczna
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10407  .bss:0000000000000038 opoznienie_SIM900_100MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10368  .bss:0000000000000030 licznik_bezpieczenstwa_wykonywana_rozmowa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10333  .bss:000000000000002a ustaw_maksymalny_czas_dzwonienia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10338  .bss:000000000000002b maksymalny_czas_dzwonienia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10292  .bss:000000000000001f blokada_clip
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:2839   .text:0000000000000d4a zakonczono_wysylanie_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10129  .bss:0000000000000000 wysylanie_smsa_clipa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:2862   .text:0000000000000d56 problem_z_wyslaniem_powiadomienia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10391  .bss:0000000000000034 licznik_wysylane_polecenie_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:2894   .text:0000000000000d7e wyzerowanie_danych_SIM900
                            *COM*:0000000000000001 licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10373  .bss:0000000000000032 trwa_rozmowa_przychodzaca_od_uzytkownika
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10356  .bss:000000000000002e flaga_odczytywanie_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:2933   .text:0000000000000dac reset_modulu_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10318  .bss:0000000000000026 licznik_blad_stanu_karty_SIM
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10313  .bss:0000000000000025 licznik_blad_zalogowania_u_operatora
                            *COM*:000000000000000b nazwa_operatora
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10308  .bss:0000000000000023 licznik_ogolny_blad_zalogowania
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10386  .bss:0000000000000033 nastepne_wysylane_polecenie_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:2997   .text:0000000000000e06 obsluga_wysylania_sms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10345  .bss:000000000000002c liczba_prob_wyslania_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:3209   .text:0000000000000f10 odpowiedz_na_polecenie
                            *COM*:0000000000000001 liczba_wykonanych_komend_identycznego_polecenia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10003  .progmem.data:0000000000000199 urc.3242
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9991   .progmem.data:0000000000000189 __c.3305
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10297  .bss:0000000000000020 max_oczekiwanie_na_odpowiedz_at
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10017  .progmem.data:00000000000001b3 polecenie_zegar.3221
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10013  .progmem.data:00000000000001a6 polecenie_pin_ready.3232
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9912   .bss:0000000000000045 nr_zapytania_o_pin.3233
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10007  .progmem.data:00000000000001a0 urc.3239
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9999   .progmem.data:0000000000000192 polecenie_operator.3247
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10228  .bss:0000000000000012 licznik_timeout_rozmowy_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9995   .progmem.data:000000000000018b __c.3276
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10362  .bss:000000000000002f dlugosc_pdu
                            *COM*:00000000000000c8 bufor_pdu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:4364   .text:000000000000158c obsluga_komendy_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10402  .bss:0000000000000037 oproznij_bufor_SIM900_po_bledzie
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9987   .progmem.data:0000000000000182 __c.3318
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9983   .progmem.data:000000000000017b __c.3323
                            *COM*:0000000000000001 licznik_100ms_dioda_led
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9979   .progmem.data:0000000000000174 __c.3330
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:4840   .text:0000000000001832 wyslanie_polecenia_ROM
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:4883   .text:000000000000185a wyslij_sms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9975   .progmem.data:000000000000016d instrukcja_wyslij_smsa.3350
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10379  .data:0000000000000004 max_oczekiwanie_na_odpowiedz
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:5059   .text:0000000000001954 wykonanie_komend_SIM900
                            *COM*:0000000000000001 opoznienie_zatrzymaj_odpytywanie_urzadzenia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9870   .progmem.data:000000000000004e nastepna_komenda.3469
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9883   .progmem.data:0000000000000058 instrukcje.3468
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9971   .progmem.data:0000000000000166 instrukcja_odczytaj_smsa.3382
                            *COM*:0000000000000001 nie_wysylaj_echa_z_powodu_nietypowego_smsa
                            *COM*:0000000000000002 ptr_start_pdu_z_wiadomoscia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9967   .progmem.data:000000000000015f instrukcja_usun_smsa.3415
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9963   .progmem.data:0000000000000158 __c.3419
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9959   .progmem.data:0000000000000156 instrukcja_odrzuc_rozmowe.3422
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9955   .progmem.data:0000000000000154 instrukcja_odbierz_rozmowe.3424
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9951   .progmem.data:000000000000014d instrukcja_vts.3426
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9947   .progmem.data:0000000000000148 instrukcja_poziom_sieci.3430
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9943   .progmem.data:0000000000000141 instrukcja_creg.3432
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9939   .progmem.data:0000000000000138 instrukcja_odczyt_ksiazki.3434
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9935   .progmem.data:0000000000000131 instrukcja_sprawdz_operatora.3436
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9931   .progmem.data:000000000000012a instrukcja_cclk.3438
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9927   .progmem.data:0000000000000123 instrukcja_ustawienie_pamieci.3440
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9923   .progmem.data:000000000000010e instrukcja_ustawienie_pamieci.3442
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9919   .progmem.data:0000000000000105 instrukcja_at.3445
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9915   .progmem.data:00000000000000f8 instrukcja_podaj_pin.3448
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9867   .bss:0000000000000044 drugi_raz.3450
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9909   .progmem.data:00000000000000ef instrukcja_usun_wszystkie_smsy.3451
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9905   .progmem.data:00000000000000e4 instrukcja.3454
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:6463   .text:0000000000002202 steruj_SIM900_100MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10172  .bss:0000000000000003 opoznienie_wysylania_clipow_100MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9865   .bss:0000000000000043 licznik_cyklu_8_sek.3478
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10323  .bss:0000000000000027 licznik_awaria_brak_zasiegu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10182  .bss:0000000000000006 licznik_reset_modulu_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:6762   .text:00000000000023da steruj_SIM900_10MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9863   .bss:0000000000000041 licznik_bezpieczenstwa.3482
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9861   .bss:0000000000000040 poprzednia_komenda.3483
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9859   .bss:000000000000003e licznik_poprzednia_komenda.3484
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9839   .bss:000000000000003c licznik_odebranych_znakow.3485
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:7065   .text:000000000000259a wykonanie_komend_powiadomien
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:7341   .text:0000000000002706 test_sms_clip_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:7357   .text:0000000000002708 steruj_wejscia_wyjscia_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:7379   .text:0000000000002714 zapis_w_eeprom_stanu_wyjsc
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:7475   .text:0000000000002790 steruj_urzadzeniem_100MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10146  .bss:0000000000000052 ostatnia_pierwsza_komenda
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10144  .bss:0000000000000050 licznik_kolejka_stoi_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10138  .bss:000000000000004a licznik_watchdog_wysylanie_smsa_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10140  .bss:000000000000004c licznik_awaryjnych_resetow_kolejki
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10124  .bss:0000000000000049 liczba_kolejnych_watchdogow_wysylania
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10276  .bss:000000000000001b watchdog_sms_trwa_reset
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10271  .bss:0000000000000019 watchdog_sms_safe_mode_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9837   .bss:000000000000003b licznik_dioda_led_poziom_sieci.3737
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:7818   .text:00000000000029bc steruj_urzadzeniem_10MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:7840   .text:00000000000029c8 wolne_zdarzenie_timer
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10197  .bss:0000000000000009 wykonac_watki
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9835   .bss:000000000000003a licznik_wybuc_watki_100MS.3744
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:8024   .text:0000000000002aa6 ustaw_parametry_dla_bezpieczenstwa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:8062   .text:0000000000002ac6 inicjalizuj_parametry_modulu
                            *COM*:0000000000000004 kod_modulu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10239  .data:0000000000000002 skryba_limit
                             .bss:0000000000000039 licznik_resetow.3788
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:8472   .text:0000000000002d22 wykonanie_komend_ukladow
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9851   .progmem.data:0000000000000048 tab_eeprom_fabryczny.3640
                            *COM*:0000000000000014 numer_telefonu_skryba
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9847   .progmem.data:000000000000002a __c.3691
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9843   .progmem.data:0000000000000000 __c.3699
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9666   .text:00000000000033aa wykonanie_komend
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:9697   .text.startup:0000000000000000 main
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10135  .bss:0000000000000001 wysylanie_echa_przez_pdu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10177  .bss:0000000000000005 licznik_reset_urzadzenia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10223  .bss:000000000000000e g_czas_systemowy_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10303  .bss:0000000000000021 licznik_bezpieczenstwa_opoznienie_wysylania_sms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccE8bxLU.s:10328  .bss:0000000000000029 liczba_smsow_ech_do_wyslania

UNDEFINED SYMBOLS
bufor_eeprom
konwertuj_telefon_na_blok_eeprom
porownaj_numer_telefonu_blok
filtruj_i_dodaj_komende
odebrany_blok_SIM900
strstr_P
bufor_pomoc_liczba_znakow_do_zapisu
liczba_znakow_do_zapisu
czy_zajety_bufor_eeprom
komendy_kolejka
zapisz_znaki_w_eeprom
licznik_wejscie
komenda_SIM900
liczba_odebranych_znakow_SIM900
licznik_opoznienie_oczekiwania_na_bajt_SIM900
sprawdzaj_wejscie_CTS_SIM900
podlaczony_modul_gsm_SIM900
nr_wyslanego_znaku_SIM900
wysylany_blok_SIM900
memcpy_P
strcpy_P
rtc_czas
strcat
poziom_sieci_gsm
__divmodhi4
__utoa_ncheck
eeprom_read_byte
tekst_wysylanego_smsa
czas_start_h
czas_stop_m
czas_stop_h
czas_start_m
sprintf
licznik_przelacznik_wyjscia
interpretuj_wiadomosc_sms
bufor_ustaw_czas
dodaj_komende
blokada_sterowania_czasowa
__tablejump2__
strcpy
konwertuj_blok_eeprom_na_telefon
czy_sa_komendy_z_przedzialu
stan_logiczny_na_wejsciu
wykonywanie_rozmowy_telefonicznej
czekanie_na_odebranie_zachety
liczba_komend_w_kolejce_SIM900
flaga_odebrany_znak_zachety
licznik_100ms_procedura_inicjalizacyjna_SIM900
podlaczona_karta_SIM_SIM900
filtruj_komendy_z_przedzialu
numer_bledu_cms
numer_bledu_cme
strtol
strchr
bledny_PIN
strncmp_P
memcpy
konwertuj_blok_dwa_znaki_na_znak_pdu
liczba_wysylanych_znakow_SIM900
memcmp
strtoul
wyslij_polecenie_ROM_SIM900
zapisz_naglowek_pdu
ascii_to_pdu_blok
wyslij_polecenie_RAM_SIM900
pobierz_numer_telefonu_nadawcy_z_PDU
konwertuj_pdu_na_blok_wysylany
wyslij_znaki_SIM900
pobierz_date_z_PDU
pobierz_czas_z_PDU
pdu_to_ascii
procedura_inicjalizacyjna_SIM900_100MS
czy_jest_nowa_komenda_SIM900
kopiuj_blok_eeprom_na_telefon
aktualizuj_stan_wyzwolenia_wejsc_100ms
steruj_wyjscia_100ms
steruj_wejscia_10ms
zapisz_bajt_w_EEPROM
poczatek_polecenia_SIM900
zakonczenie_polecenia_SIM900
czy_jest_nowe_polecenie_SIM900
eeprom_read_block
eeprom_update_block
eeprom_update_byte
zapisz_znaki_w_eeprom_bez_kopiowania
memset
zapisz_znak_w_eeprom
usun_komende
inicjalizacja_SIM900
__do_copy_data
__do_clear_bss
