   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	watchdog_sms_disarm:
  13               	.LFB33:
  14               		.file 1 "main.c"
   1:main.c        **** 
   2:main.c        **** #ifndef INCLUDE
   3:main.c        **** #include "narzedzia.h"
   4:main.c        **** #include <avr/eeprom.h>
   5:main.c        **** #include <avr/interrupt.h>
   6:main.c        **** #include <avr/io.h>
   7:main.c        **** #include <avr/pgmspace.h>
   8:main.c        **** #include <avr/sleep.h>
   9:main.c        **** #include <avr/wdt.h>
  10:main.c        **** #include <ctype.h>
  11:main.c        **** #include <stdio.h>
  12:main.c        **** #include <stdlib.h>
  13:main.c        **** #include <string.h>
  14:main.c        **** #include <util/crc16.h>
  15:main.c        **** #include <util/delay.h>
  16:main.c        **** 
  17:main.c        **** #ifndef TEST_ATMEGA128
  18:main.c        **** #include "pin_ATmega328.h"
  19:main.c        **** #else
  20:main.c        **** #include "pin_ATmega128.h"
  21:main.c        **** #endif
  22:main.c        **** #include "bufpomoc.h"
  23:main.c        **** #include "data_sim900.h"
  24:main.c        **** #include "interpretacjaSMS.h"
  25:main.c        **** #include "komendy.h"
  26:main.c        **** #include "konfiguracja.h"
  27:main.c        **** #include "pdu.h"
  28:main.c        **** #include "sim900.h"
  29:main.c        **** #include "wewy.h"
  30:main.c        **** #include "zapiseeprom.h"
  31:main.c        **** 
  32:main.c        **** #include "test_pcb.h"
  33:main.c        **** 
  34:main.c        **** #endif
  35:main.c        **** 
  36:main.c        **** // static const char nazwa_urzadzenia[12 + 1] PROGMEM = "BRAMA";
  37:main.c        **** 
  38:main.c        **** uchar skryba_wlaczona = FALSE;
  39:main.c        **** uint skryba_limit = 800; // Domyslny limit uzytkownikow dla Skryby
  40:main.c        **** uchar tryb_clip = TRUE;
  41:main.c        **** uint licznik_timeout_rozmowy_100ms = 0;
  42:main.c        **** 
  43:main.c        **** volatile uint32_t g_czas_systemowy_100ms = 0;
  44:main.c        **** 
  45:main.c        **** #define INFORMACJA_W_RAPORCIE "www.sonfy.pl"
  46:main.c        **** 
  47:main.c        **** uchar licznik_100ms_dioda_led;
  48:main.c        **** uchar liczba_blyskow_led = 0;
  49:main.c        **** uchar stan_cyklu_blysku =
  50:main.c        ****     0; // 0-5: 0-1=ON (200ms), 2-5=OFF (400ms), 1 blysk=600ms
  51:main.c        **** 
  52:main.c        **** #define zapal_diode_led(czas_100ms) (licznik_100ms_dioda_led = (czas_100ms) + 1)
  53:main.c        **** #define zapal_diode_led_blyski(liczba)                                         \
  54:main.c        ****   (liczba_blyskow_led = (liczba), stan_cyklu_blysku = 0)
  55:main.c        **** // #define zapal_diode_led(czas_100ms)
  56:main.c        **** 
  57:main.c        **** volatile uchar wykonaj_zdarzenie_timer = FALSE;
  58:main.c        **** #define CZY_WYKONAC_ZDARZENIE_TIMER() wykonaj_zdarzenie_timer
  59:main.c        **** 
  60:main.c        **** #define WYKONAJ_WATKI_BRAK 0
  61:main.c        **** #define WYKONAJ_WATKI_10MS BIT(0)
  62:main.c        **** #define WYKONAJ_WATKI_100MS BIT(1)
  63:main.c        **** volatile uchar wykonac_watki_10MS = FALSE;
  64:main.c        **** uchar wykonac_watki = WYKONAJ_WATKI_BRAK;
  65:main.c        **** #define CZY_WYKONAC_WATKI_10MS() (wykonac_watki & WYKONAJ_WATKI_10MS)
  66:main.c        **** #define CZY_WYKONAC_WATKI_100MS() (wykonac_watki & WYKONAJ_WATKI_100MS)
  67:main.c        **** #define RESETUJ_WYKONANIE_WATKOW() (wykonac_watki = 0)
  68:main.c        **** 
  69:main.c        **** volatile uchar licznik_wybudz_watki_10MS = 0;
  70:main.c        **** #define OPOZNIENIE_TIMERA_0 18
  71:main.c        **** #define czy_pozostal_czas(procent)                                             \
  72:main.c        ****   (licznik_wybudz_watki_10MS < (100 - (procent)) * OPOZNIENIE_TIMERA_0 / 100)
  73:main.c        **** 
  74:main.c        **** przerwanie_timer() {
  75:main.c        ****   if (++licznik_wybudz_watki_10MS >= OPOZNIENIE_TIMERA_0) {
  76:main.c        ****     licznik_wybudz_watki_10MS = 0;
  77:main.c        ****     wykonac_watki_10MS = TRUE;
  78:main.c        ****   }
  79:main.c        **** 
  80:main.c        ****   if (STATUS_WLACZONY_SIM900()) {
  81:main.c        ****     if (!CZY_ODBIERANIE_DANYCH_SIM900() && czy_jest_bezczynny_SIM900()) {
  82:main.c        ****       ustaw_odbior_SIM900();
  83:main.c        ****     }
  84:main.c        ****     if (CZY_HANDSHAKING_CTS_ZEZWALA_NA_TRANSMISJE_SIM900()) {
  85:main.c        ****       cli();
  86:main.c        ****       if (CZY_WYSYLANIE_DANYCH_SIM900()) {
  87:main.c        ****         WYLACZ_PRZERWANIE_WYSYLANIA_DANYCH_SIM900();
  88:main.c        ****         sei();
  89:main.c        ****         uchar p = sprawdzaj_wejscie_CTS_SIM900;
  90:main.c        ****         if (p && (podlaczony_modul_gsm_SIM900 ||
  91:main.c        ****                   aktualnie_wysylane_polecenie_SIM900 ==
  92:main.c        ****                       KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT)) {
  93:main.c        ****           p = FALSE;
  94:main.c        ****           sprawdzaj_wejscie_CTS_SIM900 = p;
  95:main.c        ****           WSTAW_ZNAK_DO_BUFORA_SIM900();
  96:main.c        ****         }
  97:main.c        ****         cli();
  98:main.c        ****         WLACZ_PRZERWANIE_WYSYLANIA_DANYCH_SIM900();
  99:main.c        ****       }
 100:main.c        ****       sei();
 101:main.c        ****     }
 102:main.c        ****   } else {
 103:main.c        ****     zakoncz_przesylanie_SIM900();
 104:main.c        ****   }
 105:main.c        **** 
 106:main.c        ****   wykonaj_zdarzenie_timer =
 107:main.c        ****       TRUE; // uruchamia zdarzenie_timer, ktra korzysta z pozostaych zmiennych
 108:main.c        **** }
 109:main.c        **** 
 110:main.c        **** uchar modul_zalogowany_w_sieci = FALSE;
 111:main.c        **** 
 112:main.c        **** uchar licznik_reset_modulu_SIM900 = 0;
 113:main.c        **** #define START_LICZNIK_RESET_MODULU_SIM900 30
 114:main.c        **** 
 115:main.c        **** uchar licznik_reset_urzadzenia = 0;
 116:main.c        **** #define LICZNIK_RESET_URZADZENIA_RESET_SIM900 200
 117:main.c        **** #define START_LICZNIK_RESET_URZADZENIA 220
 118:main.c        **** 
 119:main.c        **** uint opoznienie_wysylania_clipow_100MS = 0;
 120:main.c        **** 
 121:main.c        **** void generuj_raport_sieci(uchar **buf_sms) {
 122:main.c        ****   static const char tekst_gsm[] PROGMEM = "AC800-TS";
 123:main.c        ****   uchar *ptr = *buf_sms;
 124:main.c        **** 
 125:main.c        ****   memcpy_R(ptr, tekst_gsm);
 126:main.c        ****   ptr += sizeof tekst_gsm - 1;
 127:main.c        ****   *ptr++ = '\n';
 128:main.c        **** 
 129:main.c        ****   strcpy_P((char *)ptr, PSTR("Czas: "));
 130:main.c        ****   ptr += strlen((char *)ptr);
 131:main.c        ****   strcat((char *)ptr, rtc_czas);
 132:main.c        ****   ptr += strlen((char *)ptr);
 133:main.c        ****   *ptr++ = '\n';
 134:main.c        **** 
 135:main.c        ****   static const char text_sygnal[] PROGMEM = "Sygnal GSM ";
 136:main.c        ****   memcpy_R(ptr, text_sygnal);
 137:main.c        ****   ptr += sizeof text_sygnal - 1;
 138:main.c        **** 
 139:main.c        ****   if (poziom_sieci_gsm <= 31 && modul_zalogowany_w_sieci) {
 140:main.c        ****     utoa(poziom_sieci_gsm * 100 / 31, ptr, 10);
 141:main.c        ****     ptr += strlen(ptr);
 142:main.c        ****     *ptr++ = '%';
 143:main.c        ****   } else {
 144:main.c        ****     *ptr++ = '-';
 145:main.c        ****     *ptr++ = '-';
 146:main.c        ****     *ptr++ = '-';
 147:main.c        ****   }
 148:main.c        ****   *ptr = 0;
 149:main.c        ****   *buf_sms = ptr;
 150:main.c        **** }
 151:main.c        **** 
 152:main.c        **** void generuj_raport_uzytkownikow_1(uchar **buf_sms) {
 153:main.c        ****   static const char tekst_gsm[] PROGMEM = "Uzytkownicy ";
 154:main.c        ****   uchar *ptr = *buf_sms;
 155:main.c        **** 
 156:main.c        ****   memcpy_R(ptr, tekst_gsm);
 157:main.c        ****   ptr += sizeof tekst_gsm - 1;
 158:main.c        ****   uint aktywne_numery = 0;
 159:main.c        ****   uint wolne_numery = 0;
 160:main.c        ****   // for (uchar nr_uzyt_clip = 0; nr_uzyt_clip <
 161:main.c        ****   // MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip)
 162:main.c        ****   for (uint nr_uzyt_clip = 0; nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 163:main.c        ****        ++nr_uzyt_clip) {
 164:main.c        ****     if (czy_aktywny_numer_telefonu_brama(nr_uzyt_clip))
 165:main.c        ****       ++aktywne_numery;
 166:main.c        ****     else
 167:main.c        ****       ++wolne_numery;
 168:main.c        ****   }
 169:main.c        **** 
 170:main.c        ****   utoa(aktywne_numery, ptr, 10);
 171:main.c        ****   ptr += strlen(ptr);
 172:main.c        ****   *ptr++ = '/';
 173:main.c        ****   utoa(wolne_numery, ptr, 10);
 174:main.c        ****   ptr += strlen(ptr);
 175:main.c        ****   *buf_sms = ptr;
 176:main.c        **** }
 177:main.c        **** 
 178:main.c        **** void generuj_raport_uzytkownikow(uchar **buf_sms) {
 179:main.c        ****   static const char tekst_gsm[] PROGMEM = "Uzytkownicy ";
 180:main.c        ****   uchar *ptr = *buf_sms;
 181:main.c        **** 
 182:main.c        ****   memcpy_R(ptr, tekst_gsm);
 183:main.c        ****   ptr += sizeof tekst_gsm - 1;
 184:main.c        ****   uchar aktywne_numery = 0;
 185:main.c        ****   uchar wolne_numery = 0;
 186:main.c        ****   for (uint nr_uzyt_clip = 0; nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 187:main.c        ****        ++nr_uzyt_clip) {
 188:main.c        ****     if (czy_aktywny_numer_telefonu_brama(nr_uzyt_clip))
 189:main.c        ****       ++aktywne_numery;
 190:main.c        ****     else
 191:main.c        ****       ++wolne_numery;
 192:main.c        ****   }
 193:main.c        ****   utoa(aktywne_numery, ptr, 10);
 194:main.c        ****   ptr += strlen(ptr);
 195:main.c        ****   *ptr++ = '/';
 196:main.c        ****   utoa(wolne_numery, ptr, 10);
 197:main.c        ****   ptr += strlen(ptr);
 198:main.c        ****   *buf_sms = ptr;
 199:main.c        **** }
 200:main.c        **** 
 201:main.c        **** uchar blokada_systemu = FALSE; // Nowa zmienna globalna
 202:main.c        **** uchar tryb_pracy = 1;          // 0=Prywatny, 1=Publiczny (domyślnie Publiczny)
 203:main.c        **** 
 204:main.c        **** void generuj_raport_stanu_urzadzenia(void) {
 205:main.c        ****   uchar *sms = (char *)tekst_wysylanego_smsa;
 206:main.c        ****   *sms++ = '*';
 207:main.c        ****   *sms++ = '\n';
 208:main.c        ****   generuj_raport_sieci(&sms);
 209:main.c        ****   *sms++ = '\n';
 210:main.c        ****   generuj_raport_uzytkownikow_1(&sms);
 211:main.c        ****   *sms++ = '\n';
 212:main.c        **** 
 213:main.c        ****   // Status sterownika (START/STOP)
 214:main.c        ****   if (blokada_systemu) {
 215:main.c        ****     strcpy_P((char *)sms, PSTR("Status: Zablokowany"));
 216:main.c        ****   } else {
 217:main.c        ****     strcpy_P((char *)sms, PSTR("Status: Aktywny"));
 218:main.c        ****   }
 219:main.c        ****   sms += strlen((char *)sms);
 220:main.c        ****   *sms++ = '\n';
 221:main.c        **** 
 222:main.c        ****   // Tryb pracy (OPEN/CLOSE)
 223:main.c        ****   if (tryb_pracy == 0) {
 224:main.c        ****     strcpy_P((char *)sms, PSTR("Tryb: Prywatny"));
 225:main.c        ****   } else {
 226:main.c        ****     strcpy_P((char *)sms, PSTR("Tryb: Publiczny"));
 227:main.c        ****   }
 228:main.c        ****   sms += strlen((char *)sms);
 229:main.c        **** 
 230:main.c        ****   if (tryb_clip) {
 231:main.c        ****     strcpy_P((char *)sms, PSTR(" CLIP"));
 232:main.c        ****   } else {
 233:main.c        ****     strcpy_P((char *)sms, PSTR(" DTMF"));
 234:main.c        ****   }
 235:main.c        ****   sms += strlen((char *)sms);
 236:main.c        ****   *sms++ = '\n';
 237:main.c        **** 
 238:main.c        ****   if (czas_start_h == 0xFF) {
 239:main.c        ****     strcpy_P((char *)sms, PSTR("Harmonogram: Wylaczony"));
 240:main.c        ****   } else {
 241:main.c        ****     sprintf((char *)sms, "Harmonogram: %02d:%02d %02d:%02d", (int)czas_start_h,
 242:main.c        ****             (int)czas_start_m, (int)czas_stop_h, (int)czas_stop_m);
 243:main.c        ****   }
 244:main.c        ****   sms += strlen((char *)sms);
 245:main.c        ****   *sms++ = '\n';
 246:main.c        **** 
 247:main.c        ****   if (skryba_wlaczona) {
 248:main.c        ****     uint aktywne_numery = 0;
 249:main.c        ****     for (uint nr_uzyt_clip = 0;
 250:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 251:main.c        ****       if (czy_aktywny_numer_telefonu_brama(nr_uzyt_clip))
 252:main.c        ****         ++aktywne_numery;
 253:main.c        ****     }
 254:main.c        ****     int pozostalo = (int)skryba_limit - (int)aktywne_numery;
 255:main.c        ****     if (pozostalo < 0)
 256:main.c        ****       pozostalo = 0;
 257:main.c        ****     sprintf((char *)sms, "Skryba: Limit %d", pozostalo);
 258:main.c        ****   } else {
 259:main.c        ****     strcpy_P((char *)sms, PSTR("Skryba: Wylaczony"));
 260:main.c        ****   }
 261:main.c        ****   sms += strlen((char *)sms);
 262:main.c        ****   *sms++ = '\n';
 263:main.c        **** 
 264:main.c        ****   static const char tekst_demo[] PROGMEM = INFORMACJA_W_RAPORCIE;
 265:main.c        ****   strcpy_P((char *)sms, tekst_demo);
 266:main.c        **** }
 267:main.c        **** 
 268:main.c        **** void ustaw_wyjscie_clip(void) {
 269:main.c        ****   stan_wyjscie[0] = TRUE;
 270:main.c        ****   licznik_przelacznik_wyjscia[0] = 2 * 10ul; // 2 sekundy
 271:main.c        **** }
 272:main.c        **** 
 273:main.c        **** uchar kod_modulu[LICZBA_BAJTOW_KODU_DOSTEPU];
 274:main.c        **** 
 275:main.c        **** uchar nie_wysylaj_echa_z_powodu_nietypowego_smsa;
 276:main.c        **** 
 277:main.c        **** uchar numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama;
 278:main.c        **** uchar numer_telefonu_skryba[20];
 279:main.c        **** 
 280:main.c        **** // Blokada komend REPORT/USER - maksymalnie 8 w ciągu 30 sekund
 281:main.c        **** static uchar licznik_report_user = 0;
 282:main.c        **** static uint timer_report_user_100ms = 0;
 283:main.c        **** #define MAX_LICZBA_KOMEND_REPORT_USER_W_OKNIE 8
 284:main.c        **** #define OKNO_CZASOWE_REPORT_USER_100MS (30 * 10) // 30 sekund
 285:main.c        **** 
 286:main.c        **** // Mechanizm wykrywania zablokowanej kolejki i czyszczenia
 287:main.c        **** static komenda_typ ostatnia_pierwsza_komenda = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 288:main.c        **** static uint licznik_kolejka_stoi_100ms = 0;
 289:main.c        **** #define MAX_CZAS_KOLEJKA_STOI_100MS                                            \
 290:main.c        ****   (15 * 10) // 15 sekund - jesli kolejka stoi tyle czasu, wyczysc
 291:main.c        **** 
 292:main.c        **** static uint licznik_usunietych_sms_przez_limit = 0;
 293:main.c        **** static uint licznik_awaryjnych_resetow_kolejki = 0;
 294:main.c        **** 
 295:main.c        **** #define WATCHDOG_WYSYLANIA_SMS_100MS (30 * 10) // 30 sekund
 296:main.c        **** static uint licznik_watchdog_wysylanie_smsa_100ms = 0;
 297:main.c        **** static uchar liczba_kolejnych_watchdogow_wysylania = 0;
 298:main.c        **** #define WATCHDOG_SMS_TIMEOUT_100MS (10 * 10) // 10 sekund
 299:main.c        **** #define WATCHDOG_SMS_SAFE_MODE_100MS                                           \
 300:main.c        ****   (5 * 10) // 5 sekund po resecie - nie przyjmuj SMS
 301:main.c        **** 
 302:main.c        **** static inline void watchdog_sms_arm(void) {
 303:main.c        ****   watchdog_sms_aktywny = TRUE;
 304:main.c        ****   watchdog_sms_licznik_100ms = 0;
 305:main.c        **** }
 306:main.c        **** 
 307:main.c        **** static inline void watchdog_sms_disarm(void) {
  15               		.loc 1 307 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 308:main.c        ****   watchdog_sms_aktywny = FALSE;
  21               		.loc 1 308 0
  22 0000 1092 0000 		sts watchdog_sms_aktywny,__zero_reg__
 309:main.c        ****   watchdog_sms_licznik_100ms = 0;
  23               		.loc 1 309 0
  24 0004 1092 0000 		sts watchdog_sms_licznik_100ms+1,__zero_reg__
  25 0008 1092 0000 		sts watchdog_sms_licznik_100ms,__zero_reg__
  26               	/* epilogue start */
 310:main.c        **** }
  27               		.loc 1 310 0
  28 000c 0895      		ret
  29               		.cfi_endproc
  30               	.LFE33:
  33               	czy_numer_istnieje:
  34               	.LFB57:
 311:main.c        **** 
 312:main.c        **** static inline void sygnalizuj_pelny_system(void) {
 313:main.c        ****   // 10 szybkich blyskow informuje, ze kolejka/limit SMS jest zapelniony
 314:main.c        ****   zapal_diode_led_blyski(10);
 315:main.c        **** }
 316:main.c        **** 
 317:main.c        **** // Funkcja usuwania zablokowanego SMS z modulu SIM900
 318:main.c        **** static void usun_zablokowany_sms(void) {
 319:main.c        ****   // Usun SMS z modulu SIM900 (numer jest w aktualnie_wysylane_polecenie_SIM900)
 320:main.c        ****   // Sprawdzamy czy to byla komenda odczytu SMS
 321:main.c        ****   if (aktualnie_wysylane_polecenie_SIM900 >= KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 322:main.c        ****       aktualnie_wysylane_polecenie_SIM900 <= KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 323:main.c        ****     const uchar nr_smsa =
 324:main.c        ****         aktualnie_wysylane_polecenie_SIM900 - KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1;
 325:main.c        ****     // Uzywamy filtruj_i_dodaj_komende zamiast dodaj_komende
 326:main.c        ****     filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_USUN_SMSA_1 + nr_smsa);
 327:main.c        ****   } else {
 328:main.c        ****     // Fallback: Usun wszystkie
 329:main.c        ****     filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 330:main.c        ****   }
 331:main.c        **** }
 332:main.c        **** 
 333:main.c        **** static void zareaguj_na_usuniety_sms_z_powodu_limitu(void) {
 334:main.c        ****   if (licznik_usunietych_sms_przez_limit < 0xFFFF)
 335:main.c        ****     ++licznik_usunietych_sms_przez_limit;
 336:main.c        ****   sygnalizuj_pelny_system();
 337:main.c        ****   watchdog_sms_disarm();
 338:main.c        ****   // Uzywamy filtruj_i_dodaj
 339:main.c        ****   filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 340:main.c        **** }
 341:main.c        **** 
 342:main.c        **** // Funkcja zapisu znacznikow debugowania do EEPROM
 343:main.c        **** static void zapisz_debug_do_eeprom(uchar komenda, uchar akcja) {
 344:main.c        ****   if (!czy_wolny_eeprom())
 345:main.c        ****     return;
 346:main.c        **** 
 347:main.c        ****   uchar buf[8];
 348:main.c        ****   buf[0] = licznik_report_user;
 349:main.c        ****   buf[1] = (uchar)(timer_report_user_100ms & 0xFF);
 350:main.c        ****   buf[2] = (uchar)((timer_report_user_100ms >> 8) & 0xFF);
 351:main.c        ****   buf[3] = (uchar)flaga_wysylanie_smsa;
 352:main.c        **** 
 353:main.c        ****   uchar liczba_sms_w_kolejce = 0;
 354:main.c        ****   for (uchar i = 0; i < LICZBA_KOMEND; ++i) {
 355:main.c        ****     if (komendy_kolejka[i] >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
 356:main.c        ****         komendy_kolejka[i] <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
 357:main.c        ****       ++liczba_sms_w_kolejce;
 358:main.c        ****   }
 359:main.c        ****   buf[4] = liczba_sms_w_kolejce;
 360:main.c        ****   buf[5] = komenda;
 361:main.c        ****   buf[6] = akcja;
 362:main.c        **** 
 363:main.c        ****   zapisz_znaki_w_eeprom(buf, EEPROM_DEBUG_START, 7);
 364:main.c        **** }
 365:main.c        **** 
 366:main.c        **** void wykonanie_polecenia_sms(void) {
 367:main.c        ****   tekst_odebranego_smsa[MAX_LICZBA_ZNAKOW_SMS] = 0; // (1) dla pewnoci
 368:main.c        ****   watchdog_sms_arm();
 369:main.c        ****   const uchar komenda = interpretuj_wiadomosc_sms(tekst_odebranego_smsa);
 370:main.c        **** 
 371:main.c        ****   // Aktualizacja czasu z timestampu SMS (PRZED wykonaniem komendy!)
 372:main.c        ****   // KAŻDY SMS (nawet bez kodu ABCD) synchronizuje RTC, z wyłączeniem SET
 373:main.c        ****   extern uchar sms_timestamp_godzina;
 374:main.c        ****   extern uchar sms_timestamp_minuta;
 375:main.c        ****   extern uchar sms_timestamp_sekunda;
 376:main.c        ****   extern uchar sms_pomijaj_aktualizacje_czasu;
 377:main.c        **** 
 378:main.c        ****   if (!sms_pomijaj_aktualizacje_czasu) {
 379:main.c        ****     // Aktualizuj rtc_czas z timestampu SMS (z sekundami z PDU)
 380:main.c        ****     sprintf(rtc_czas, "%02d:%02d:%02d", sms_timestamp_godzina,
 381:main.c        ****             sms_timestamp_minuta, sms_timestamp_sekunda);
 382:main.c        **** 
 383:main.c        ****     // Zaktualizuj RTC w SIM900 (hardware)
 384:main.c        ****     extern char bufor_ustaw_czas[32];
 385:main.c        ****     sprintf(bufor_ustaw_czas, "+CCLK=\"24/01/01,%02d:%02d:%02d+04\"",
 386:main.c        ****             sms_timestamp_godzina, sms_timestamp_minuta, sms_timestamp_sekunda);
 387:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_USTAW_ZEGAR_SIM900);
 388:main.c        **** 
 389:main.c        ****     // Aktualizuj blokadę czasową
 390:main.c        ****     if (czas_start_h != 0xFF) {
 391:main.c        ****       int curr_time = sms_timestamp_godzina * 60 + sms_timestamp_minuta;
 392:main.c        ****       int start_time = czas_start_h * 60 + czas_start_m;
 393:main.c        ****       int stop_time = czas_stop_h * 60 + czas_stop_m;
 394:main.c        **** 
 395:main.c        ****       if (start_time <= stop_time) {
 396:main.c        ****         // Normalny przedział (np. 08:00 - 16:00)
 397:main.c        ****         blokada_sterowania_czasowa =
 398:main.c        ****             !(curr_time >= start_time && curr_time <= stop_time);
 399:main.c        ****       } else {
 400:main.c        ****         // Przejście przez północ (np. 22:00 - 06:00)
 401:main.c        ****         blokada_sterowania_czasowa =
 402:main.c        ****             !(curr_time >= start_time || curr_time <= stop_time);
 403:main.c        ****       }
 404:main.c        ****     } else {
 405:main.c        ****       blokada_sterowania_czasowa = FALSE;
 406:main.c        ****     }
 407:main.c        ****   }
 408:main.c        **** 
 409:main.c        ****   // Resetuj flagę pomijania dla następnego SMS
 410:main.c        ****   sms_pomijaj_aktualizacje_czasu = FALSE;
 411:main.c        **** 
 412:main.c        ****   // --- BLOKADA SYSTEMU (START/STOP) ---
 413:main.c        ****   if (blokada_systemu) {
 414:main.c        ****     // Gdy zablokowany, akceptuj tylko START i REPORT
 415:main.c        ****     if (komenda != INTERPRETACJA_SMS_POPRAWNY && // START/STOP zwracaja POPRAWNY
 416:main.c        ****         komenda != INTERPRETACJA_SMS_RAPORT) {
 417:main.c        ****       // Sprawdz czy to byla komenda START (ktora wlasnie odblokowala system)
 418:main.c        ****       // Jesli system nadal jest zablokowany (czyli to nie byl START), to
 419:main.c        ****       // ignoruj
 420:main.c        ****       if (eeprom_read_byte((const uint8_t *)ADRES_EEPROM_BLOKADA_SYSTEMU) ==
 421:main.c        ****           1) {
 422:main.c        ****         zapisz_debug_do_eeprom(1, 2); // Debug: Odrzucono przez blokade
 423:main.c        ****         usun_zablokowany_sms();
 424:main.c        ****         return;
 425:main.c        ****       }
 426:main.c        ****     }
 427:main.c        ****   }
 428:main.c        **** 
 429:main.c        ****   // --- WARSTWA 1: Limit czasowy (Rate Limiting) - V7 style ---
 430:main.c        ****   if (komenda == INTERPRETACJA_SMS_RAPORT ||
 431:main.c        ****       komenda == INTERPRETACJA_SMS_USER) {
 432:main.c        ****     if (licznik_report_user >= MAX_LICZBA_KOMEND_REPORT_USER_W_OKNIE) {
 433:main.c        ****       zapisz_debug_do_eeprom(1, 1);
 434:main.c        ****       usun_zablokowany_sms();
 435:main.c        ****       zareaguj_na_usuniety_sms_z_powodu_limitu();
 436:main.c        ****       watchdog_sms_disarm();
 437:main.c        ****       return;
 438:main.c        ****     }
 439:main.c        ****   }
 440:main.c        **** 
 441:main.c        ****   // --- WARSTWA 2: Sprawdzenie zajętości modemu (Busy Check) ---
 442:main.c        ****   if (flaga_wysylanie_smsa) {
 443:main.c        ****     // Same number check
 444:main.c        ****     if (strcmp((char *)numer_telefonu_odebranego_smsa,
 445:main.c        ****                (char *)numer_telefonu_wysylanego_smsa) == 0) {
 446:main.c        ****       zapisz_debug_do_eeprom(1, 1);
 447:main.c        ****       usun_zablokowany_sms();
 448:main.c        ****       zareaguj_na_usuniety_sms_z_powodu_limitu();
 449:main.c        ****       watchdog_sms_disarm();
 450:main.c        ****       return;
 451:main.c        ****     }
 452:main.c        ****     // Different number but busy
 453:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 454:main.c        ****     usun_zablokowany_sms();
 455:main.c        ****     zareaguj_na_usuniety_sms_z_powodu_limitu();
 456:main.c        ****     watchdog_sms_disarm();
 457:main.c        ****     return;
 458:main.c        ****   }
 459:main.c        **** 
 460:main.c        ****   // --- WARSTWA 3 i 4: Ochrona kolejki ---
 461:main.c        ****   uchar liczba_sms_w_kolejce = 0;
 462:main.c        ****   uchar liczba_wszystkich_komend = 0;
 463:main.c        ****   for (uchar i = 0; i < LICZBA_KOMEND; ++i) {
 464:main.c        ****     if (komendy_kolejka[i] != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 465:main.c        ****       ++liczba_wszystkich_komend;
 466:main.c        ****       if (komendy_kolejka[i] >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
 467:main.c        ****           komendy_kolejka[i] <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
 468:main.c        ****         ++liczba_sms_w_kolejce;
 469:main.c        ****     }
 470:main.c        ****   }
 471:main.c        **** 
 472:main.c        ****   if (liczba_wszystkich_komend >= 35) {
 473:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 474:main.c        ****     usun_zablokowany_sms();
 475:main.c        ****     zareaguj_na_usuniety_sms_z_powodu_limitu();
 476:main.c        ****     watchdog_sms_disarm();
 477:main.c        ****     return;
 478:main.c        ****   }
 479:main.c        **** 
 480:main.c        ****   if (liczba_sms_w_kolejce >= 6) {
 481:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 482:main.c        ****     usun_zablokowany_sms();
 483:main.c        ****     zareaguj_na_usuniety_sms_z_powodu_limitu();
 484:main.c        ****     watchdog_sms_disarm();
 485:main.c        ****     return;
 486:main.c        ****   }
 487:main.c        **** 
 488:main.c        ****   switch (komenda) {
 489:main.c        ****   case INTERPRETACJA_SMS_POPRAWNY:
 490:main.c        ****     zapal_diode_led_blyski(2); // Odbior poprawnej komendy - 2 blyski
 491:main.c        ****     break;
 492:main.c        ****   case INTERPRETACJA_SMS_BRAK_KODU: {
 493:main.c        ****     zapal_diode_led_blyski(1); // Odbior zwyklego SMS (bez kodu) - 1 blysk
 494:main.c        ****     zapisz_debug_do_eeprom(0, 3);
 495:main.c        ****     break;
 496:main.c        ****   }
 497:main.c        ****   case INTERPRETACJA_SMS_RAPORT: {
 498:main.c        ****     ++licznik_report_user;
 499:main.c        ****     timer_report_user_100ms = OKNO_CZASOWE_REPORT_USER_100MS;
 500:main.c        **** 
 501:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 502:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 503:main.c        ****     generuj_raport_stanu_urzadzenia();
 504:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 505:main.c        ****     zapal_diode_led_blyski(2); // Komenda REPORT - 2 blyski
 506:main.c        ****     zapisz_debug_do_eeprom(1, 0);
 507:main.c        ****     break;
 508:main.c        ****   }
 509:main.c        ****   case INTERPRETACJA_SMS_DEBUG: {
 510:main.c        ****     // DEBUG - wyślij flagi debug dla SKRYBA i USER
 511:main.c        ****     strcpy_P((char *)tekst_wysylanego_smsa, PSTR("DEBUG\n"));
 512:main.c        ****     uchar *sms = tekst_wysylanego_smsa + strlen((char *)tekst_wysylanego_smsa);
 513:main.c        **** 
 514:main.c        ****     // SKRYBA DEBUG
 515:main.c        ****     strcpy_P((char *)sms, PSTR("SKRYBA:"));
 516:main.c        ****     sms += strlen((char *)sms);
 517:main.c        ****     *sms++ =
 518:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_2);
 519:main.c        ****     *sms++ =
 520:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_3);
 521:main.c        ****     *sms++ =
 522:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_4);
 523:main.c        ****     *sms++ =
 524:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_5);
 525:main.c        ****     *sms++ = '\n';
 526:main.c        **** 
 527:main.c        ****     // USER DEBUG - wyświetl jako liczby dziesiętne
 528:main.c        ****     strcpy_P((char *)sms, PSTR("U1="));
 529:main.c        ****     sms += strlen((char *)sms);
 530:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_1), sms, 10);
 531:main.c        ****     sms += strlen((char *)sms);
 532:main.c        **** 
 533:main.c        ****     strcpy_P((char *)sms, PSTR(" U2="));
 534:main.c        ****     sms += strlen((char *)sms);
 535:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_2), sms, 10);
 536:main.c        ****     sms += strlen((char *)sms);
 537:main.c        **** 
 538:main.c        ****     strcpy_P((char *)sms, PSTR(" U3="));
 539:main.c        ****     sms += strlen((char *)sms);
 540:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_3), sms, 10);
 541:main.c        ****     sms += strlen((char *)sms);
 542:main.c        ****     *sms++ = '\n';
 543:main.c        **** 
 544:main.c        ****     strcpy_P((char *)sms, PSTR("U4="));
 545:main.c        ****     sms += strlen((char *)sms);
 546:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_4), sms, 10);
 547:main.c        ****     sms += strlen((char *)sms);
 548:main.c        **** 
 549:main.c        ****     strcpy_P((char *)sms, PSTR(" U5="));
 550:main.c        ****     sms += strlen((char *)sms);
 551:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_5), sms, 10);
 552:main.c        ****     sms += strlen((char *)sms);
 553:main.c        **** 
 554:main.c        ****     strcpy_P((char *)sms, PSTR(" U6="));
 555:main.c        ****     sms += strlen((char *)sms);
 556:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_6), sms, 10);
 557:main.c        ****     sms += strlen((char *)sms);
 558:main.c        **** 
 559:main.c        ****     strcpy_P((char *)sms, PSTR(" U7="));
 560:main.c        ****     sms += strlen((char *)sms);
 561:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_7), sms, 10);
 562:main.c        ****     sms += strlen((char *)sms);
 563:main.c        ****     *sms++ = '\n';
 564:main.c        **** 
 565:main.c        ****     strcpy_P((char *)sms, PSTR("1=RCV 2=BSY 3=CNT 4=QSM 5=QAL 6=FND 7=ADD"));
 566:main.c        **** 
 567:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 568:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 569:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 570:main.c        ****     zapal_diode_led_blyski(2);
 571:main.c        ****     break;
 572:main.c        ****   }
 573:main.c        ****   case INTERPRETACJA_SMS_USER: {
 574:main.c        ****     ++licznik_report_user;
 575:main.c        ****     timer_report_user_100ms = OKNO_CZASOWE_REPORT_USER_100MS;
 576:main.c        **** 
 577:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 578:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 579:main.c        **** 
 580:main.c        ****     // Uzyj lokalnego bufora aby uniknac konfliktow z EEPROM
 581:main.c        ****     uchar temp_buf[10];
 582:main.c        **** 
 583:main.c        ****     // Konwertuj numer na format EEPROM
 584:main.c        ****     konwertuj_telefon_na_blok_eeprom(
 585:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
 586:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[strlen(
 587:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
 588:main.c        ****         temp_buf);
 589:main.c        **** 
 590:main.c        ****     // Sprawdz czy numer jest na liscie
 591:main.c        ****     uchar znaleziono = FALSE;
 592:main.c        ****     for (uint nr_uzyt_clip = 0;
 593:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 594:main.c        ****       if (porownaj_numer_telefonu_blok(
 595:main.c        ****               temp_buf, (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
 596:main.c        ****         znaleziono = TRUE;
 597:main.c        ****         break;
 598:main.c        ****       }
 599:main.c        ****     }
 600:main.c        **** 
 601:main.c        ****     // Przygotuj odpowiedz z numerem telefonu i statusem
 602:main.c        ****     strcpy((char *)tekst_wysylanego_smsa,
 603:main.c        ****            (char *)numer_telefonu_do_ktorego_dzwonic);
 604:main.c        ****     strcat((char *)tekst_wysylanego_smsa, ": ");
 605:main.c        ****     if (znaleziono) {
 606:main.c        ****       strcat((char *)tekst_wysylanego_smsa, "OK");
 607:main.c        ****     } else {
 608:main.c        ****       strcat((char *)tekst_wysylanego_smsa, "Brak takiego numeru w systemie");
 609:main.c        ****     }
 610:main.c        **** 
 611:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 612:main.c        **** 
 613:main.c        ****     zapal_diode_led_blyski(2); // Komenda USER - 2 blyski
 614:main.c        **** 
 615:main.c        ****     // Zapisz debug tylko na koncu (bezpiecznie)
 616:main.c        ****     // U1=1 (USER), U6=znaleziono
 617:main.c        ****     if (czy_wolny_eeprom()) {
 618:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 619:main.c        ****       // Ale poniewaz zapisz_znak_w_eeprom uzywa przerwan, nie mozemy wolac go
 620:main.c        ****       // od razu drugi raz Mozemy zapisac skondensowana informacje lub uzyc
 621:main.c        ****       // bufora Dla bezpieczenstwa zapiszmy tylko jeden bajt statusu Bit 0:
 622:main.c        ****       // znaleziono, Bit 1: USER wykonany zapisz_znak_w_eeprom(znaleziono |
 623:main.c        ****       // 0x02, ADRES_EEPROM_DEBUG_USER_6);
 624:main.c        ****     }
 625:main.c        ****     zapisz_debug_do_eeprom(2, znaleziono); // 2 = USER
 626:main.c        ****     break;
 627:main.c        ****   }
 628:main.c        ****   case INTERPRETACJA_SMS_USER_BEZ_NUMERU: {
 629:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 630:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 631:main.c        ****     strcpy((char *)tekst_wysylanego_smsa,
 632:main.c        ****            "Wpisz numer jaki sprawdzasz, np: USER 793557357");
 633:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 634:main.c        ****     zapal_diode_led_blyski(2);
 635:main.c        ****     break;
 636:main.c        ****   }
 637:main.c        ****   case INTERPRETACJA_SMS_USER_LIST: {
 638:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 639:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 640:main.c        ****     numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama = 0;
 641:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW);
 642:main.c        ****     zapal_diode_led_blyski(2);
 643:main.c        ****     break;
 644:main.c        ****   }
 645:main.c        ****   case INTERPRETACJA_SMS_RESET_WSZYSTKICH_USTAWIEN: {
 646:main.c        ****     if (not czy_sa_komendy_z_przedzialu(
 647:main.c        ****             KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 648:main.c        ****             KOMENDA_KOLEJKI_RESET_USTAWIEN_INICJALIZACJA)) {
 649:main.c        ****       zapal_diode_led_blyski(25);
 650:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
 651:main.c        ****     }
 652:main.c        ****     break;
 653:main.c        ****   }
 654:main.c        ****   default:
 655:main.c        ****     break;
 656:main.c        ****   }
 657:main.c        **** 
 658:main.c        ****   watchdog_sms_disarm();
 659:main.c        **** }
 660:main.c        **** 
 661:main.c        **** void steruj_wejsciem_reset_100ms(void) {
 662:main.c        ****   static uchar licznik_reset;
 663:main.c        ****   if (CZY_AKTUALNY_STAN_LOGICZNY_ON(0)) {
 664:main.c        ****     if (licznik_reset < 20 * 10)
 665:main.c        ****       ++licznik_reset;
 666:main.c        ****   } else {
 667:main.c        ****     if (licznik_reset >= 20 * 10) {
 668:main.c        ****       if (not czy_sa_komendy_z_przedzialu(
 669:main.c        ****               KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 670:main.c        ****               KOMENDA_KOLEJKI_RESET_USTAWIEN_INICJALIZACJA))
 671:main.c        ****         dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
 672:main.c        ****     } else if (licznik_reset >= 5 * 10) {
 673:main.c        ****       if (not czy_sa_komendy_z_przedzialu(
 674:main.c        ****               KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 675:main.c        ****               KOMENDA_KOLEJKI_RESET_USTAWIEN_INICJALIZACJA))
 676:main.c        ****         dodaj_komende(KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU);
 677:main.c        ****     }
 678:main.c        ****     licznik_reset = 0;
 679:main.c        ****   }
 680:main.c        **** }
 681:main.c        **** 
 682:main.c        **** uchar sprawdz_przychodzaca_rozmowe(void) // wysya TRUE, gdy naley odebra
 683:main.c        **** {
 684:main.c        ****   if (blokada_systemu) {
 685:main.c        ****     return FALSE; // Ignoruj rozmowy gdy system zablokowany
 686:main.c        ****   }
 687:main.c        **** 
 688:main.c        ****   if (blokada_sterowania_czasowa) {
 689:main.c        ****     return FALSE; // Ignoruj rozmowy gdy blokada czasowa
 690:main.c        ****   }
 691:main.c        **** 
 692:main.c        ****   // W trybie DTMF:
 693:main.c        ****   if (!tryb_clip) {
 694:main.c        ****     if (numer_telefonu_ktory_dzwoni[0] != 0)
 695:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA);
 696:main.c        **** 
 697:main.c        ****     // Publiczny: odbierz wszystkie
 698:main.c        ****     if (tryb_pracy == 1)
 699:main.c        ****       return TRUE;
 700:main.c        **** 
 701:main.c        ****     // Prywatny: sprawdź autoryzację SYNCHRONICZNIE
 702:main.c        ****     // Konwertuj numer na format EEPROM
 703:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_ktory_dzwoni[0],
 704:main.c        ****                                      &numer_telefonu_ktory_dzwoni[strlen(
 705:main.c        ****                                          (char *)numer_telefonu_ktory_dzwoni)],
 706:main.c        ****                                      &bufor_eeprom[0]);
 707:main.c        **** 
 708:main.c        ****     // Sprawdź listę autoryzowanych numerów
 709:main.c        ****     for (uint nr_uzyt = 0; nr_uzyt < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 710:main.c        ****          ++nr_uzyt) {
 711:main.c        ****       if (porownaj_numer_telefonu_blok(
 712:main.c        ****               &bufor_eeprom[0], (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt))) {
 713:main.c        ****         return TRUE; // Numer autoryzowany - odbierz
 714:main.c        ****       }
 715:main.c        ****     }
 716:main.c        ****     return FALSE; // Numer nieautoryzowany - odrzuć
 717:main.c        ****   }
 718:main.c        **** 
 719:main.c        ****   // W trybie CLIP:
 720:main.c        ****   if (numer_telefonu_ktory_dzwoni[0] != 0)
 721:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA);
 722:main.c        **** 
 723:main.c        ****   // Publiczny: włącz wyjście dla wszystkich
 724:main.c        ****   if (tryb_pracy == 1)
 725:main.c        ****     return TRUE;
 726:main.c        **** 
 727:main.c        ****   // Prywatny: sprawdź autoryzację
 728:main.c        ****   return FALSE; // Autoryzacja przez SPRAWDZ_UZYTKOWNIKOW_BRAMA
 729:main.c        **** }
 730:main.c        **** 
 731:main.c        **** uchar wysylanie_echa_przez_pdu = FALSE;
 732:main.c        **** 
 733:main.c        **** uchar *ptr_start_pdu_z_wiadomoscia; // pierwszy znak
 734:main.c        **** 
 735:main.c        **** #define WYSYLANIE_SMSA_CLIPA_BRAK 0
 736:main.c        **** #define WYSYLANIE_SMSA_WYSYLANIE 1
 737:main.c        **** #define WYSYLANIE_SMSA_POWTARZANIE 2
 738:main.c        **** #define WYSYLANIE_CLIPA_WYSYLANIE 4
 739:main.c        **** #define WYSYLANIE_CLIPA_KONCZENIE 5
 740:main.c        **** 
 741:main.c        **** uchar wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
 742:main.c        **** 
 743:main.c        **** enum PowodZakonczeniaRozmowyTelefonicznej {
 744:main.c        ****   powod_zakonczenia_rozmowy_odrzucenie,
 745:main.c        ****   powod_zakonczenia_rozmowy_zakonczenie,
 746:main.c        ****   powod_zakonczenia_rozmowy_przekroczony_czas,
 747:main.c        ****   powod_zakonczenia_rozmowy_otrzymana_wiadomosc
 748:main.c        **** };
 749:main.c        **** 
 750:main.c        **** void zakonczono_rozmowe_telefoniczna(
 751:main.c        ****     const enum PowodZakonczeniaRozmowyTelefonicznej powod) {
 752:main.c        ****   POMOC_DODAJ2('#', 'a');
 753:main.c        ****   opoznienie_SIM900_100MS = 60; // byo 60
 754:main.c        ****   licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 755:main.c        ****   ustaw_maksymalny_czas_dzwonienia = 0;
 756:main.c        ****   maksymalny_czas_dzwonienia = 0;
 757:main.c        ****   blokada_clip = FALSE;
 758:main.c        **** }
 759:main.c        **** 
 760:main.c        **** enum PowodZakonczeniaWysylaniaSMS {
 761:main.c        ****   zakonczenie_wysylania_sms_ok,
 762:main.c        ****   zakonczenie_wysylania_sms_blad_powtarzanie,
 763:main.c        ****   zakonczenie_wysylania_sms_blad_zakonczenie,
 764:main.c        ****   zakonczenie_wysylania_sms_blad_powtorz_sms,
 765:main.c        **** };
 766:main.c        **** 
 767:main.c        **** void zakonczono_wysylanie_smsa(const enum PowodZakonczeniaWysylaniaSMS powod) {
 768:main.c        ****   POMOC_DODAJ2('#', 'A');
 769:main.c        ****   opoznienie_SIM900_100MS = 60;
 770:main.c        **** 
 771:main.c        ****   wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
 772:main.c        **** }
 773:main.c        **** 
 774:main.c        **** void problem_z_wyslaniem_powiadomienia(void) {
 775:main.c        ****   wykonywanie_rozmowy_telefonicznej = FALSE;
 776:main.c        ****   licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 777:main.c        ****   wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 778:main.c        ****   czekanie_na_odebranie_zachety = FALSE;
 779:main.c        ****   opoznienie_SIM900_100MS = 60;
 780:main.c        ****   flaga_wysylanie_smsa = 0;
 781:main.c        **** }
 782:main.c        **** 
 783:main.c        **** #define JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ()                             \
 784:main.c        ****   if (!czy_mozna_wysylac_dane_do_SIM900) {                                     \
 785:main.c        ****     dodaj_komende(wykonywana_komenda);                                         \
 786:main.c        ****     break;                                                                     \
 787:main.c        ****   }                                                                            \
 788:main.c        ****   wysylane_polecenie_SIM900 = wykonywana_komenda;
 789:main.c        **** 
 790:main.c        **** #define POWTORZ_JESLI(WAR)                                                     \
 791:main.c        ****   {                                                                            \
 792:main.c        ****     if (WAR) {                                                                 \
 793:main.c        ****       dodaj_komende(wykonywana_komenda);                                       \
 794:main.c        ****       break;                                                                   \
 795:main.c        ****     }                                                                          \
 796:main.c        ****   }
 797:main.c        **** 
 798:main.c        **** #define JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ() POWTORZ_JESLI(!czy_wolny_eeprom())
 799:main.c        **** 
 800:main.c        **** #define JESLI_SIM900_ZAJETY_WYKONAJ_POZNIEJ() POWTORZ_JESLI(czy_gsm_zajety)
 801:main.c        **** 
 802:main.c        **** #include "main_sim900.h"
 803:main.c        **** 
 804:main.c        **** #define aktualnie_wykonywana_komenda wykonywana_komenda
 805:main.c        **** 
 806:main.c        **** void inicjalizuj_parametry_modulu(void);
 807:main.c        **** 
 808:main.c        **** #define MAX_LICZBA_KOMEND_DLA_ALARMOW (LICZBA_KOMEND / 4)
 809:main.c        **** 
 810:main.c        **** // Funkcja pomocnicza: Wyciąga ostatnie N cyfr z numeru telefonu
 811:main.c        **** // max_digits: maksimum cyfr (9)
 812:main.c        **** static void wyciagnij_ostatnie_cyfry(const uchar *numer_pelny,
 813:main.c        ****                                      uchar *numer_skrocony, uchar max_digits) {
 814:main.c        ****   uchar len = strlen((char *)numer_pelny);
 815:main.c        **** 
 816:main.c        ****   if (len > max_digits) {
 817:main.c        ****     // Take last max_digits
 818:main.c        ****     strcpy((char *)numer_skrocony, (char *)numer_pelny + (len - max_digits));
 819:main.c        ****   } else {
 820:main.c        ****     // Take all
 821:main.c        ****     strcpy((char *)numer_skrocony, (char *)numer_pelny);
 822:main.c        ****   }
 823:main.c        **** }
 824:main.c        **** 
 825:main.c        **** // Helper function to check if a number exists in EEPROM
 826:main.c        **** // Uses bufor_eeprom as temporary storage for comparison
 827:main.c        **** static uchar czy_numer_istnieje(const uchar *numer_telefonu) {
  35               		.loc 1 827 0
  36               		.cfi_startproc
  37               	.LVL0:
  38 000e CF93      		push r28
  39               	.LCFI0:
  40               		.cfi_def_cfa_offset 3
  41               		.cfi_offset 28, -2
  42 0010 DF93      		push r29
  43               	.LCFI1:
  44               		.cfi_def_cfa_offset 4
  45               		.cfi_offset 29, -3
  46               	/* prologue: function */
  47               	/* frame size = 0 */
  48               	/* stack size = 2 */
  49               	.L__stack_usage = 2
 828:main.c        ****   // Convert number to EEPROM block format
 829:main.c        ****   // We use a local buffer to avoid corrupting global buffers if possible,
 830:main.c        ****   // but porownaj_numer_telefonu_blok expects a block.
 831:main.c        ****   // Let's use bufor_eeprom as it is standard for this operation in this
 832:main.c        ****   // codebase.
 833:main.c        ****   konwertuj_telefon_na_blok_eeprom(
 834:main.c        ****       numer_telefonu, numer_telefonu + strlen((char *)numer_telefonu),
  50               		.loc 1 834 0
  51 0012 FC01      		movw r30,r24
  52               		0:
  53 0014 0190      		ld __tmp_reg__,Z+
  54 0016 0020      		tst __tmp_reg__
  55 0018 01F4      		brne 0b
  56 001a BF01      		movw r22,r30
 833:main.c        ****       numer_telefonu, numer_telefonu + strlen((char *)numer_telefonu),
  57               		.loc 1 833 0
  58 001c 6150      		subi r22,1
  59 001e 7109      		sbc r23,__zero_reg__
  60 0020 40E0      		ldi r20,lo8(bufor_eeprom)
  61 0022 50E0      		ldi r21,hi8(bufor_eeprom)
  62 0024 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
  63               	.LVL1:
  64 0028 C8E0      		ldi r28,lo8(8)
  65 002a D0E0      		ldi r29,0
  66               	.LVL2:
  67               	.L4:
  68               	.LBB357:
 835:main.c        ****       bufor_eeprom);
 836:main.c        **** 
 837:main.c        ****   for (uint nr_uzyt_clip = 0; nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 838:main.c        ****        ++nr_uzyt_clip) {
 839:main.c        ****     if (porownaj_numer_telefonu_blok(
  69               		.loc 1 839 0
  70 002c BE01      		movw r22,r28
  71 002e 80E0      		ldi r24,lo8(bufor_eeprom)
  72 0030 90E0      		ldi r25,hi8(bufor_eeprom)
  73 0032 0E94 0000 		call porownaj_numer_telefonu_blok
  74               	.LVL3:
  75 0036 8111      		cpse r24,__zero_reg__
  76 0038 00C0      		rjmp .L5
  77 003a 2596      		adiw r28,5
 837:main.c        ****        ++nr_uzyt_clip) {
  78               		.loc 1 837 0
  79 003c C83A      		cpi r28,-88
  80 003e FFE0      		ldi r31,15
  81 0040 DF07      		cpc r29,r31
  82 0042 01F4      		brne .L4
  83               	.L2:
  84               	/* epilogue start */
  85               	.LBE357:
 840:main.c        ****             bufor_eeprom, (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
 841:main.c        ****       return TRUE;
 842:main.c        ****     }
 843:main.c        ****   }
 844:main.c        ****   return FALSE;
 845:main.c        **** }
  86               		.loc 1 845 0
  87 0044 DF91      		pop r29
  88 0046 CF91      		pop r28
  89 0048 0895      		ret
  90               	.L5:
  91               	.LBB358:
 841:main.c        ****     }
  92               		.loc 1 841 0
  93 004a 8FEF      		ldi r24,lo8(-1)
  94 004c 00C0      		rjmp .L2
  95               	.LBE358:
  96               		.cfi_endproc
  97               	.LFE57:
 100               	usun_zablokowany_sms:
 101               	.LFB35:
 318:main.c        ****   // Usun SMS z modulu SIM900 (numer jest w aktualnie_wysylane_polecenie_SIM900)
 102               		.loc 1 318 0
 103               		.cfi_startproc
 104               	/* prologue: function */
 105               	/* frame size = 0 */
 106               	/* stack size = 0 */
 107               	.L__stack_usage = 0
 321:main.c        ****       aktualnie_wysylane_polecenie_SIM900 <= KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 108               		.loc 1 321 0
 109 004e 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 110 0052 97E5      		ldi r25,lo8(87)
 111 0054 980F      		add r25,r24
 112               	.LBB359:
 326:main.c        ****   } else {
 113               		.loc 1 326 0
 114 0056 8C5E      		subi r24,lo8(-(20))
 115               	.LBE359:
 321:main.c        ****       aktualnie_wysylane_polecenie_SIM900 <= KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 116               		.loc 1 321 0
 117 0058 9431      		cpi r25,lo8(20)
 118 005a 00F0      		brlo .L9
 329:main.c        ****   }
 119               		.loc 1 329 0
 120 005c 81E9      		ldi r24,lo8(-111)
 121               	.L9:
 122 005e 0C94 0000 		jmp filtruj_i_dodaj_komende
 123               	.LVL4:
 124               		.cfi_endproc
 125               	.LFE35:
 128               	zareaguj_na_usuniety_sms_z_powodu_limitu:
 129               	.LFB36:
 333:main.c        ****   if (licznik_usunietych_sms_przez_limit < 0xFFFF)
 130               		.loc 1 333 0
 131               		.cfi_startproc
 132               	/* prologue: function */
 133               	/* frame size = 0 */
 134               	/* stack size = 0 */
 135               	.L__stack_usage = 0
 334:main.c        ****     ++licznik_usunietych_sms_przez_limit;
 136               		.loc 1 334 0
 137 0062 8091 0000 		lds r24,licznik_usunietych_sms_przez_limit
 138 0066 9091 0000 		lds r25,licznik_usunietych_sms_przez_limit+1
 139 006a 8F3F      		cpi r24,-1
 140 006c 9807      		cpc r25,r24
 141 006e 01F0      		breq .L11
 335:main.c        ****   sygnalizuj_pelny_system();
 142               		.loc 1 335 0
 143 0070 0196      		adiw r24,1
 144 0072 9093 0000 		sts licznik_usunietych_sms_przez_limit+1,r25
 145 0076 8093 0000 		sts licznik_usunietych_sms_przez_limit,r24
 146               	.L11:
 147               	.LBB362:
 148               	.LBB363:
 314:main.c        **** }
 149               		.loc 1 314 0
 150 007a 8AE0      		ldi r24,lo8(10)
 151 007c 8093 0000 		sts liczba_blyskow_led,r24
 152 0080 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 153               	.LBE363:
 154               	.LBE362:
 337:main.c        ****   // Uzywamy filtruj_i_dodaj
 155               		.loc 1 337 0
 156 0084 0E94 0000 		call watchdog_sms_disarm
 157               	.LVL5:
 339:main.c        **** }
 158               		.loc 1 339 0
 159 0088 81E9      		ldi r24,lo8(-111)
 160 008a 0C94 0000 		jmp filtruj_i_dodaj_komende
 161               	.LVL6:
 162               		.cfi_endproc
 163               	.LFE36:
 166               	polozenie_polecenia_SIM900:
 167               	.LFB47:
 168               		.file 2 "main_sim900.h"
   1:main_sim900.h **** 
   2:main_sim900.h **** #ifdef MAIN_SIM900_H
   3:main_sim900.h **** #error Dwa razy wlaczany plik
   4:main_sim900.h **** #endif
   5:main_sim900.h **** 
   6:main_sim900.h **** void wyzerowanie_danych_SIM900(void) {
   7:main_sim900.h ****   POMOC_DODAJ2('*', 't');
   8:main_sim900.h ****   problem_z_wyslaniem_powiadomienia();
   9:main_sim900.h ****   licznik_wysylane_polecenie_SIM900 = 0;
  10:main_sim900.h ****   aktualnie_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
  11:main_sim900.h ****   liczba_komend_w_kolejce_SIM900 = 0;
  12:main_sim900.h ****   licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow = 0;
  13:main_sim900.h ****   czekanie_na_odebranie_zachety = FALSE;
  14:main_sim900.h ****   flaga_odebrany_znak_zachety = FALSE;
  15:main_sim900.h ****   trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
  16:main_sim900.h ****   wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
  17:main_sim900.h ****   flaga_odczytywanie_smsa = FALSE;
  18:main_sim900.h **** }
  19:main_sim900.h **** 
  20:main_sim900.h **** void reset_modulu_SIM900(void) {
  21:main_sim900.h ****   wyzerowanie_danych_SIM900();
  22:main_sim900.h ****   POMOC_DODAJ2('*', 'm');
  23:main_sim900.h ****   HARDRESET_SIM900();
  24:main_sim900.h ****   podlaczony_modul_gsm_SIM900 = FALSE;
  25:main_sim900.h ****   podlaczona_karta_SIM_SIM900 = FALSE;
  26:main_sim900.h ****   licznik_blad_stanu_karty_SIM = 0;
  27:main_sim900.h ****   licznik_blad_zalogowania_u_operatora = 0;
  28:main_sim900.h ****   nazwa_operatora[0] = '\0';
  29:main_sim900.h ****   licznik_ogolny_blad_zalogowania = 0;
  30:main_sim900.h ****   blokada_clip = FALSE;
  31:main_sim900.h ****   nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
  32:main_sim900.h ****   poziom_sieci_gsm = POZIOM_SIECI_BLAD;
  33:main_sim900.h ****   filtruj_komendy_z_przedzialu(KOMENDA_KOLEJKI_USUN_SMSA_1,
  34:main_sim900.h ****                                KOMENDA_KOLEJKI_USUN_SMSA_20);
  35:main_sim900.h ****   filtruj_komendy_z_przedzialu(
  36:main_sim900.h ****       KOMENDA_KOLEJKI_KOMENDA_SIM900,
  37:main_sim900.h ****       KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE);
  38:main_sim900.h ****   filtruj_komendy_z_przedzialu(
  39:main_sim900.h ****       KOMENDA_KOLEJKI_SPRAWDZ_PIN,
  40:main_sim900.h ****       KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ);
  41:main_sim900.h ****   filtruj_komendy_z_przedzialu(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT,
  42:main_sim900.h ****                                KOMENDA_KOLEJKI_WYSLIJ_PDU);
  43:main_sim900.h ****   modul_zalogowany_w_sieci = FALSE;
  44:main_sim900.h **** }
  45:main_sim900.h **** 
  46:main_sim900.h **** static uchar czy_polecenie_SIM900(PGM_P polecenie, const uchar liczba_znakow) {
  47:main_sim900.h ****   return strncmp_P(odebrany_blok_SIM900 + 2, polecenie, liczba_znakow) == 0;
  48:main_sim900.h **** }
  49:main_sim900.h **** 
  50:main_sim900.h **** static uchar *polozenie_polecenia_SIM900(PGM_P polecenie) {
 169               		.loc 2 50 0
 170               		.cfi_startproc
 171               	.LVL7:
 172               	/* prologue: function */
 173               	/* frame size = 0 */
 174               	/* stack size = 0 */
 175               	.L__stack_usage = 0
  51:main_sim900.h ****   return strstr_P(odebrany_blok_SIM900, polecenie);
 176               		.loc 2 51 0
 177 008e BC01      		movw r22,r24
 178 0090 80E0      		ldi r24,lo8(odebrany_blok_SIM900)
 179 0092 90E0      		ldi r25,hi8(odebrany_blok_SIM900)
 180               	.LVL8:
 181 0094 0C94 0000 		jmp strstr_P
 182               	.LVL9:
 183               		.cfi_endproc
 184               	.LFE47:
 187               	opoznienie_startowe:
 188               	.LFB69:
 846:main.c        **** 
 847:main.c        **** uchar wykonanie_komend_ukladow(void) {
 848:main.c        ****   const komenda_typ aktualnie_wykonywana_komenda = komendy_kolejka[0];
 849:main.c        **** 
 850:main.c        ****   switch (aktualnie_wykonywana_komenda) {
 851:main.c        ****   case KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU: {
 852:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 853:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 854:main.c        ****     kod_modulu[1] = bufor_eeprom[1] = 'B';
 855:main.c        ****     kod_modulu[2] = bufor_eeprom[2] = 'C';
 856:main.c        ****     kod_modulu[3] = bufor_eeprom[3] = 'D';
 857:main.c        ****     zapisz_znaki_w_eeprom_bez_kopiowania(ADRES_EEPROM_KOD_DOSTEPU,
 858:main.c        ****                                          LICZBA_BAJTOW_KODU_DOSTEPU);
 859:main.c        ****     zapal_diode_led(50);
 860:main.c        ****     break;
 861:main.c        ****   }
 862:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_0:
 863:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_1:
 864:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_2:
 865:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_3:
 866:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_4:
 867:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_5:
 868:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_6:
 869:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_7:
 870:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_8:
 871:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_9:
 872:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_10:
 873:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_11:
 874:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_12:
 875:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_13:
 876:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_14:
 877:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_15:
 878:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_16:
 879:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_17:
 880:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_18:
 881:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_19:
 882:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_20:
 883:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_21:
 884:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_22:
 885:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_23:
 886:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_24:
 887:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_25:
 888:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_26:
 889:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_27:
 890:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_28:
 891:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_29:
 892:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_30:
 893:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_31:
 894:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_32:
 895:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_33:
 896:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_34:
 897:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_35:
 898:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_36:
 899:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_37:
 900:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_38:
 901:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_39:
 902:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_40:
 903:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_41:
 904:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_42:
 905:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_43:
 906:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_44:
 907:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_45:
 908:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_46:
 909:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_47:
 910:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_48:
 911:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_49:
 912:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_50:
 913:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_51:
 914:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_52:
 915:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_53:
 916:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_54:
 917:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_55:
 918:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_56:
 919:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_57:
 920:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_58:
 921:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_59:
 922:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_60:
 923:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_61:
 924:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_62:
 925:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_63:
 926:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_64:
 927:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_65:
 928:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_66:
 929:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_67:
 930:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_68:
 931:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_69:
 932:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_70:
 933:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_71:
 934:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_72:
 935:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_73:
 936:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_74:
 937:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_75:
 938:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_76:
 939:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_77:
 940:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_78:
 941:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_79:
 942:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_80:
 943:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_81:
 944:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_82:
 945:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_83:
 946:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_84:
 947:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_85:
 948:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_86:
 949:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_87:
 950:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_88:
 951:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_89:
 952:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_90:
 953:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_91:
 954:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_92:
 955:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_93:
 956:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_94:
 957:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_95:
 958:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_96:
 959:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_97:
 960:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_98:
 961:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_99:
 962:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_100:
 963:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_101:
 964:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_102:
 965:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_103:
 966:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_104:
 967:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_105:
 968:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_106:
 969:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_107:
 970:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_108:
 971:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_109:
 972:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_110:
 973:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_111:
 974:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_112:
 975:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_113:
 976:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_114:
 977:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_115:
 978:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_116:
 979:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_117:
 980:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_118:
 981:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_119:
 982:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_120:
 983:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_121:
 984:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_122:
 985:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_123:
 986:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_124:
 987:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_125:
 988:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_126:
 989:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_127: {
 990:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 991:main.c        ****     const uchar nr_bloku =
 992:main.c        ****         aktualnie_wykonywana_komenda - KOMENDA_KOLEJKI_RESET_USTAWIEN_0;
 993:main.c        **** #define LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE 32
 994:main.c        ****     memset(bufor_eeprom, 0xff, LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE);
 995:main.c        ****     if (nr_bloku == 0) {
 996:main.c        ****       kod_modulu[0] = bufor_eeprom[1] = 'A';
 997:main.c        ****       kod_modulu[1] = bufor_eeprom[2] = 'B';
 998:main.c        ****       kod_modulu[2] = bufor_eeprom[3] = 'C';
 999:main.c        ****       kod_modulu[3] = bufor_eeprom[4] = 'D';
1000:main.c        ****       bufor_eeprom[5] = 0;
1001:main.c        ****       stan_wyjscie[0] = 0;
1002:main.c        ****       licznik_przelacznik_wyjscia[0] = 0;
1003:main.c        ****     }
1004:main.c        ****     zapisz_znaki_w_eeprom_bez_kopiowania(
1005:main.c        ****         nr_bloku * LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE,
1006:main.c        ****         LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE);
1007:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0 + nr_bloku + 1);
1008:main.c        ****     zapal_diode_led(50);
1009:main.c        ****     break;
1010:main.c        ****   }
1011:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_INICJALIZACJA: {
1012:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1013:main.c        ****     uchar bledny_zapis = FALSE;
1014:main.c        ****     static const uchar tab_eeprom_fabryczny[6] PROGMEM = {
1015:main.c        ****         0xff, 'A', 'B', 'C', 'D', 0x00,
1016:main.c        ****     };
1017:main.c        ****     for (uint i = 0; i < 6; ++i) {
1018:main.c        ****       if (eeprom_read_byte((void *)i) !=
1019:main.c        ****           pgm_read_byte(tab_eeprom_fabryczny + i))
1020:main.c        ****         bledny_zapis = TRUE;
1021:main.c        ****     }
1022:main.c        ****     for (uint i = EEPROM_NUMER_TELEFONU_BRAMA_0;
1023:main.c        ****          i < EEPROM_NUMER_TELEFONU_BRAMA_0 +
1024:main.c        ****                  MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA *
1025:main.c        ****                      LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM;
1026:main.c        ****          ++i) {
1027:main.c        ****       if (eeprom_read_byte((void *)i) != 0xff) {
1028:main.c        ****         bledny_zapis = TRUE;
1029:main.c        ****         break;
1030:main.c        ****       }
1031:main.c        ****     }
1032:main.c        ****     if (bledny_zapis) {
1033:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
1034:main.c        ****       break;
1035:main.c        ****     }
1036:main.c        ****     inicjalizuj_parametry_modulu();
1037:main.c        ****     ustaw_stan_led(FALSE); // Wylacz diode po zakonczeniu resetu
1038:main.c        ****     break;
1039:main.c        ****   }
1040:main.c        ****   case KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA: {
1041:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1042:main.c        **** 
1043:main.c        ****     if (blokada_sterowania_czasowa) {
1044:main.c        ****       // Poza dozwolonym czasem - ignoruj
1045:main.c        ****       break;
1046:main.c        ****     }
1047:main.c        **** 
1048:main.c        ****     // Make a local copy of the phone number to prevent corruption
1049:main.c        ****     // if the global buffer changes during processing (e.g. new CLIP)
1050:main.c        ****     uchar numer_lokalny[MAX_LICZBA_ZNAKOW_TELEFON + 1];
1051:main.c        ****     strcpy((char *)numer_lokalny, (char *)numer_telefonu_ktory_dzwoni);
1052:main.c        **** 
1053:main.c        ****     // Konwertuj numer dla późniejszego użycia
1054:main.c        ****     konwertuj_telefon_na_blok_eeprom(
1055:main.c        ****         &numer_lokalny[0], &numer_lokalny[strlen((char *)numer_lokalny)],
1056:main.c        ****         &bufor_eeprom[0]);
1057:main.c        **** 
1058:main.c        ****     // Sprawdź czy numer jest na liście (PEŁNY NUMER)
1059:main.c        ****     uchar znaleziono = FALSE;
1060:main.c        ****     if (tryb_pracy != 1) {
1061:main.c        ****       // Tylko w trybie prywatnym sprawdzamy listę
1062:main.c        ****       for (uint nr_uzyt_clip = 0;
1063:main.c        ****            nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
1064:main.c        ****         if (porownaj_numer_telefonu_blok(
1065:main.c        ****                 &bufor_eeprom[0],
1066:main.c        ****                 (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
1067:main.c        ****           znaleziono = TRUE;
1068:main.c        ****           break;
1069:main.c        ****         }
1070:main.c        ****       }
1071:main.c        ****     }
1072:main.c        **** 
1073:main.c        ****     // SKRYBA: Jeśli nie znaleziono pełnego, sprawdź skrócony (ostatnie 9 cyfr)
1074:main.c        ****     uchar numer_skrocony[20]; // Increased buffer size
1075:main.c        ****     if (skryba_wlaczona && !znaleziono) {
1076:main.c        ****       wyciagnij_ostatnie_cyfry(numer_lokalny, numer_skrocony, 9);
1077:main.c        **** 
1078:main.c        ****       // Konwertuj skrócony numer do bufor_eeprom dla porównania
1079:main.c        ****       konwertuj_telefon_na_blok_eeprom(
1080:main.c        ****           &numer_skrocony[0], &numer_skrocony[strlen((char *)numer_skrocony)],
1081:main.c        ****           &bufor_eeprom[0]);
1082:main.c        **** 
1083:main.c        ****       if (tryb_pracy != 1) {
1084:main.c        ****         for (uint nr_uzyt_clip = 0;
1085:main.c        ****              nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
1086:main.c        ****              ++nr_uzyt_clip) {
1087:main.c        ****           if (porownaj_numer_telefonu_blok(
1088:main.c        ****                   &bufor_eeprom[0],
1089:main.c        ****                   (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
1090:main.c        ****             znaleziono = TRUE;
1091:main.c        ****             break;
1092:main.c        ****           }
1093:main.c        ****         }
1094:main.c        ****       }
1095:main.c        ****     }
1096:main.c        **** 
1097:main.c        ****     // SKRYBA: Auto-save numer jesli wlaczona i nie znaleziono
1098:main.c        ****     zapisz_znak_w_eeprom(skryba_wlaczona ? 1 : 0,
1099:main.c        ****                          ADRES_EEPROM_DEBUG_SKRYBA_2); // DEBUG
1100:main.c        ****     zapisz_znak_w_eeprom(znaleziono ? 0 : 1,
1101:main.c        ****                          ADRES_EEPROM_DEBUG_SKRYBA_3); // DEBUG
1102:main.c        **** 
1103:main.c        ****     if (skryba_wlaczona && !znaleziono) {
1104:main.c        ****       uchar len_full = strlen((char *)numer_lokalny);
1105:main.c        **** 
1106:main.c        ****       // DEBUG: Zapisz dlugosc numeru
1107:main.c        ****       zapisz_znak_w_eeprom(len_full, ADRES_EEPROM_DEBUG_SKRYBA_5);
1108:main.c        **** 
1109:main.c        ****       if (len_full >= 3) {
1110:main.c        ****         // Skopiuj skrócony numer do numer_telefonu_skryba
1111:main.c        ****         strcpy((char *)numer_telefonu_skryba, (char *)numer_skrocony);
1112:main.c        **** 
1113:main.c        ****         // Extra check: ensure extracted number is also >= 3 chars
1114:main.c        ****         if (strlen((char *)numer_telefonu_skryba) >= 3) {
1115:main.c        ****           zapisz_znak_w_eeprom(
1116:main.c        ****               1, ADRES_EEPROM_DEBUG_SKRYBA_4); // DEBUG: komenda dodana
1117:main.c        **** 
1118:main.c        ****           // Dodaj komende dodania uzytkownika Skryba
1119:main.c        ****           dodaj_komende(KOMENDA_KOLEJKI_DODAJ_UZYTKOWNIKA_SKRYBA);
1120:main.c        ****         }
1121:main.c        ****       }
1122:main.c        ****     }
1123:main.c        **** 
1124:main.c        ****     // Teraz sprawdź tryb i otwórz bramę (TYLKO W TRYBIE CLIP!)
1125:main.c        ****     if (tryb_clip) {
1126:main.c        ****       if (tryb_pracy == 1) {
1127:main.c        ****         // Tryb publiczny - otwórz dla każdego
1128:main.c        ****         ustaw_wyjscie_clip();
1129:main.c        ****       } else if (znaleziono) {
1130:main.c        ****         // Tryb prywatny - otwórz tylko dla znalezionych
1131:main.c        ****         ustaw_wyjscie_clip();
1132:main.c        ****       }
1133:main.c        ****     }
1134:main.c        ****     // W trybie DTMF NIE włączamy wyjścia - czekamy na klawisz '1'
1135:main.c        **** 
1136:main.c        ****     break;
1137:main.c        ****   }
1138:main.c        ****   case KOMENDA_KOLEJKI_DODAJ_UZYTKOWNIKA_BRAMA: {
1139:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1140:main.c        **** 
1141:main.c        ****     // Check for duplicates using the helper function
1142:main.c        ****     if (czy_numer_istnieje(numer_telefonu_do_ktorego_dzwonic)) {
1143:main.c        ****       return TRUE; // Duplicate found, abort
1144:main.c        ****     }
1145:main.c        **** 
1146:main.c        ****     // Re-convert because czy_numer_istnieje uses bufor_eeprom which might be
1147:main.c        ****     // modified (though in this implementation it sets it correctly for writing
1148:main.c        ****     // too) But to be safe and consistent with original logic:
1149:main.c        ****     konwertuj_telefon_na_blok_eeprom(
1150:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
1151:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[strlen(
1152:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
1153:main.c        ****         &bufor_eeprom[0]);
1154:main.c        **** 
1155:main.c        ****     uchar dodano = FALSE;
1156:main.c        ****     for (uint nr_uzyt_clip = 0;
1157:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
1158:main.c        ****       if (not czy_aktywny_numer_telefonu_brama(nr_uzyt_clip)) {
1159:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
1160:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
1161:main.c        ****             LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1162:main.c        ****         dodano = TRUE;
1163:main.c        ****         break;
1164:main.c        ****       }
1165:main.c        ****     }
1166:main.c        **** 
1167:main.c        ****     // Jesli dodano numer i Skryba jest wlaczona, sprawdz czy osiagnieto limit
1168:main.c        ****     if (dodano && skryba_wlaczona) {
1169:main.c        ****       // Policz aktywnych uzytkownikow
1170:main.c        ****       uint aktywne_numery = 0;
1171:main.c        ****       for (uint i = 0; i < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++i) {
1172:main.c        ****         if (czy_aktywny_numer_telefonu_brama(i)) {
1173:main.c        ****           ++aktywne_numery;
1174:main.c        ****         }
1175:main.c        ****       }
1176:main.c        **** 
1177:main.c        ****       // Jesli osiagnieto limit, wylacz Skrybe
1178:main.c        ****       if (aktywne_numery >= skryba_limit) {
1179:main.c        ****         skryba_wlaczona = FALSE;
1180:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_SKRYBA);
1181:main.c        **** 
1182:main.c        ****         tryb_pracy = 0; // Prywatny
1183:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_TRYB_PRACY);
1184:main.c        ****       }
1185:main.c        ****     }
1186:main.c        ****     break;
1187:main.c        ****   }
1188:main.c        ****   case KOMENDA_KOLEJKI_DODAJ_UZYTKOWNIKA_SKRYBA: {
1189:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1190:main.c        **** 
1191:main.c        ****     // Use a LOCAL buffer for Skryba to avoid corruption by czy_numer_istnieje
1192:main.c        ****     uchar bufor_skryba[LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM];
1193:main.c        **** 
1194:main.c        ****     // Convert Skryba number to EEPROM format FIRST, before duplicate check
1195:main.c        ****     konwertuj_telefon_na_blok_eeprom(
1196:main.c        ****         &numer_telefonu_skryba[0],
1197:main.c        ****         &numer_telefonu_skryba[strlen((char *)numer_telefonu_skryba)],
1198:main.c        ****         bufor_skryba);
1199:main.c        **** 
1200:main.c        ****     // Check for duplicates using the helper function
1201:main.c        ****     // (This will use bufor_eeprom internally, but we have our number safe in
1202:main.c        ****     // bufor_skryba)
1203:main.c        ****     if (czy_numer_istnieje(numer_telefonu_skryba)) {
1204:main.c        ****       return TRUE; // Duplicate found, abort
1205:main.c        ****     }
1206:main.c        **** 
1207:main.c        ****     // Copy our safe buffer to bufor_eeprom for writing
1208:main.c        ****     memcpy(bufor_eeprom, bufor_skryba, LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1209:main.c        **** 
1210:main.c        ****     uchar dodano = FALSE;
1211:main.c        ****     for (uint nr_uzyt_clip = 0;
1212:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
1213:main.c        ****       if (not czy_aktywny_numer_telefonu_brama(nr_uzyt_clip)) {
1214:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
1215:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
1216:main.c        ****             LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1217:main.c        **** 
1218:main.c        ****         dodano = TRUE;
1219:main.c        ****         break;
1220:main.c        ****       }
1221:main.c        ****     }
1222:main.c        **** 
1223:main.c        ****     // Jesli dodano numer i Skryba jest wlaczona, sprawdz czy osiagnieto limit
1224:main.c        ****     if (dodano && skryba_wlaczona) {
1225:main.c        ****       // Policz aktywnych uzytkownikow
1226:main.c        ****       uint aktywne_numery = 0;
1227:main.c        ****       for (uint i = 0; i < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++i) {
1228:main.c        ****         if (czy_aktywny_numer_telefonu_brama(i)) {
1229:main.c        ****           ++aktywne_numery;
1230:main.c        ****         }
1231:main.c        ****       }
1232:main.c        **** 
1233:main.c        ****       // Jesli osiagnieto limit, wylacz Skrybe
1234:main.c        ****       if (aktywne_numery >= skryba_limit) {
1235:main.c        ****         skryba_wlaczona = FALSE;
1236:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_SKRYBA);
1237:main.c        **** 
1238:main.c        ****         tryb_pracy = 0; // Prywatny
1239:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_TRYB_PRACY);
1240:main.c        ****       }
1241:main.c        ****     }
1242:main.c        ****   } break;
1243:main.c        ****   case KOMENDA_KOLEJKI_USUN_UZYTKOWNIKA_BRAMA: {
1244:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1245:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
1246:main.c        ****                                      &numer_telefonu_do_ktorego_dzwonic[strlen(
1247:main.c        ****                                          numer_telefonu_do_ktorego_dzwonic)],
1248:main.c        ****                                      &bufor_eeprom[0]);
1249:main.c        ****     // for (uchar nr_uzyt_clip = 0; nr_uzyt_clip <
1250:main.c        ****     // MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip)
1251:main.c        ****     for (uint nr_uzyt_clip = 0;
1252:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
1253:main.c        ****       if (porownaj_numer_telefonu_blok(
1254:main.c        ****               &bufor_eeprom[0], // 1 porwnanie zajmuje ~10us, czyli 170 numerw ~
1255:main.c        ****                                 // 2ms
1256:main.c        ****               (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
1257:main.c        ****         numer_telefonu_do_ktorego_dzwonic[0] = '\0';
1258:main.c        ****         konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
1259:main.c        ****                                          &numer_telefonu_do_ktorego_dzwonic[1],
1260:main.c        ****                                          &bufor_eeprom[0]);
1261:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
1262:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
1263:main.c        ****             LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1264:main.c        ****         break;
1265:main.c        ****       }
1266:main.c        ****     }
1267:main.c        ****     break;
1268:main.c        ****   }
1269:main.c        ****   default:
1270:main.c        ****     return FALSE;
1271:main.c        ****   }
1272:main.c        ****   return TRUE;
1273:main.c        **** }
1274:main.c        **** 
1275:main.c        **** uchar wykonanie_komend_powiadomien(void) {
1276:main.c        ****   const komenda_typ aktualnie_wykonywana_komenda = komendy_kolejka[0];
1277:main.c        **** 
1278:main.c        ****   const uchar czy_gsm_zajety =
1279:main.c        ****       flaga_odczytywanie_smsa || flaga_wysylanie_smsa ||
1280:main.c        ****       wykonywanie_rozmowy_telefonicznej ||
1281:main.c        ****       trwa_rozmowa_przychodzaca_od_uzytkownika ||
1282:main.c        ****       aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
1283:main.c        ****       opoznienie_SIM900_100MS || czekanie_na_odebranie_zachety;
1284:main.c        **** 
1285:main.c        ****   const uchar czy_mozna_wysylac_dane_do_SIM900 =
1286:main.c        ****       !czy_gsm_zajety && CZY_MOZNA_WYSYLAC_DANE_SIM900() &&
1287:main.c        ****       czy_jest_bezczynny_SIM900();
1288:main.c        **** 
1289:main.c        ****   switch (aktualnie_wykonywana_komenda) {
1290:main.c        ****   case KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW: {
1291:main.c        ****     if (not czy_mozna_wysylac_dane_do_SIM900 ||
1292:main.c        ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1293:main.c        ****       dodaj_komende(aktualnie_wykonywana_komenda);
1294:main.c        ****       break;
1295:main.c        ****     }
1296:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1297:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
1298:main.c        ****     *sms++ = '*';
1299:main.c        ****     for (;;) {
1300:main.c        ****       if (czy_aktywny_numer_telefonu_brama(
1301:main.c        ****               numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama)) {
1302:main.c        ****         sms += kopiuj_blok_eeprom_na_telefon(
1303:main.c        ****             (void *)EEPROM_NUMER_TELEFONU_BRAMA(
1304:main.c        ****                 numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama),
1305:main.c        ****             sms, MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER);
1306:main.c        ****         *sms++ = '#';
1307:main.c        ****         *sms++ = '\n';
1308:main.c        ****         ++numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama;
1309:main.c        ****         if ((sms + MAX_LICZBA_ZNAKOW_TELEFON + 1 >=
1310:main.c        ****              &tekst_wysylanego_smsa[MAX_LICZBA_ZNAKOW_SMS]) ||
1311:main.c        ****             (numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama >=
1312:main.c        ****              MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER)) {
1313:main.c        ****           if ((numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama <
1314:main.c        ****                MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER))
1315:main.c        ****             dodaj_komende(aktualnie_wykonywana_komenda);
1316:main.c        ****           *sms = '\0';
1317:main.c        ****           dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
1318:main.c        ****           wysylanie_smsa_clipa = WYSYLANIE_SMSA_WYSYLANIE;
1319:main.c        ****           break;
1320:main.c        ****         }
1321:main.c        ****       } else {
1322:main.c        ****         if (++numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama >=
1323:main.c        ****             MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER) {
1324:main.c        ****           if (sms != &tekst_wysylanego_smsa[0]) {
1325:main.c        ****             *sms = '\0';
1326:main.c        ****             dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
1327:main.c        ****             wysylanie_smsa_clipa = WYSYLANIE_SMSA_WYSYLANIE;
1328:main.c        ****           }
1329:main.c        ****           break;
1330:main.c        ****         }
1331:main.c        ****       }
1332:main.c        ****     }
1333:main.c        ****     break;
1334:main.c        ****   }
1335:main.c        ****   default:
1336:main.c        ****     return FALSE;
1337:main.c        ****   }
1338:main.c        ****   return TRUE;
1339:main.c        **** }
1340:main.c        **** 
1341:main.c        **** void wykonanie_komend(void) {
1342:main.c        ****   if (wykonanie_komend_SIM900())
1343:main.c        ****     ;
1344:main.c        ****   else if (wykonanie_komend_ukladow())
1345:main.c        ****     ;
1346:main.c        ****   else if (wykonanie_komend_powiadomien())
1347:main.c        ****     ;
1348:main.c        ****   else
1349:main.c        ****     ;
1350:main.c        ****   usun_komende();
1351:main.c        **** }
1352:main.c        **** 
1353:main.c        **** void test_sms_clip_100ms(void) {
1354:main.c        ****   // static ulong licznik_sms;
1355:main.c        ****   // if ( ++licznik_sms > 60 * 10 )
1356:main.c        ****   //{
1357:main.c        ****   //	licznik_sms = 0;
1358:main.c        **** 
1359:main.c        ****   // tekst_wysylanego_smsa[0] = 'A';
1360:main.c        ****   // tekst_wysylanego_smsa[1] = 'B';
1361:main.c        ****   // tekst_wysylanego_smsa[2] = 'C';
1362:main.c        ****   // tekst_wysylanego_smsa[3] = 'D';
1363:main.c        ****   // tekst_wysylanego_smsa[4] = 0;
1364:main.c        ****   // static const char tel[] PROGMEM = "731314727";
1365:main.c        ****   ////static const char tel[] PROGMEM = "505691117";
1366:main.c        ****   // memcpy_R(numer_telefonu_wysylanego_smsa, tel);
1367:main.c        ****   // dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
1368:main.c        **** 
1369:main.c        ****   // memcpy_R(numer_telefonu_do_ktorego_dzwonic, tel);
1370:main.c        ****   // dodaj_komende(KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE);
1371:main.c        ****   //}
1372:main.c        **** }
1373:main.c        **** 
1374:main.c        **** void steruj_wejscia_wyjscia_100ms(void) {
1375:main.c        ****   aktualizuj_stan_wyzwolenia_wejsc_100ms();
1376:main.c        ****   steruj_wejsciem_reset_100ms();
1377:main.c        ****   steruj_wyjscia_100ms();
1378:main.c        **** }
1379:main.c        **** 
1380:main.c        **** void zapis_w_eeprom_stanu_wyjsc(void) {
1381:main.c        ****   if (not czy_wolny_eeprom())
1382:main.c        ****     return;
1383:main.c        ****   uchar par = 0;
1384:main.c        ****   if ((stan_wyjscie[0] != 0) ^ (licznik_przelacznik_wyjscia[0] != 0))
1385:main.c        ****     par |= BIT(0);
1386:main.c        ****   if (par != eeprom_read_byte((void *)EEPROM_USTAWIENIE_STANOW_WYJSC))
1387:main.c        ****     zapisz_znaki_w_eeprom(&par, (uint)EEPROM_USTAWIENIE_STANOW_WYJSC, 1);
1388:main.c        **** }
1389:main.c        **** 
1390:main.c        **** // void test_clip_na_101(void)
1391:main.c        **** //{
1392:main.c        **** //	if ( not modul_zalogowany_w_sieci )
1393:main.c        **** //		return;
1394:main.c        **** //	static uint licznik_101;
1395:main.c        **** //	if ( ++licznik_101 < 2 * 60 * 10 )
1396:main.c        **** //		return;
1397:main.c        **** //	licznik_101 = 0;
1398:main.c        **** //	static const char doladowanie[] PROGMEM = "*101#";
1399:main.c        **** //	strcpy_P(numer_telefonu_do_ktorego_dzwonic, doladowanie);
1400:main.c        **** //	dodaj_komende(KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE);
1401:main.c        **** // }
1402:main.c        **** 
1403:main.c        **** void steruj_urzadzeniem_100MS(void) {
1404:main.c        ****   steruj_wejscia_wyjscia_100ms();
1405:main.c        ****   steruj_SIM900_100MS();
1406:main.c        ****   if (licznik_100ms_dioda_led) {
1407:main.c        ****     if (--licznik_100ms_dioda_led == 0)
1408:main.c        ****       ustaw_stan_led(FALSE);
1409:main.c        ****     else
1410:main.c        ****       ustaw_stan_led(TRUE);
1411:main.c        ****   }
1412:main.c        **** 
1413:main.c        ****   // Aktualizacja timera blokady komend REPORT/USER
1414:main.c        ****   if (timer_report_user_100ms > 0) {
1415:main.c        ****     --timer_report_user_100ms;
1416:main.c        ****     if (timer_report_user_100ms == 0) {
1417:main.c        ****       // Okno czasowe minelo - resetuj licznik
1418:main.c        ****       licznik_report_user = 0;
1419:main.c        ****     }
1420:main.c        ****   } else {
1421:main.c        ****     // Timer jest 0 - upewnij sie ze licznik tez jest 0 (ochrona przed
1422:main.c        ****     // bledami)
1423:main.c        ****     licznik_report_user = 0;
1424:main.c        ****   }
1425:main.c        **** 
1426:main.c        ****   // Mechanizm wykrywania zablokowanej kolejki i czyszczenia starych komend
1427:main.c        ****   // SMS
1428:main.c        ****   const komenda_typ pierwsza_komenda = komendy_kolejka[0];
1429:main.c        ****   if (pierwsza_komenda != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
1430:main.c        ****     // Sprawdz czy pierwsza komenda to SMS - jesli tak i stoi zbyt dlugo,
1431:main.c        ****     // wyczysc
1432:main.c        ****     if (pierwsza_komenda >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
1433:main.c        ****         pierwsza_komenda <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU) {
1434:main.c        ****       // To jest komenda SMS - sprawdz czy stoi zbyt dlugo
1435:main.c        ****       if (pierwsza_komenda == ostatnia_pierwsza_komenda) {
1436:main.c        ****         // Ta sama komenda SMS jest na poczatku kolejki - kolejka moze stac
1437:main.c        ****         if (licznik_kolejka_stoi_100ms < MAX_CZAS_KOLEJKA_STOI_100MS)
1438:main.c        ****           ++licznik_kolejka_stoi_100ms;
1439:main.c        ****         else {
1440:main.c        ****           // Komenda SMS stoi juz 30 sekund - wyczysc wszystkie komendy SMS i
1441:main.c        ****           // wznow dzialanie
1442:main.c        ****           filtruj_komendy_z_przedzialu(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT,
1443:main.c        ****                                        KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
1444:main.c        ****           if (licznik_awaryjnych_resetow_kolejki < 0xFFFF)
1445:main.c        ****             ++licznik_awaryjnych_resetow_kolejki;
1446:main.c        **** 
1447:main.c        ****           filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
1448:main.c        **** 
1449:main.c        ****           // Resetuj blokade komend REPORT/USER aby wznowic dzialanie
1450:main.c        ****           licznik_report_user = 0;
1451:main.c        ****           timer_report_user_100ms = 0;
1452:main.c        **** 
1453:main.c        ****           // Resetuj liczniki kolejki
1454:main.c        ****           licznik_kolejka_stoi_100ms = 0;
1455:main.c        ****           ostatnia_pierwsza_komenda = KOMENDA_KOLEJKI_BRAK_KOMENDY;
1456:main.c        **** 
1457:main.c        ****           // Resetuj flage wysylania SMS (na wypadek zablokowania)
1458:main.c        ****           flaga_wysylanie_smsa = 0;
1459:main.c        ****         }
1460:main.c        ****       } else {
1461:main.c        ****         // Pierwsza komenda SMS sie zmienila - kolejka dziala
1462:main.c        ****         ostatnia_pierwsza_komenda = pierwsza_komenda;
1463:main.c        ****         licznik_kolejka_stoi_100ms = 0;
1464:main.c        ****       }
1465:main.c        ****     } else {
1466:main.c        ****       // To nie jest komenda SMS - resetuj licznik (nie interesuje nas)
1467:main.c        ****       ostatnia_pierwsza_komenda = pierwsza_komenda;
1468:main.c        ****       licznik_kolejka_stoi_100ms = 0;
1469:main.c        ****     }
1470:main.c        ****   } else {
1471:main.c        ****     // Kolejka jest pusta
1472:main.c        ****     ostatnia_pierwsza_komenda = KOMENDA_KOLEJKI_BRAK_KOMENDY;
1473:main.c        ****     licznik_kolejka_stoi_100ms = 0;
1474:main.c        ****   }
1475:main.c        **** 
1476:main.c        ****   // Watchdog pilnujacy zakleszczonego wysylania SMS
1477:main.c        ****   if (flaga_wysylanie_smsa) {
1478:main.c        ****     if (licznik_watchdog_wysylanie_smsa_100ms < WATCHDOG_WYSYLANIA_SMS_100MS) {
1479:main.c        ****       ++licznik_watchdog_wysylanie_smsa_100ms;
1480:main.c        ****     } else {
1481:main.c        ****       licznik_watchdog_wysylanie_smsa_100ms = 0;
1482:main.c        ****       // Awaryjne odblokowanie
1483:main.c        ****       watchdog_sms_disarm();
1484:main.c        ****       flaga_wysylanie_smsa = 0;
1485:main.c        ****       liczba_prob_wyslania_smsa = 0;
1486:main.c        ****       czekanie_na_odebranie_zachety = FALSE;
1487:main.c        ****       wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
1488:main.c        **** 
1489:main.c        ****       if (liczba_kolejnych_watchdogow_wysylania < 255)
1490:main.c        ****         ++liczba_kolejnych_watchdogow_wysylania;
1491:main.c        ****       if (liczba_kolejnych_watchdogow_wysylania >= 3) {
1492:main.c        ****         liczba_kolejnych_watchdogow_wysylania = 0;
1493:main.c        ****         reset_modulu_SIM900();
1494:main.c        ****       }
1495:main.c        ****     }
1496:main.c        ****   } else {
1497:main.c        ****     licznik_watchdog_wysylanie_smsa_100ms = 0;
1498:main.c        ****     liczba_kolejnych_watchdogow_wysylania = 0;
1499:main.c        ****   }
1500:main.c        **** 
1501:main.c        ****   if (watchdog_sms_aktywny) {
1502:main.c        ****     if (watchdog_sms_licznik_100ms < WATCHDOG_SMS_TIMEOUT_100MS)
1503:main.c        ****       ++watchdog_sms_licznik_100ms;
1504:main.c        ****     else {
1505:main.c        ****       watchdog_sms_trwa_reset = TRUE;
1506:main.c        ****       cli();
1507:main.c        ****       wdt_enable(WDTO_15MS);
1508:main.c        ****       while (1)
1509:main.c        ****         ;
1510:main.c        ****     }
1511:main.c        ****   } else if (watchdog_sms_safe_mode_100ms) {
1512:main.c        ****     --watchdog_sms_safe_mode_100ms;
1513:main.c        ****   }
1514:main.c        **** 
1515:main.c        ****   // Obsluga szybkich blyskow LED
1516:main.c        ****   if (liczba_blyskow_led > 0) {
1517:main.c        ****     ++stan_cyklu_blysku;
1518:main.c        ****     if (stan_cyklu_blysku >= 6) {
1519:main.c        ****       stan_cyklu_blysku = 0;
1520:main.c        ****       --liczba_blyskow_led;
1521:main.c        ****     }
1522:main.c        ****     ustaw_stan_led(stan_cyklu_blysku < 2);
1523:main.c        ****     return;
1524:main.c        ****   }
1525:main.c        **** 
1526:main.c        ****   // LED: ON gdy nie zalogowany, OFF gdy zalogowany (z mruganiem przy dobrym
1527:main.c        ****   // sygnale)
1528:main.c        ****   if (!modul_zalogowany_w_sieci) {
1529:main.c        ****     // Nie zalogowany - dioda swiecei ciagle
1530:main.c        ****     ustaw_stan_led(TRUE);
1531:main.c        ****   } else {
1532:main.c        ****     // Zalogowany - dioda zgaszona lub mruga w zaleznosci od sygnalu
1533:main.c        ****     if (licznik_100ms_dioda_led) {
1534:main.c        ****       // Mrugniecie (SMS, etc.)
1535:main.c        ****       ustaw_stan_led(TRUE);
1536:main.c        ****     } else {
1537:main.c        ****       // Normalne dzialanie - mrugaj w zaleznosci od poziomu sygnalu
1538:main.c        ****       static uchar licznik_dioda_led_poziom_sieci;
1539:main.c        ****       if (poziom_sieci_gsm < 16) {
1540:main.c        ****         if (++licznik_dioda_led_poziom_sieci >= 50)
1541:main.c        ****           licznik_dioda_led_poziom_sieci = 1;
1542:main.c        ****       } else
1543:main.c        ****         licznik_dioda_led_poziom_sieci = 0;
1544:main.c        **** 
1545:main.c        ****       ustaw_stan_led(licznik_dioda_led_poziom_sieci == 40 ||
1546:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
1547:main.c        ****                      (licznik_dioda_led_poziom_sieci >= 46 &&
1548:main.c        ****                       licznik_dioda_led_poziom_sieci <= 49));
1549:main.c        ****     }
1550:main.c        ****   }
1551:main.c        ****   zapis_w_eeprom_stanu_wyjsc();
1552:main.c        **** }
1553:main.c        **** 
1554:main.c        **** void steruj_urzadzeniem_10MS(void) {
1555:main.c        ****   steruj_wejscia_10ms();
1556:main.c        ****   steruj_SIM900_10MS();
1557:main.c        ****   zapisz_bajt_w_EEPROM();
1558:main.c        ****   // test_dioda_wyjscia();
1559:main.c        ****   // test_wejscie();
1560:main.c        **** }
1561:main.c        **** 
1562:main.c        **** void wolne_zdarzenie_timer(void) {
1563:main.c        ****   WYKONAJ_CLI_SEI(WYLACZ_PRZERWANIE_TIMER());
1564:main.c        ****   if (!CZY_WYKONAC_ZDARZENIE_TIMER()) {
1565:main.c        ****     WYKONAJ_CLI_SEI(WLACZ_PRZERWANIE_TIMER());
1566:main.c        ****     return;
1567:main.c        ****   }
1568:main.c        ****   wykonaj_zdarzenie_timer = FALSE;
1569:main.c        ****   if (wykonac_watki_10MS) {
1570:main.c        ****     wykonac_watki = WYKONAJ_WATKI_10MS;
1571:main.c        ****     wykonac_watki_10MS = FALSE;
1572:main.c        ****   }
1573:main.c        ****   WYKONAJ_CLI_SEI(WLACZ_PRZERWANIE_TIMER());
1574:main.c        ****   if (CZY_WYKONAC_WATKI_10MS()) {
1575:main.c        ****     static uchar licznik_wybuc_watki_100MS = 0;
1576:main.c        **** #define OPOZNIENIE_100_MS 10
1577:main.c        ****     if (++licznik_wybuc_watki_100MS == OPOZNIENIE_100_MS) {
1578:main.c        ****       licznik_wybuc_watki_100MS = 0;
1579:main.c        ****       wykonac_watki = WYKONAJ_WATKI_100MS | WYKONAJ_WATKI_10MS;
1580:main.c        ****     }
1581:main.c        ****     NOP();
1582:main.c        ****     cli();
1583:main.c        ****     if (CZY_ODBIERANIE_DANYCH_SIM900()) {
1584:main.c        ****       WYLACZ_PRZERWANIE_ODBIORU_DANYCH_SIM900();
1585:main.c        ****       sei();
1586:main.c        ****       if (liczba_odebranych_znakow_SIM900 != 0 &&
1587:main.c        ****           ++licznik_opoznienie_oczekiwania_na_bajt_SIM900 >
1588:main.c        ****               MAX_OPOZNIENIE_OCZEKIWANIA_NA_BAJT_SIM900_500_MS) {
1589:main.c        ****         resetuj_odbior_SIM900_po_bledzie();
1590:main.c        ****       } else {
1591:main.c        ****         WYKONAJ_CLI_SEI(WLACZ_PRZERWANIE_ODBIORU_DANYCH_SIM900());
1592:main.c        ****       }
1593:main.c        ****     }
1594:main.c        ****     sei();
1595:main.c        ****   }
1596:main.c        **** }
1597:main.c        **** 
1598:main.c        **** void ustaw_parametry_dla_bezpieczenstwa(void) {
1599:main.c        ****   wdt_reset();
1600:main.c        ****   ustaw_parametry_dla_bezpieczenstwa_rejestry();
1601:main.c        ****   set_sleep_mode(SLEEP_MODE_IDLE);
1602:main.c        **** }
1603:main.c        **** 
1604:main.c        **** void inicjalizuj_parametry_modulu(void) {
1605:main.c        ****   memcpy_E(kod_modulu, ADRES_EEPROM_KOD_DOSTEPU, LICZBA_BAJTOW_KODU_DOSTEPU);
1606:main.c        **** 
1607:main.c        ****   // Auto-naprawa: Jeśli kod jest pusty (FF) lub zerowy, ustaw ABCD
1608:main.c        ****   if (kod_modulu[0] == 0xFF || kod_modulu[0] == 0x00) {
1609:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
1610:main.c        ****     kod_modulu[1] = bufor_eeprom[1] = 'B';
1611:main.c        ****     kod_modulu[2] = bufor_eeprom[2] = 'C';
1612:main.c        ****     kod_modulu[3] = bufor_eeprom[3] = 'D';
1613:main.c        ****     // Zapisz do EEPROM natychmiast (BLOCKING)
1614:main.c        ****     while (!eeprom_is_ready())
1615:main.c        ****       ;
1616:main.c        ****     eeprom_update_block(kod_modulu, (void *)ADRES_EEPROM_KOD_DOSTEPU,
1617:main.c        ****                         LICZBA_BAJTOW_KODU_DOSTEPU);
1618:main.c        ****   }
1619:main.c        **** 
1620:main.c        ****   // Auto-naprawa: Jeśli tryb pracy jest nieokreślony (0xFF), ustaw Publiczny
1621:main.c        ****   // (1)
1622:main.c        ****   tryb_pracy = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_TRYB_PRACY);
1623:main.c        ****   if (tryb_pracy == 0xFF) {
1624:main.c        ****     tryb_pracy = 1; // Domyślnie Publiczny
1625:main.c        ****     while (!eeprom_is_ready())
1626:main.c        ****       ;
1627:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_TRYB_PRACY, 1);
1628:main.c        ****   }
1629:main.c        **** 
1630:main.c        ****   // --- Inicjalizacja trybu CLIP/DTMF ---
1631:main.c        ****   tryb_clip = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_TRYB_CLIP_DTMF);
1632:main.c        ****   if (tryb_clip == 0xFF) {
1633:main.c        ****     tryb_clip = 1; // Domyślnie CLIP (1)
1634:main.c        ****     while (!eeprom_is_ready())
1635:main.c        ****       ;
1636:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_TRYB_CLIP_DTMF, 1);
1637:main.c        ****   }
1638:main.c        **** 
1639:main.c        ****   // Inicjalizacja parametrow czasowych
1640:main.c        ****   czas_start_h = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_START_H);
1641:main.c        ****   czas_start_m = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_START_M);
1642:main.c        ****   czas_stop_h = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_STOP_H);
1643:main.c        ****   czas_stop_m = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_STOP_M);
1644:main.c        **** 
1645:main.c        ****   // Inicjalizacja SKRYBA
1646:main.c        ****   skryba_wlaczona = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA);
1647:main.c        ****   if (skryba_wlaczona == 0xFF)
1648:main.c        ****     skryba_wlaczona = FALSE;
1649:main.c        **** 
1650:main.c        ****   // Odczyt limitu Skryby z EEPROM
1651:main.c        ****   uchar limit_l =
1652:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA_LIMIT_L);
1653:main.c        ****   uchar limit_h =
1654:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA_LIMIT_H);
1655:main.c        ****   if (limit_l == 0xFF && limit_h == 0xFF) {
1656:main.c        ****     // Nie ustawiono - domyslnie 800
1657:main.c        ****     skryba_limit = 800;
1658:main.c        ****   } else {
1659:main.c        ****     skryba_limit = limit_l | (limit_h << 8);
1660:main.c        ****     // Walidacja zakresu
1661:main.c        ****     if (skryba_limit < 1 || skryba_limit > MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA) {
1662:main.c        ****       skryba_limit = 800;
1663:main.c        ****     }
1664:main.c        ****   }
1665:main.c        ****   // Debug initialization
1666:main.c        ****   zapisz_debug_do_eeprom(skryba_wlaczona ? 1 : 0, (uchar)(skryba_limit & 0xFF));
1667:main.c        **** 
1668:main.c        ****   // Auto-naprawa Harmonogramu: Jeśli wartości są nieprawidłowe (ale nie
1669:main.c        ****   // 0xFF), ustaw na OFF
1670:main.c        ****   if ((czas_start_h > 23 && czas_start_h != 0xFF) ||
1671:main.c        ****       (czas_start_m > 59 && czas_start_m != 0xFF) ||
1672:main.c        ****       (czas_stop_h > 23 && czas_stop_h != 0xFF) ||
1673:main.c        ****       (czas_stop_m > 59 && czas_stop_m != 0xFF)) {
1674:main.c        ****     // Zapisz wartosci wylaczajace (0xFF) - BLOCKING
1675:main.c        ****     while (!eeprom_is_ready())
1676:main.c        ****       ;
1677:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_CZAS_START_H, 0xFF);
1678:main.c        ****     while (!eeprom_is_ready())
1679:main.c        ****       ;
1680:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_CZAS_START_M, 0xFF);
1681:main.c        ****     while (!eeprom_is_ready())
1682:main.c        ****       ;
1683:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_CZAS_STOP_H, 0xFF);
1684:main.c        ****     while (!eeprom_is_ready())
1685:main.c        ****       ;
1686:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_CZAS_STOP_M, 0xFF);
1687:main.c        **** 
1688:main.c        ****     czas_start_h = 0xFF;
1689:main.c        ****     czas_start_m = 0xFF;
1690:main.c        ****     czas_stop_h = 0xFF;
1691:main.c        ****     czas_stop_m = 0xFF;
1692:main.c        ****   }
1693:main.c        **** 
1694:main.c        ****   blokada_sterowania_czasowa =
1695:main.c        ****       FALSE; // Domyślnie odblokowane, zaktualizuje sie przy odczycie czasu
1696:main.c        **** 
1697:main.c        ****   // Inicjalizacja blokady systemu (START/STOP)
1698:main.c        ****   blokada_systemu =
1699:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_BLOKADA_SYSTEMU);
1700:main.c        ****   if (blokada_systemu == 0xFF) {
1701:main.c        ****     blokada_systemu = FALSE; // Domyślnie odblokowany
1702:main.c        ****   }
1703:main.c        **** 
1704:main.c        ****   // Inicjalizacja zmiennych debug SKRYBA (jesli 0xFF to wyczysc)
1705:main.c        ****   for (uint16_t addr = ADRES_EEPROM_DEBUG_SKRYBA_1;
1706:main.c        ****        addr <= ADRES_EEPROM_DEBUG_SKRYBA_5; ++addr) {
1707:main.c        ****     if (eeprom_read_byte((const uint8_t *)addr) == 0xFF) {
1708:main.c        ****       while (!eeprom_is_ready())
1709:main.c        ****         ;
1710:main.c        ****       eeprom_update_byte((uint8_t *)addr, 0);
1711:main.c        ****     }
1712:main.c        ****   }
1713:main.c        **** 
1714:main.c        ****   // Inicjalizacja zmiennych debug USER (jesli 0xFF to wyczysc)
1715:main.c        ****   for (uint16_t addr = ADRES_EEPROM_DEBUG_USER_1;
1716:main.c        ****        addr <= ADRES_EEPROM_DEBUG_USER_7; ++addr) {
1717:main.c        ****     if (eeprom_read_byte((const uint8_t *)addr) == 0xFF) {
1718:main.c        ****       while (!eeprom_is_ready())
1719:main.c        ****         ;
1720:main.c        ****       eeprom_update_byte((uint8_t *)addr, 0);
1721:main.c        ****     }
1722:main.c        ****   }
1723:main.c        **** 
1724:main.c        ****   // --- NOWE Z V7 (Ported) ---
1725:main.c        ****   // Reset blokady komend REPORT/USER po inicjalizacji/resecie
1726:main.c        ****   licznik_report_user = 0;
1727:main.c        ****   timer_report_user_100ms = 0;
1728:main.c        **** 
1729:main.c        ****   // Reset flagi wysylania SMS po resecie
1730:main.c        ****   flaga_wysylanie_smsa = 0;
1731:main.c        **** 
1732:main.c        ****   // Zwieksz licznik resetow i zapisz debug
1733:main.c        ****   static uchar licznik_resetow = 0;
1734:main.c        ****   if (licznik_resetow < 255)
1735:main.c        ****     ++licznik_resetow;
1736:main.c        ****   while (!eeprom_is_ready())
1737:main.c        ****     ;
1738:main.c        ****   eeprom_update_byte((void *)EEPROM_DEBUG_LICZNIK_RESETOW, licznik_resetow);
1739:main.c        ****   while (!eeprom_is_ready())
1740:main.c        ****     ;
1741:main.c        ****   zapisz_debug_do_eeprom(0, 2); // Reset (komenda=0 oznacza reset)
1742:main.c        **** }
1743:main.c        **** 
1744:main.c        **** static void opoznienie_startowe(void) {
 189               		.loc 1 1744 0
 190               		.cfi_startproc
 191               	/* prologue: function */
 192               	/* frame size = 0 */
 193               	/* stack size = 0 */
 194               	.L__stack_usage = 0
 195               	.LVL10:
 196               	.LBB364:
 197               	.LBB365:
 198               	.LBB366:
 199               		.file 3 "/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h"
   1:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
   6:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
   9:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  12:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      distribution.
  16:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  17:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  21:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  33:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  35:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  38:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #  endif
  42:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  44:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  48:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /** \file */
  49:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \code
  51:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \endcode
  55:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  56:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     used.
  60:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  61:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  70:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  79:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  83:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** */
  84:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  85:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif
  89:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  90:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  97:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 103:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     integer value.
 107:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****  */
 108:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif
 110:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 111:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif
 114:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 115:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif
 120:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 121:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /**
 122:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 124:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 126:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 129:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 131:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 137:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 142:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 147:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    respectively.
 151:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 152:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    \note
 153:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 154:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 164:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****  */
 165:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** void
 166:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** {
 168:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 176:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 179:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 182:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	#else
 183:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	#endif
 186:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 187:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 200               		.loc 3 187 0
 201 0098 8FEF      		ldi r24,lo8(-28673)
 202 009a 9FE8      		ldi r25,hi8(-28673)
 203 009c 0197      	1:	sbiw r24,1
 204 009e 01F4      		brne 1b
 205 00a0 00C0      		rjmp .
 206 00a2 0000      		nop
 207               	.LVL11:
 208 00a4 8FEF      		ldi r24,lo8(-28673)
 209 00a6 9FE8      		ldi r25,hi8(-28673)
 210 00a8 0197      	1:	sbiw r24,1
 211 00aa 01F4      		brne 1b
 212 00ac 00C0      		rjmp .
 213 00ae 0000      		nop
 214               	.LVL12:
 215 00b0 8FEF      		ldi r24,lo8(-28673)
 216 00b2 9FE8      		ldi r25,hi8(-28673)
 217 00b4 0197      	1:	sbiw r24,1
 218 00b6 01F4      		brne 1b
 219 00b8 00C0      		rjmp .
 220 00ba 0000      		nop
 221               	.LVL13:
 222 00bc 8FEF      		ldi r24,lo8(-28673)
 223 00be 9FE8      		ldi r25,hi8(-28673)
 224 00c0 0197      	1:	sbiw r24,1
 225 00c2 01F4      		brne 1b
 226 00c4 00C0      		rjmp .
 227 00c6 0000      		nop
 228               	.LVL14:
 229 00c8 8FEF      		ldi r24,lo8(-28673)
 230 00ca 9FE8      		ldi r25,hi8(-28673)
 231 00cc 0197      	1:	sbiw r24,1
 232 00ce 01F4      		brne 1b
 233 00d0 00C0      		rjmp .
 234 00d2 0000      		nop
 235               	.LVL15:
 236               	.LBE366:
 237               	.LBE365:
 238               	.LBE364:
1745:main.c        ****   for (uchar i = 0; i < 5; ++i)
1746:main.c        ****     _delay_ms(20);
1747:main.c        ****   wdt_reset();
 239               		.loc 1 1747 0
 240               	/* #APP */
 241               	 ;  1747 "main.c" 1
 242 00d4 A895      		wdr
 243               	 ;  0 "" 2
 244               	/* epilogue start */
1748:main.c        **** }
 245               		.loc 1 1748 0
 246               	/* #NOAPP */
 247 00d6 0895      		ret
 248               		.cfi_endproc
 249               	.LFE69:
 252               	zapisz_debug_do_eeprom:
 253               	.LFB37:
 343:main.c        ****   if (!czy_wolny_eeprom())
 254               		.loc 1 343 0
 255               		.cfi_startproc
 256               	.LVL16:
 257 00d8 CF93      		push r28
 258               	.LCFI2:
 259               		.cfi_def_cfa_offset 3
 260               		.cfi_offset 28, -2
 261 00da DF93      		push r29
 262               	.LCFI3:
 263               		.cfi_def_cfa_offset 4
 264               		.cfi_offset 29, -3
 265 00dc CDB7      		in r28,__SP_L__
 266 00de DEB7      		in r29,__SP_H__
 267               	.LCFI4:
 268               		.cfi_def_cfa_register 28
 269 00e0 2897      		sbiw r28,8
 270               	.LCFI5:
 271               		.cfi_def_cfa_offset 12
 272 00e2 0FB6      		in __tmp_reg__,__SREG__
 273 00e4 F894      		cli
 274 00e6 DEBF      		out __SP_H__,r29
 275 00e8 0FBE      		out __SREG__,__tmp_reg__
 276 00ea CDBF      		out __SP_L__,r28
 277               	/* prologue: function */
 278               	/* frame size = 8 */
 279               	/* stack size = 10 */
 280               	.L__stack_usage = 10
 344:main.c        ****     return;
 281               		.loc 1 344 0
 282 00ec 9091 0000 		lds r25,bufor_pomoc_liczba_znakow_do_zapisu
 283 00f0 9111      		cpse r25,__zero_reg__
 284 00f2 00C0      		rjmp .L17
 344:main.c        ****     return;
 285               		.loc 1 344 0 is_stmt 0 discriminator 1
 286 00f4 9091 0000 		lds r25,liczba_znakow_do_zapisu
 287 00f8 9111      		cpse r25,__zero_reg__
 288 00fa 00C0      		rjmp .L17
 344:main.c        ****     return;
 289               		.loc 1 344 0 discriminator 2
 290 00fc 9091 0000 		lds r25,czy_zajety_bufor_eeprom
 291 0100 9111      		cpse r25,__zero_reg__
 292 0102 00C0      		rjmp .L17
 344:main.c        ****     return;
 293               		.loc 1 344 0 discriminator 3
 294 0104 F999      		sbic 0x1f,1
 295 0106 00C0      		rjmp .L17
 296               	.LVL17:
 297               	.LBB370:
 298               	.LBB371:
 348:main.c        ****   buf[1] = (uchar)(timer_report_user_100ms & 0xFF);
 299               		.loc 1 348 0 is_stmt 1
 300 0108 2091 0000 		lds r18,licznik_report_user
 301 010c 2983      		std Y+1,r18
 349:main.c        ****   buf[2] = (uchar)((timer_report_user_100ms >> 8) & 0xFF);
 302               		.loc 1 349 0
 303 010e 3091 0000 		lds r19,timer_report_user_100ms
 304 0112 2091 0000 		lds r18,timer_report_user_100ms+1
 305 0116 3A83      		std Y+2,r19
 350:main.c        ****   buf[3] = (uchar)flaga_wysylanie_smsa;
 306               		.loc 1 350 0
 307 0118 2B83      		std Y+3,r18
 351:main.c        **** 
 308               		.loc 1 351 0
 309 011a 2091 0000 		lds r18,flaga_wysylanie_smsa
 310 011e 2C83      		std Y+4,r18
 311               	.LVL18:
 312 0120 E0E0      		ldi r30,lo8(komendy_kolejka)
 313 0122 F0E0      		ldi r31,hi8(komendy_kolejka)
 314               	.LVL19:
 315               	.L20:
 316               	.LBB372:
 355:main.c        ****         komendy_kolejka[i] <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
 317               		.loc 1 355 0
 318 0124 2191      		ld r18,Z+
 319               	.LVL20:
 320 0126 225D      		subi r18,lo8(-(46))
 321 0128 2230      		cpi r18,lo8(2)
 322 012a 00F4      		brsh .L19
 357:main.c        ****   }
 323               		.loc 1 357 0
 324 012c 9F5F      		subi r25,lo8(-(1))
 325               	.LVL21:
 326               	.L19:
 354:main.c        ****     if (komendy_kolejka[i] >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
 327               		.loc 1 354 0
 328 012e 20E0      		ldi r18,hi8(komendy_kolejka+30)
 329 0130 E030      		cpi r30,lo8(komendy_kolejka+30)
 330 0132 F207      		cpc r31,r18
 331 0134 01F4      		brne .L20
 332               	.LBE372:
 359:main.c        ****   buf[5] = komenda;
 333               		.loc 1 359 0
 334 0136 9D83      		std Y+5,r25
 360:main.c        ****   buf[6] = akcja;
 335               		.loc 1 360 0
 336 0138 8E83      		std Y+6,r24
 361:main.c        **** 
 337               		.loc 1 361 0
 338 013a 6F83      		std Y+7,r22
 363:main.c        **** }
 339               		.loc 1 363 0
 340 013c 47E0      		ldi r20,lo8(7)
 341 013e 62ED      		ldi r22,lo8(-46)
 342 0140 7FE0      		ldi r23,lo8(15)
 343               	.LVL22:
 344 0142 CE01      		movw r24,r28
 345               	.LVL23:
 346 0144 0196      		adiw r24,1
 347 0146 0E94 0000 		call zapisz_znaki_w_eeprom
 348               	.LVL24:
 349               	.L17:
 350               	/* epilogue start */
 351               	.LBE371:
 352               	.LBE370:
 364:main.c        **** 
 353               		.loc 1 364 0
 354 014a 2896      		adiw r28,8
 355 014c 0FB6      		in __tmp_reg__,__SREG__
 356 014e F894      		cli
 357 0150 DEBF      		out __SP_H__,r29
 358 0152 0FBE      		out __SREG__,__tmp_reg__
 359 0154 CDBF      		out __SP_L__,r28
 360 0156 DF91      		pop r29
 361 0158 CF91      		pop r28
 362 015a 0895      		ret
 363               		.cfi_endproc
 364               	.LFE37:
 366               	.global	test_dioda_wyjscia
 368               	test_dioda_wyjscia:
 369               	.LFB24:
 370               		.file 4 "test_pcb.h"
   1:test_pcb.h    **** void test_dioda_wyjscia(void)
   2:test_pcb.h    **** {
 371               		.loc 4 2 0
 372               		.cfi_startproc
 373               	/* prologue: function */
 374               	/* frame size = 0 */
 375               	/* stack size = 0 */
 376               	.L__stack_usage = 0
   3:test_pcb.h    **** 	static uchar opoznienie_1s;
   4:test_pcb.h    **** 	if ( ++opoznienie_1s < 100 )
 377               		.loc 4 4 0
 378 015c 8091 0000 		lds r24,opoznienie_1s.2969
 379 0160 8F5F      		subi r24,lo8(-(1))
 380 0162 8436      		cpi r24,lo8(100)
 381 0164 00F4      		brsh .L23
 382 0166 8093 0000 		sts opoznienie_1s.2969,r24
 383 016a 0895      		ret
 384               	.L23:
   5:test_pcb.h    **** 		return;
   6:test_pcb.h    **** 	opoznienie_1s = 0;
 385               		.loc 4 6 0
 386 016c 1092 0000 		sts opoznienie_1s.2969,__zero_reg__
   7:test_pcb.h    **** 	static uchar stan;
   8:test_pcb.h    **** 	stan = not stan;
 387               		.loc 4 8 0
 388 0170 8091 0000 		lds r24,stan.2970
 389 0174 91E0      		ldi r25,lo8(1)
 390 0176 8111      		cpse r24,__zero_reg__
 391 0178 90E0      		ldi r25,0
 392               	.L25:
 393 017a 9093 0000 		sts stan.2970,r25
   9:test_pcb.h    **** 	if ( stan )
 394               		.loc 4 9 0
 395 017e 8111      		cpse r24,__zero_reg__
 396 0180 00C0      		rjmp .L26
  10:test_pcb.h    **** 	{
  11:test_pcb.h    **** 		ustaw_stan_led(TRUE);
 397               		.loc 4 11 0 discriminator 2
 398 0182 4098      		cbi 0x8,0
 399 0184 0895      		ret
 400               	.L26:
  12:test_pcb.h    **** 	}
  13:test_pcb.h    **** 	else
  14:test_pcb.h    **** 	{
  15:test_pcb.h    **** 		ustaw_stan_led(FALSE);
 401               		.loc 4 15 0 discriminator 1
 402 0186 409A      		sbi 0x8,0
 403               	/* epilogue start */
  16:test_pcb.h    **** 	}
  17:test_pcb.h    **** }
 404               		.loc 4 17 0 discriminator 1
 405 0188 0895      		ret
 406               		.cfi_endproc
 407               	.LFE24:
 409               	.global	test_wejscie
 411               	test_wejscie:
 412               	.LFB25:
  18:test_pcb.h    **** 
  19:test_pcb.h    **** void test_wejscie(void)
  20:test_pcb.h    **** {
 413               		.loc 4 20 0
 414               		.cfi_startproc
 415               	/* prologue: function */
 416               	/* frame size = 0 */
 417               	/* stack size = 0 */
 418               	.L__stack_usage = 0
 419               	.LBB373:
 420               	.LBB374:
 421               		.file 5 "wewy.h"
   1:wewy.h        **** 
   2:wewy.h        **** #include <avr/io.h>
   3:wewy.h        **** #include "narzedzia.h"
   4:wewy.h        **** #include "konfiguracja_eeprom.h"
   5:wewy.h        **** 
   6:wewy.h        **** #define LICZBA_WEJSC	1
   7:wewy.h        **** extern uchar licznik_wejscie[LICZBA_WEJSC];
   8:wewy.h        **** 
   9:wewy.h        **** extern uchar parametry_wejscia[LICZBA_WEJSC];
  10:wewy.h        **** void kopiuj_parametry_we_wy_z_eeprom(void);
  11:wewy.h        **** 
  12:wewy.h        **** extern ulong czas_trwania_impulsu_na_wejsciu[LICZBA_WEJSC];
  13:wewy.h        **** extern ulong czas_trwania_impulsu_off_na_wejsciu[LICZBA_WEJSC];
  14:wewy.h        **** 
  15:wewy.h        **** #define STAN_LOGICZNY_NA_WEJSCIU_WYZWOLENIE	0x02
  16:wewy.h        **** #define STAN_LOGICZNY_NA_WEJSCIU_ON					0x01
  17:wewy.h        **** #define STAN_LOGICZNY_NA_WEJSCIU_OFF				0x00
  18:wewy.h        **** #define CZY_WYZWOLENIE_NA_WEJSCIU(NR_WEJ)	(stan_logiczny_na_wejsciu[NR_WEJ] & STAN_LOGICZNY_NA_WEJS
  19:wewy.h        **** #define CZY_AKTUALNY_STAN_LOGICZNY_ON(NR_WEJ)	(stan_logiczny_na_wejsciu[NR_WEJ] & STAN_LOGICZNY_NA_
  20:wewy.h        **** #define CZY_AKTUALNY_STAN_LOGICZNY_OFF(NR_WEJ)	(!CZY_AKTUALNY_STAN_LOGICZNY_ON(NR_WEJ))
  21:wewy.h        **** 
  22:wewy.h        **** extern uchar stan_logiczny_na_wejsciu[LICZBA_WEJSC];
  23:wewy.h        **** 
  24:wewy.h        **** void steruj_wejscia_10ms(void);
  25:wewy.h        **** void aktualizuj_stan_wyzwolenia_wejsc_100ms(void);
  26:wewy.h        **** void inicjalizuj_parametry_we_wy(void);
  27:wewy.h        **** 
  28:wewy.h        **** static uchar stan_wejscia(const uchar nr_wejscia) __attribute__((unused));
  29:wewy.h        **** 
  30:wewy.h        **** static uchar stan_wejscia(const uchar nr_wejscia)
  31:wewy.h        **** {
  32:wewy.h        **** 	return licznik_wejscie[nr_wejscia] & 0xf0;
 422               		.loc 5 32 0
 423 018a 8091 0000 		lds r24,licznik_wejscie
 424 018e 807F      		andi r24,lo8(-16)
 425               	.LBE374:
 426               	.LBE373:
  21:test_pcb.h    **** 	ustaw_stan_led(stan_wejscia(0));
 427               		.loc 4 21 0
 428 0190 01F4      		brne .L31
 429               		.loc 4 21 0 is_stmt 0 discriminator 1
 430 0192 409A      		sbi 0x8,0
 431 0194 0895      		ret
 432               	.L31:
 433               		.loc 4 21 0 discriminator 2
 434 0196 4098      		cbi 0x8,0
 435               	/* epilogue start */
  22:test_pcb.h    **** }
 436               		.loc 4 22 0 is_stmt 1 discriminator 2
 437 0198 0895      		ret
 438               		.cfi_endproc
 439               	.LFE25:
 441               	.global	__vector_16
 443               	__vector_16:
 444               	.LFB26:
  74:main.c        ****   if (++licznik_wybudz_watki_10MS >= OPOZNIENIE_TIMERA_0) {
 445               		.loc 1 74 0
 446               		.cfi_startproc
 447 019a 7894      		sei
 448 019c 1F92      		push r1
 449               	.LCFI6:
 450               		.cfi_def_cfa_offset 3
 451               		.cfi_offset 1, -2
 452 019e 0F92      		push r0
 453               	.LCFI7:
 454               		.cfi_def_cfa_offset 4
 455               		.cfi_offset 0, -3
 456 01a0 0FB6      		in r0,__SREG__
 457 01a2 0F92      		push r0
 458 01a4 1124      		clr __zero_reg__
 459 01a6 0BB6      		in r0,__RAMPZ__
 460 01a8 0F92      		push r0
 461 01aa 2F93      		push r18
 462               	.LCFI8:
 463               		.cfi_def_cfa_offset 5
 464               		.cfi_offset 18, -4
 465 01ac 8F93      		push r24
 466               	.LCFI9:
 467               		.cfi_def_cfa_offset 6
 468               		.cfi_offset 24, -5
 469 01ae 9F93      		push r25
 470               	.LCFI10:
 471               		.cfi_def_cfa_offset 7
 472               		.cfi_offset 25, -6
 473 01b0 EF93      		push r30
 474               	.LCFI11:
 475               		.cfi_def_cfa_offset 8
 476               		.cfi_offset 30, -7
 477 01b2 FF93      		push r31
 478               	.LCFI12:
 479               		.cfi_def_cfa_offset 9
 480               		.cfi_offset 31, -8
 481               	/* prologue: Interrupt */
 482               	/* frame size = 0 */
 483               	/* stack size = 9 */
 484               	.L__stack_usage = 9
  75:main.c        ****     licznik_wybudz_watki_10MS = 0;
 485               		.loc 1 75 0
 486 01b4 8091 0000 		lds r24,licznik_wybudz_watki_10MS
 487 01b8 8F5F      		subi r24,lo8(-(1))
 488 01ba 8093 0000 		sts licznik_wybudz_watki_10MS,r24
 489 01be 8231      		cpi r24,lo8(18)
 490 01c0 00F0      		brlo .L34
  76:main.c        ****     wykonac_watki_10MS = TRUE;
 491               		.loc 1 76 0
 492 01c2 1092 0000 		sts licznik_wybudz_watki_10MS,__zero_reg__
  77:main.c        ****   }
 493               		.loc 1 77 0
 494 01c6 8FEF      		ldi r24,lo8(-1)
 495 01c8 8093 0000 		sts wykonac_watki_10MS,r24
 496               	.L34:
  80:main.c        ****     if (!CZY_ODBIERANIE_DANYCH_SIM900() && czy_jest_bezczynny_SIM900()) {
 497               		.loc 1 80 0
 498 01cc 4F9B      		sbis 0x9,7
 499 01ce 00C0      		rjmp .L35
  81:main.c        ****       ustaw_odbior_SIM900();
 500               		.loc 1 81 0
 501 01d0 00B6      		in __tmp_reg__,0x30
 502 01d2 01FC      		sbrc __tmp_reg__,1
 503 01d4 00C0      		rjmp .L36
  81:main.c        ****       ustaw_odbior_SIM900();
 504               		.loc 1 81 0 is_stmt 0 discriminator 1
 505 01d6 8091 0000 		lds r24,komenda_SIM900
 506 01da 8111      		cpse r24,__zero_reg__
 507 01dc 00C0      		rjmp .L36
  82:main.c        ****     }
 508               		.loc 1 82 0 is_stmt 1
 509 01de 1092 0000 		sts liczba_odebranych_znakow_SIM900+1,__zero_reg__
 510 01e2 1092 0000 		sts liczba_odebranych_znakow_SIM900,__zero_reg__
 511 01e6 1092 0000 		sts licznik_opoznienie_oczekiwania_na_bajt_SIM900,__zero_reg__
 512 01ea 80B7      		in r24,0x30
 513 01ec 8260      		ori r24,lo8(2)
 514 01ee 80BF      		out 0x30,r24
 515               	/* #APP */
 516               	 ;  82 "main.c" 1
 517 01f0 F894      		cli
 518               	 ;  0 "" 2
 519               	/* #NOAPP */
 520 01f2 8091 C100 		lds r24,193
 521 01f6 8068      		ori r24,lo8(-128)
 522 01f8 8093 C100 		sts 193,r24
 523               	/* #APP */
 524               	 ;  82 "main.c" 1
 525 01fc 7894      		sei
 526               	 ;  0 "" 2
 527               	 ;  82 "main.c" 1
 528 01fe 0000      		nop
 529               	 ;  0 "" 2
 530               	/* #NOAPP */
 531 0200 4598      		cbi 0x8,5
 532               	.L36:
  84:main.c        ****       cli();
 533               		.loc 1 84 0
 534 0202 3499      		sbic 0x6,4
 535 0204 00C0      		rjmp .L37
  85:main.c        ****       if (CZY_WYSYLANIE_DANYCH_SIM900()) {
 536               		.loc 1 85 0
 537               	/* #APP */
 538               	 ;  85 "main.c" 1
 539 0206 F894      		cli
 540               	 ;  0 "" 2
  86:main.c        ****         WYLACZ_PRZERWANIE_WYSYLANIA_DANYCH_SIM900();
 541               		.loc 1 86 0
 542               	/* #NOAPP */
 543 0208 8091 C100 		lds r24,193
 544 020c 86FF      		sbrs r24,6
 545 020e 00C0      		rjmp .L38
 546               	.LBB375:
  87:main.c        ****         sei();
 547               		.loc 1 87 0
 548 0210 8091 C100 		lds r24,193
 549 0214 8F7B      		andi r24,lo8(-65)
 550 0216 8093 C100 		sts 193,r24
  88:main.c        ****         uchar p = sprawdzaj_wejscie_CTS_SIM900;
 551               		.loc 1 88 0
 552               	/* #APP */
 553               	 ;  88 "main.c" 1
 554 021a 7894      		sei
 555               	 ;  0 "" 2
  89:main.c        ****         if (p && (podlaczony_modul_gsm_SIM900 ||
 556               		.loc 1 89 0
 557               	/* #NOAPP */
 558 021c 8091 0000 		lds r24,sprawdzaj_wejscie_CTS_SIM900
 559               	.LVL25:
  90:main.c        ****                   aktualnie_wysylane_polecenie_SIM900 ==
 560               		.loc 1 90 0
 561 0220 8823      		tst r24
 562 0222 01F0      		breq .L39
  90:main.c        ****                   aktualnie_wysylane_polecenie_SIM900 ==
 563               		.loc 1 90 0 is_stmt 0 discriminator 1
 564 0224 8091 0000 		lds r24,podlaczony_modul_gsm_SIM900
 565               	.LVL26:
 566 0228 8111      		cpse r24,__zero_reg__
 567 022a 00C0      		rjmp .L40
  90:main.c        ****                   aktualnie_wysylane_polecenie_SIM900 ==
 568               		.loc 1 90 0 discriminator 2
 569 022c 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 570 0230 8B38      		cpi r24,lo8(-117)
 571 0232 01F4      		brne .L39
 572               	.L40:
 573               	.LVL27:
  94:main.c        ****           WSTAW_ZNAK_DO_BUFORA_SIM900();
 574               		.loc 1 94 0 is_stmt 1
 575 0234 1092 0000 		sts sprawdzaj_wejscie_CTS_SIM900,__zero_reg__
 576               	.LBB376:
  95:main.c        ****         }
 577               		.loc 1 95 0
 578 0238 8091 0000 		lds r24,nr_wyslanego_znaku_SIM900
 579 023c 9091 0000 		lds r25,nr_wyslanego_znaku_SIM900+1
 580               	.LVL28:
 581 0240 FC01      		movw r30,r24
 582 0242 E050      		subi r30,lo8(-(wysylany_blok_SIM900))
 583 0244 F040      		sbci r31,hi8(-(wysylany_blok_SIM900))
 584 0246 2081      		ld r18,Z
 585               	.LVL29:
 586 0248 0196      		adiw r24,1
 587               	.LVL30:
 588 024a 9093 0000 		sts nr_wyslanego_znaku_SIM900+1,r25
 589 024e 8093 0000 		sts nr_wyslanego_znaku_SIM900,r24
 590 0252 2093 C600 		sts 198,r18
 591               	.LVL31:
 592               	.L39:
 593               	.LBE376:
  97:main.c        ****         WLACZ_PRZERWANIE_WYSYLANIA_DANYCH_SIM900();
 594               		.loc 1 97 0
 595               	/* #APP */
 596               	 ;  97 "main.c" 1
 597 0256 F894      		cli
 598               	 ;  0 "" 2
  98:main.c        ****       }
 599               		.loc 1 98 0
 600               	/* #NOAPP */
 601 0258 8091 C100 		lds r24,193
 602 025c 8064      		ori r24,lo8(64)
 603 025e 8093 C100 		sts 193,r24
 604               	.L38:
 605               	.LBE375:
 100:main.c        ****     }
 606               		.loc 1 100 0
 607               	/* #APP */
 608               	 ;  100 "main.c" 1
 609 0262 7894      		sei
 610               	 ;  0 "" 2
 611               	/* #NOAPP */
 612               	.L37:
 106:main.c        ****       TRUE; // uruchamia zdarzenie_timer, ktra korzysta z pozostaych zmiennych
 613               		.loc 1 106 0
 614 0264 8FEF      		ldi r24,lo8(-1)
 615 0266 8093 0000 		sts wykonaj_zdarzenie_timer,r24
 616               	/* epilogue start */
 108:main.c        **** 
 617               		.loc 1 108 0
 618 026a FF91      		pop r31
 619 026c EF91      		pop r30
 620 026e 9F91      		pop r25
 621 0270 8F91      		pop r24
 622 0272 2F91      		pop r18
 623 0274 0F90      		pop r0
 624 0276 0BBE      		out __RAMPZ__,r0
 625 0278 0F90      		pop r0
 626 027a 0FBE      		out __SREG__,r0
 627 027c 0F90      		pop r0
 628 027e 1F90      		pop r1
 629 0280 1895      		reti
 630               	.L35:
 103:main.c        ****   }
 631               		.loc 1 103 0
 632 0282 459A      		sbi 0x8,5
 633               	/* #APP */
 634               	 ;  103 "main.c" 1
 635 0284 F894      		cli
 636               	 ;  0 "" 2
 637               	/* #NOAPP */
 638 0286 8091 C100 		lds r24,193
 639 028a 8F73      		andi r24,lo8(63)
 640 028c 8093 C100 		sts 193,r24
 641 0290 80B7      		in r24,0x30
 642 0292 8D7F      		andi r24,lo8(-3)
 643 0294 80BF      		out 0x30,r24
 644               	/* #APP */
 645               	 ;  103 "main.c" 1
 646 0296 7894      		sei
 647               	 ;  0 "" 2
 648               	 ;  103 "main.c" 1
 649 0298 0000      		nop
 650               	 ;  0 "" 2
 651               	/* #NOAPP */
 652 029a 00C0      		rjmp .L37
 653               		.cfi_endproc
 654               	.LFE26:
 656               	.global	generuj_raport_sieci
 658               	generuj_raport_sieci:
 659               	.LFB27:
 121:main.c        ****   static const char tekst_gsm[] PROGMEM = "AC800-TS";
 660               		.loc 1 121 0
 661               		.cfi_startproc
 662               	.LVL32:
 663 029c DF92      		push r13
 664               	.LCFI13:
 665               		.cfi_def_cfa_offset 3
 666               		.cfi_offset 13, -2
 667 029e EF92      		push r14
 668               	.LCFI14:
 669               		.cfi_def_cfa_offset 4
 670               		.cfi_offset 14, -3
 671 02a0 FF92      		push r15
 672               	.LCFI15:
 673               		.cfi_def_cfa_offset 5
 674               		.cfi_offset 15, -4
 675 02a2 0F93      		push r16
 676               	.LCFI16:
 677               		.cfi_def_cfa_offset 6
 678               		.cfi_offset 16, -5
 679 02a4 1F93      		push r17
 680               	.LCFI17:
 681               		.cfi_def_cfa_offset 7
 682               		.cfi_offset 17, -6
 683 02a6 CF93      		push r28
 684               	.LCFI18:
 685               		.cfi_def_cfa_offset 8
 686               		.cfi_offset 28, -7
 687 02a8 DF93      		push r29
 688               	.LCFI19:
 689               		.cfi_def_cfa_offset 9
 690               		.cfi_offset 29, -8
 691               	/* prologue: function */
 692               	/* frame size = 0 */
 693               	/* stack size = 7 */
 694               	.L__stack_usage = 7
 695 02aa 8C01      		movw r16,r24
 123:main.c        **** 
 696               		.loc 1 123 0
 697 02ac DC01      		movw r26,r24
 698 02ae ED90      		ld r14,X+
 699 02b0 FC90      		ld r15,X
 700               	.LVL33:
 125:main.c        ****   ptr += sizeof tekst_gsm - 1;
 701               		.loc 1 125 0
 702 02b2 48E0      		ldi r20,lo8(8)
 703 02b4 50E0      		ldi r21,0
 704 02b6 60E0      		ldi r22,lo8(tekst_gsm.3001)
 705 02b8 70E0      		ldi r23,hi8(tekst_gsm.3001)
 706 02ba C701      		movw r24,r14
 707               	.LVL34:
 708 02bc 0E94 0000 		call memcpy_P
 709               	.LVL35:
 127:main.c        **** 
 710               		.loc 1 127 0
 711 02c0 E701      		movw r28,r14
 712 02c2 2996      		adiw r28,9
 713               	.LVL36:
 714 02c4 8AE0      		ldi r24,lo8(10)
 715 02c6 D82E      		mov r13,r24
 716 02c8 F701      		movw r30,r14
 717 02ca D086      		std Z+8,r13
 129:main.c        ****   ptr += strlen((char *)ptr);
 718               		.loc 1 129 0
 719 02cc 60E0      		ldi r22,lo8(__c.3003)
 720 02ce 70E0      		ldi r23,hi8(__c.3003)
 721 02d0 CE01      		movw r24,r28
 722 02d2 0E94 0000 		call strcpy_P
 723               	.LVL37:
 130:main.c        ****   strcat((char *)ptr, rtc_czas);
 724               		.loc 1 130 0
 725               		0:
 726 02d6 0990      		ld __tmp_reg__,Y+
 727 02d8 0020      		tst __tmp_reg__
 728 02da 01F4      		brne 0b
 729               	.LVL38:
 730 02dc 2197      		sbiw r28,1
 731               	.LVL39:
 131:main.c        ****   ptr += strlen((char *)ptr);
 732               		.loc 1 131 0
 733 02de 60E0      		ldi r22,lo8(rtc_czas)
 734 02e0 70E0      		ldi r23,hi8(rtc_czas)
 735 02e2 CE01      		movw r24,r28
 736 02e4 0E94 0000 		call strcat
 737               	.LVL40:
 132:main.c        ****   *ptr++ = '\n';
 738               		.loc 1 132 0
 739               		0:
 740 02e8 0990      		ld __tmp_reg__,Y+
 741 02ea 0020      		tst __tmp_reg__
 742 02ec 01F4      		brne 0b
 743               	.LVL41:
 744 02ee 2197      		sbiw r28,1
 745               	.LVL42:
 133:main.c        **** 
 746               		.loc 1 133 0
 747 02f0 DE01      		movw r26,r28
 748 02f2 DD92      		st X+,r13
 749               	.LVL43:
 750 02f4 CD01      		movw r24,r26
 136:main.c        ****   ptr += sizeof text_sygnal - 1;
 751               		.loc 1 136 0
 752 02f6 4BE0      		ldi r20,lo8(11)
 753 02f8 50E0      		ldi r21,0
 754 02fa 60E0      		ldi r22,lo8(text_sygnal.3005)
 755 02fc 70E0      		ldi r23,hi8(text_sygnal.3005)
 756 02fe 0E94 0000 		call memcpy_P
 757               	.LVL44:
 139:main.c        ****     utoa(poziom_sieci_gsm * 100 / 31, ptr, 10);
 758               		.loc 1 139 0
 759 0302 8091 0000 		lds r24,poziom_sieci_gsm
 760 0306 8032      		cpi r24,lo8(32)
 761 0308 00F4      		brsh .L48
 139:main.c        ****     utoa(poziom_sieci_gsm * 100 / 31, ptr, 10);
 762               		.loc 1 139 0 is_stmt 0 discriminator 1
 763 030a 9091 0000 		lds r25,modul_zalogowany_w_sieci
 764 030e 9923      		tst r25
 765 0310 01F0      		breq .L48
 137:main.c        **** 
 766               		.loc 1 137 0 is_stmt 1
 767 0312 2C96      		adiw r28,12
 768               	.LVL45:
 140:main.c        ****     ptr += strlen(ptr);
 769               		.loc 1 140 0
 770 0314 B4E6      		ldi r27,lo8(100)
 771 0316 8B9F      		mul r24,r27
 772 0318 C001      		movw r24,r0
 773 031a 1124      		clr __zero_reg__
 774               	.LVL46:
 775 031c 6FE1      		ldi r22,lo8(31)
 776 031e 70E0      		ldi r23,0
 777 0320 0E94 0000 		call __divmodhi4
 778 0324 CB01      		movw r24,r22
 779               	.LBB377:
 780               	.LBB378:
 781               		.file 6 "/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h"
   1:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Copyright (c) 2004,2007 Joerg Wunsch
   3:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
   4:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Portions of documentation Copyright (c) 1990, 1991, 1993, 1994
   5:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The Regents of the University of California.
   6:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
   7:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    All rights reserved.
   8:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
   9:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Redistribution and use in source and binary forms, with or without
  10:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    modification, are permitted provided that the following conditions are met:
  11:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  12:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    * Redistributions of source code must retain the above copyright
  13:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer.
  14:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  15:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    * Redistributions in binary form must reproduce the above copyright
  16:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer in
  17:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      the documentation and/or other materials provided with the
  18:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      distribution.
  19:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  20:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    * Neither the name of the copyright holders nor the names of
  21:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      contributors may be used to endorse or promote products derived
  22:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      from this software without specific prior written permission.
  23:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  24:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  28:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  34:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   POSSIBILITY OF SUCH DAMAGE.
  35:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  36:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   $Id$
  37:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
  38:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  39:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef _STDLIB_H_
  40:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define	_STDLIB_H_ 1
  41:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  42:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ASSEMBLER__
  43:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  44:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __DOXYGEN__
  45:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define __need_NULL
  46:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define __need_size_t
  47:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define __need_wchar_t
  48:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #include <stddef.h>
  49:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  50:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ptr_t
  51:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define __ptr_t void *
  52:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  53:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif	/* !__DOXYGEN__ */
  54:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  55:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifdef __cplusplus
  56:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern "C" {
  57:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  58:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  59:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** \file */
  60:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  61:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** \defgroup avr_stdlib <stdlib.h>: General utilities
  62:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \code #include <stdlib.h> \endcode
  63:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  64:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     This file declares some basic C macros and functions as
  65:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     defined by the ISO standard, plus some AVR-specific extensions.
  66:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
  67:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  68:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /*@{*/
  69:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** Result type for function div(). */
  70:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** typedef struct {
  71:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	int quot;                   /**< The Quotient. */
  72:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	int rem;                    /**< The Remainder. */
  73:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** } div_t;
  74:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  75:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** Result type for function ldiv(). */
  76:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** typedef struct {
  77:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	long quot;                  /**< The Quotient. */
  78:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	long rem;                   /**< The Remainder. */
  79:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** } ldiv_t;
  80:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  81:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** Comparision function type for qsort(), just for convenience. */
  82:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** typedef int (*__compar_fn_t)(const void *, const void *);
  83:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  84:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __DOXYGEN__
  85:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  86:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ATTR_CONST__
  87:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # define __ATTR_CONST__ __attribute__((__const__))
  88:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  89:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  90:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ATTR_MALLOC__
  91:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # define __ATTR_MALLOC__ __attribute__((__malloc__))
  92:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  93:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  94:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ATTR_NORETURN__
  95:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # define __ATTR_NORETURN__ __attribute__((__noreturn__))
  96:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  97:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  98:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ATTR_PURE__
  99:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # define __ATTR_PURE__ __attribute__((__pure__))
 100:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 101:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 102:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef	__ATTR_GNU_INLINE__
 103:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # ifdef  __GNUC_STDC_INLINE__
 104:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__   __attribute__((__gnu_inline__))
 105:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # else
 106:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__
 107:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # endif
 108:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 109:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 110:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 111:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 112:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** The abort() function causes abnormal program termination to occur.
 113:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     This realization disables interrupts and jumps to _exit() function
 114:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     with argument equal to 1. In the limited AVR environment, execution is
 115:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     effectively halted by entering an infinite loop. */
 116:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void abort(void) __ATTR_NORETURN__;
 117:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 118:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** The abs() function computes the absolute value of the integer \c i.
 119:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 120:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 121:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern int abs(int __i) __ATTR_CONST__;
 122:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 123:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define	abs(__i) __builtin_abs(__i)
 124:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 125:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 126:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** The labs() function computes the absolute value of the long integer
 127:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c i.
 128:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 129:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 130:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern long labs(long __i) __ATTR_CONST__;
 131:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 132:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define labs(__i) __builtin_labs(__i)
 133:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 134:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 135:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 136:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The bsearch() function searches an array of \c nmemb objects, the
 137:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      initial member of which is pointed to by \c base, for a member
 138:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      that matches the object pointed to by \c key.  The size of each
 139:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      member of the array is specified by \c size.
 140:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 141:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The contents of the array should be in ascending sorted order
 142:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      according to the comparison function referenced by \c compar.
 143:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The \c compar routine is expected to have two arguments which
 144:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      point to the key object and to an array member, in that order,
 145:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      and should return an integer less than, equal to, or greater than
 146:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      zero if the key object is found, respectively, to be less than,
 147:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      to match, or be greater than the array member.
 148:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 149:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The bsearch() function returns a pointer to a matching member of
 150:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      the array, or a null pointer if no match is found.  If two
 151:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      members compare as equal, which member is matched is unspecified.
 152:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 153:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void *bsearch(const void *__key, const void *__base, size_t __nmemb,
 154:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 		     size_t __size, int (*__compar)(const void *, const void *));
 155:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 156:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /* __divmodhi4 and __divmodsi4 from libgcc.a */
 157:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 158:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The div() function computes the value \c num/denom and returns
 159:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c div_t that
 160:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      contains two int members named \c quot and \c rem.
 161:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 162:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern div_t div(int __num, int __denom) __asm__("__divmodhi4") __ATTR_CONST__;
 163:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 164:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The ldiv() function computes the value \c num/denom and returns
 165:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c ldiv_t that
 166:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      contains two long integer members named \c quot and \c rem.
 167:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 168:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern ldiv_t ldiv(long __num, long __denom) __asm__("__divmodsi4") __ATTR_CONST__;
 169:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 170:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 171:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The qsort() function is a modified partition-exchange sort, or
 172:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      quicksort.
 173:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 174:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The qsort() function sorts an array of \c nmemb objects, the
 175:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      initial member of which is pointed to by \c base.  The size of
 176:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      each object is specified by \c size.  The contents of the array
 177:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      base are sorted in ascending order according to a comparison
 178:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      function pointed to by \c compar, which requires two arguments
 179:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      pointing to the objects being compared.
 180:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 181:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The comparison function must return an integer less than, equal
 182:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      to, or greater than zero if the first argument is considered to
 183:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      be respectively less than, equal to, or greater than the second.
 184:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 185:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void qsort(void *__base, size_t __nmemb, size_t __size,
 186:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 		  __compar_fn_t __compar);
 187:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 188:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 189:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The strtol() function converts the string in \c nptr to a long
 190:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     value.  The conversion is done according to the given base, which
 191:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     must be between 2 and 36 inclusive, or be the special value 0.
 192:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 193:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 194:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 195:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 196:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 197:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 198:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 199:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 200:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The remainder of the string is converted to a long value in the
 201:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     obvious manner, stopping at the first character which is not a
 202:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     valid digit in the given base.  (In bases above 10, the letter \c 'A'
 203:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     in either upper or lower case represents 10, \c 'B' represents 11,
 204:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     and so forth, with \c 'Z' representing 35.)
 205:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 206:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     If \c endptr is not NULL, strtol() stores the address of the first
 207:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 208:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     however, strtol() stores the original value of \c nptr in \c
 209:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 210:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     on return, the entire string was valid.)
 211:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 212:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The strtol() function returns the result of the conversion, unless
 213:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     the value would underflow or overflow.  If no conversion could be
 214:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     performed, 0 is returned.  If an overflow or underflow occurs, \c
 215:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE" and the function return value
 216:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     is clamped to \c LONG_MIN or \c LONG_MAX, respectively.
 217:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 218:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern long strtol(const char *__nptr, char **__endptr, int __base);
 219:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 220:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 221:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The strtoul() function converts the string in \c nptr to an
 222:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     unsigned long value.  The conversion is done according to the
 223:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     given base, which must be between 2 and 36 inclusive, or be the
 224:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     special value 0.
 225:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 226:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 227:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 228:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 229:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 230:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 231:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 232:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 233:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The remainder of the string is converted to an unsigned long value
 234:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     in the obvious manner, stopping at the first character which is
 235:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     not a valid digit in the given base.  (In bases above 10, the
 236:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     letter \c 'A' in either upper or lower case represents 10, \c 'B'
 237:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     represents 11, and so forth, with \c 'Z' representing 35.)
 238:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 239:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     If \c endptr is not NULL, strtoul() stores the address of the first
 240:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 241:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     however, strtoul() stores the original value of \c nptr in \c
 242:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 243:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     on return, the entire string was valid.)
 244:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 245:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The strtoul() function return either the result of the conversion
 246:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     or, if there was a leading minus sign, the negation of the result
 247:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     of the conversion, unless the original (non-negated) value would
 248:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     overflow; in the latter case, strtoul() returns ULONG_MAX, and \c
 249:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE".  If no conversion could 
 250:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     be performed, 0 is returned.
 251:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 252:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern unsigned long strtoul(const char *__nptr, char **__endptr, int __base);
 253:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 254:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 255:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The atol() function converts the initial portion of the string
 256:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     pointed to by \p s to long integer representation. In contrast to
 257:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 258:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****         \code strtol(s, (char **)NULL, 10); \endcode
 259:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 260:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 261:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 262:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     stack) and works more quickly.
 263:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 264:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern long atol(const char *__s) __ATTR_PURE__;
 265:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 266:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 267:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The atoi() function converts the initial portion of the string
 268:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     pointed to by \p s to integer representation. In contrast to
 269:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 270:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****         \code (int)strtol(s, (char **)NULL, 10); \endcode
 271:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 272:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 273:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 274:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     stack) and works more quickly.
 275:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 276:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern int atoi(const char *__s) __ATTR_PURE__;
 277:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 278:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 279:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The exit() function terminates the application.  Since there is no
 280:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    environment to return to, \c status is ignored, and code execution
 281:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    will eventually reach an infinite loop, thereby effectively halting
 282:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    all code processing.  Before entering the infinite loop, interrupts
 283:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    are globally disabled.
 284:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 285:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    In a C++ context, global destructors will be called before halting
 286:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    execution.
 287:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 288:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void exit(int __status) __ATTR_NORETURN__;
 289:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 290:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 291:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The malloc() function allocates \c size bytes of memory.
 292:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    If malloc() fails, a NULL pointer is returned.
 293:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 294:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Note that malloc() does \e not initialize the returned memory to
 295:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    zero bytes.
 296:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 297:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    See the chapter about \ref malloc "malloc() usage" for implementation
 298:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    details.
 299:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 300:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void *malloc(size_t __size) __ATTR_MALLOC__;
 301:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 302:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 303:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The free() function causes the allocated memory referenced by \c
 304:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    ptr to be made available for future allocations.  If \c ptr is
 305:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    NULL, no action occurs.
 306:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 307:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void free(void *__ptr);
 308:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 309:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 310:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 311:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 312:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern size_t __malloc_margin;
 313:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 314:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 315:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 316:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 317:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *__malloc_heap_start;
 318:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 319:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 320:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 321:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 322:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *__malloc_heap_end;
 323:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 324:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 325:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Allocate \c nele elements of \c size each.  Identical to calling
 326:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c malloc() using <tt>nele * size</tt> as argument, except the
 327:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    allocated memory will be cleared to zero.
 328:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 329:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void *calloc(size_t __nele, size_t __size) __ATTR_MALLOC__;
 330:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 331:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 332:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The realloc() function tries to change the size of the region
 333:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    allocated at \c ptr to the new \c size value.  It returns a
 334:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    pointer to the new region.  The returned pointer might be the
 335:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    same as the old pointer, or a pointer to a completely different
 336:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    region.
 337:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 338:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The contents of the returned region up to either the old or the new
 339:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    size value (whatever is less) will be identical to the contents of
 340:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    the old region, even in case a new region had to be allocated.
 341:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 342:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    It is acceptable to pass \c ptr as NULL, in which case realloc()
 343:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    will behave identical to malloc().
 344:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 345:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    If the new memory cannot be allocated, realloc() returns NULL, and
 346:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    the region at \c ptr will not be changed.
 347:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 348:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void *realloc(void *__ptr, size_t __size) __ATTR_MALLOC__;
 349:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 350:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern double strtod(const char *__nptr, char **__endptr);
 351:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 352:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** \ingroup avr_stdlib
 353:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \fn  double atof (const char *nptr)
 354:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 355:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The atof() function converts the initial portion of the string pointed
 356:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     to by \a nptr to double representation.
 357:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 358:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     It is equivalent to calling
 359:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	\code strtod(nptr, (char **)0); \endcode
 360:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  */
 361:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern double atof(const char *__nptr);
 362:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 363:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** Highest number that can be generated by rand(). */
 364:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define	RAND_MAX 0x7FFF
 365:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 366:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 367:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The rand() function computes a sequence of pseudo-random integers in the
 368:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      range of 0 to \c RAND_MAX (as defined by the header file <stdlib.h>).
 369:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 370:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The srand() function sets its argument \c seed as the seed for a new
 371:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      sequence of pseudo-random numbers to be returned by rand().  These
 372:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      sequences are repeatable by calling srand() with the same seed value.
 373:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 374:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      If no seed value is provided, the functions are automatically seeded with
 375:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      a value of 1.
 376:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 377:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      In compliance with the C standard, these functions operate on
 378:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      \c int arguments.  Since the underlying algorithm already uses
 379:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      32-bit calculations, this causes a loss of precision.  See
 380:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      \c random() for an alternate set of functions that retains full
 381:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      32-bit precision.
 382:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 383:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern int rand(void);
 384:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 385:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Pseudo-random number generator seeding; see rand().
 386:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 387:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void srand(unsigned int __seed);
 388:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 389:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 390:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Variant of rand() that stores the context in the user-supplied
 391:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    variable located at \c ctx instead of a static library variable
 392:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    so the function becomes re-entrant.
 393:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 394:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern int rand_r(unsigned long *__ctx);
 395:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /*@}*/
 396:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 397:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /*@{*/
 398:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** \name Non-standard (i.e. non-ISO C) functions.
 399:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  \ingroup avr_stdlib
 400:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 401:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 402:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \brief Convert an integer to a string.
 403:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 404:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The function itoa() converts the integer value from \c val into an
 405:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 406:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 407:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 408:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 409:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 410:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (int) + 1 characters, i.e. one
 411:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 412:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 413:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 414:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 415:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 416:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 417:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 418:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 419:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c 'a'.
 420:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     
 421:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     If radix is 10 and val is negative, a minus sign will be prepended.
 422:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 423:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The itoa() function returns the pointer passed as \c s.
 424:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 425:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 426:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *itoa(int val, char *s, int radix);
 427:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #else
 428:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 429:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** char *itoa (int __val, char *__s, int __radix)
 430:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** {
 431:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 432:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__itoa (int, char *, int);
 433:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __itoa (__val, __s, __radix);
 434:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 435:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	*__s = 0;
 436:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __s;
 437:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else {
 438:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__itoa_ncheck (int, char *, unsigned char);
 439:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __itoa_ncheck (__val, __s, __radix);
 440:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     }
 441:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** }
 442:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 443:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 444:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 445:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  \ingroup avr_stdlib
 446:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  
 447:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \brief Convert a long integer to a string.
 448:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 449:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The function ltoa() converts the long integer value from \c val into an
 450:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 451:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 452:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 453:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 454:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 455:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (long int) + 1 characters, i.e. one
 456:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 457:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 458:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 459:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 460:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 461:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 462:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 463:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 464:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c 'a'.
 465:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 466:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    If radix is 10 and val is negative, a minus sign will be prepended.
 467:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 468:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The ltoa() function returns the pointer passed as \c s.
 469:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 470:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 471:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *ltoa(long val, char *s, int radix);
 472:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #else
 473:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 474:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** char *ltoa (long __val, char *__s, int __radix)
 475:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** {
 476:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 477:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__ltoa (long, char *, int);
 478:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __ltoa (__val, __s, __radix);
 479:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 480:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	*__s = 0;
 481:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __s;
 482:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else {
 483:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__ltoa_ncheck (long, char *, unsigned char);
 484:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __ltoa_ncheck (__val, __s, __radix);
 485:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     }
 486:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** }
 487:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 488:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 489:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 490:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  \ingroup avr_stdlib
 491:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 492:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \brief Convert an unsigned integer to a string.
 493:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 494:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The function utoa() converts the unsigned integer value from \c val into an
 495:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 496:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 497:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 498:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 499:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 500:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (unsigned int) + 1 characters, i.e. one
 501:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 502:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 503:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 504:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 505:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 506:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 507:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 508:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 509:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c 'a'.
 510:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 511:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The utoa() function returns the pointer passed as \c s.
 512:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 513:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 514:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *utoa(unsigned int val, char *s, int radix);
 515:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #else
 516:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 517:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** char *utoa (unsigned int __val, char *__s, int __radix)
 518:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** {
 519:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 520:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__utoa (unsigned int, char *, int);
 521:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __utoa (__val, __s, __radix);
 522:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 523:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	*__s = 0;
 524:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __s;
 525:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else {
 526:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__utoa_ncheck (unsigned int, char *, unsigned char);
 527:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __utoa_ncheck (__val, __s, __radix);
 782               		.loc 6 527 0
 783 0326 4AE0      		ldi r20,lo8(10)
 784 0328 BE01      		movw r22,r28
 785 032a 0E94 0000 		call __utoa_ncheck
 786               	.LVL47:
 787               	.LBE378:
 788               	.LBE377:
 141:main.c        ****     *ptr++ = '%';
 789               		.loc 1 141 0
 790               		0:
 791 032e 0990      		ld __tmp_reg__,Y+
 792 0330 0020      		tst __tmp_reg__
 793 0332 01F4      		brne 0b
 794               	.LVL48:
 795 0334 2197      		sbiw r28,1
 796               	.LVL49:
 142:main.c        ****   } else {
 797               		.loc 1 142 0
 798 0336 FE01      		movw r30,r28
 799 0338 3196      		adiw r30,1
 800               	.LVL50:
 801 033a 85E2      		ldi r24,lo8(37)
 802 033c 8883      		st Y,r24
 803               	.L49:
 148:main.c        ****   *buf_sms = ptr;
 804               		.loc 1 148 0
 805 033e 1082      		st Z,__zero_reg__
 149:main.c        **** }
 806               		.loc 1 149 0
 807 0340 D801      		movw r26,r16
 808 0342 ED93      		st X+,r30
 809 0344 FC93      		st X,r31
 810               	/* epilogue start */
 150:main.c        **** 
 811               		.loc 1 150 0
 812 0346 DF91      		pop r29
 813 0348 CF91      		pop r28
 814 034a 1F91      		pop r17
 815 034c 0F91      		pop r16
 816               	.LVL51:
 817 034e FF90      		pop r15
 818 0350 EF90      		pop r14
 819 0352 DF90      		pop r13
 820 0354 0895      		ret
 821               	.LVL52:
 822               	.L48:
 144:main.c        ****     *ptr++ = '-';
 823               		.loc 1 144 0
 824 0356 8DE2      		ldi r24,lo8(45)
 825 0358 8C87      		std Y+12,r24
 826               	.LVL53:
 145:main.c        ****     *ptr++ = '-';
 827               		.loc 1 145 0
 828 035a 8D87      		std Y+13,r24
 146:main.c        ****   }
 829               		.loc 1 146 0
 830 035c FE01      		movw r30,r28
 831 035e 3F96      		adiw r30,15
 832               	.LVL54:
 833 0360 8E87      		std Y+14,r24
 834 0362 00C0      		rjmp .L49
 835               		.cfi_endproc
 836               	.LFE27:
 838               	.global	generuj_raport_uzytkownikow_1
 840               	generuj_raport_uzytkownikow_1:
 841               	.LFB28:
 152:main.c        ****   static const char tekst_gsm[] PROGMEM = "Uzytkownicy ";
 842               		.loc 1 152 0
 843               		.cfi_startproc
 844               	.LVL55:
 845 0364 AF92      		push r10
 846               	.LCFI20:
 847               		.cfi_def_cfa_offset 3
 848               		.cfi_offset 10, -2
 849 0366 BF92      		push r11
 850               	.LCFI21:
 851               		.cfi_def_cfa_offset 4
 852               		.cfi_offset 11, -3
 853 0368 CF92      		push r12
 854               	.LCFI22:
 855               		.cfi_def_cfa_offset 5
 856               		.cfi_offset 12, -4
 857 036a DF92      		push r13
 858               	.LCFI23:
 859               		.cfi_def_cfa_offset 6
 860               		.cfi_offset 13, -5
 861 036c EF92      		push r14
 862               	.LCFI24:
 863               		.cfi_def_cfa_offset 7
 864               		.cfi_offset 14, -6
 865 036e FF92      		push r15
 866               	.LCFI25:
 867               		.cfi_def_cfa_offset 8
 868               		.cfi_offset 15, -7
 869 0370 0F93      		push r16
 870               	.LCFI26:
 871               		.cfi_def_cfa_offset 9
 872               		.cfi_offset 16, -8
 873 0372 1F93      		push r17
 874               	.LCFI27:
 875               		.cfi_def_cfa_offset 10
 876               		.cfi_offset 17, -9
 877 0374 CF93      		push r28
 878               	.LCFI28:
 879               		.cfi_def_cfa_offset 11
 880               		.cfi_offset 28, -10
 881 0376 DF93      		push r29
 882               	.LCFI29:
 883               		.cfi_def_cfa_offset 12
 884               		.cfi_offset 29, -11
 885               	/* prologue: function */
 886               	/* frame size = 0 */
 887               	/* stack size = 10 */
 888               	.L__stack_usage = 10
 889 0378 8C01      		movw r16,r24
 154:main.c        **** 
 890               		.loc 1 154 0
 891 037a FC01      		movw r30,r24
 892 037c C081      		ld r28,Z
 893 037e D181      		ldd r29,Z+1
 894               	.LVL56:
 156:main.c        ****   ptr += sizeof tekst_gsm - 1;
 895               		.loc 1 156 0
 896 0380 4CE0      		ldi r20,lo8(12)
 897 0382 50E0      		ldi r21,0
 898 0384 60E0      		ldi r22,lo8(tekst_gsm.3009)
 899 0386 70E0      		ldi r23,hi8(tekst_gsm.3009)
 900 0388 CE01      		movw r24,r28
 901               	.LVL57:
 902 038a 0E94 0000 		call memcpy_P
 903               	.LVL58:
 157:main.c        ****   uint aktywne_numery = 0;
 904               		.loc 1 157 0
 905 038e 2C96      		adiw r28,12
 906               	.LVL59:
 907 0390 88E0      		ldi r24,lo8(8)
 908 0392 C82E      		mov r12,r24
 909 0394 D12C      		mov r13,__zero_reg__
 159:main.c        ****   // for (uchar nr_uzyt_clip = 0; nr_uzyt_clip <
 910               		.loc 1 159 0
 911 0396 F12C      		mov r15,__zero_reg__
 912 0398 E12C      		mov r14,__zero_reg__
 158:main.c        ****   uint wolne_numery = 0;
 913               		.loc 1 158 0
 914 039a B12C      		mov r11,__zero_reg__
 915 039c A12C      		mov r10,__zero_reg__
 916               	.LVL60:
 917               	.L56:
 918               	.LBB379:
 164:main.c        ****       ++aktywne_numery;
 919               		.loc 1 164 0
 920 039e C601      		movw r24,r12
 921 03a0 0E94 0000 		call eeprom_read_byte
 922               	.LVL61:
 923 03a4 8F3F      		cpi r24,lo8(-1)
 924 03a6 01F0      		breq .L54
 165:main.c        ****     else
 925               		.loc 1 165 0
 926 03a8 FFEF      		ldi r31,-1
 927 03aa AF1A      		sub r10,r31
 928 03ac BF0A      		sbc r11,r31
 929               	.LVL62:
 930               	.L55:
 931 03ae E5E0      		ldi r30,5
 932 03b0 CE0E      		add r12,r30
 933 03b2 D11C      		adc r13,__zero_reg__
 162:main.c        ****        ++nr_uzyt_clip) {
 934               		.loc 1 162 0
 935 03b4 F8EA      		ldi r31,-88
 936 03b6 CF16      		cp r12,r31
 937 03b8 FFE0      		ldi r31,15
 938 03ba DF06      		cpc r13,r31
 939 03bc 01F4      		brne .L56
 940               	.LVL63:
 941               	.LBE379:
 942               	.LBB380:
 943               	.LBB381:
 944               		.loc 6 527 0
 945 03be 4AE0      		ldi r20,lo8(10)
 946 03c0 BE01      		movw r22,r28
 947 03c2 C501      		movw r24,r10
 948 03c4 0E94 0000 		call __utoa_ncheck
 949               	.LVL64:
 950               	.LBE381:
 951               	.LBE380:
 171:main.c        ****   *ptr++ = '/';
 952               		.loc 1 171 0
 953               		0:
 954 03c8 0990      		ld __tmp_reg__,Y+
 955 03ca 0020      		tst __tmp_reg__
 956 03cc 01F4      		brne 0b
 957               	.LVL65:
 958 03ce 2197      		sbiw r28,1
 959               	.LVL66:
 172:main.c        ****   utoa(wolne_numery, ptr, 10);
 960               		.loc 1 172 0
 961 03d0 6E01      		movw r12,r28
 962 03d2 8FEF      		ldi r24,-1
 963 03d4 C81A      		sub r12,r24
 964 03d6 D80A      		sbc r13,r24
 965               	.LVL67:
 966 03d8 8FE2      		ldi r24,lo8(47)
 967 03da 8883      		st Y,r24
 968               	.LVL68:
 969               	.LBB382:
 970               	.LBB383:
 971               		.loc 6 527 0
 972 03dc 4AE0      		ldi r20,lo8(10)
 973 03de B601      		movw r22,r12
 974 03e0 C701      		movw r24,r14
 975 03e2 0E94 0000 		call __utoa_ncheck
 976               	.LVL69:
 977               	.LBE383:
 978               	.LBE382:
 174:main.c        ****   *buf_sms = ptr;
 979               		.loc 1 174 0
 980 03e6 F601      		movw r30,r12
 981               		0:
 982 03e8 0190      		ld __tmp_reg__,Z+
 983 03ea 0020      		tst __tmp_reg__
 984 03ec 01F4      		brne 0b
 985 03ee CF01      		movw r24,r30
 986               	.LVL70:
 987 03f0 0197      		sbiw r24,1
 988               	.LVL71:
 175:main.c        **** }
 989               		.loc 1 175 0
 990 03f2 F801      		movw r30,r16
 991               	.LVL72:
 992 03f4 9183      		std Z+1,r25
 993 03f6 8083      		st Z,r24
 994               	/* epilogue start */
 176:main.c        **** 
 995               		.loc 1 176 0
 996 03f8 DF91      		pop r29
 997 03fa CF91      		pop r28
 998 03fc 1F91      		pop r17
 999 03fe 0F91      		pop r16
 1000               	.LVL73:
 1001 0400 FF90      		pop r15
 1002 0402 EF90      		pop r14
 1003               	.LVL74:
 1004 0404 DF90      		pop r13
 1005 0406 CF90      		pop r12
 1006               	.LVL75:
 1007 0408 BF90      		pop r11
 1008 040a AF90      		pop r10
 1009               	.LVL76:
 1010 040c 0895      		ret
 1011               	.LVL77:
 1012               	.L54:
 1013               	.LBB384:
 167:main.c        ****   }
 1014               		.loc 1 167 0
 1015 040e 8FEF      		ldi r24,-1
 1016 0410 E81A      		sub r14,r24
 1017 0412 F80A      		sbc r15,r24
 1018               	.LVL78:
 1019 0414 00C0      		rjmp .L55
 1020               	.LBE384:
 1021               		.cfi_endproc
 1022               	.LFE28:
 1024               	.global	generuj_raport_uzytkownikow
 1026               	generuj_raport_uzytkownikow:
 1027               	.LFB29:
 178:main.c        ****   static const char tekst_gsm[] PROGMEM = "Uzytkownicy ";
 1028               		.loc 1 178 0
 1029               		.cfi_startproc
 1030               	.LVL79:
 1031 0416 CF92      		push r12
 1032               	.LCFI30:
 1033               		.cfi_def_cfa_offset 3
 1034               		.cfi_offset 12, -2
 1035 0418 DF92      		push r13
 1036               	.LCFI31:
 1037               		.cfi_def_cfa_offset 4
 1038               		.cfi_offset 13, -3
 1039 041a EF92      		push r14
 1040               	.LCFI32:
 1041               		.cfi_def_cfa_offset 5
 1042               		.cfi_offset 14, -4
 1043 041c FF92      		push r15
 1044               	.LCFI33:
 1045               		.cfi_def_cfa_offset 6
 1046               		.cfi_offset 15, -5
 1047 041e 0F93      		push r16
 1048               	.LCFI34:
 1049               		.cfi_def_cfa_offset 7
 1050               		.cfi_offset 16, -6
 1051 0420 1F93      		push r17
 1052               	.LCFI35:
 1053               		.cfi_def_cfa_offset 8
 1054               		.cfi_offset 17, -7
 1055 0422 CF93      		push r28
 1056               	.LCFI36:
 1057               		.cfi_def_cfa_offset 9
 1058               		.cfi_offset 28, -8
 1059 0424 DF93      		push r29
 1060               	.LCFI37:
 1061               		.cfi_def_cfa_offset 10
 1062               		.cfi_offset 29, -9
 1063               	/* prologue: function */
 1064               	/* frame size = 0 */
 1065               	/* stack size = 8 */
 1066               	.L__stack_usage = 8
 1067 0426 8C01      		movw r16,r24
 180:main.c        **** 
 1068               		.loc 1 180 0
 1069 0428 FC01      		movw r30,r24
 1070 042a C081      		ld r28,Z
 1071 042c D181      		ldd r29,Z+1
 1072               	.LVL80:
 182:main.c        ****   ptr += sizeof tekst_gsm - 1;
 1073               		.loc 1 182 0
 1074 042e 4CE0      		ldi r20,lo8(12)
 1075 0430 50E0      		ldi r21,0
 1076 0432 60E0      		ldi r22,lo8(tekst_gsm.3020)
 1077 0434 70E0      		ldi r23,hi8(tekst_gsm.3020)
 1078 0436 CE01      		movw r24,r28
 1079               	.LVL81:
 1080 0438 0E94 0000 		call memcpy_P
 1081               	.LVL82:
 183:main.c        ****   uchar aktywne_numery = 0;
 1082               		.loc 1 183 0
 1083 043c 2C96      		adiw r28,12
 1084               	.LVL83:
 1085 043e 88E0      		ldi r24,lo8(8)
 1086 0440 E82E      		mov r14,r24
 1087 0442 F12C      		mov r15,__zero_reg__
 185:main.c        ****   for (uint nr_uzyt_clip = 0; nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 1088               		.loc 1 185 0
 1089 0444 D12C      		mov r13,__zero_reg__
 184:main.c        ****   uchar wolne_numery = 0;
 1090               		.loc 1 184 0
 1091 0446 C12C      		mov r12,__zero_reg__
 1092               	.LVL84:
 1093               	.L61:
 1094               	.LBB385:
 188:main.c        ****       ++aktywne_numery;
 1095               		.loc 1 188 0
 1096 0448 C701      		movw r24,r14
 1097 044a 0E94 0000 		call eeprom_read_byte
 1098               	.LVL85:
 1099 044e 8F3F      		cpi r24,lo8(-1)
 1100 0450 01F0      		breq .L59
 189:main.c        ****     else
 1101               		.loc 1 189 0
 1102 0452 C394      		inc r12
 1103               	.LVL86:
 1104               	.L60:
 1105 0454 F5E0      		ldi r31,5
 1106 0456 EF0E      		add r14,r31
 1107 0458 F11C      		adc r15,__zero_reg__
 186:main.c        ****        ++nr_uzyt_clip) {
 1108               		.loc 1 186 0
 1109 045a 88EA      		ldi r24,-88
 1110 045c E816      		cp r14,r24
 1111 045e 8FE0      		ldi r24,15
 1112 0460 F806      		cpc r15,r24
 1113 0462 01F4      		brne .L61
 1114               	.LVL87:
 1115               	.LBE385:
 1116               	.LBB386:
 1117               	.LBB387:
 1118               		.loc 6 527 0
 1119 0464 4AE0      		ldi r20,lo8(10)
 1120 0466 BE01      		movw r22,r28
 1121 0468 8C2D      		mov r24,r12
 1122 046a 90E0      		ldi r25,0
 1123 046c 0E94 0000 		call __utoa_ncheck
 1124               	.LVL88:
 1125               	.LBE387:
 1126               	.LBE386:
 194:main.c        ****   *ptr++ = '/';
 1127               		.loc 1 194 0
 1128               		0:
 1129 0470 0990      		ld __tmp_reg__,Y+
 1130 0472 0020      		tst __tmp_reg__
 1131 0474 01F4      		brne 0b
 1132               	.LVL89:
 1133 0476 2197      		sbiw r28,1
 1134               	.LVL90:
 195:main.c        ****   utoa(wolne_numery, ptr, 10);
 1135               		.loc 1 195 0
 1136 0478 7E01      		movw r14,r28
 1137 047a EFEF      		ldi r30,-1
 1138 047c EE1A      		sub r14,r30
 1139 047e FE0A      		sbc r15,r30
 1140               	.LVL91:
 1141 0480 8FE2      		ldi r24,lo8(47)
 1142 0482 8883      		st Y,r24
 1143               	.LVL92:
 1144               	.LBB388:
 1145               	.LBB389:
 1146               		.loc 6 527 0
 1147 0484 4AE0      		ldi r20,lo8(10)
 1148 0486 B701      		movw r22,r14
 1149 0488 8D2D      		mov r24,r13
 1150 048a 90E0      		ldi r25,0
 1151 048c 0E94 0000 		call __utoa_ncheck
 1152               	.LVL93:
 1153               	.LBE389:
 1154               	.LBE388:
 197:main.c        ****   *buf_sms = ptr;
 1155               		.loc 1 197 0
 1156 0490 F701      		movw r30,r14
 1157               		0:
 1158 0492 0190      		ld __tmp_reg__,Z+
 1159 0494 0020      		tst __tmp_reg__
 1160 0496 01F4      		brne 0b
 1161 0498 CF01      		movw r24,r30
 1162               	.LVL94:
 1163 049a 0197      		sbiw r24,1
 1164               	.LVL95:
 198:main.c        **** }
 1165               		.loc 1 198 0
 1166 049c F801      		movw r30,r16
 1167               	.LVL96:
 1168 049e 9183      		std Z+1,r25
 1169 04a0 8083      		st Z,r24
 1170               	/* epilogue start */
 199:main.c        **** 
 1171               		.loc 1 199 0
 1172 04a2 DF91      		pop r29
 1173 04a4 CF91      		pop r28
 1174 04a6 1F91      		pop r17
 1175 04a8 0F91      		pop r16
 1176               	.LVL97:
 1177 04aa FF90      		pop r15
 1178 04ac EF90      		pop r14
 1179               	.LVL98:
 1180 04ae DF90      		pop r13
 1181               	.LVL99:
 1182 04b0 CF90      		pop r12
 1183               	.LVL100:
 1184 04b2 0895      		ret
 1185               	.LVL101:
 1186               	.L59:
 1187               	.LBB390:
 191:main.c        ****   }
 1188               		.loc 1 191 0
 1189 04b4 D394      		inc r13
 1190               	.LVL102:
 1191 04b6 00C0      		rjmp .L60
 1192               	.LBE390:
 1193               		.cfi_endproc
 1194               	.LFE29:
 1196               		.section	.rodata.str1.1,"aMS",@progbits,1
 1197               	.LC0:
 1198 0000 4861 726D 		.string	"Harmonogram: %02d:%02d %02d:%02d"
 1198      6F6E 6F67 
 1198      7261 6D3A 
 1198      2025 3032 
 1198      643A 2530 
 1199               	.LC1:
 1200 0021 536B 7279 		.string	"Skryba: Limit %d"
 1200      6261 3A20 
 1200      4C69 6D69 
 1200      7420 2564 
 1200      00
 1201               		.text
 1202               	.global	generuj_raport_stanu_urzadzenia
 1204               	generuj_raport_stanu_urzadzenia:
 1205               	.LFB30:
 204:main.c        ****   uchar *sms = (char *)tekst_wysylanego_smsa;
 1206               		.loc 1 204 0
 1207               		.cfi_startproc
 1208 04b8 EF92      		push r14
 1209               	.LCFI38:
 1210               		.cfi_def_cfa_offset 3
 1211               		.cfi_offset 14, -2
 1212 04ba FF92      		push r15
 1213               	.LCFI39:
 1214               		.cfi_def_cfa_offset 4
 1215               		.cfi_offset 15, -3
 1216 04bc 0F93      		push r16
 1217               	.LCFI40:
 1218               		.cfi_def_cfa_offset 5
 1219               		.cfi_offset 16, -4
 1220 04be 1F93      		push r17
 1221               	.LCFI41:
 1222               		.cfi_def_cfa_offset 6
 1223               		.cfi_offset 17, -5
 1224 04c0 CF93      		push r28
 1225               	.LCFI42:
 1226               		.cfi_def_cfa_offset 7
 1227               		.cfi_offset 28, -6
 1228 04c2 DF93      		push r29
 1229               	.LCFI43:
 1230               		.cfi_def_cfa_offset 8
 1231               		.cfi_offset 29, -7
 1232 04c4 00D0      		rcall .
 1233               	.LCFI44:
 1234               		.cfi_def_cfa_offset 10
 1235 04c6 CDB7      		in r28,__SP_L__
 1236 04c8 DEB7      		in r29,__SP_H__
 1237               	.LCFI45:
 1238               		.cfi_def_cfa_register 28
 1239               	/* prologue: function */
 1240               	/* frame size = 2 */
 1241               	/* stack size = 8 */
 1242               	.L__stack_usage = 8
 206:main.c        ****   *sms++ = '\n';
 1243               		.loc 1 206 0
 1244 04ca 8AE2      		ldi r24,lo8(42)
 1245 04cc 8093 0000 		sts tekst_wysylanego_smsa,r24
 207:main.c        ****   generuj_raport_sieci(&sms);
 1246               		.loc 1 207 0
 1247 04d0 80E0      		ldi r24,lo8(tekst_wysylanego_smsa+2)
 1248 04d2 90E0      		ldi r25,hi8(tekst_wysylanego_smsa+2)
 1249 04d4 9A83      		std Y+2,r25
 1250 04d6 8983      		std Y+1,r24
 1251 04d8 1AE0      		ldi r17,lo8(10)
 1252 04da 1093 0000 		sts tekst_wysylanego_smsa+1,r17
 208:main.c        ****   *sms++ = '\n';
 1253               		.loc 1 208 0
 1254 04de CE01      		movw r24,r28
 1255 04e0 0196      		adiw r24,1
 1256 04e2 0E94 0000 		call generuj_raport_sieci
 1257               	.LVL103:
 209:main.c        ****   generuj_raport_uzytkownikow_1(&sms);
 1258               		.loc 1 209 0
 1259 04e6 E981      		ldd r30,Y+1
 1260 04e8 FA81      		ldd r31,Y+2
 1261 04ea CF01      		movw r24,r30
 1262 04ec 0196      		adiw r24,1
 1263 04ee 9A83      		std Y+2,r25
 1264 04f0 8983      		std Y+1,r24
 1265 04f2 1083      		st Z,r17
 210:main.c        ****   *sms++ = '\n';
 1266               		.loc 1 210 0
 1267 04f4 CE01      		movw r24,r28
 1268 04f6 0196      		adiw r24,1
 1269 04f8 0E94 0000 		call generuj_raport_uzytkownikow_1
 1270               	.LVL104:
 211:main.c        **** 
 1271               		.loc 1 211 0
 1272 04fc E981      		ldd r30,Y+1
 1273 04fe FA81      		ldd r31,Y+2
 1274 0500 CF01      		movw r24,r30
 1275 0502 0196      		adiw r24,1
 1276 0504 9A83      		std Y+2,r25
 1277 0506 8983      		std Y+1,r24
 1278 0508 1083      		st Z,r17
 214:main.c        ****     strcpy_P((char *)sms, PSTR("Status: Zablokowany"));
 1279               		.loc 1 214 0
 1280 050a 2091 0000 		lds r18,blokada_systemu
 1281 050e 8981      		ldd r24,Y+1
 1282 0510 9A81      		ldd r25,Y+2
 215:main.c        ****   } else {
 1283               		.loc 1 215 0
 1284 0512 60E0      		ldi r22,lo8(__c.3034)
 1285 0514 70E0      		ldi r23,hi8(__c.3034)
 214:main.c        ****     strcpy_P((char *)sms, PSTR("Status: Zablokowany"));
 1286               		.loc 1 214 0
 1287 0516 2111      		cpse r18,__zero_reg__
 1288 0518 00C0      		rjmp .L81
 217:main.c        ****   }
 1289               		.loc 1 217 0
 1290 051a 60E0      		ldi r22,lo8(__c.3036)
 1291 051c 70E0      		ldi r23,hi8(__c.3036)
 1292               	.L81:
 1293 051e 0E94 0000 		call strcpy_P
 1294               	.LVL105:
 219:main.c        ****   *sms++ = '\n';
 1295               		.loc 1 219 0
 1296 0522 E981      		ldd r30,Y+1
 1297 0524 FA81      		ldd r31,Y+2
 1298               		0:
 1299 0526 0190      		ld __tmp_reg__,Z+
 1300 0528 0020      		tst __tmp_reg__
 1301 052a 01F4      		brne 0b
 220:main.c        **** 
 1302               		.loc 1 220 0
 1303 052c DF01      		movw r26,r30
 1304 052e 1197      		sbiw r26,1
 1305 0530 FA83      		std Y+2,r31
 1306 0532 E983      		std Y+1,r30
 1307 0534 8AE0      		ldi r24,lo8(10)
 1308 0536 8C93      		st X,r24
 223:main.c        ****     strcpy_P((char *)sms, PSTR("Tryb: Prywatny"));
 1309               		.loc 1 223 0
 1310 0538 2091 0000 		lds r18,tryb_pracy
 1311 053c 8981      		ldd r24,Y+1
 1312 053e 9A81      		ldd r25,Y+2
 224:main.c        ****   } else {
 1313               		.loc 1 224 0
 1314 0540 60E0      		ldi r22,lo8(__c.3038)
 1315 0542 70E0      		ldi r23,hi8(__c.3038)
 223:main.c        ****     strcpy_P((char *)sms, PSTR("Tryb: Prywatny"));
 1316               		.loc 1 223 0
 1317 0544 2223      		tst r18
 1318 0546 01F0      		breq .L82
 226:main.c        ****   }
 1319               		.loc 1 226 0
 1320 0548 60E0      		ldi r22,lo8(__c.3040)
 1321 054a 70E0      		ldi r23,hi8(__c.3040)
 1322               	.L82:
 1323 054c 0E94 0000 		call strcpy_P
 1324               	.LVL106:
 228:main.c        **** 
 1325               		.loc 1 228 0
 1326 0550 8981      		ldd r24,Y+1
 1327 0552 9A81      		ldd r25,Y+2
 1328 0554 FC01      		movw r30,r24
 1329               		0:
 1330 0556 0190      		ld __tmp_reg__,Z+
 1331 0558 0020      		tst __tmp_reg__
 1332 055a 01F4      		brne 0b
 1333 055c CF01      		movw r24,r30
 1334 055e 0197      		sbiw r24,1
 1335 0560 9A83      		std Y+2,r25
 1336 0562 8983      		std Y+1,r24
 230:main.c        ****     strcpy_P((char *)sms, PSTR(" CLIP"));
 1337               		.loc 1 230 0
 1338 0564 2091 0000 		lds r18,tryb_clip
 231:main.c        ****   } else {
 1339               		.loc 1 231 0
 1340 0568 60E0      		ldi r22,lo8(__c.3042)
 1341 056a 70E0      		ldi r23,hi8(__c.3042)
 230:main.c        ****     strcpy_P((char *)sms, PSTR(" CLIP"));
 1342               		.loc 1 230 0
 1343 056c 2111      		cpse r18,__zero_reg__
 1344 056e 00C0      		rjmp .L83
 233:main.c        ****   }
 1345               		.loc 1 233 0
 1346 0570 60E0      		ldi r22,lo8(__c.3044)
 1347 0572 70E0      		ldi r23,hi8(__c.3044)
 1348               	.L83:
 1349 0574 0E94 0000 		call strcpy_P
 1350               	.LVL107:
 235:main.c        ****   *sms++ = '\n';
 1351               		.loc 1 235 0
 1352 0578 E981      		ldd r30,Y+1
 1353 057a FA81      		ldd r31,Y+2
 1354               		0:
 1355 057c 0190      		ld __tmp_reg__,Z+
 1356 057e 0020      		tst __tmp_reg__
 1357 0580 01F4      		brne 0b
 236:main.c        **** 
 1358               		.loc 1 236 0
 1359 0582 DF01      		movw r26,r30
 1360 0584 1197      		sbiw r26,1
 1361 0586 FA83      		std Y+2,r31
 1362 0588 E983      		std Y+1,r30
 1363 058a 8AE0      		ldi r24,lo8(10)
 1364 058c 8C93      		st X,r24
 238:main.c        ****     strcpy_P((char *)sms, PSTR("Harmonogram: Wylaczony"));
 1365               		.loc 1 238 0
 1366 058e 8091 0000 		lds r24,czas_start_h
 1367 0592 8F3F      		cpi r24,lo8(-1)
 1368 0594 01F0      		breq .+2
 1369 0596 00C0      		rjmp .L70
 239:main.c        ****   } else {
 1370               		.loc 1 239 0
 1371 0598 60E0      		ldi r22,lo8(__c.3046)
 1372 059a 70E0      		ldi r23,hi8(__c.3046)
 1373 059c 8981      		ldd r24,Y+1
 1374 059e 9A81      		ldd r25,Y+2
 1375 05a0 0E94 0000 		call strcpy_P
 1376               	.LVL108:
 1377               	.L71:
 244:main.c        ****   *sms++ = '\n';
 1378               		.loc 1 244 0
 1379 05a4 E981      		ldd r30,Y+1
 1380 05a6 FA81      		ldd r31,Y+2
 1381               		0:
 1382 05a8 0190      		ld __tmp_reg__,Z+
 1383 05aa 0020      		tst __tmp_reg__
 1384 05ac 01F4      		brne 0b
 245:main.c        **** 
 1385               		.loc 1 245 0
 1386 05ae DF01      		movw r26,r30
 1387 05b0 1197      		sbiw r26,1
 1388 05b2 FA83      		std Y+2,r31
 1389 05b4 E983      		std Y+1,r30
 1390 05b6 8AE0      		ldi r24,lo8(10)
 1391 05b8 8C93      		st X,r24
 247:main.c        ****     uint aktywne_numery = 0;
 1392               		.loc 1 247 0
 1393 05ba 8091 0000 		lds r24,skryba_wlaczona
 1394 05be 8823      		tst r24
 1395 05c0 01F4      		brne .+2
 1396 05c2 00C0      		rjmp .L72
 1397 05c4 08E0      		ldi r16,lo8(8)
 1398 05c6 10E0      		ldi r17,0
 1399               	.LBB391:
 248:main.c        ****     for (uint nr_uzyt_clip = 0;
 1400               		.loc 1 248 0
 1401 05c8 F12C      		mov r15,__zero_reg__
 1402 05ca E12C      		mov r14,__zero_reg__
 1403               	.L74:
 1404               	.LVL109:
 1405               	.LBB392:
 251:main.c        ****         ++aktywne_numery;
 1406               		.loc 1 251 0
 1407 05cc C801      		movw r24,r16
 1408 05ce 0E94 0000 		call eeprom_read_byte
 1409               	.LVL110:
 1410 05d2 8F3F      		cpi r24,lo8(-1)
 1411 05d4 01F0      		breq .L73
 252:main.c        ****     }
 1412               		.loc 1 252 0
 1413 05d6 9FEF      		ldi r25,-1
 1414 05d8 E91A      		sub r14,r25
 1415 05da F90A      		sbc r15,r25
 1416               	.LVL111:
 1417               	.L73:
 1418 05dc 0B5F      		subi r16,-5
 1419 05de 1F4F      		sbci r17,-1
 249:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 1420               		.loc 1 249 0
 1421 05e0 083A      		cpi r16,-88
 1422 05e2 EFE0      		ldi r30,15
 1423 05e4 1E07      		cpc r17,r30
 1424 05e6 01F4      		brne .L74
 1425               	.LBE392:
 254:main.c        ****     if (pozostalo < 0)
 1426               		.loc 1 254 0
 1427 05e8 8091 0000 		lds r24,skryba_limit
 1428 05ec 9091 0000 		lds r25,skryba_limit+1
 1429               	.LVL112:
 257:main.c        ****   } else {
 1430               		.loc 1 257 0
 1431 05f0 8E19      		sub r24,r14
 1432 05f2 9F09      		sbc r25,r15
 1433               	.LVL113:
 1434 05f4 97FF      		sbrs r25,7
 1435 05f6 00C0      		rjmp .L75
 1436 05f8 90E0      		ldi r25,0
 1437 05fa 80E0      		ldi r24,0
 1438               	.LVL114:
 1439               	.L75:
 1440 05fc 9F93      		push r25
 1441 05fe 8F93      		push r24
 1442 0600 80E0      		ldi r24,lo8(.LC1)
 1443 0602 90E0      		ldi r25,hi8(.LC1)
 1444 0604 9F93      		push r25
 1445 0606 8F93      		push r24
 1446 0608 8A81      		ldd r24,Y+2
 1447 060a 8F93      		push r24
 1448 060c 8981      		ldd r24,Y+1
 1449 060e 8F93      		push r24
 1450 0610 0E94 0000 		call sprintf
 1451               	.LVL115:
 1452               	.LBE391:
 1453 0614 0F90      		pop __tmp_reg__
 1454 0616 0F90      		pop __tmp_reg__
 1455 0618 0F90      		pop __tmp_reg__
 1456 061a 0F90      		pop __tmp_reg__
 1457 061c 0F90      		pop __tmp_reg__
 1458 061e 0F90      		pop __tmp_reg__
 1459               	.LVL116:
 1460               	.L76:
 261:main.c        ****   *sms++ = '\n';
 1461               		.loc 1 261 0
 1462 0620 E981      		ldd r30,Y+1
 1463 0622 FA81      		ldd r31,Y+2
 1464               		0:
 1465 0624 0190      		ld __tmp_reg__,Z+
 1466 0626 0020      		tst __tmp_reg__
 1467 0628 01F4      		brne 0b
 262:main.c        **** 
 1468               		.loc 1 262 0
 1469 062a DF01      		movw r26,r30
 1470 062c 1197      		sbiw r26,1
 1471 062e FA83      		std Y+2,r31
 1472 0630 E983      		std Y+1,r30
 1473 0632 8AE0      		ldi r24,lo8(10)
 1474 0634 8C93      		st X,r24
 265:main.c        **** }
 1475               		.loc 1 265 0
 1476 0636 60E0      		ldi r22,lo8(tekst_demo.3056)
 1477 0638 70E0      		ldi r23,hi8(tekst_demo.3056)
 1478 063a 8981      		ldd r24,Y+1
 1479 063c 9A81      		ldd r25,Y+2
 1480 063e 0E94 0000 		call strcpy_P
 1481               	.LVL117:
 1482               	/* epilogue start */
 266:main.c        **** 
 1483               		.loc 1 266 0
 1484 0642 0F90      		pop __tmp_reg__
 1485 0644 0F90      		pop __tmp_reg__
 1486 0646 DF91      		pop r29
 1487 0648 CF91      		pop r28
 1488 064a 1F91      		pop r17
 1489 064c 0F91      		pop r16
 1490 064e FF90      		pop r15
 1491 0650 EF90      		pop r14
 1492 0652 0895      		ret
 1493               	.L70:
 241:main.c        ****             (int)czas_start_m, (int)czas_stop_h, (int)czas_stop_m);
 1494               		.loc 1 241 0
 1495 0654 9091 0000 		lds r25,czas_stop_m
 1496 0658 1F92      		push __zero_reg__
 1497 065a 9F93      		push r25
 1498 065c 9091 0000 		lds r25,czas_stop_h
 1499 0660 1F92      		push __zero_reg__
 1500 0662 9F93      		push r25
 1501 0664 9091 0000 		lds r25,czas_start_m
 1502 0668 1F92      		push __zero_reg__
 1503 066a 9F93      		push r25
 1504 066c 1F92      		push __zero_reg__
 1505 066e 8F93      		push r24
 1506 0670 80E0      		ldi r24,lo8(.LC0)
 1507 0672 90E0      		ldi r25,hi8(.LC0)
 1508 0674 9F93      		push r25
 1509 0676 8F93      		push r24
 1510 0678 8A81      		ldd r24,Y+2
 1511 067a 8F93      		push r24
 1512 067c 8981      		ldd r24,Y+1
 1513 067e 8F93      		push r24
 1514 0680 0E94 0000 		call sprintf
 1515               	.LVL118:
 1516 0684 0FB6      		in __tmp_reg__,__SREG__
 1517 0686 F894      		cli
 1518 0688 DEBF      		out __SP_H__,r29
 1519 068a 0FBE      		out __SREG__,__tmp_reg__
 1520 068c CDBF      		out __SP_L__,r28
 1521 068e 00C0      		rjmp .L71
 1522               	.L72:
 259:main.c        ****   }
 1523               		.loc 1 259 0
 1524 0690 60E0      		ldi r22,lo8(__c.3054)
 1525 0692 70E0      		ldi r23,hi8(__c.3054)
 1526 0694 8981      		ldd r24,Y+1
 1527 0696 9A81      		ldd r25,Y+2
 1528 0698 0E94 0000 		call strcpy_P
 1529               	.LVL119:
 1530 069c 00C0      		rjmp .L76
 1531               		.cfi_endproc
 1532               	.LFE30:
 1534               	.global	ustaw_wyjscie_clip
 1536               	ustaw_wyjscie_clip:
 1537               	.LFB31:
 268:main.c        ****   stan_wyjscie[0] = TRUE;
 1538               		.loc 1 268 0
 1539               		.cfi_startproc
 1540               	/* prologue: function */
 1541               	/* frame size = 0 */
 1542               	/* stack size = 0 */
 1543               	.L__stack_usage = 0
 269:main.c        ****   licznik_przelacznik_wyjscia[0] = 2 * 10ul; // 2 sekundy
 1544               		.loc 1 269 0
 1545 069e 8FEF      		ldi r24,lo8(-1)
 1546 06a0 8093 0000 		sts stan_wyjscie,r24
 270:main.c        **** }
 1547               		.loc 1 270 0
 1548 06a4 84E1      		ldi r24,lo8(20)
 1549 06a6 90E0      		ldi r25,0
 1550 06a8 A0E0      		ldi r26,0
 1551 06aa B0E0      		ldi r27,0
 1552 06ac 8093 0000 		sts licznik_przelacznik_wyjscia,r24
 1553 06b0 9093 0000 		sts licznik_przelacznik_wyjscia+1,r25
 1554 06b4 A093 0000 		sts licznik_przelacznik_wyjscia+2,r26
 1555 06b8 B093 0000 		sts licznik_przelacznik_wyjscia+3,r27
 1556               	/* epilogue start */
 271:main.c        **** 
 1557               		.loc 1 271 0
 1558 06bc 0895      		ret
 1559               		.cfi_endproc
 1560               	.LFE31:
 1562               		.section	.rodata.str1.1
 1563               	.LC2:
 1564 0032 2530 3264 		.string	"%02d:%02d:%02d"
 1564      3A25 3032 
 1564      643A 2530 
 1564      3264 00
 1565               	.LC3:
 1566 0041 2B43 434C 		.string	"+CCLK=\"24/01/01,%02d:%02d:%02d+04\""
 1566      4B3D 2232 
 1566      342F 3031 
 1566      2F30 312C 
 1566      2530 3264 
 1567               	.LC4:
 1568 0064 3A20 00   		.string	": "
 1569               	.LC5:
 1570 0067 4F4B 00   		.string	"OK"
 1571               	.LC6:
 1572 006a 4272 616B 		.string	"Brak takiego numeru w systemie"
 1572      2074 616B 
 1572      6965 676F 
 1572      206E 756D 
 1572      6572 7520 
 1573               	.LC7:
 1574 0089 5770 6973 		.string	"Wpisz numer jaki sprawdzasz, np: USER 793557357"
 1574      7A20 6E75 
 1574      6D65 7220 
 1574      6A61 6B69 
 1574      2073 7072 
 1575               		.text
 1576               	.global	wykonanie_polecenia_sms
 1578               	wykonanie_polecenia_sms:
 1579               	.LFB38:
 366:main.c        ****   tekst_odebranego_smsa[MAX_LICZBA_ZNAKOW_SMS] = 0; // (1) dla pewnoci
 1580               		.loc 1 366 0
 1581               		.cfi_startproc
 1582 06be CF92      		push r12
 1583               	.LCFI46:
 1584               		.cfi_def_cfa_offset 3
 1585               		.cfi_offset 12, -2
 1586 06c0 DF92      		push r13
 1587               	.LCFI47:
 1588               		.cfi_def_cfa_offset 4
 1589               		.cfi_offset 13, -3
 1590 06c2 FF92      		push r15
 1591               	.LCFI48:
 1592               		.cfi_def_cfa_offset 5
 1593               		.cfi_offset 15, -4
 1594 06c4 0F93      		push r16
 1595               	.LCFI49:
 1596               		.cfi_def_cfa_offset 6
 1597               		.cfi_offset 16, -5
 1598 06c6 1F93      		push r17
 1599               	.LCFI50:
 1600               		.cfi_def_cfa_offset 7
 1601               		.cfi_offset 17, -6
 1602 06c8 CF93      		push r28
 1603               	.LCFI51:
 1604               		.cfi_def_cfa_offset 8
 1605               		.cfi_offset 28, -7
 1606 06ca DF93      		push r29
 1607               	.LCFI52:
 1608               		.cfi_def_cfa_offset 9
 1609               		.cfi_offset 29, -8
 1610 06cc CDB7      		in r28,__SP_L__
 1611 06ce DEB7      		in r29,__SP_H__
 1612               	.LCFI53:
 1613               		.cfi_def_cfa_register 28
 1614 06d0 2A97      		sbiw r28,10
 1615               	.LCFI54:
 1616               		.cfi_def_cfa_offset 19
 1617 06d2 0FB6      		in __tmp_reg__,__SREG__
 1618 06d4 F894      		cli
 1619 06d6 DEBF      		out __SP_H__,r29
 1620 06d8 0FBE      		out __SREG__,__tmp_reg__
 1621 06da CDBF      		out __SP_L__,r28
 1622               	/* prologue: function */
 1623               	/* frame size = 10 */
 1624               	/* stack size = 17 */
 1625               	.L__stack_usage = 17
 367:main.c        ****   watchdog_sms_arm();
 1626               		.loc 1 367 0
 1627 06dc 1092 0000 		sts wysylany_blok_SIM900+399,__zero_reg__
 1628               	.LBB432:
 1629               	.LBB433:
 303:main.c        ****   watchdog_sms_licznik_100ms = 0;
 1630               		.loc 1 303 0
 1631 06e0 8FEF      		ldi r24,lo8(-1)
 1632 06e2 8093 0000 		sts watchdog_sms_aktywny,r24
 304:main.c        **** }
 1633               		.loc 1 304 0
 1634 06e6 1092 0000 		sts watchdog_sms_licznik_100ms+1,__zero_reg__
 1635 06ea 1092 0000 		sts watchdog_sms_licznik_100ms,__zero_reg__
 1636               	.LBE433:
 1637               	.LBE432:
 369:main.c        **** 
 1638               		.loc 1 369 0
 1639 06ee 80E0      		ldi r24,lo8(wysylany_blok_SIM900+239)
 1640 06f0 90E0      		ldi r25,hi8(wysylany_blok_SIM900+239)
 1641 06f2 0E94 0000 		call interpretuj_wiadomosc_sms
 1642               	.LVL120:
 1643 06f6 182F      		mov r17,r24
 1644               	.LVL121:
 378:main.c        ****     // Aktualizuj rtc_czas z timestampu SMS (z sekundami z PDU)
 1645               		.loc 1 378 0
 1646 06f8 8091 0000 		lds r24,sms_pomijaj_aktualizacje_czasu
 1647 06fc 8111      		cpse r24,__zero_reg__
 1648 06fe 00C0      		rjmp .L86
 1649               	.LBB434:
 380:main.c        ****             sms_timestamp_minuta, sms_timestamp_sekunda);
 1650               		.loc 1 380 0
 1651 0700 8091 0000 		lds r24,sms_timestamp_sekunda
 1652 0704 1F92      		push __zero_reg__
 1653 0706 8F93      		push r24
 1654 0708 8091 0000 		lds r24,sms_timestamp_minuta
 1655 070c 1F92      		push __zero_reg__
 1656 070e 8F93      		push r24
 1657 0710 8091 0000 		lds r24,sms_timestamp_godzina
 1658 0714 1F92      		push __zero_reg__
 1659 0716 8F93      		push r24
 1660 0718 80E0      		ldi r24,lo8(.LC2)
 1661 071a 90E0      		ldi r25,hi8(.LC2)
 1662 071c 9F93      		push r25
 1663 071e 8F93      		push r24
 1664 0720 80E0      		ldi r24,lo8(rtc_czas)
 1665 0722 90E0      		ldi r25,hi8(rtc_czas)
 1666 0724 9F93      		push r25
 1667 0726 8F93      		push r24
 1668 0728 0E94 0000 		call sprintf
 1669               	.LVL122:
 385:main.c        ****             sms_timestamp_godzina, sms_timestamp_minuta, sms_timestamp_sekunda);
 1670               		.loc 1 385 0
 1671 072c 8091 0000 		lds r24,sms_timestamp_sekunda
 1672 0730 1F92      		push __zero_reg__
 1673 0732 8F93      		push r24
 1674 0734 8091 0000 		lds r24,sms_timestamp_minuta
 1675 0738 1F92      		push __zero_reg__
 1676 073a 8F93      		push r24
 1677 073c 8091 0000 		lds r24,sms_timestamp_godzina
 1678 0740 1F92      		push __zero_reg__
 1679 0742 8F93      		push r24
 1680 0744 80E0      		ldi r24,lo8(.LC3)
 1681 0746 90E0      		ldi r25,hi8(.LC3)
 1682 0748 9F93      		push r25
 1683 074a 8F93      		push r24
 1684 074c 80E0      		ldi r24,lo8(bufor_ustaw_czas)
 1685 074e 90E0      		ldi r25,hi8(bufor_ustaw_czas)
 1686 0750 9F93      		push r25
 1687 0752 8F93      		push r24
 1688 0754 0E94 0000 		call sprintf
 1689               	.LVL123:
 387:main.c        **** 
 1690               		.loc 1 387 0
 1691 0758 8DEF      		ldi r24,lo8(-3)
 1692 075a 0E94 0000 		call dodaj_komende
 1693               	.LVL124:
 390:main.c        ****       int curr_time = sms_timestamp_godzina * 60 + sms_timestamp_minuta;
 1694               		.loc 1 390 0
 1695 075e 2091 0000 		lds r18,czas_start_h
 1696 0762 0FB6      		in __tmp_reg__,__SREG__
 1697 0764 F894      		cli
 1698 0766 DEBF      		out __SP_H__,r29
 1699 0768 0FBE      		out __SREG__,__tmp_reg__
 1700 076a CDBF      		out __SP_L__,r28
 1701 076c 2F3F      		cpi r18,lo8(-1)
 1702 076e 01F4      		brne .+2
 1703 0770 00C0      		rjmp .L87
 1704               	.LBB435:
 391:main.c        ****       int start_time = czas_start_h * 60 + czas_start_m;
 1705               		.loc 1 391 0
 1706 0772 3091 0000 		lds r19,sms_timestamp_godzina
 1707 0776 6CE3      		ldi r22,lo8(60)
 1708 0778 8091 0000 		lds r24,sms_timestamp_minuta
 1709 077c 90E0      		ldi r25,0
 1710 077e 369F      		mul r19,r22
 1711 0780 800D      		add r24,r0
 1712 0782 911D      		adc r25,r1
 1713 0784 1124      		clr __zero_reg__
 1714               	.LVL125:
 392:main.c        ****       int stop_time = czas_stop_h * 60 + czas_stop_m;
 1715               		.loc 1 392 0
 1716 0786 4091 0000 		lds r20,czas_start_m
 1717 078a 50E0      		ldi r21,0
 1718 078c 269F      		mul r18,r22
 1719 078e 400D      		add r20,r0
 1720 0790 511D      		adc r21,r1
 1721 0792 1124      		clr __zero_reg__
 1722               	.LVL126:
 393:main.c        **** 
 1723               		.loc 1 393 0
 1724 0794 7091 0000 		lds r23,czas_stop_h
 1725 0798 2091 0000 		lds r18,czas_stop_m
 1726 079c 30E0      		ldi r19,0
 1727 079e 769F      		mul r23,r22
 1728 07a0 200D      		add r18,r0
 1729 07a2 311D      		adc r19,r1
 1730 07a4 1124      		clr __zero_reg__
 1731               	.LVL127:
 395:main.c        ****         // Normalny przedział (np. 08:00 - 16:00)
 1732               		.loc 1 395 0
 1733 07a6 2417      		cp r18,r20
 1734 07a8 3507      		cpc r19,r21
 1735 07aa 04F0      		brlt .L88
 398:main.c        ****       } else {
 1736               		.loc 1 398 0
 1737 07ac 8417      		cp r24,r20
 1738 07ae 9507      		cpc r25,r21
 1739 07b0 04F0      		brlt .L114
 398:main.c        ****       } else {
 1740               		.loc 1 398 0 is_stmt 0 discriminator 2
 1741 07b2 41E0      		ldi r20,lo8(1)
 1742               	.LVL128:
 1743 07b4 2817      		cp r18,r24
 1744 07b6 3907      		cpc r19,r25
 1745 07b8 04F0      		brlt .L89
 1746 07ba 40E0      		ldi r20,0
 1747               	.L89:
 397:main.c        ****             !(curr_time >= start_time && curr_time <= stop_time);
 1748               		.loc 1 397 0 is_stmt 1
 1749 07bc 4093 0000 		sts blokada_sterowania_czasowa,r20
 1750               	.LVL129:
 1751               	.L86:
 1752               	.LBE435:
 1753               	.LBE434:
 410:main.c        **** 
 1754               		.loc 1 410 0
 1755 07c0 1092 0000 		sts sms_pomijaj_aktualizacje_czasu,__zero_reg__
 413:main.c        ****     // Gdy zablokowany, akceptuj tylko START i REPORT
 1756               		.loc 1 413 0
 1757 07c4 8091 0000 		lds r24,blokada_systemu
 1758 07c8 8823      		tst r24
 1759 07ca 01F0      		breq .L93
 415:main.c        ****         komenda != INTERPRETACJA_SMS_RAPORT) {
 1760               		.loc 1 415 0
 1761 07cc 8DEF      		ldi r24,lo8(-3)
 1762 07ce 810F      		add r24,r17
 1763 07d0 8230      		cpi r24,lo8(2)
 1764 07d2 00F0      		brlo .L93
 420:main.c        ****           1) {
 1765               		.loc 1 420 0
 1766 07d4 87EF      		ldi r24,lo8(-9)
 1767 07d6 9FE0      		ldi r25,lo8(15)
 1768 07d8 0E94 0000 		call eeprom_read_byte
 1769               	.LVL130:
 1770 07dc 8130      		cpi r24,lo8(1)
 1771 07de 01F4      		brne .L93
 422:main.c        ****         usun_zablokowany_sms();
 1772               		.loc 1 422 0
 1773 07e0 62E0      		ldi r22,lo8(2)
 1774 07e2 0E94 0000 		call zapisz_debug_do_eeprom
 1775               	.LVL131:
 423:main.c        ****         return;
 1776               		.loc 1 423 0
 1777 07e6 0E94 0000 		call usun_zablokowany_sms
 1778               	.LVL132:
 1779               	.L85:
 1780               	/* epilogue start */
 659:main.c        **** 
 1781               		.loc 1 659 0
 1782 07ea 2A96      		adiw r28,10
 1783 07ec 0FB6      		in __tmp_reg__,__SREG__
 1784 07ee F894      		cli
 1785 07f0 DEBF      		out __SP_H__,r29
 1786 07f2 0FBE      		out __SREG__,__tmp_reg__
 1787 07f4 CDBF      		out __SP_L__,r28
 1788 07f6 DF91      		pop r29
 1789 07f8 CF91      		pop r28
 1790 07fa 1F91      		pop r17
 1791 07fc 0F91      		pop r16
 1792 07fe FF90      		pop r15
 1793 0800 DF90      		pop r13
 1794 0802 CF90      		pop r12
 1795 0804 0895      		ret
 1796               	.LVL133:
 1797               	.L114:
 1798               	.LBB437:
 1799               	.LBB436:
 398:main.c        ****       } else {
 1800               		.loc 1 398 0
 1801 0806 41E0      		ldi r20,lo8(1)
 1802               	.LVL134:
 1803 0808 00C0      		rjmp .L89
 1804               	.LVL135:
 1805               	.L88:
 402:main.c        ****       }
 1806               		.loc 1 402 0
 1807 080a 8417      		cp r24,r20
 1808 080c 9507      		cpc r25,r21
 1809 080e 04F4      		brge .L115
 402:main.c        ****       }
 1810               		.loc 1 402 0 is_stmt 0 discriminator 1
 1811 0810 41E0      		ldi r20,lo8(1)
 1812               	.LVL136:
 1813 0812 2817      		cp r18,r24
 1814 0814 3907      		cpc r19,r25
 1815 0816 04F0      		brlt .L92
 1816 0818 40E0      		ldi r20,0
 1817               	.L92:
 1818 081a 842F      		mov r24,r20
 1819               	.LVL137:
 1820               	.L91:
 401:main.c        ****             !(curr_time >= start_time || curr_time <= stop_time);
 1821               		.loc 1 401 0 is_stmt 1
 1822 081c 8093 0000 		sts blokada_sterowania_czasowa,r24
 1823 0820 00C0      		rjmp .L86
 1824               	.LVL138:
 1825               	.L115:
 402:main.c        ****       }
 1826               		.loc 1 402 0
 1827 0822 80E0      		ldi r24,0
 1828               	.LVL139:
 1829 0824 00C0      		rjmp .L91
 1830               	.LVL140:
 1831               	.L87:
 1832               	.LBE436:
 405:main.c        ****     }
 1833               		.loc 1 405 0
 1834 0826 1092 0000 		sts blokada_sterowania_czasowa,__zero_reg__
 1835 082a 00C0      		rjmp .L86
 1836               	.L93:
 1837               	.LBE437:
 430:main.c        ****       komenda == INTERPRETACJA_SMS_USER) {
 1838               		.loc 1 430 0
 1839 082c 8CEF      		ldi r24,lo8(-4)
 1840 082e 810F      		add r24,r17
 1841 0830 8230      		cpi r24,lo8(2)
 1842 0832 00F4      		brsh .L95
 432:main.c        ****       zapisz_debug_do_eeprom(1, 1);
 1843               		.loc 1 432 0
 1844 0834 8091 0000 		lds r24,licznik_report_user
 1845 0838 8830      		cpi r24,lo8(8)
 1846 083a 00F0      		brlo .L95
 1847               	.L96:
 433:main.c        ****       usun_zablokowany_sms();
 1848               		.loc 1 433 0
 1849 083c 61E0      		ldi r22,lo8(1)
 1850 083e 81E0      		ldi r24,lo8(1)
 1851 0840 0E94 0000 		call zapisz_debug_do_eeprom
 1852               	.LVL141:
 434:main.c        ****       zareaguj_na_usuniety_sms_z_powodu_limitu();
 1853               		.loc 1 434 0
 1854 0844 0E94 0000 		call usun_zablokowany_sms
 1855               	.LVL142:
 435:main.c        ****       watchdog_sms_disarm();
 1856               		.loc 1 435 0
 1857 0848 0E94 0000 		call zareaguj_na_usuniety_sms_z_powodu_limitu
 1858               	.LVL143:
 1859               	.L99:
 658:main.c        **** }
 1860               		.loc 1 658 0
 1861 084c 0E94 0000 		call watchdog_sms_disarm
 1862               	.LVL144:
 1863 0850 00C0      		rjmp .L85
 1864               	.LVL145:
 1865               	.L95:
 442:main.c        ****     // Same number check
 1866               		.loc 1 442 0
 1867 0852 8091 0000 		lds r24,flaga_wysylanie_smsa
 1868 0856 8111      		cpse r24,__zero_reg__
 1869 0858 00C0      		rjmp .L96
 1870 085a E0E0      		ldi r30,lo8(komendy_kolejka)
 1871 085c F0E0      		ldi r31,hi8(komendy_kolejka)
 462:main.c        ****   for (uchar i = 0; i < LICZBA_KOMEND; ++i) {
 1872               		.loc 1 462 0
 1873 085e 20E0      		ldi r18,0
 461:main.c        ****   uchar liczba_wszystkich_komend = 0;
 1874               		.loc 1 461 0
 1875 0860 90E0      		ldi r25,0
 1876               	.L98:
 1877               	.LVL146:
 1878               	.LBB438:
 464:main.c        ****       ++liczba_wszystkich_komend;
 1879               		.loc 1 464 0
 1880 0862 8191      		ld r24,Z+
 1881               	.LVL147:
 1882 0864 8823      		tst r24
 1883 0866 01F0      		breq .L97
 465:main.c        ****       if (komendy_kolejka[i] >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
 1884               		.loc 1 465 0
 1885 0868 2F5F      		subi r18,lo8(-(1))
 1886               	.LVL148:
 466:main.c        ****           komendy_kolejka[i] <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
 1887               		.loc 1 466 0
 1888 086a 825D      		subi r24,lo8(-(46))
 1889 086c 8230      		cpi r24,lo8(2)
 1890 086e 00F4      		brsh .L97
 468:main.c        ****     }
 1891               		.loc 1 468 0
 1892 0870 9F5F      		subi r25,lo8(-(1))
 1893               	.LVL149:
 1894               	.L97:
 463:main.c        ****     if (komendy_kolejka[i] != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 1895               		.loc 1 463 0 discriminator 2
 1896 0872 80E0      		ldi r24,hi8(komendy_kolejka+30)
 1897 0874 E030      		cpi r30,lo8(komendy_kolejka+30)
 1898 0876 F807      		cpc r31,r24
 1899 0878 01F4      		brne .L98
 1900               	.LBE438:
 472:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 1901               		.loc 1 472 0
 1902 087a 2332      		cpi r18,lo8(35)
 1903 087c 00F4      		brsh .L96
 480:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 1904               		.loc 1 480 0
 1905 087e 9630      		cpi r25,lo8(6)
 1906 0880 00F4      		brsh .L96
 488:main.c        ****   case INTERPRETACJA_SMS_POPRAWNY:
 1907               		.loc 1 488 0
 1908 0882 1C30      		cpi r17,lo8(12)
 1909 0884 00F4      		brsh .L99
 1910 0886 E12F      		mov r30,r17
 1911               	.LVL150:
 1912 0888 F0E0      		ldi r31,0
 1913 088a E050      		subi r30,lo8(-(gs(.L101)))
 1914 088c F040      		sbci r31,hi8(-(gs(.L101)))
 1915 088e 0C94 0000 		jmp __tablejump2__
 1916               		.p2align	1
 1917               	.L101:
 1918 0892 0000      		.word gs(.L100)
 1919 0894 0000      		.word gs(.L99)
 1920 0896 0000      		.word gs(.L99)
 1921 0898 0000      		.word gs(.L126)
 1922 089a 0000      		.word gs(.L103)
 1923 089c 0000      		.word gs(.L104)
 1924 089e 0000      		.word gs(.L105)
 1925 08a0 0000      		.word gs(.L106)
 1926 08a2 0000      		.word gs(.L107)
 1927 08a4 0000      		.word gs(.L99)
 1928 08a6 0000      		.word gs(.L99)
 1929 08a8 0000      		.word gs(.L108)
 1930               	.L100:
 493:main.c        ****     zapisz_debug_do_eeprom(0, 3);
 1931               		.loc 1 493 0
 1932 08aa 81E0      		ldi r24,lo8(1)
 1933 08ac 8093 0000 		sts liczba_blyskow_led,r24
 1934 08b0 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 494:main.c        ****     break;
 1935               		.loc 1 494 0
 1936 08b4 63E0      		ldi r22,lo8(3)
 1937 08b6 80E0      		ldi r24,0
 1938               	.LVL151:
 1939               	.L128:
 506:main.c        ****     break;
 1940               		.loc 1 506 0
 1941 08b8 0E94 0000 		call zapisz_debug_do_eeprom
 1942               	.LVL152:
 507:main.c        ****   }
 1943               		.loc 1 507 0
 1944 08bc 00C0      		rjmp .L99
 1945               	.LVL153:
 1946               	.L103:
 498:main.c        ****     timer_report_user_100ms = OKNO_CZASOWE_REPORT_USER_100MS;
 1947               		.loc 1 498 0
 1948 08be 8091 0000 		lds r24,licznik_report_user
 1949 08c2 8F5F      		subi r24,lo8(-(1))
 1950 08c4 8093 0000 		sts licznik_report_user,r24
 499:main.c        **** 
 1951               		.loc 1 499 0
 1952 08c8 8CE2      		ldi r24,lo8(44)
 1953 08ca 91E0      		ldi r25,lo8(1)
 1954 08cc 9093 0000 		sts timer_report_user_100ms+1,r25
 1955 08d0 8093 0000 		sts timer_report_user_100ms,r24
 501:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 1956               		.loc 1 501 0
 1957 08d4 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 1958 08d6 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 1959 08d8 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 1960 08da 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 1961 08dc 0E94 0000 		call strcpy
 1962               	.LVL154:
 503:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 1963               		.loc 1 503 0
 1964 08e0 0E94 0000 		call generuj_raport_stanu_urzadzenia
 1965               	.LVL155:
 504:main.c        ****     zapal_diode_led_blyski(2); // Komenda REPORT - 2 blyski
 1966               		.loc 1 504 0
 1967 08e4 82ED      		ldi r24,lo8(-46)
 1968 08e6 0E94 0000 		call dodaj_komende
 1969               	.LVL156:
 505:main.c        ****     zapisz_debug_do_eeprom(1, 0);
 1970               		.loc 1 505 0
 1971 08ea 82E0      		ldi r24,lo8(2)
 1972 08ec 8093 0000 		sts liczba_blyskow_led,r24
 1973 08f0 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 506:main.c        ****     break;
 1974               		.loc 1 506 0
 1975 08f4 60E0      		ldi r22,0
 1976 08f6 81E0      		ldi r24,lo8(1)
 1977 08f8 00C0      		rjmp .L128
 1978               	.LVL157:
 1979               	.L107:
 1980               	.LBB439:
 511:main.c        ****     uchar *sms = tekst_wysylanego_smsa + strlen((char *)tekst_wysylanego_smsa);
 1981               		.loc 1 511 0
 1982 08fa 60E0      		ldi r22,lo8(__c.3122)
 1983 08fc 70E0      		ldi r23,hi8(__c.3122)
 1984 08fe 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 1985 0900 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 1986 0902 0E94 0000 		call strcpy_P
 1987               	.LVL158:
 512:main.c        **** 
 1988               		.loc 1 512 0
 1989 0906 00E0      		ldi r16,lo8(tekst_wysylanego_smsa)
 1990 0908 10E0      		ldi r17,hi8(tekst_wysylanego_smsa)
 1991 090a F801      		movw r30,r16
 1992               		0:
 1993 090c 0190      		ld __tmp_reg__,Z+
 1994 090e 0020      		tst __tmp_reg__
 1995 0910 01F4      		brne 0b
 1996 0912 8F01      		movw r16,r30
 1997 0914 0150      		subi r16,1
 1998 0916 1109      		sbc r17,__zero_reg__
 1999               	.LVL159:
 515:main.c        ****     sms += strlen((char *)sms);
 2000               		.loc 1 515 0
 2001 0918 60E0      		ldi r22,lo8(__c.3125)
 2002 091a 70E0      		ldi r23,hi8(__c.3125)
 2003 091c C801      		movw r24,r16
 2004 091e 0E94 0000 		call strcpy_P
 2005               	.LVL160:
 516:main.c        ****     *sms++ =
 2006               		.loc 1 516 0
 2007 0922 F801      		movw r30,r16
 2008               		0:
 2009 0924 0190      		ld __tmp_reg__,Z+
 2010 0926 0020      		tst __tmp_reg__
 2011 0928 01F4      		brne 0b
 2012 092a CF01      		movw r24,r30
 2013 092c 0197      		sbiw r24,1
 2014 092e 6C01      		movw r12,r24
 2015               	.LVL161:
 518:main.c        ****     *sms++ =
 2016               		.loc 1 518 0
 2017 0930 81EF      		ldi r24,lo8(-15)
 2018 0932 9FE0      		ldi r25,lo8(15)
 2019 0934 0E94 0000 		call eeprom_read_byte
 2020               	.LVL162:
 2021 0938 805D      		subi r24,lo8(-(48))
 517:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_2);
 2022               		.loc 1 517 0
 2023 093a F601      		movw r30,r12
 2024 093c 8083      		st Z,r24
 520:main.c        ****     *sms++ =
 2025               		.loc 1 520 0
 2026 093e 82EF      		ldi r24,lo8(-14)
 2027 0940 9FE0      		ldi r25,lo8(15)
 2028 0942 0E94 0000 		call eeprom_read_byte
 2029               	.LVL163:
 2030 0946 805D      		subi r24,lo8(-(48))
 519:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_3);
 2031               		.loc 1 519 0
 2032 0948 F601      		movw r30,r12
 2033 094a 8183      		std Z+1,r24
 522:main.c        ****     *sms++ =
 2034               		.loc 1 522 0
 2035 094c 83EF      		ldi r24,lo8(-13)
 2036 094e 9FE0      		ldi r25,lo8(15)
 2037 0950 0E94 0000 		call eeprom_read_byte
 2038               	.LVL164:
 2039 0954 805D      		subi r24,lo8(-(48))
 521:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_4);
 2040               		.loc 1 521 0
 2041 0956 F601      		movw r30,r12
 2042 0958 8283      		std Z+2,r24
 524:main.c        ****     *sms++ = '\n';
 2043               		.loc 1 524 0
 2044 095a 84EF      		ldi r24,lo8(-12)
 2045 095c 9FE0      		ldi r25,lo8(15)
 2046 095e 0E94 0000 		call eeprom_read_byte
 2047               	.LVL165:
 2048 0962 805D      		subi r24,lo8(-(48))
 523:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_5);
 2049               		.loc 1 523 0
 2050 0964 F601      		movw r30,r12
 2051 0966 8383      		std Z+3,r24
 525:main.c        **** 
 2052               		.loc 1 525 0
 2053 0968 8601      		movw r16,r12
 2054 096a 0B5F      		subi r16,-5
 2055 096c 1F4F      		sbci r17,-1
 2056               	.LVL166:
 2057 096e 9AE0      		ldi r25,lo8(10)
 2058 0970 F92E      		mov r15,r25
 2059 0972 F482      		std Z+4,r15
 528:main.c        ****     sms += strlen((char *)sms);
 2060               		.loc 1 528 0
 2061 0974 60E0      		ldi r22,lo8(__c.3127)
 2062 0976 70E0      		ldi r23,hi8(__c.3127)
 2063 0978 C801      		movw r24,r16
 2064 097a 0E94 0000 		call strcpy_P
 2065               	.LVL167:
 529:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_1), sms, 10);
 2066               		.loc 1 529 0
 2067 097e F801      		movw r30,r16
 2068               		0:
 2069 0980 0190      		ld __tmp_reg__,Z+
 2070 0982 0020      		tst __tmp_reg__
 2071 0984 01F4      		brne 0b
 2072 0986 8F01      		movw r16,r30
 2073               	.LVL168:
 2074 0988 0150      		subi r16,1
 2075 098a 1109      		sbc r17,__zero_reg__
 2076               	.LVL169:
 530:main.c        ****     sms += strlen((char *)sms);
 2077               		.loc 1 530 0
 2078 098c 86EE      		ldi r24,lo8(-26)
 2079 098e 9FE0      		ldi r25,lo8(15)
 2080 0990 0E94 0000 		call eeprom_read_byte
 2081               	.LVL170:
 2082               	.LBB440:
 2083               	.LBB441:
 2084               		.loc 6 527 0
 2085 0994 4AE0      		ldi r20,lo8(10)
 2086 0996 B801      		movw r22,r16
 2087 0998 90E0      		ldi r25,0
 2088 099a 0E94 0000 		call __utoa_ncheck
 2089               	.LVL171:
 2090               	.LBE441:
 2091               	.LBE440:
 531:main.c        **** 
 2092               		.loc 1 531 0
 2093 099e F801      		movw r30,r16
 2094               		0:
 2095 09a0 0190      		ld __tmp_reg__,Z+
 2096 09a2 0020      		tst __tmp_reg__
 2097 09a4 01F4      		brne 0b
 2098 09a6 8F01      		movw r16,r30
 2099               	.LVL172:
 2100 09a8 0150      		subi r16,1
 2101 09aa 1109      		sbc r17,__zero_reg__
 2102               	.LVL173:
 533:main.c        ****     sms += strlen((char *)sms);
 2103               		.loc 1 533 0
 2104 09ac 60E0      		ldi r22,lo8(__c.3129)
 2105 09ae 70E0      		ldi r23,hi8(__c.3129)
 2106 09b0 C801      		movw r24,r16
 2107 09b2 0E94 0000 		call strcpy_P
 2108               	.LVL174:
 534:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_2), sms, 10);
 2109               		.loc 1 534 0
 2110 09b6 F801      		movw r30,r16
 2111               		0:
 2112 09b8 0190      		ld __tmp_reg__,Z+
 2113 09ba 0020      		tst __tmp_reg__
 2114 09bc 01F4      		brne 0b
 2115 09be 8F01      		movw r16,r30
 2116               	.LVL175:
 2117 09c0 0150      		subi r16,1
 2118 09c2 1109      		sbc r17,__zero_reg__
 2119               	.LVL176:
 535:main.c        ****     sms += strlen((char *)sms);
 2120               		.loc 1 535 0
 2121 09c4 87EE      		ldi r24,lo8(-25)
 2122 09c6 9FE0      		ldi r25,lo8(15)
 2123 09c8 0E94 0000 		call eeprom_read_byte
 2124               	.LVL177:
 2125               	.LBB442:
 2126               	.LBB443:
 2127               		.loc 6 527 0
 2128 09cc 4AE0      		ldi r20,lo8(10)
 2129 09ce B801      		movw r22,r16
 2130 09d0 90E0      		ldi r25,0
 2131 09d2 0E94 0000 		call __utoa_ncheck
 2132               	.LVL178:
 2133               	.LBE443:
 2134               	.LBE442:
 536:main.c        **** 
 2135               		.loc 1 536 0
 2136 09d6 F801      		movw r30,r16
 2137               		0:
 2138 09d8 0190      		ld __tmp_reg__,Z+
 2139 09da 0020      		tst __tmp_reg__
 2140 09dc 01F4      		brne 0b
 2141 09de 8F01      		movw r16,r30
 2142               	.LVL179:
 2143 09e0 0150      		subi r16,1
 2144 09e2 1109      		sbc r17,__zero_reg__
 2145               	.LVL180:
 538:main.c        ****     sms += strlen((char *)sms);
 2146               		.loc 1 538 0
 2147 09e4 60E0      		ldi r22,lo8(__c.3131)
 2148 09e6 70E0      		ldi r23,hi8(__c.3131)
 2149 09e8 C801      		movw r24,r16
 2150 09ea 0E94 0000 		call strcpy_P
 2151               	.LVL181:
 539:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_3), sms, 10);
 2152               		.loc 1 539 0
 2153 09ee F801      		movw r30,r16
 2154               		0:
 2155 09f0 0190      		ld __tmp_reg__,Z+
 2156 09f2 0020      		tst __tmp_reg__
 2157 09f4 01F4      		brne 0b
 2158 09f6 8F01      		movw r16,r30
 2159               	.LVL182:
 2160 09f8 0150      		subi r16,1
 2161 09fa 1109      		sbc r17,__zero_reg__
 2162               	.LVL183:
 540:main.c        ****     sms += strlen((char *)sms);
 2163               		.loc 1 540 0
 2164 09fc 88EE      		ldi r24,lo8(-24)
 2165 09fe 9FE0      		ldi r25,lo8(15)
 2166 0a00 0E94 0000 		call eeprom_read_byte
 2167               	.LVL184:
 2168               	.LBB444:
 2169               	.LBB445:
 2170               		.loc 6 527 0
 2171 0a04 4AE0      		ldi r20,lo8(10)
 2172 0a06 B801      		movw r22,r16
 2173 0a08 90E0      		ldi r25,0
 2174 0a0a 0E94 0000 		call __utoa_ncheck
 2175               	.LVL185:
 2176               	.LBE445:
 2177               	.LBE444:
 541:main.c        ****     *sms++ = '\n';
 2178               		.loc 1 541 0
 2179 0a0e F801      		movw r30,r16
 2180               		0:
 2181 0a10 0190      		ld __tmp_reg__,Z+
 2182 0a12 0020      		tst __tmp_reg__
 2183 0a14 01F4      		brne 0b
 2184 0a16 3197      		sbiw r30,1
 2185               	.LVL186:
 542:main.c        **** 
 2186               		.loc 1 542 0
 2187 0a18 8F01      		movw r16,r30
 2188 0a1a 0F5F      		subi r16,-1
 2189 0a1c 1F4F      		sbci r17,-1
 2190               	.LVL187:
 2191 0a1e F082      		st Z,r15
 544:main.c        ****     sms += strlen((char *)sms);
 2192               		.loc 1 544 0
 2193 0a20 60E0      		ldi r22,lo8(__c.3133)
 2194 0a22 70E0      		ldi r23,hi8(__c.3133)
 2195 0a24 C801      		movw r24,r16
 2196 0a26 0E94 0000 		call strcpy_P
 2197               	.LVL188:
 545:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_4), sms, 10);
 2198               		.loc 1 545 0
 2199 0a2a F801      		movw r30,r16
 2200               		0:
 2201 0a2c 0190      		ld __tmp_reg__,Z+
 2202 0a2e 0020      		tst __tmp_reg__
 2203 0a30 01F4      		brne 0b
 2204 0a32 8F01      		movw r16,r30
 2205               	.LVL189:
 2206 0a34 0150      		subi r16,1
 2207 0a36 1109      		sbc r17,__zero_reg__
 2208               	.LVL190:
 546:main.c        ****     sms += strlen((char *)sms);
 2209               		.loc 1 546 0
 2210 0a38 89EE      		ldi r24,lo8(-23)
 2211 0a3a 9FE0      		ldi r25,lo8(15)
 2212 0a3c 0E94 0000 		call eeprom_read_byte
 2213               	.LVL191:
 2214               	.LBB446:
 2215               	.LBB447:
 2216               		.loc 6 527 0
 2217 0a40 4AE0      		ldi r20,lo8(10)
 2218 0a42 B801      		movw r22,r16
 2219 0a44 90E0      		ldi r25,0
 2220 0a46 0E94 0000 		call __utoa_ncheck
 2221               	.LVL192:
 2222               	.LBE447:
 2223               	.LBE446:
 547:main.c        **** 
 2224               		.loc 1 547 0
 2225 0a4a F801      		movw r30,r16
 2226               		0:
 2227 0a4c 0190      		ld __tmp_reg__,Z+
 2228 0a4e 0020      		tst __tmp_reg__
 2229 0a50 01F4      		brne 0b
 2230 0a52 8F01      		movw r16,r30
 2231               	.LVL193:
 2232 0a54 0150      		subi r16,1
 2233 0a56 1109      		sbc r17,__zero_reg__
 2234               	.LVL194:
 549:main.c        ****     sms += strlen((char *)sms);
 2235               		.loc 1 549 0
 2236 0a58 60E0      		ldi r22,lo8(__c.3135)
 2237 0a5a 70E0      		ldi r23,hi8(__c.3135)
 2238 0a5c C801      		movw r24,r16
 2239 0a5e 0E94 0000 		call strcpy_P
 2240               	.LVL195:
 550:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_5), sms, 10);
 2241               		.loc 1 550 0
 2242 0a62 F801      		movw r30,r16
 2243               		0:
 2244 0a64 0190      		ld __tmp_reg__,Z+
 2245 0a66 0020      		tst __tmp_reg__
 2246 0a68 01F4      		brne 0b
 2247 0a6a 8F01      		movw r16,r30
 2248               	.LVL196:
 2249 0a6c 0150      		subi r16,1
 2250 0a6e 1109      		sbc r17,__zero_reg__
 2251               	.LVL197:
 551:main.c        ****     sms += strlen((char *)sms);
 2252               		.loc 1 551 0
 2253 0a70 8AEE      		ldi r24,lo8(-22)
 2254 0a72 9FE0      		ldi r25,lo8(15)
 2255 0a74 0E94 0000 		call eeprom_read_byte
 2256               	.LVL198:
 2257               	.LBB448:
 2258               	.LBB449:
 2259               		.loc 6 527 0
 2260 0a78 4AE0      		ldi r20,lo8(10)
 2261 0a7a B801      		movw r22,r16
 2262 0a7c 90E0      		ldi r25,0
 2263 0a7e 0E94 0000 		call __utoa_ncheck
 2264               	.LVL199:
 2265               	.LBE449:
 2266               	.LBE448:
 552:main.c        **** 
 2267               		.loc 1 552 0
 2268 0a82 F801      		movw r30,r16
 2269               		0:
 2270 0a84 0190      		ld __tmp_reg__,Z+
 2271 0a86 0020      		tst __tmp_reg__
 2272 0a88 01F4      		brne 0b
 2273 0a8a 8F01      		movw r16,r30
 2274               	.LVL200:
 2275 0a8c 0150      		subi r16,1
 2276 0a8e 1109      		sbc r17,__zero_reg__
 2277               	.LVL201:
 554:main.c        ****     sms += strlen((char *)sms);
 2278               		.loc 1 554 0
 2279 0a90 60E0      		ldi r22,lo8(__c.3137)
 2280 0a92 70E0      		ldi r23,hi8(__c.3137)
 2281 0a94 C801      		movw r24,r16
 2282 0a96 0E94 0000 		call strcpy_P
 2283               	.LVL202:
 555:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_6), sms, 10);
 2284               		.loc 1 555 0
 2285 0a9a F801      		movw r30,r16
 2286               		0:
 2287 0a9c 0190      		ld __tmp_reg__,Z+
 2288 0a9e 0020      		tst __tmp_reg__
 2289 0aa0 01F4      		brne 0b
 2290 0aa2 8F01      		movw r16,r30
 2291               	.LVL203:
 2292 0aa4 0150      		subi r16,1
 2293 0aa6 1109      		sbc r17,__zero_reg__
 2294               	.LVL204:
 556:main.c        ****     sms += strlen((char *)sms);
 2295               		.loc 1 556 0
 2296 0aa8 8BEE      		ldi r24,lo8(-21)
 2297 0aaa 9FE0      		ldi r25,lo8(15)
 2298 0aac 0E94 0000 		call eeprom_read_byte
 2299               	.LVL205:
 2300               	.LBB450:
 2301               	.LBB451:
 2302               		.loc 6 527 0
 2303 0ab0 4AE0      		ldi r20,lo8(10)
 2304 0ab2 B801      		movw r22,r16
 2305 0ab4 90E0      		ldi r25,0
 2306 0ab6 0E94 0000 		call __utoa_ncheck
 2307               	.LVL206:
 2308               	.LBE451:
 2309               	.LBE450:
 557:main.c        **** 
 2310               		.loc 1 557 0
 2311 0aba F801      		movw r30,r16
 2312               		0:
 2313 0abc 0190      		ld __tmp_reg__,Z+
 2314 0abe 0020      		tst __tmp_reg__
 2315 0ac0 01F4      		brne 0b
 2316 0ac2 8F01      		movw r16,r30
 2317               	.LVL207:
 2318 0ac4 0150      		subi r16,1
 2319 0ac6 1109      		sbc r17,__zero_reg__
 2320               	.LVL208:
 559:main.c        ****     sms += strlen((char *)sms);
 2321               		.loc 1 559 0
 2322 0ac8 60E0      		ldi r22,lo8(__c.3139)
 2323 0aca 70E0      		ldi r23,hi8(__c.3139)
 2324 0acc C801      		movw r24,r16
 2325 0ace 0E94 0000 		call strcpy_P
 2326               	.LVL209:
 560:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_7), sms, 10);
 2327               		.loc 1 560 0
 2328 0ad2 F801      		movw r30,r16
 2329               		0:
 2330 0ad4 0190      		ld __tmp_reg__,Z+
 2331 0ad6 0020      		tst __tmp_reg__
 2332 0ad8 01F4      		brne 0b
 2333 0ada 8F01      		movw r16,r30
 2334               	.LVL210:
 2335 0adc 0150      		subi r16,1
 2336 0ade 1109      		sbc r17,__zero_reg__
 2337               	.LVL211:
 561:main.c        ****     sms += strlen((char *)sms);
 2338               		.loc 1 561 0
 2339 0ae0 8CEE      		ldi r24,lo8(-20)
 2340 0ae2 9FE0      		ldi r25,lo8(15)
 2341 0ae4 0E94 0000 		call eeprom_read_byte
 2342               	.LVL212:
 2343               	.LBB452:
 2344               	.LBB453:
 2345               		.loc 6 527 0
 2346 0ae8 4AE0      		ldi r20,lo8(10)
 2347 0aea B801      		movw r22,r16
 2348 0aec 90E0      		ldi r25,0
 2349 0aee 0E94 0000 		call __utoa_ncheck
 2350               	.LVL213:
 2351               	.LBE453:
 2352               	.LBE452:
 562:main.c        ****     *sms++ = '\n';
 2353               		.loc 1 562 0
 2354 0af2 F801      		movw r30,r16
 2355               		0:
 2356 0af4 0190      		ld __tmp_reg__,Z+
 2357 0af6 0020      		tst __tmp_reg__
 2358 0af8 01F4      		brne 0b
 2359 0afa CF01      		movw r24,r30
 2360               	.LVL214:
 563:main.c        **** 
 2361               		.loc 1 563 0
 2362 0afc 0197      		sbiw r24,1
 2363               	.LVL215:
 2364 0afe FC01      		movw r30,r24
 2365               	.LVL216:
 2366 0b00 F192      		st Z+,r15
 2367 0b02 CF01      		movw r24,r30
 2368               	.LVL217:
 565:main.c        **** 
 2369               		.loc 1 565 0
 2370 0b04 60E0      		ldi r22,lo8(__c.3141)
 2371 0b06 70E0      		ldi r23,hi8(__c.3141)
 2372 0b08 0E94 0000 		call strcpy_P
 2373               	.LVL218:
 567:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 2374               		.loc 1 567 0
 2375 0b0c 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 2376 0b0e 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 2377 0b10 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 2378 0b12 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 2379               	.L129:
 2380 0b14 0E94 0000 		call strcpy
 2381               	.LVL219:
 569:main.c        ****     zapal_diode_led_blyski(2);
 2382               		.loc 1 569 0
 2383 0b18 82ED      		ldi r24,lo8(-46)
 2384               	.L127:
 2385 0b1a 0E94 0000 		call dodaj_komende
 2386               	.LVL220:
 2387               	.L126:
 570:main.c        ****     break;
 2388               		.loc 1 570 0
 2389 0b1e 82E0      		ldi r24,lo8(2)
 2390 0b20 8093 0000 		sts liczba_blyskow_led,r24
 2391 0b24 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 571:main.c        ****   }
 2392               		.loc 1 571 0
 2393 0b28 00C0      		rjmp .L99
 2394               	.LVL221:
 2395               	.L104:
 2396               	.LBE439:
 2397               	.LBB454:
 574:main.c        ****     timer_report_user_100ms = OKNO_CZASOWE_REPORT_USER_100MS;
 2398               		.loc 1 574 0
 2399 0b2a 8091 0000 		lds r24,licznik_report_user
 2400 0b2e 8F5F      		subi r24,lo8(-(1))
 2401 0b30 8093 0000 		sts licznik_report_user,r24
 575:main.c        **** 
 2402               		.loc 1 575 0
 2403 0b34 8CE2      		ldi r24,lo8(44)
 2404 0b36 91E0      		ldi r25,lo8(1)
 2405 0b38 9093 0000 		sts timer_report_user_100ms+1,r25
 2406 0b3c 8093 0000 		sts timer_report_user_100ms,r24
 577:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 2407               		.loc 1 577 0
 2408 0b40 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 2409 0b42 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 2410 0b44 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 2411 0b46 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 2412 0b48 0E94 0000 		call strcpy
 2413               	.LVL222:
 586:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
 2414               		.loc 1 586 0
 2415 0b4c 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 2416 0b4e 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 2417 0b50 FB01      		movw r30,r22
 2418               		0:
 2419 0b52 0190      		ld __tmp_reg__,Z+
 2420 0b54 0020      		tst __tmp_reg__
 2421 0b56 01F4      		brne 0b
 2422 0b58 BF01      		movw r22,r30
 2423 0b5a 6150      		subi r22,1
 2424 0b5c 7109      		sbc r23,__zero_reg__
 584:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
 2425               		.loc 1 584 0
 2426 0b5e AE01      		movw r20,r28
 2427 0b60 4F5F      		subi r20,-1
 2428 0b62 5F4F      		sbci r21,-1
 2429 0b64 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 2430 0b66 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 2431 0b68 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 2432               	.LVL223:
 2433 0b6c 88E0      		ldi r24,lo8(8)
 2434 0b6e C82E      		mov r12,r24
 2435 0b70 D12C      		mov r13,__zero_reg__
 2436               	.LVL224:
 2437               	.L110:
 2438               	.LBB455:
 594:main.c        ****               temp_buf, (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
 2439               		.loc 1 594 0
 2440 0b72 B601      		movw r22,r12
 2441 0b74 CE01      		movw r24,r28
 2442 0b76 0196      		adiw r24,1
 2443 0b78 0E94 0000 		call porownaj_numer_telefonu_blok
 2444               	.LVL225:
 2445 0b7c 182F      		mov r17,r24
 2446 0b7e 8111      		cpse r24,__zero_reg__
 2447 0b80 00C0      		rjmp .L116
 2448 0b82 F5E0      		ldi r31,5
 2449 0b84 CF0E      		add r12,r31
 2450 0b86 D11C      		adc r13,__zero_reg__
 592:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 2451               		.loc 1 592 0
 2452 0b88 88EA      		ldi r24,-88
 2453 0b8a C816      		cp r12,r24
 2454 0b8c 8FE0      		ldi r24,15
 2455 0b8e D806      		cpc r13,r24
 2456 0b90 01F4      		brne .L110
 2457               	.L109:
 2458               	.LVL226:
 2459               	.LBE455:
 602:main.c        ****            (char *)numer_telefonu_do_ktorego_dzwonic);
 2460               		.loc 1 602 0
 2461 0b92 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 2462 0b94 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 2463 0b96 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 2464 0b98 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 2465 0b9a 0E94 0000 		call strcpy
 2466               	.LVL227:
 604:main.c        ****     if (znaleziono) {
 2467               		.loc 1 604 0
 2468 0b9e 60E0      		ldi r22,lo8(.LC4)
 2469 0ba0 70E0      		ldi r23,hi8(.LC4)
 2470 0ba2 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 2471 0ba4 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 2472 0ba6 0E94 0000 		call strcat
 2473               	.LVL228:
 606:main.c        ****     } else {
 2474               		.loc 1 606 0
 2475 0baa 60E0      		ldi r22,lo8(.LC5)
 2476 0bac 70E0      		ldi r23,hi8(.LC5)
 605:main.c        ****       strcat((char *)tekst_wysylanego_smsa, "OK");
 2477               		.loc 1 605 0
 2478 0bae 1111      		cpse r17,__zero_reg__
 2479 0bb0 00C0      		rjmp .L125
 2480               	.LVL229:
 608:main.c        ****     }
 2481               		.loc 1 608 0
 2482 0bb2 60E0      		ldi r22,lo8(.LC6)
 2483 0bb4 70E0      		ldi r23,hi8(.LC6)
 2484               	.LVL230:
 2485               	.L125:
 2486 0bb6 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 2487 0bb8 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 2488 0bba 0E94 0000 		call strcat
 2489               	.LVL231:
 611:main.c        **** 
 2490               		.loc 1 611 0
 2491 0bbe 82ED      		ldi r24,lo8(-46)
 2492 0bc0 0E94 0000 		call dodaj_komende
 2493               	.LVL232:
 613:main.c        **** 
 2494               		.loc 1 613 0
 2495 0bc4 82E0      		ldi r24,lo8(2)
 2496 0bc6 8093 0000 		sts liczba_blyskow_led,r24
 2497 0bca 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 617:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 2498               		.loc 1 617 0
 2499 0bce 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 2500 0bd2 8111      		cpse r24,__zero_reg__
 2501 0bd4 00C0      		rjmp .L113
 617:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 2502               		.loc 1 617 0 is_stmt 0 discriminator 1
 2503 0bd6 8091 0000 		lds r24,liczba_znakow_do_zapisu
 2504 0bda 8111      		cpse r24,__zero_reg__
 2505 0bdc 00C0      		rjmp .L113
 617:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 2506               		.loc 1 617 0 discriminator 2
 2507 0bde 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 2508 0be2 8111      		cpse r24,__zero_reg__
 2509 0be4 00C0      		rjmp .L113
 617:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 2510               		.loc 1 617 0 discriminator 3
 2511 0be6 8FB3      		in r24,0x1f
 2512               	.L113:
 625:main.c        ****     break;
 2513               		.loc 1 625 0 is_stmt 1
 2514 0be8 612F      		mov r22,r17
 2515 0bea 82E0      		ldi r24,lo8(2)
 2516 0bec 00C0      		rjmp .L128
 2517               	.LVL233:
 2518               	.L116:
 2519               	.LBB456:
 596:main.c        ****         break;
 2520               		.loc 1 596 0
 2521 0bee 1FEF      		ldi r17,lo8(-1)
 2522 0bf0 00C0      		rjmp .L109
 2523               	.LVL234:
 2524               	.L105:
 2525               	.LBE456:
 2526               	.LBE454:
 629:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 2527               		.loc 1 629 0
 2528 0bf2 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 2529 0bf4 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 2530 0bf6 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 2531 0bf8 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 2532 0bfa 0E94 0000 		call strcpy
 2533               	.LVL235:
 631:main.c        ****            "Wpisz numer jaki sprawdzasz, np: USER 793557357");
 2534               		.loc 1 631 0
 2535 0bfe 60E0      		ldi r22,lo8(.LC7)
 2536 0c00 70E0      		ldi r23,hi8(.LC7)
 2537 0c02 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 2538 0c04 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 2539 0c06 00C0      		rjmp .L129
 2540               	.LVL236:
 2541               	.L106:
 638:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 2542               		.loc 1 638 0
 2543 0c08 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 2544 0c0a 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 2545 0c0c 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 2546 0c0e 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 2547 0c10 0E94 0000 		call strcpy
 2548               	.LVL237:
 640:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW);
 2549               		.loc 1 640 0
 2550 0c14 1092 0000 		sts numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama,__zero_reg__
 641:main.c        ****     zapal_diode_led_blyski(2);
 2551               		.loc 1 641 0
 2552 0c18 88E8      		ldi r24,lo8(-120)
 2553 0c1a 00C0      		rjmp .L127
 2554               	.LVL238:
 2555               	.L108:
 646:main.c        ****             KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 2556               		.loc 1 646 0
 2557 0c1c 63E8      		ldi r22,lo8(-125)
 2558 0c1e 82E0      		ldi r24,lo8(2)
 2559 0c20 0E94 0000 		call czy_sa_komendy_z_przedzialu
 2560               	.LVL239:
 2561 0c24 8111      		cpse r24,__zero_reg__
 2562 0c26 00C0      		rjmp .L99
 649:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
 2563               		.loc 1 649 0
 2564 0c28 89E1      		ldi r24,lo8(25)
 2565 0c2a 8093 0000 		sts liczba_blyskow_led,r24
 2566 0c2e 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 650:main.c        ****     }
 2567               		.loc 1 650 0
 2568 0c32 83E0      		ldi r24,lo8(3)
 2569 0c34 0E94 0000 		call dodaj_komende
 2570               	.LVL240:
 2571 0c38 00C0      		rjmp .L99
 2572               		.cfi_endproc
 2573               	.LFE38:
 2575               	.global	steruj_wejsciem_reset_100ms
 2577               	steruj_wejsciem_reset_100ms:
 2578               	.LFB39:
 661:main.c        ****   static uchar licznik_reset;
 2579               		.loc 1 661 0
 2580               		.cfi_startproc
 2581               	/* prologue: function */
 2582               	/* frame size = 0 */
 2583               	/* stack size = 0 */
 2584               	.L__stack_usage = 0
 2585 0c3a 8091 0000 		lds r24,licznik_reset.3161
 663:main.c        ****     if (licznik_reset < 20 * 10)
 2586               		.loc 1 663 0
 2587 0c3e 9091 0000 		lds r25,stan_logiczny_na_wejsciu
 2588 0c42 90FF      		sbrs r25,0
 2589 0c44 00C0      		rjmp .L131
 664:main.c        ****       ++licznik_reset;
 2590               		.loc 1 664 0
 2591 0c46 883C      		cpi r24,lo8(-56)
 2592 0c48 00F4      		brsh .L130
 665:main.c        ****   } else {
 2593               		.loc 1 665 0
 2594 0c4a 8F5F      		subi r24,lo8(-(1))
 2595 0c4c 8093 0000 		sts licznik_reset.3161,r24
 2596 0c50 0895      		ret
 2597               	.L131:
 2598               	.LBB459:
 2599               	.LBB460:
 667:main.c        ****       if (not czy_sa_komendy_z_przedzialu(
 2600               		.loc 1 667 0
 2601 0c52 883C      		cpi r24,lo8(-56)
 2602 0c54 00F0      		brlo .L133
 668:main.c        ****               KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 2603               		.loc 1 668 0
 2604 0c56 63E8      		ldi r22,lo8(-125)
 2605 0c58 82E0      		ldi r24,lo8(2)
 2606 0c5a 0E94 0000 		call czy_sa_komendy_z_przedzialu
 2607               	.LVL241:
 2608 0c5e 8111      		cpse r24,__zero_reg__
 2609 0c60 00C0      		rjmp .L135
 671:main.c        ****     } else if (licznik_reset >= 5 * 10) {
 2610               		.loc 1 671 0
 2611 0c62 83E0      		ldi r24,lo8(3)
 2612               	.L137:
 676:main.c        ****     }
 2613               		.loc 1 676 0
 2614 0c64 0E94 0000 		call dodaj_komende
 2615               	.LVL242:
 2616               	.L135:
 678:main.c        ****   }
 2617               		.loc 1 678 0
 2618 0c68 1092 0000 		sts licznik_reset.3161,__zero_reg__
 2619               	.L130:
 2620               	/* epilogue start */
 2621               	.LBE460:
 2622               	.LBE459:
 680:main.c        **** 
 2623               		.loc 1 680 0
 2624 0c6c 0895      		ret
 2625               	.L133:
 2626               	.LBB462:
 2627               	.LBB461:
 672:main.c        ****       if (not czy_sa_komendy_z_przedzialu(
 2628               		.loc 1 672 0
 2629 0c6e 8233      		cpi r24,lo8(50)
 2630 0c70 00F0      		brlo .L135
 673:main.c        ****               KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 2631               		.loc 1 673 0
 2632 0c72 63E8      		ldi r22,lo8(-125)
 2633 0c74 82E0      		ldi r24,lo8(2)
 2634 0c76 0E94 0000 		call czy_sa_komendy_z_przedzialu
 2635               	.LVL243:
 2636 0c7a 8111      		cpse r24,__zero_reg__
 2637 0c7c 00C0      		rjmp .L135
 676:main.c        ****     }
 2638               		.loc 1 676 0
 2639 0c7e 82E0      		ldi r24,lo8(2)
 2640 0c80 00C0      		rjmp .L137
 2641               	.LBE461:
 2642               	.LBE462:
 2643               		.cfi_endproc
 2644               	.LFE39:
 2646               	.global	sprawdz_przychodzaca_rozmowe
 2648               	sprawdz_przychodzaca_rozmowe:
 2649               	.LFB40:
 683:main.c        ****   if (blokada_systemu) {
 2650               		.loc 1 683 0
 2651               		.cfi_startproc
 2652 0c82 CF93      		push r28
 2653               	.LCFI55:
 2654               		.cfi_def_cfa_offset 3
 2655               		.cfi_offset 28, -2
 2656 0c84 DF93      		push r29
 2657               	.LCFI56:
 2658               		.cfi_def_cfa_offset 4
 2659               		.cfi_offset 29, -3
 2660               	/* prologue: function */
 2661               	/* frame size = 0 */
 2662               	/* stack size = 2 */
 2663               	.L__stack_usage = 2
 684:main.c        ****     return FALSE; // Ignoruj rozmowy gdy system zablokowany
 2664               		.loc 1 684 0
 2665 0c86 8091 0000 		lds r24,blokada_systemu
 2666 0c8a 8823      		tst r24
 2667 0c8c 01F0      		breq .L139
 2668               	.L141:
 685:main.c        ****   }
 2669               		.loc 1 685 0
 2670 0c8e 80E0      		ldi r24,0
 2671               	.L138:
 2672               	/* epilogue start */
 729:main.c        **** 
 2673               		.loc 1 729 0
 2674 0c90 DF91      		pop r29
 2675 0c92 CF91      		pop r28
 2676 0c94 0895      		ret
 2677               	.L139:
 688:main.c        ****     return FALSE; // Ignoruj rozmowy gdy blokada czasowa
 2678               		.loc 1 688 0
 2679 0c96 8091 0000 		lds r24,blokada_sterowania_czasowa
 2680 0c9a 8111      		cpse r24,__zero_reg__
 2681 0c9c 00C0      		rjmp .L141
 2682 0c9e 8091 0000 		lds r24,numer_telefonu_ktory_dzwoni
 693:main.c        ****     if (numer_telefonu_ktory_dzwoni[0] != 0)
 2683               		.loc 1 693 0
 2684 0ca2 9091 0000 		lds r25,tryb_clip
 2685 0ca6 9111      		cpse r25,__zero_reg__
 2686 0ca8 00C0      		rjmp .L142
 694:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA);
 2687               		.loc 1 694 0
 2688 0caa 8823      		tst r24
 2689 0cac 01F0      		breq .L143
 695:main.c        **** 
 2690               		.loc 1 695 0
 2691 0cae 84E8      		ldi r24,lo8(-124)
 2692 0cb0 0E94 0000 		call dodaj_komende
 2693               	.LVL244:
 2694               	.L143:
 698:main.c        ****       return TRUE;
 2695               		.loc 1 698 0
 2696 0cb4 8091 0000 		lds r24,tryb_pracy
 2697 0cb8 8130      		cpi r24,lo8(1)
 2698 0cba 01F4      		brne .L144
 2699               	.L145:
 699:main.c        **** 
 2700               		.loc 1 699 0
 2701 0cbc 8FEF      		ldi r24,lo8(-1)
 2702 0cbe 00C0      		rjmp .L138
 2703               	.L144:
 2704               	.LBB466:
 2705               	.LBB467:
 704:main.c        ****                                          (char *)numer_telefonu_ktory_dzwoni)],
 2706               		.loc 1 704 0
 2707 0cc0 60E0      		ldi r22,lo8(numer_telefonu_ktory_dzwoni)
 2708 0cc2 70E0      		ldi r23,hi8(numer_telefonu_ktory_dzwoni)
 2709 0cc4 FB01      		movw r30,r22
 2710               		0:
 2711 0cc6 0190      		ld __tmp_reg__,Z+
 2712 0cc8 0020      		tst __tmp_reg__
 2713 0cca 01F4      		brne 0b
 2714 0ccc BF01      		movw r22,r30
 2715 0cce 6150      		subi r22,1
 2716 0cd0 7109      		sbc r23,__zero_reg__
 703:main.c        ****                                      &numer_telefonu_ktory_dzwoni[strlen(
 2717               		.loc 1 703 0
 2718 0cd2 40E0      		ldi r20,lo8(bufor_eeprom)
 2719 0cd4 50E0      		ldi r21,hi8(bufor_eeprom)
 2720 0cd6 80E0      		ldi r24,lo8(numer_telefonu_ktory_dzwoni)
 2721 0cd8 90E0      		ldi r25,hi8(numer_telefonu_ktory_dzwoni)
 2722 0cda 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 2723               	.LVL245:
 2724 0cde C8E0      		ldi r28,lo8(8)
 2725 0ce0 D0E0      		ldi r29,0
 2726               	.LVL246:
 2727               	.L146:
 2728               	.LBB468:
 711:main.c        ****               &bufor_eeprom[0], (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt))) {
 2729               		.loc 1 711 0
 2730 0ce2 BE01      		movw r22,r28
 2731 0ce4 80E0      		ldi r24,lo8(bufor_eeprom)
 2732 0ce6 90E0      		ldi r25,hi8(bufor_eeprom)
 2733 0ce8 0E94 0000 		call porownaj_numer_telefonu_blok
 2734               	.LVL247:
 2735 0cec 8111      		cpse r24,__zero_reg__
 2736 0cee 00C0      		rjmp .L145
 2737 0cf0 2596      		adiw r28,5
 709:main.c        ****          ++nr_uzyt) {
 2738               		.loc 1 709 0
 2739 0cf2 C83A      		cpi r28,-88
 2740 0cf4 FFE0      		ldi r31,15
 2741 0cf6 DF07      		cpc r29,r31
 2742 0cf8 01F4      		brne .L146
 2743 0cfa 00C0      		rjmp .L141
 2744               	.L142:
 2745               	.LBE468:
 2746               	.LBE467:
 2747               	.LBE466:
 720:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA);
 2748               		.loc 1 720 0
 2749 0cfc 8823      		tst r24
 2750 0cfe 01F0      		breq .L147
 721:main.c        **** 
 2751               		.loc 1 721 0
 2752 0d00 84E8      		ldi r24,lo8(-124)
 2753 0d02 0E94 0000 		call dodaj_komende
 2754               	.LVL248:
 2755               	.L147:
 724:main.c        ****     return TRUE;
 2756               		.loc 1 724 0
 2757 0d06 81E0      		ldi r24,lo8(1)
 2758 0d08 9091 0000 		lds r25,tryb_pracy
 2759 0d0c 9130      		cpi r25,lo8(1)
 2760 0d0e 01F0      		breq .L148
 2761 0d10 80E0      		ldi r24,0
 2762               	.L148:
 2763 0d12 8195      		neg r24
 2764 0d14 00C0      		rjmp .L138
 2765               		.cfi_endproc
 2766               	.LFE40:
 2768               	.global	zakonczono_rozmowe_telefoniczna
 2770               	zakonczono_rozmowe_telefoniczna:
 2771               	.LFB41:
 751:main.c        ****   POMOC_DODAJ2('#', 'a');
 2772               		.loc 1 751 0
 2773               		.cfi_startproc
 2774               	.LVL249:
 2775               	/* prologue: function */
 2776               	/* frame size = 0 */
 2777               	/* stack size = 0 */
 2778               	.L__stack_usage = 0
 753:main.c        ****   licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 2779               		.loc 1 753 0
 2780 0d16 8CE3      		ldi r24,lo8(60)
 2781               	.LVL250:
 2782 0d18 8093 0000 		sts opoznienie_SIM900_100MS,r24
 754:main.c        ****   ustaw_maksymalny_czas_dzwonienia = 0;
 2783               		.loc 1 754 0
 2784 0d1c 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 2785 0d20 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 755:main.c        ****   maksymalny_czas_dzwonienia = 0;
 2786               		.loc 1 755 0
 2787 0d24 1092 0000 		sts ustaw_maksymalny_czas_dzwonienia,__zero_reg__
 756:main.c        ****   blokada_clip = FALSE;
 2788               		.loc 1 756 0
 2789 0d28 1092 0000 		sts maksymalny_czas_dzwonienia,__zero_reg__
 757:main.c        **** }
 2790               		.loc 1 757 0
 2791 0d2c 1092 0000 		sts blokada_clip,__zero_reg__
 2792               	/* epilogue start */
 758:main.c        **** 
 2793               		.loc 1 758 0
 2794 0d30 0895      		ret
 2795               		.cfi_endproc
 2796               	.LFE41:
 2798               	.global	zakonczono_wysylanie_smsa
 2800               	zakonczono_wysylanie_smsa:
 2801               	.LFB42:
 767:main.c        ****   POMOC_DODAJ2('#', 'A');
 2802               		.loc 1 767 0
 2803               		.cfi_startproc
 2804               	.LVL251:
 2805               	/* prologue: function */
 2806               	/* frame size = 0 */
 2807               	/* stack size = 0 */
 2808               	.L__stack_usage = 0
 769:main.c        **** 
 2809               		.loc 1 769 0
 2810 0d32 8CE3      		ldi r24,lo8(60)
 2811               	.LVL252:
 2812 0d34 8093 0000 		sts opoznienie_SIM900_100MS,r24
 771:main.c        **** }
 2813               		.loc 1 771 0
 2814 0d38 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 2815               	/* epilogue start */
 772:main.c        **** 
 2816               		.loc 1 772 0
 2817 0d3c 0895      		ret
 2818               		.cfi_endproc
 2819               	.LFE42:
 2821               	.global	problem_z_wyslaniem_powiadomienia
 2823               	problem_z_wyslaniem_powiadomienia:
 2824               	.LFB43:
 774:main.c        ****   wykonywanie_rozmowy_telefonicznej = FALSE;
 2825               		.loc 1 774 0
 2826               		.cfi_startproc
 2827               	/* prologue: function */
 2828               	/* frame size = 0 */
 2829               	/* stack size = 0 */
 2830               	.L__stack_usage = 0
 775:main.c        ****   licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 2831               		.loc 1 775 0
 2832 0d3e 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 776:main.c        ****   wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 2833               		.loc 1 776 0
 2834 0d42 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 2835 0d46 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 777:main.c        ****   czekanie_na_odebranie_zachety = FALSE;
 2836               		.loc 1 777 0
 2837 0d4a 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 2838 0d4e 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 2839 0d52 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
 778:main.c        ****   opoznienie_SIM900_100MS = 60;
 2840               		.loc 1 778 0
 2841 0d56 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
 779:main.c        ****   flaga_wysylanie_smsa = 0;
 2842               		.loc 1 779 0
 2843 0d5a 8CE3      		ldi r24,lo8(60)
 2844 0d5c 8093 0000 		sts opoznienie_SIM900_100MS,r24
 780:main.c        **** }
 2845               		.loc 1 780 0
 2846 0d60 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
 2847               	/* epilogue start */
 781:main.c        **** 
 2848               		.loc 1 781 0
 2849 0d64 0895      		ret
 2850               		.cfi_endproc
 2851               	.LFE43:
 2853               	.global	wyzerowanie_danych_SIM900
 2855               	wyzerowanie_danych_SIM900:
 2856               	.LFB44:
   6:main_sim900.h ****   POMOC_DODAJ2('*', 't');
 2857               		.loc 2 6 0
 2858               		.cfi_startproc
 2859               	/* prologue: function */
 2860               	/* frame size = 0 */
 2861               	/* stack size = 0 */
 2862               	.L__stack_usage = 0
 2863               	.LVL253:
   8:main_sim900.h ****   licznik_wysylane_polecenie_SIM900 = 0;
 2864               		.loc 2 8 0
 2865 0d66 0E94 0000 		call problem_z_wyslaniem_powiadomienia
 2866               	.LVL254:
   9:main_sim900.h ****   aktualnie_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 2867               		.loc 2 9 0
 2868 0d6a 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 2869 0d6e 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
  10:main_sim900.h ****   liczba_komend_w_kolejce_SIM900 = 0;
 2870               		.loc 2 10 0
 2871 0d72 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
  11:main_sim900.h ****   licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow = 0;
 2872               		.loc 2 11 0
 2873 0d76 1092 0000 		sts liczba_komend_w_kolejce_SIM900,__zero_reg__
  12:main_sim900.h ****   czekanie_na_odebranie_zachety = FALSE;
 2874               		.loc 2 12 0
 2875 0d7a 1092 0000 		sts licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow,__zero_reg__
  13:main_sim900.h ****   flaga_odebrany_znak_zachety = FALSE;
 2876               		.loc 2 13 0
 2877 0d7e 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
  14:main_sim900.h ****   trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 2878               		.loc 2 14 0
 2879 0d82 1092 0000 		sts flaga_odebrany_znak_zachety,__zero_reg__
  15:main_sim900.h ****   wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
 2880               		.loc 2 15 0
 2881 0d86 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
  16:main_sim900.h ****   flaga_odczytywanie_smsa = FALSE;
 2882               		.loc 2 16 0
 2883 0d8a 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
  17:main_sim900.h **** }
 2884               		.loc 2 17 0
 2885 0d8e 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 2886               	/* epilogue start */
  18:main_sim900.h **** 
 2887               		.loc 2 18 0
 2888 0d92 0895      		ret
 2889               		.cfi_endproc
 2890               	.LFE44:
 2892               	.global	reset_modulu_SIM900
 2894               	reset_modulu_SIM900:
 2895               	.LFB45:
  20:main_sim900.h ****   wyzerowanie_danych_SIM900();
 2896               		.loc 2 20 0
 2897               		.cfi_startproc
 2898               	/* prologue: function */
 2899               	/* frame size = 0 */
 2900               	/* stack size = 0 */
 2901               	.L__stack_usage = 0
  21:main_sim900.h ****   POMOC_DODAJ2('*', 'm');
 2902               		.loc 2 21 0
 2903 0d94 0E94 0000 		call wyzerowanie_danych_SIM900
 2904               	.LVL255:
  23:main_sim900.h ****   podlaczony_modul_gsm_SIM900 = FALSE;
 2905               		.loc 2 23 0
 2906 0d98 86E9      		ldi r24,lo8(-106)
 2907 0d9a 8093 0000 		sts licznik_100ms_procedura_inicjalizacyjna_SIM900,r24
  24:main_sim900.h ****   podlaczona_karta_SIM_SIM900 = FALSE;
 2908               		.loc 2 24 0
 2909 0d9e 1092 0000 		sts podlaczony_modul_gsm_SIM900,__zero_reg__
  25:main_sim900.h ****   licznik_blad_stanu_karty_SIM = 0;
 2910               		.loc 2 25 0
 2911 0da2 1092 0000 		sts podlaczona_karta_SIM_SIM900,__zero_reg__
  26:main_sim900.h ****   licznik_blad_zalogowania_u_operatora = 0;
 2912               		.loc 2 26 0
 2913 0da6 1092 0000 		sts licznik_blad_stanu_karty_SIM,__zero_reg__
  27:main_sim900.h ****   nazwa_operatora[0] = '\0';
 2914               		.loc 2 27 0
 2915 0daa 1092 0000 		sts licznik_blad_zalogowania_u_operatora,__zero_reg__
  28:main_sim900.h ****   licznik_ogolny_blad_zalogowania = 0;
 2916               		.loc 2 28 0
 2917 0dae 1092 0000 		sts nazwa_operatora,__zero_reg__
  29:main_sim900.h ****   blokada_clip = FALSE;
 2918               		.loc 2 29 0
 2919 0db2 1092 0000 		sts licznik_ogolny_blad_zalogowania+1,__zero_reg__
 2920 0db6 1092 0000 		sts licznik_ogolny_blad_zalogowania,__zero_reg__
  30:main_sim900.h ****   nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 2921               		.loc 2 30 0
 2922 0dba 1092 0000 		sts blokada_clip,__zero_reg__
  31:main_sim900.h ****   poziom_sieci_gsm = POZIOM_SIECI_BLAD;
 2923               		.loc 2 31 0
 2924 0dbe 1092 0000 		sts nastepne_wysylane_polecenie_SIM900,__zero_reg__
  32:main_sim900.h ****   filtruj_komendy_z_przedzialu(KOMENDA_KOLEJKI_USUN_SMSA_1,
 2925               		.loc 2 32 0
 2926 0dc2 83E6      		ldi r24,lo8(99)
 2927 0dc4 8093 0000 		sts poziom_sieci_gsm,r24
  33:main_sim900.h ****                                KOMENDA_KOLEJKI_USUN_SMSA_20);
 2928               		.loc 2 33 0
 2929 0dc8 60ED      		ldi r22,lo8(-48)
 2930 0dca 8DEB      		ldi r24,lo8(-67)
 2931 0dcc 0E94 0000 		call filtruj_komendy_z_przedzialu
 2932               	.LVL256:
  35:main_sim900.h ****       KOMENDA_KOLEJKI_KOMENDA_SIM900,
 2933               		.loc 2 35 0
 2934 0dd0 6DE9      		ldi r22,lo8(-99)
 2935 0dd2 89E8      		ldi r24,lo8(-119)
 2936 0dd4 0E94 0000 		call filtruj_komendy_z_przedzialu
 2937               	.LVL257:
  38:main_sim900.h ****       KOMENDA_KOLEJKI_SPRAWDZ_PIN,
 2938               		.loc 2 38 0
 2939 0dd8 67EA      		ldi r22,lo8(-89)
 2940 0dda 8EE9      		ldi r24,lo8(-98)
 2941 0ddc 0E94 0000 		call filtruj_komendy_z_przedzialu
 2942               	.LVL258:
  41:main_sim900.h ****                                KOMENDA_KOLEJKI_WYSLIJ_PDU);
 2943               		.loc 2 41 0
 2944 0de0 64ED      		ldi r22,lo8(-44)
 2945 0de2 82ED      		ldi r24,lo8(-46)
 2946 0de4 0E94 0000 		call filtruj_komendy_z_przedzialu
 2947               	.LVL259:
  43:main_sim900.h **** }
 2948               		.loc 2 43 0
 2949 0de8 1092 0000 		sts modul_zalogowany_w_sieci,__zero_reg__
 2950               	/* epilogue start */
  44:main_sim900.h **** 
 2951               		.loc 2 44 0
 2952 0dec 0895      		ret
 2953               		.cfi_endproc
 2954               	.LFE45:
 2956               	.global	obsluga_wysylania_sms
 2958               	obsluga_wysylania_sms:
 2959               	.LFB48:
  52:main_sim900.h **** }
  53:main_sim900.h **** 
  54:main_sim900.h **** void obsluga_wysylania_sms(void) {
 2960               		.loc 2 54 0
 2961               		.cfi_startproc
 2962               	/* prologue: function */
 2963               	/* frame size = 0 */
 2964               	/* stack size = 0 */
 2965               	.L__stack_usage = 0
 2966               	.LVL260:
  55:main_sim900.h ****   POMOC_DODAJ2('#', 'M');
  56:main_sim900.h ****   if (czy_jest_komenda_wyslano_sms()) {
 2967               		.loc 2 56 0
 2968 0dee 8091 0000 		lds r24,komenda_SIM900
 2969 0df2 8D30      		cpi r24,lo8(13)
 2970 0df4 01F4      		brne .L165
 2971               	.LVL261:
  57:main_sim900.h ****     POMOC_DODAJ2('#', 'T');
  58:main_sim900.h ****     liczba_prob_wyslania_smsa = 0;
 2972               		.loc 2 58 0
 2973 0df6 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
 2974               	.LVL262:
 2975               	.LBB489:
 2976               	.LBB490:
 771:main.c        **** }
 2977               		.loc 1 771 0
 2978 0dfa 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 2979               	.LBE490:
 2980               	.LBE489:
  59:main_sim900.h ****     zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_ok);
  60:main_sim900.h ****     flaga_wysylanie_smsa = 0;
 2981               		.loc 2 60 0
 2982 0dfe 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
  61:main_sim900.h ****     opoznienie_SIM900_100MS = 70;
 2983               		.loc 2 61 0
 2984 0e02 86E4      		ldi r24,lo8(70)
 2985 0e04 8093 0000 		sts opoznienie_SIM900_100MS,r24
  62:main_sim900.h ****     return;
 2986               		.loc 2 62 0
 2987 0e08 0895      		ret
 2988               	.LVL263:
 2989               	.L165:
  63:main_sim900.h ****   } else if (
  64:main_sim900.h ****       czy_jest_komenda_blad_CMS()) // spawdzi
 2990               		.loc 2 64 0
 2991 0e0a 8091 0000 		lds r24,komenda_SIM900
  63:main_sim900.h ****   } else if (
 2992               		.loc 2 63 0
 2993 0e0e 8630      		cpi r24,lo8(6)
 2994 0e10 01F4      		brne .L167
  65:main_sim900.h ****                                    // czy_modul_byl_polaczony_z_internetem
  66:main_sim900.h ****   {
  67:main_sim900.h ****     ++liczba_prob_wyslania_smsa;
 2995               		.loc 2 67 0
 2996 0e12 2091 0000 		lds r18,liczba_prob_wyslania_smsa
 2997 0e16 2F5F      		subi r18,lo8(-(1))
 2998 0e18 2093 0000 		sts liczba_prob_wyslania_smsa,r18
  68:main_sim900.h ****     if (numer_bledu_cms == CMS_SM_BL_NOT_READY ||
 2999               		.loc 2 68 0
 3000 0e1c 8091 0000 		lds r24,numer_bledu_cms
 3001 0e20 9091 0000 		lds r25,numer_bledu_cms+1
 3002 0e24 8530      		cpi r24,5
 3003 0e26 32E0      		ldi r19,2
 3004 0e28 9307      		cpc r25,r19
 3005 0e2a 01F0      		breq .L168
 3006               		.loc 2 68 0 is_stmt 0 discriminator 1
 3007 0e2c 8A33      		cpi r24,58
 3008 0e2e 31E0      		ldi r19,1
 3009 0e30 9307      		cpc r25,r19
 3010 0e32 01F0      		breq .L168
  69:main_sim900.h ****         numer_bledu_cms == CMS_SIM_BUSY ||
 3011               		.loc 2 69 0 is_stmt 1
 3012 0e34 8330      		cpi r24,3
 3013 0e36 32E0      		ldi r19,2
 3014 0e38 9307      		cpc r25,r19
 3015 0e3a 01F0      		breq .L168
  70:main_sim900.h ****         numer_bledu_cms == CMS_PC_BUSY // powinien by reset
  71:main_sim900.h ****         || numer_bledu_cms == CMS_INVALID_CHARS_IN_PDU ||
 3016               		.loc 2 71 0
 3017 0e3c 8051      		subi r24,16
 3018 0e3e 9240      		sbci r25,2
 3019 0e40 0297      		sbiw r24,2
 3020 0e42 00F4      		brsh .L169
 3021               	.L168:
  72:main_sim900.h ****         numer_bledu_cms == CMS_INCORECT_PDU_LENGTH) {
  73:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 3022               		.loc 2 73 0
 3023 0e44 8CE3      		ldi r24,lo8(60)
 3024 0e46 8093 0000 		sts opoznienie_SIM900_100MS,r24
  74:main_sim900.h ****       if (liczba_prob_wyslania_smsa < max_liczba_prob_wyslania_smsa) {
  75:main_sim900.h ****         POMOC_DODAJ2('#', 'C');
  76:main_sim900.h ****         POMOC_DODAJ_HEX(numer_bledu_cms >> 8);
  77:main_sim900.h ****         POMOC_DODAJ_HEX(numer_bledu_cms & 0xff);
  78:main_sim900.h ****         dodaj_komende(flaga_wysylanie_smsa);
 3025               		.loc 2 78 0
 3026 0e4a 8091 0000 		lds r24,flaga_wysylanie_smsa
  74:main_sim900.h ****       if (liczba_prob_wyslania_smsa < max_liczba_prob_wyslania_smsa) {
 3027               		.loc 2 74 0
 3028 0e4e 2230      		cpi r18,lo8(2)
 3029 0e50 00F0      		brlo .L193
 3030               	.LVL264:
 3031               	.L194:
  79:main_sim900.h ****       } else {
  80:main_sim900.h ****         POMOC_DODAJ2('#', 'D');
  81:main_sim900.h ****         POMOC_DODAJ_HEX(numer_bledu_cms >> 8);
  82:main_sim900.h ****         POMOC_DODAJ_HEX(numer_bledu_cms & 0xff);
  83:main_sim900.h ****         liczba_prob_wyslania_smsa = 0;
  84:main_sim900.h ****         zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
  85:main_sim900.h ****       }
  86:main_sim900.h ****     } else {
  87:main_sim900.h ****       POMOC_DODAJ2('#', 'F');
  88:main_sim900.h ****       POMOC_DODAJ_HEX(numer_bledu_cms >> 8);
  89:main_sim900.h ****       POMOC_DODAJ_HEX(numer_bledu_cms & 0xff);
  90:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
  91:main_sim900.h ****       liczba_prob_wyslania_smsa = 0;
 3032               		.loc 2 91 0
 3033 0e52 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
 3034               	.LVL265:
 3035               	.LBB491:
 3036               	.LBB492:
 771:main.c        **** }
 3037               		.loc 1 771 0
 3038 0e56 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 3039               	.LVL266:
 3040               	.L171:
 3041               	.LBE492:
 3042               	.LBE491:
  92:main_sim900.h ****       zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
  93:main_sim900.h ****     }
  94:main_sim900.h ****     flaga_wysylanie_smsa = 0;
 3043               		.loc 2 94 0
 3044 0e5a 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
 3045 0e5e 0895      		ret
 3046               	.LVL267:
 3047               	.L169:
  90:main_sim900.h ****       liczba_prob_wyslania_smsa = 0;
 3048               		.loc 2 90 0
 3049 0e60 8CE3      		ldi r24,lo8(60)
 3050 0e62 8093 0000 		sts opoznienie_SIM900_100MS,r24
 3051 0e66 00C0      		rjmp .L194
 3052               	.LVL268:
 3053               	.L167:
 3054               	.LBB493:
 3055               	.LBB494:
  95:main_sim900.h ****   } else if (czy_jest_komenda_ERROR()) {
 3056               		.loc 2 95 0
 3057 0e68 8091 0000 		lds r24,komenda_SIM900
 3058 0e6c 8430      		cpi r24,lo8(4)
 3059 0e6e 01F4      		brne .L172
 3060               	.LVL269:
  96:main_sim900.h ****     POMOC_DODAJ2('#', 'G');
  97:main_sim900.h ****     opoznienie_SIM900_100MS = 60;
 3061               		.loc 2 97 0
 3062 0e70 8CE3      		ldi r24,lo8(60)
 3063 0e72 8093 0000 		sts opoznienie_SIM900_100MS,r24
  98:main_sim900.h ****     czekanie_na_odebranie_zachety = FALSE;
 3064               		.loc 2 98 0
 3065 0e76 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
  99:main_sim900.h ****     if ((odebrany_blok_SIM900[2] == '>' &&
 3066               		.loc 2 99 0
 3067 0e7a 8091 0000 		lds r24,odebrany_blok_SIM900+2
 3068 0e7e 8E33      		cpi r24,lo8(62)
 3069 0e80 01F4      		brne .L173
 100:main_sim900.h ****          liczba_odebranych_znakow_SIM900 < 10) ||
 3070               		.loc 2 100 0
 3071 0e82 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 3072 0e86 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
  99:main_sim900.h ****     if ((odebrany_blok_SIM900[2] == '>' &&
 3073               		.loc 2 99 0
 3074 0e8a 0A97      		sbiw r24,10
 3075 0e8c 00F0      		brlo .L174
 3076               	.L173:
 101:main_sim900.h ****         flaga_wysylanie_smsa == 0) // SIM900 nie odpowiada
 3077               		.loc 2 101 0
 3078 0e8e 8091 0000 		lds r24,flaga_wysylanie_smsa
 100:main_sim900.h ****          liczba_odebranych_znakow_SIM900 < 10) ||
 3079               		.loc 2 100 0
 3080 0e92 8111      		cpse r24,__zero_reg__
 3081 0e94 00C0      		rjmp .L175
 3082               	.L174:
 3083               	.LVL270:
 102:main_sim900.h ****     {
 103:main_sim900.h ****       POMOC_DODAJ2('#', 'H');
 104:main_sim900.h ****       liczba_prob_wyslania_smsa = 0;
 3084               		.loc 2 104 0
 3085 0e96 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
 3086               	.LVL271:
 3087               	.LBB495:
 3088               	.LBB496:
 771:main.c        **** }
 3089               		.loc 1 771 0
 3090 0e9a 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 3091               	.LBE496:
 3092               	.LBE495:
 105:main_sim900.h ****       zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
 106:main_sim900.h ****       reset_modulu_SIM900();
 3093               		.loc 2 106 0
 3094 0e9e 0E94 0000 		call reset_modulu_SIM900
 3095               	.LVL272:
 3096 0ea2 00C0      		rjmp .L171
 3097               	.LVL273:
 3098               	.L175:
 107:main_sim900.h ****     } else {
 108:main_sim900.h ****       POMOC_DODAJ2('#', 'I');
 109:main_sim900.h ****       if (++liczba_prob_wyslania_smsa <
 3099               		.loc 2 109 0
 3100 0ea4 9091 0000 		lds r25,liczba_prob_wyslania_smsa
 3101 0ea8 9F5F      		subi r25,lo8(-(1))
 3102 0eaa 9093 0000 		sts liczba_prob_wyslania_smsa,r25
 3103 0eae 9230      		cpi r25,lo8(2)
 3104 0eb0 00F4      		brsh .L194
 3105               	.LVL274:
 3106               	.L193:
 110:main_sim900.h ****           max_liczba_prob_wyslania_smsa) // musi by sta wartoci
 111:main_sim900.h ****         dodaj_komende(flaga_wysylanie_smsa);
 3107               		.loc 2 111 0
 3108 0eb2 0E94 0000 		call dodaj_komende
 3109               	.LVL275:
 3110 0eb6 00C0      		rjmp .L171
 3111               	.LVL276:
 3112               	.L172:
 112:main_sim900.h ****       else {
 113:main_sim900.h ****         liczba_prob_wyslania_smsa = 0;
 114:main_sim900.h ****         zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
 115:main_sim900.h ****       }
 116:main_sim900.h ****     }
 117:main_sim900.h ****     flaga_wysylanie_smsa = 0;
 118:main_sim900.h ****   } else if (czy_jest_komenda_blad_CME()) {
 3113               		.loc 2 118 0
 3114 0eb8 8091 0000 		lds r24,komenda_SIM900
 3115 0ebc 8530      		cpi r24,lo8(5)
 3116 0ebe 01F4      		brne .L176
 3117               	.LVL277:
 119:main_sim900.h ****     POMOC_DODAJ2('#', 'J');
 120:main_sim900.h ****     POMOC_DODAJ_HEX(numer_bledu_cme >> 8);
 3118               		.loc 2 120 0
 3119 0ec0 8091 0000 		lds r24,numer_bledu_cme
 3120 0ec4 9091 0000 		lds r25,numer_bledu_cme+1
 3121               	.LVL278:
 121:main_sim900.h ****     POMOC_DODAJ_HEX(numer_bledu_cme & 0xff);
 122:main_sim900.h ****     if (numer_bledu_cme == CME_SIM_NOT_INSERTED ||
 3122               		.loc 2 122 0
 3123 0ec8 8A30      		cpi r24,10
 3124 0eca 9105      		cpc r25,__zero_reg__
 3125 0ecc 01F0      		breq .L177
 3126 0ece 9C01      		movw r18,r24
 3127 0ed0 2D7F      		andi r18,253
 3128 0ed2 2D30      		cpi r18,13
 3129 0ed4 3105      		cpc r19,__zero_reg__
 3130 0ed6 01F0      		breq .L177
 123:main_sim900.h ****         numer_bledu_cme == CME_SIM_FAILURE ||
 124:main_sim900.h ****         numer_bledu_cme == CME_SIM_WRONG ||
 3131               		.loc 2 124 0
 3132 0ed8 4E97      		sbiw r24,30
 3133 0eda 01F4      		brne .L164
 3134               	.L177:
 3135               	.LVL279:
 125:main_sim900.h ****         numer_bledu_cme == CME_NO_NETWORK_SERVICE) {
 126:main_sim900.h ****       POMOC_DODAJ2('#', 'K');
 127:main_sim900.h ****       liczba_prob_wyslania_smsa = 0;
 3136               		.loc 2 127 0
 3137 0edc 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
 3138               	.LVL280:
 3139               	.LBB497:
 3140               	.LBB498:
 769:main.c        **** 
 3141               		.loc 1 769 0
 3142 0ee0 8CE3      		ldi r24,lo8(60)
 3143               	.LVL281:
 3144 0ee2 8093 0000 		sts opoznienie_SIM900_100MS,r24
 771:main.c        **** }
 3145               		.loc 1 771 0
 3146 0ee6 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 3147               	.LBE498:
 3148               	.LBE497:
 128:main_sim900.h ****       zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
 129:main_sim900.h ****       reset_modulu_SIM900();
 3149               		.loc 2 129 0
 3150 0eea 0C94 0000 		jmp reset_modulu_SIM900
 3151               	.LVL282:
 3152               	.L176:
 130:main_sim900.h ****     }
 131:main_sim900.h ****   } else {
 132:main_sim900.h ****     POMOC_DODAJ2('#', 'L');
 133:main_sim900.h ****     POMOC_DODAJ_HEX(komenda_SIM900 >> 8);
 3153               		.loc 2 133 0
 3154 0eee 8091 0000 		lds r24,komenda_SIM900
 3155               	.LVL283:
 134:main_sim900.h ****     POMOC_DODAJ_HEX(komenda_SIM900 & 0xff);
 3156               		.loc 2 134 0
 3157 0ef2 8091 0000 		lds r24,komenda_SIM900
 3158               	.LVL284:
 3159               	.L164:
 3160               	/* epilogue start */
 3161               	.LBE494:
 3162               	.LBE493:
 135:main_sim900.h ****   }
 136:main_sim900.h **** }
 3163               		.loc 2 136 0
 3164 0ef6 0895      		ret
 3165               		.cfi_endproc
 3166               	.LFE48:
 3168               	.global	odpowiedz_na_polecenie
 3170               	odpowiedz_na_polecenie:
 3171               	.LFB49:
 137:main_sim900.h **** 
 138:main_sim900.h **** void odpowiedz_na_polecenie(void) {
 3172               		.loc 2 138 0
 3173               		.cfi_startproc
 3174 0ef8 0F93      		push r16
 3175               	.LCFI57:
 3176               		.cfi_def_cfa_offset 3
 3177               		.cfi_offset 16, -2
 3178 0efa 1F93      		push r17
 3179               	.LCFI58:
 3180               		.cfi_def_cfa_offset 4
 3181               		.cfi_offset 17, -3
 3182 0efc CF93      		push r28
 3183               	.LCFI59:
 3184               		.cfi_def_cfa_offset 5
 3185               		.cfi_offset 28, -4
 3186 0efe DF93      		push r29
 3187               	.LCFI60:
 3188               		.cfi_def_cfa_offset 6
 3189               		.cfi_offset 29, -5
 3190               	/* prologue: function */
 3191               	/* frame size = 0 */
 3192               	/* stack size = 4 */
 3193               	.L__stack_usage = 4
 139:main_sim900.h **** #define czy_polecenie_sim(POL) czy_polecenie_SIM900(POL, sizeof POL - 1)
 140:main_sim900.h ****   const uchar kom = komenda_SIM900;
 3194               		.loc 2 140 0
 3195 0f00 D091 0000 		lds r29,komenda_SIM900
 3196               	.LVL285:
 141:main_sim900.h **** 
 142:main_sim900.h ****   switch (aktualnie_wysylane_polecenie_SIM900) {
 3197               		.loc 2 142 0
 3198 0f04 C091 0000 		lds r28,aktualnie_wysylane_polecenie_SIM900
 3199 0f08 CD39      		cpi r28,lo8(-99)
 3200 0f0a 01F4      		brne .+2
 3201 0f0c 00C0      		rjmp .L197
 3202 0f0e 00F0      		brlo .+2
 3203 0f10 00C0      		rjmp .L198
 3204 0f12 C439      		cpi r28,lo8(-108)
 3205 0f14 01F4      		brne .+2
 3206 0f16 00C0      		rjmp .L199
 3207 0f18 00F4      		brsh .L200
 3208 0f1a CE38      		cpi r28,lo8(-114)
 3209 0f1c 01F4      		brne .+2
 3210 0f1e 00C0      		rjmp .L201
 3211 0f20 00F4      		brsh .L202
 3212 0f22 CB38      		cpi r28,lo8(-117)
 3213 0f24 01F4      		brne .+2
 3214 0f26 00C0      		rjmp .L203
 3215 0f28 CD38      		cpi r28,lo8(-115)
 3216 0f2a 01F4      		brne .+2
 3217 0f2c 00C0      		rjmp .L204
 3218               	.L196:
 143:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 144:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_ODEBRANO_POLECENIE_ROZPOCZYNAJACE);
 145:main_sim900.h ****     max_oczekiwanie_na_odpowiedz_at = 0;
 146:main_sim900.h ****     break;
 147:main_sim900.h ****   }
 148:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE: {
 149:main_sim900.h ****     static const char polecenie_zegar[] PROGMEM = "+CCLK:";
 150:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 &&
 151:main_sim900.h ****         polozenie_polecenia_SIM900(polecenie_zegar) != NULL) {
 152:main_sim900.h ****       const uchar *p1 =
 153:main_sim900.h ****           strchr(polozenie_polecenia_SIM900(polecenie_zegar), '\"');
 154:main_sim900.h ****       if (p1++ != NULL) {
 155:main_sim900.h ****         const uchar *p2 = strchr(p1, '\"');
 156:main_sim900.h ****         const uchar *p3 = strchr(p1, ',');
 157:main_sim900.h ****         if (p2 != NULL && p3++ != NULL && p2 > p3) {
 158:main_sim900.h ****           // const uchar g = atoi(p3);
 159:main_sim900.h ****           if ((p3 = strchr(p3, ':')) != NULL && p2 > p3++) {
 160:main_sim900.h ****             // Pobierz czas z odpowiedzi +CCLK: "yy/MM/dd,hh:mm:ss+zz"
 161:main_sim900.h ****             // p3 wskazuje na minuty po pierwszym ':'
 162:main_sim900.h ****             // cofnijmy si do pocztku godziny (p3 wskazuje na mm, wic -3 to hh)
 163:main_sim900.h ****             // ale w kodzie powyej p3 byo przesuwane.
 164:main_sim900.h **** 
 165:main_sim900.h ****             // Restart parsowania dla pewnoci:
 166:main_sim900.h ****             // "24/01/01,12:34:56+00"
 167:main_sim900.h ****             const char *ptr_time = strchr(p1, ',');
 168:main_sim900.h ****             if (ptr_time) {
 169:main_sim900.h ****               ptr_time++; // skip comma
 170:main_sim900.h ****               if (strlen(ptr_time) >= 8) {
 171:main_sim900.h ****                 memcpy(rtc_czas, ptr_time, 8);
 172:main_sim900.h ****                 rtc_czas[8] = '\0';
 173:main_sim900.h **** 
 174:main_sim900.h ****                 // Aktualizacja blokady czasowej
 175:main_sim900.h ****                 if (czas_start_h == 0xFF) {
 176:main_sim900.h ****                   blokada_sterowania_czasowa = FALSE;
 177:main_sim900.h ****                 } else {
 178:main_sim900.h ****                   // Parsowanie aktualnego czasu
 179:main_sim900.h ****                   int curr_h = (rtc_czas[0] - '0') * 10 + (rtc_czas[1] - '0');
 180:main_sim900.h ****                   int curr_m = (rtc_czas[3] - '0') * 10 + (rtc_czas[4] - '0');
 181:main_sim900.h ****                   int curr_time = curr_h * 60 + curr_m;
 182:main_sim900.h **** 
 183:main_sim900.h ****                   int start_time = czas_start_h * 60 + czas_start_m;
 184:main_sim900.h ****                   int stop_time = czas_stop_h * 60 + czas_stop_m;
 185:main_sim900.h **** 
 186:main_sim900.h ****                   if (start_time <= stop_time) {
 187:main_sim900.h ****                     // Normalny przedzial (np. 08:00 - 16:00)
 188:main_sim900.h ****                     if (curr_time >= start_time && curr_time <= stop_time)
 189:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 190:main_sim900.h ****                     else
 191:main_sim900.h ****                       blokada_sterowania_czasowa = TRUE;
 192:main_sim900.h ****                   } else {
 193:main_sim900.h ****                     // Przejscie przez polnoc (np. 22:00 - 06:00)
 194:main_sim900.h ****                     if (curr_time >= start_time || curr_time <= stop_time)
 195:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 196:main_sim900.h ****                     else
 197:main_sim900.h ****                       blokada_sterowania_czasowa = TRUE;
 198:main_sim900.h ****                   }
 199:main_sim900.h ****                 }
 200:main_sim900.h ****               }
 201:main_sim900.h ****             }
 202:main_sim900.h ****           }
 203:main_sim900.h ****         }
 204:main_sim900.h ****       }
 205:main_sim900.h ****     }
 206:main_sim900.h ****     break;
 207:main_sim900.h ****   }
 208:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_PIN: {
 209:main_sim900.h ****     static const char polecenie_pin_ready[] PROGMEM = "+CPIN: READY";
 210:main_sim900.h ****     static uchar nr_zapytania_o_pin;
 211:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 212:main_sim900.h ****       if (polozenie_polecenia_SIM900(polecenie_pin_ready) != NULL) {
 213:main_sim900.h ****         podlaczona_karta_SIM_SIM900 = TRUE;
 214:main_sim900.h ****         bledny_PIN = FALSE;
 215:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 216:main_sim900.h ****       } else
 217:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_PODAJ_PIN);
 218:main_sim900.h ****       nr_zapytania_o_pin = 0;
 219:main_sim900.h ****     } else if (kom == CME_ERROR_KOMENDA_SIM900 &&
 220:main_sim900.h ****                numer_bledu_cme == CME_SIM_BUSY)
 221:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 222:main_sim900.h ****     else if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900()) {
 223:main_sim900.h ****       if (++nr_zapytania_o_pin >= 20) {
 224:main_sim900.h ****         reset_modulu_SIM900();
 225:main_sim900.h ****         nr_zapytania_o_pin = 0;
 226:main_sim900.h ****       } else {
 227:main_sim900.h ****         opoznienie_SIM900_100MS = 20;
 228:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 229:main_sim900.h ****       }
 230:main_sim900.h ****     } else
 231:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 232:main_sim900.h ****     break;
 233:main_sim900.h ****   }
 234:main_sim900.h ****   case KOMENDA_KOLEJKI_PODAJ_PIN: {
 235:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 236:main_sim900.h ****       podlaczona_karta_SIM_SIM900 = TRUE;
 237:main_sim900.h ****       bledny_PIN = FALSE;
 238:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 239:main_sim900.h ****       opoznienie_SIM900_100MS = 50;
 240:main_sim900.h ****     } else if (kom == CME_ERROR_KOMENDA_SIM900 &&
 241:main_sim900.h ****                numer_bledu_cme == CME_SIM_INCORECT_PASWORD)
 242:main_sim900.h ****       bledny_PIN = TRUE;
 243:main_sim900.h ****     else if (kom == CME_ERROR_KOMENDA_SIM900 && numer_bledu_cme == CME_SIM_BUSY)
 244:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 245:main_sim900.h ****     else if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900())
 246:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 247:main_sim900.h ****     else
 248:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 249:main_sim900.h ****     break;
 250:main_sim900.h ****   }
 251:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY: {
 252:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900)
 253:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW);
 254:main_sim900.h ****     else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 255:main_sim900.h ****       if (numer_bledu_cms == CMS_SIM_BUSY ||
 256:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 257:main_sim900.h ****         opoznienie_SIM900_100MS = 60;
 258:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 259:main_sim900.h ****       }
 260:main_sim900.h ****     } else if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900())
 261:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 262:main_sim900.h ****     break;
 263:main_sim900.h ****   }
 264:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW: {
 265:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900)
 266:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW);
 267:main_sim900.h ****     else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 268:main_sim900.h ****       if (numer_bledu_cms == CMS_SIM_BUSY ||
 269:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 270:main_sim900.h ****         opoznienie_SIM900_100MS = 20;
 271:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 272:main_sim900.h ****       }
 273:main_sim900.h ****     } else {
 274:main_sim900.h ****       opoznienie_SIM900_100MS = 10;
 275:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 276:main_sim900.h ****     }
 277:main_sim900.h ****     break;
 278:main_sim900.h ****   }
 279:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_WYSYLANIE_INFO_O_DZWONIACYM: {
 280:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 ||
 281:main_sim900.h ****         (kom == CME_ERROR_KOMENDA_SIM900 &&
 282:main_sim900.h ****          (numer_bledu_cme == CME_OPERATION_NOT_ALLOWED ||
 283:main_sim900.h ****           numer_bledu_cme == CME_OPERATION_NOT_SUPPORTED))) {
 284:main_sim900.h ****       dodaj_komende(nastepne_wysylane_polecenie_SIM900);
 285:main_sim900.h ****       nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 286:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 287:main_sim900.h ****     } else if (kom != OK_KOMENDA_SIM900 &&
 288:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 289:main_sim900.h ****                    MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 290:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 291:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 292:main_sim900.h ****     break;
 293:main_sim900.h ****   }
 294:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_POZIOM_SIECI: {
 295:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 296:main_sim900.h ****       static const uchar urc[] PROGMEM = "+CSQ:";
 297:main_sim900.h ****       const uchar *p1 = polozenie_polecenia_SIM900(urc);
 298:main_sim900.h ****       if (p1 != NULL) {
 299:main_sim900.h ****         p1 += strlen_R(urc) + 1;
 300:main_sim900.h ****         poziom_sieci_gsm = strtol(p1, NULL, 10);
 301:main_sim900.h ****         // if ( poziom_sieci_gsm != POZIOM_SIECI_BLAD )
 302:main_sim900.h ****         //	POMOC_DODAJ2('*', '0' + poziom_sieci_gsm / 4);
 303:main_sim900.h ****         // else
 304:main_sim900.h ****         //{
 305:main_sim900.h ****         //	POMOC_DODAJ2('*', 'c');
 306:main_sim900.h ****         // }
 307:main_sim900.h ****       }
 308:main_sim900.h ****     } else
 309:main_sim900.h ****       poziom_sieci_gsm = POZIOM_SIECI_BLAD;
 310:main_sim900.h ****     break;
 311:main_sim900.h ****   }
 312:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_ZAREJESTROWANIE: {
 313:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 314:main_sim900.h ****       static const uchar urc[] PROGMEM = "+CREG:";
 315:main_sim900.h ****       const uchar *p1 = polozenie_polecenia_SIM900(urc);
 316:main_sim900.h ****       if (p1 != NULL) {
 317:main_sim900.h ****         p1 += strlen_R(urc) + 1;
 318:main_sim900.h ****         if (*p1 != ',')
 319:main_sim900.h ****           ++p1;
 320:main_sim900.h ****         if (*p1 != ',')
 321:main_sim900.h ****           ++p1;
 322:main_sim900.h ****         if (*p1 != ',')
 323:main_sim900.h ****           ++p1;
 324:main_sim900.h ****         ++p1;
 325:main_sim900.h ****         uchar stan_zarejestrowania = (uchar)strtol(p1, NULL, 10);
 326:main_sim900.h ****         if (stan_zarejestrowania == 0 || stan_zarejestrowania == 3 ||
 327:main_sim900.h ****             stan_zarejestrowania == 4) {
 328:main_sim900.h ****           reset_modulu_SIM900();
 329:main_sim900.h ****         } else if (stan_zarejestrowania == 1 || stan_zarejestrowania == 5) {
 330:main_sim900.h ****           modul_zalogowany_w_sieci = TRUE;
 331:main_sim900.h ****         }
 332:main_sim900.h ****       }
 333:main_sim900.h ****     }
 334:main_sim900.h ****     break;
 335:main_sim900.h ****   }
 336:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_STAN_KARTY_SIM: {
 337:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 || (kom == CME_ERROR_KOMENDA_SIM900 &&
 338:main_sim900.h ****                                      (numer_bledu_cme == CME_INVALID_INDEX ||
 339:main_sim900.h ****                                       numer_bledu_cme == CME_NOT_FOUND))) {
 340:main_sim900.h ****       licznik_blad_stanu_karty_SIM = 0;
 341:main_sim900.h ****     } else {
 342:main_sim900.h ****       ++licznik_blad_stanu_karty_SIM;
 343:main_sim900.h ****     }
 344:main_sim900.h ****     break;
 345:main_sim900.h ****   }
 346:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_ZALOGOWANIE_U_OPERATORA: {
 347:main_sim900.h ****     static const char polecenie_operator[] PROGMEM = "+COPS:";
 348:main_sim900.h ****     uchar w = FALSE;
 349:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 && czy_polecenie_sim(polecenie_operator)) {
 350:main_sim900.h ****       const uchar *p1 =
 351:main_sim900.h ****           strchr(polozenie_polecenia_SIM900(polecenie_operator), ',');
 352:main_sim900.h ****       if (p1 != NULL) {
 353:main_sim900.h ****         p1 = strchr(p1, ',');
 354:main_sim900.h ****         if (p1 != NULL) {
 355:main_sim900.h ****           p1 = strchr(p1, '\"');
 356:main_sim900.h ****           if (p1++ != NULL) {
 357:main_sim900.h ****             const uchar *p2 = strchr(p1, '\"');
 358:main_sim900.h ****             if (p2 != NULL && p1 != p2) {
 359:main_sim900.h ****               const uchar m = min(p2 - p1, ROZMIAR_NAZWA_OPERATORA);
 360:main_sim900.h ****               memcpy(nazwa_operatora, p1, m);
 361:main_sim900.h ****               nazwa_operatora[m] = '\0';
 362:main_sim900.h ****               w = TRUE;
 363:main_sim900.h ****             }
 364:main_sim900.h ****           }
 365:main_sim900.h ****         }
 366:main_sim900.h ****       }
 367:main_sim900.h ****     }
 368:main_sim900.h ****     if (w)
 369:main_sim900.h ****       licznik_blad_zalogowania_u_operatora = 0;
 370:main_sim900.h ****     else {
 371:main_sim900.h ****       ++licznik_blad_zalogowania_u_operatora;
 372:main_sim900.h ****     }
 373:main_sim900.h ****     // POMOC_DODAJ2('*', w ? '+' : '-');
 374:main_sim900.h ****     break;
 375:main_sim900.h ****   }
 376:main_sim900.h ****   case KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS: {
 377:main_sim900.h ****     if (kom ==
 378:main_sim900.h ****         CMS_ERROR_KOMENDA_SIM900 /*&& numer_bledu_cms == CMS_SMS_ME_RESERVED*/) // co le interpretu
 379:main_sim900.h ****       ; // nic nie robi
 380:main_sim900.h ****     else if (kom != OK_KOMENDA_SIM900)
 381:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 382:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 383:main_sim900.h ****     break;
 384:main_sim900.h ****   }
 385:main_sim900.h ****   case KOMENDA_KOLEJKI_ODBIERZ_ROZMOWE: {
 386:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 ||
 387:main_sim900.h ****         czy_jest_komenda_uzytkownik_odebral_rozmowe()) {
 388:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = TRUE;
 389:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 390:main_sim900.h **** 
 391:main_sim900.h ****       // DTMF START
 392:main_sim900.h ****       if (!tryb_clip) {
 393:main_sim900.h ****         licznik_timeout_rozmowy_100ms = MAX_LICZNIK_TIMEOUT_ROZMOWY_100MS;
 394:main_sim900.h ****         opoznienie_SIM900_100MS =
 395:main_sim900.h ****             20; // 2 sekundy opoznienia przed wyslaniem tonu
 396:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_TON_DTMF); // Beep potwierdzenia
 397:main_sim900.h ****       }
 398:main_sim900.h ****     } else if ((kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900()) &&
 399:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 400:main_sim900.h ****                    MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 401:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 402:main_sim900.h ****     else if (kom == NO_CARRIER_KOMENDA_SIM900) {
 403:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 404:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 405:main_sim900.h ****     } else
 406:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 407:main_sim900.h ****     break;
 408:main_sim900.h ****   }
 409:main_sim900.h ****   case KOMENDA_KOLEJKI_ODRZUC_ROZMOWE: {
 410:main_sim900.h ****     if (kom != OK_KOMENDA_SIM900)
 411:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 412:main_sim900.h ****     else {
 413:main_sim900.h ****       zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_zakonczenie);
 414:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 415:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 416:main_sim900.h ****     }
 417:main_sim900.h ****     break;
 418:main_sim900.h ****   }
 419:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1:
 420:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_2:
 421:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_3:
 422:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_4:
 423:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_5:
 424:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_6:
 425:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_7:
 426:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_8:
 427:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_9:
 428:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_10:
 429:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_11:
 430:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_12:
 431:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_13:
 432:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_14:
 433:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_15:
 434:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_16:
 435:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_17:
 436:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_18:
 437:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_19:
 438:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20: {
 439:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 440:main_sim900.h ****       // odczytany sms
 441:main_sim900.h ****       const uchar *ptr = polozenie_polecenia_SIM900(PSTR("+CMGR:")); // (1)
 442:main_sim900.h ****       ptr = strchr(ptr, ZNAK_KONCA_ODBIERANIA_ZNAKOW_LF);            // (1)
 443:main_sim900.h ****       // const uchar* ptr = strchr(&odebrany_blok_SIM900[7],
 444:main_sim900.h ****       // ZNAK_KONCA_ODBIERANIA_ZNAKOW_LF);
 445:main_sim900.h ****       if (ptr != NULL) {
 446:main_sim900.h ****         ++ptr;
 447:main_sim900.h ****         const uchar *ptr2 = strchr(ptr, ZNAK_KONCA_WYSYLANIA_ZNAKOW_CR);
 448:main_sim900.h ****         if (ptr2 != NULL) {
 449:main_sim900.h ****           dlugosc_pdu = (ptr2 - ptr) / 2;
 450:main_sim900.h ****           if (dlugosc_pdu > MAX_DLUGOSC_PDU)
 451:main_sim900.h ****             dlugosc_pdu = MAX_DLUGOSC_PDU;
 452:main_sim900.h ****           konwertuj_blok_dwa_znaki_na_znak_pdu(ptr, dlugosc_pdu, bufor_pdu);
 453:main_sim900.h ****           dodaj_komende(KOMENDA_KOLEJKI_INTERPRETUJ_PDU);
 454:main_sim900.h ****           const uchar nr_smsa = aktualnie_wysylane_polecenie_SIM900 -
 455:main_sim900.h ****                                 KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1;
 456:main_sim900.h ****           dodaj_komende(KOMENDA_KOLEJKI_USUN_SMSA_1 + nr_smsa);
 457:main_sim900.h ****           flaga_odczytywanie_smsa = TRUE;
 458:main_sim900.h ****           POMOC_DODAJ2('#', 'O');
 459:main_sim900.h ****         } else
 460:main_sim900.h ****           flaga_odczytywanie_smsa = FALSE;
 461:main_sim900.h ****       } else
 462:main_sim900.h ****         flaga_odczytywanie_smsa = FALSE;
 463:main_sim900.h ****     } else if (kom == CME_ERROR_KOMENDA_SIM900) {
 464:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 465:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 466:main_sim900.h ****     } else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 467:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 468:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 469:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 470:main_sim900.h ****       POMOC_DODAJ2('#', 'P');
 471:main_sim900.h ****       POMOC_DODAJ_HEX(numer_bledu_cms >> 8);
 472:main_sim900.h ****       POMOC_DODAJ_HEX(numer_bledu_cms & 0xff);
 473:main_sim900.h ****     } else {
 474:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 475:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 476:main_sim900.h ****     }
 477:main_sim900.h ****     break;
 478:main_sim900.h ****   }
 479:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_1:
 480:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_2:
 481:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_3:
 482:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_4:
 483:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_5:
 484:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_6:
 485:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_7:
 486:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_8:
 487:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_9:
 488:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_10:
 489:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_11:
 490:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_12:
 491:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_13:
 492:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_14:
 493:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_15:
 494:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_16:
 495:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_17:
 496:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_18:
 497:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_19:
 498:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_20: {
 499:main_sim900.h ****     if (kom == CMS_ERROR_KOMENDA_SIM900 &&
 500:main_sim900.h ****         numer_bledu_cms != CMS_INVALID_MEMORY_INDEX) {
 501:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 502:main_sim900.h ****     } else if (kom == ERROR_KOMENDA_SIM900)
 503:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 504:main_sim900.h ****     else if (czy_jest_blad_SIM900())
 505:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 506:main_sim900.h ****     POMOC_DODAJ2('#', 'Q');
 507:main_sim900.h ****     opoznienie_SIM900_100MS = 25;
 508:main_sim900.h ****     break;
 509:main_sim900.h ****   }
 510:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT: {
 511:main_sim900.h ****     // czekanie_na_odebranie_zachety = FALSE; byo
 512:main_sim900.h ****     break;
 513:main_sim900.h ****   }
 514:main_sim900.h ****   case KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE: {
 515:main_sim900.h ****     if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900()) {
 516:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 517:main_sim900.h ****       if (++liczba_wykonanych_komend_identycznego_polecenia <
 518:main_sim900.h ****           MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 519:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 520:main_sim900.h ****       else {
 521:main_sim900.h ****         liczba_wykonanych_komend_identycznego_polecenia = 0;
 522:main_sim900.h ****         zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 523:main_sim900.h ****         trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 524:main_sim900.h ****         wykonywanie_rozmowy_telefonicznej = FALSE;
 525:main_sim900.h ****         licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 526:main_sim900.h ****       }
 527:main_sim900.h ****     } else
 528:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 529:main_sim900.h ****     break;
 530:main_sim900.h ****   }
 531:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW:
 532:main_sim900.h ****     if (kom != OK_KOMENDA_SIM900) {
 533:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 534:main_sim900.h ****       opoznienie_SIM900_100MS = 20;
 535:main_sim900.h ****       break;
 536:main_sim900.h ****     } // bez break
 537:main_sim900.h ****     goto obsluga_standardowej_instrukcji_at;
 538:main_sim900.h ****   case KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1: {
 539:main_sim900.h ****     if (polozenie_polecenia_SIM900(PSTR(">")) != 0) {
 540:main_sim900.h ****       reset_modulu_SIM900();
 541:main_sim900.h ****       break;
 542:main_sim900.h ****     }
 543:main_sim900.h ****   }
 544:main_sim900.h ****   case KOMENDA_KOLEJKI_WSTAWIENIE_MORING_GDY_DZWONI:
 545:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_WZMOCNIENIE_MIKROFONU:
 546:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_CICHY_TRYB:
 547:main_sim900.h ****   case KOMENDA_KOLEJKI_WYCISZ_DZWONKI:
 548:main_sim900.h ****   case KOMENDA_KOLEJKI_ODBIERAJ_SMS_FLASH:
 549:main_sim900.h ****   case KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ:
 550:main_sim900.h ****   case KOMENDA_KOLEJKI_WLACZ_CZAS_Z_SIECI: {
 551:main_sim900.h ****   obsluga_standardowej_instrukcji_at:
 552:main_sim900.h ****     if (kom != OK_KOMENDA_SIM900 &&
 553:main_sim900.h ****         ++liczba_wykonanych_komend_identycznego_polecenia <
 554:main_sim900.h ****             MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 555:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 556:main_sim900.h ****     else {
 557:main_sim900.h ****       dodaj_komende(nastepne_wysylane_polecenie_SIM900);
 558:main_sim900.h ****       if (nastepne_wysylane_polecenie_SIM900 >=
 559:main_sim900.h ****               KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 560:main_sim900.h ****           nastepne_wysylane_polecenie_SIM900 <=
 561:main_sim900.h ****               KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 562:main_sim900.h ****         flaga_odczytywanie_smsa = FALSE;
 563:main_sim900.h ****       }
 564:main_sim900.h ****       nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 565:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 566:main_sim900.h ****     }
 567:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 568:main_sim900.h ****     break;
 569:main_sim900.h ****   }
 570:main_sim900.h ****   }
 571:main_sim900.h **** #undef czy_polecenie_sim
 572:main_sim900.h ****   wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 3219               		.loc 2 572 0
 3220 0f2e 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 3221 0f32 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 3222 0f36 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
 3223               	/* epilogue start */
 573:main_sim900.h **** }
 3224               		.loc 2 573 0
 3225 0f3a DF91      		pop r29
 3226               	.LVL286:
 3227 0f3c CF91      		pop r28
 3228 0f3e 1F91      		pop r17
 3229 0f40 0F91      		pop r16
 3230 0f42 0895      		ret
 3231               	.LVL287:
 3232               	.L202:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3233               		.loc 2 142 0
 3234 0f44 C139      		cpi r28,lo8(-111)
 3235 0f46 01F4      		brne .+2
 3236 0f48 00C0      		rjmp .L205
 3237 0f4a C339      		cpi r28,lo8(-109)
 3238 0f4c 01F4      		brne .L196
 3239               	.L206:
 552:main_sim900.h ****         ++liczba_wykonanych_komend_identycznego_polecenia <
 3240               		.loc 2 552 0
 3241 0f4e D130      		cpi r29,lo8(1)
 3242 0f50 01F4      		brne .+2
 3243 0f52 00C0      		rjmp .L283
 553:main_sim900.h ****             MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 3244               		.loc 2 553 0 discriminator 1
 3245 0f54 8091 0000 		lds r24,liczba_wykonanych_komend_identycznego_polecenia
 3246 0f58 8F5F      		subi r24,lo8(-(1))
 552:main_sim900.h ****         ++liczba_wykonanych_komend_identycznego_polecenia <
 3247               		.loc 2 552 0 discriminator 1
 3248 0f5a 8093 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,r24
 3249 0f5e 8330      		cpi r24,lo8(3)
 3250 0f60 00F0      		brlo .+2
 3251 0f62 00C0      		rjmp .L283
 555:main_sim900.h ****     else {
 3252               		.loc 2 555 0
 3253 0f64 8C2F      		mov r24,r28
 3254 0f66 00C0      		rjmp .L390
 3255               	.L200:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3256               		.loc 2 142 0
 3257 0f68 C839      		cpi r28,lo8(-104)
 3258 0f6a 01F4      		brne .+2
 3259 0f6c 00C0      		rjmp .L207
 3260 0f6e 00F4      		brsh .L208
 3261 0f70 C539      		cpi r28,lo8(-107)
 3262 0f72 01F4      		brne .+2
 3263 0f74 00C0      		rjmp .L209
 3264 0f76 C639      		cpi r28,lo8(-106)
 3265 0f78 01F4      		brne .L196
 411:main_sim900.h ****     else {
 3266               		.loc 2 411 0
 3267 0f7a 86E9      		ldi r24,lo8(-106)
 410:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3268               		.loc 2 410 0
 3269 0f7c D130      		cpi r29,lo8(1)
 3270 0f7e 01F0      		breq .+2
 3271 0f80 00C0      		rjmp .L395
 413:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 3272               		.loc 2 413 0
 3273 0f82 81E0      		ldi r24,lo8(1)
 3274 0f84 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 3275               	.LVL288:
 414:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 3276               		.loc 2 414 0
 3277 0f88 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 415:main_sim900.h ****     }
 3278               		.loc 2 415 0
 3279 0f8c 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 3280 0f90 00C0      		rjmp .L196
 3281               	.L208:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3282               		.loc 2 142 0
 3283 0f92 CA39      		cpi r28,lo8(-102)
 3284 0f94 01F4      		brne .+2
 3285 0f96 00C0      		rjmp .L211
 3286 0f98 00F4      		brsh .+2
 3287 0f9a 00C0      		rjmp .L212
 3288 0f9c CC39      		cpi r28,lo8(-100)
 3289 0f9e 01F4      		brne .L196
 313:main_sim900.h ****       static const uchar urc[] PROGMEM = "+CREG:";
 3290               		.loc 2 313 0
 3291 0fa0 D130      		cpi r29,lo8(1)
 3292 0fa2 01F4      		brne .L196
 3293               	.LBB519:
 315:main_sim900.h ****       if (p1 != NULL) {
 3294               		.loc 2 315 0
 3295 0fa4 80E0      		ldi r24,lo8(urc.3235)
 3296 0fa6 90E0      		ldi r25,hi8(urc.3235)
 3297 0fa8 0E94 0000 		call polozenie_polecenia_SIM900
 3298               	.LVL289:
 3299 0fac FC01      		movw r30,r24
 3300               	.LVL290:
 316:main_sim900.h ****         p1 += strlen_R(urc) + 1;
 3301               		.loc 2 316 0
 3302 0fae 892B      		or r24,r25
 3303 0fb0 01F4      		brne .+2
 3304 0fb2 00C0      		rjmp .L196
 3305               	.LVL291:
 3306               	.LBB520:
 318:main_sim900.h ****           ++p1;
 3307               		.loc 2 318 0
 3308 0fb4 2781      		ldd r18,Z+7
 3309 0fb6 2C32      		cpi r18,lo8(44)
 3310 0fb8 01F0      		breq .+2
 3311 0fba 00C0      		rjmp .L255
 317:main_sim900.h ****         if (*p1 != ',')
 3312               		.loc 2 317 0
 3313 0fbc 3796      		adiw r30,7
 3314               	.LVL292:
 3315               	.L256:
 320:main_sim900.h ****           ++p1;
 3316               		.loc 2 320 0
 3317 0fbe 8081      		ld r24,Z
 3318 0fc0 8C32      		cpi r24,lo8(44)
 3319 0fc2 01F0      		breq .L257
 3320 0fc4 3196      		adiw r30,1
 3321               	.LVL293:
 3322               	.L257:
 322:main_sim900.h ****           ++p1;
 3323               		.loc 2 322 0
 3324 0fc6 8081      		ld r24,Z
 3325 0fc8 8C32      		cpi r24,lo8(44)
 3326 0fca 01F0      		breq .L258
 3327 0fcc 3196      		adiw r30,1
 3328               	.LVL294:
 3329               	.L258:
 325:main_sim900.h ****         if (stan_zarejestrowania == 0 || stan_zarejestrowania == 3 ||
 3330               		.loc 2 325 0
 3331 0fce 4AE0      		ldi r20,lo8(10)
 3332 0fd0 50E0      		ldi r21,0
 3333 0fd2 70E0      		ldi r23,0
 3334 0fd4 60E0      		ldi r22,0
 3335 0fd6 CF01      		movw r24,r30
 3336 0fd8 0196      		adiw r24,1
 3337               	.LVL295:
 3338 0fda 0E94 0000 		call strtol
 3339               	.LVL296:
 326:main_sim900.h ****             stan_zarejestrowania == 4) {
 3340               		.loc 2 326 0
 3341 0fde 6623      		tst r22
 3342 0fe0 01F0      		breq .L259
 326:main_sim900.h ****             stan_zarejestrowania == 4) {
 3343               		.loc 2 326 0 is_stmt 0 discriminator 1
 3344 0fe2 8DEF      		ldi r24,lo8(-3)
 3345 0fe4 860F      		add r24,r22
 3346 0fe6 8230      		cpi r24,lo8(2)
 3347 0fe8 00F0      		brlo .+2
 3348 0fea 00C0      		rjmp .L260
 3349               	.LVL297:
 3350               	.L259:
 328:main_sim900.h ****         } else if (stan_zarejestrowania == 1 || stan_zarejestrowania == 5) {
 3351               		.loc 2 328 0 is_stmt 1
 3352 0fec 0E94 0000 		call reset_modulu_SIM900
 3353               	.LVL298:
 3354 0ff0 00C0      		rjmp .L196
 3355               	.L198:
 3356               	.LBE520:
 3357               	.LBE519:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3358               		.loc 2 142 0
 3359 0ff2 C93A      		cpi r28,lo8(-87)
 3360 0ff4 00F4      		brsh .L214
 3361 0ff6 C53A      		cpi r28,lo8(-91)
 3362 0ff8 00F0      		brlo .+2
 3363 0ffa 00C0      		rjmp .L206
 3364 0ffc C03A      		cpi r28,lo8(-96)
 3365 0ffe 01F4      		brne .+2
 3366 1000 00C0      		rjmp .L206
 3367 1002 00F4      		brsh .L215
 3368 1004 CE39      		cpi r28,lo8(-98)
 3369 1006 01F4      		brne .+2
 3370 1008 00C0      		rjmp .L216
 3371 100a CF39      		cpi r28,lo8(-97)
 3372 100c 01F0      		breq .+2
 3373 100e 00C0      		rjmp .L196
 265:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW);
 3374               		.loc 2 265 0
 3375 1010 D130      		cpi r29,lo8(1)
 3376 1012 01F0      		breq .+2
 3377 1014 00C0      		rjmp .L247
 266:main_sim900.h ****     else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 3378               		.loc 2 266 0
 3379 1016 8EE8      		ldi r24,lo8(-114)
 3380 1018 00C0      		rjmp .L395
 3381               	.L215:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3382               		.loc 2 142 0
 3383 101a C13A      		cpi r28,lo8(-95)
 3384 101c 01F4      		brne .+2
 3385 101e 00C0      		rjmp .L218
 3386 1020 C33A      		cpi r28,lo8(-93)
 3387 1022 01F4      		brne .+2
 3388 1024 00C0      		rjmp .L206
 3389 1026 00C0      		rjmp .L196
 3390               	.L214:
 3391 1028 C13D      		cpi r28,lo8(-47)
 3392 102a 00F4      		brsh .L219
 3393 102c CD3B      		cpi r28,lo8(-67)
 3394 102e 00F4      		brsh .+2
 3395 1030 00C0      		rjmp .L387
 499:main_sim900.h ****         numer_bledu_cms != CMS_INVALID_MEMORY_INDEX) {
 3396               		.loc 2 499 0
 3397 1032 D630      		cpi r29,lo8(6)
 3398 1034 01F0      		breq .+2
 3399 1036 00C0      		rjmp .L278
 499:main_sim900.h ****         numer_bledu_cms != CMS_INVALID_MEMORY_INDEX) {
 3400               		.loc 2 499 0 is_stmt 0 discriminator 1
 3401 1038 8091 0000 		lds r24,numer_bledu_cms
 3402 103c 9091 0000 		lds r25,numer_bledu_cms+1
 3403 1040 8134      		cpi r24,65
 3404 1042 9140      		sbci r25,1
 3405 1044 01F4      		brne .+2
 3406 1046 00C0      		rjmp .L279
 3407               	.L392:
 505:main_sim900.h ****     POMOC_DODAJ2('#', 'Q');
 3408               		.loc 2 505 0 is_stmt 1
 3409 1048 8C2F      		mov r24,r28
 3410 104a 0E94 0000 		call dodaj_komende
 3411               	.LVL299:
 3412 104e 00C0      		rjmp .L280
 3413               	.L219:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3414               		.loc 2 142 0
 3415 1050 C53D      		cpi r28,lo8(-43)
 3416 1052 01F4      		brne .+2
 3417 1054 00C0      		rjmp .L222
 3418 1056 CC3F      		cpi r28,lo8(-4)
 3419 1058 01F0      		breq .+2
 3420 105a 00C0      		rjmp .L196
 539:main_sim900.h ****       reset_modulu_SIM900();
 3421               		.loc 2 539 0
 3422 105c 80E0      		ldi r24,lo8(__c.3298)
 3423 105e 90E0      		ldi r25,hi8(__c.3298)
 3424 1060 0E94 0000 		call polozenie_polecenia_SIM900
 3425               	.LVL300:
 3426 1064 892B      		or r24,r25
 3427 1066 01F4      		brne .+2
 3428 1068 00C0      		rjmp .L206
 3429 106a 00C0      		rjmp .L259
 3430               	.L203:
 144:main_sim900.h ****     max_oczekiwanie_na_odpowiedz_at = 0;
 3431               		.loc 2 144 0
 3432 106c 8CE8      		ldi r24,lo8(-116)
 3433 106e 0E94 0000 		call dodaj_komende
 3434               	.LVL301:
 145:main_sim900.h ****     break;
 3435               		.loc 2 145 0
 3436 1072 1092 0000 		sts max_oczekiwanie_na_odpowiedz_at,__zero_reg__
 146:main_sim900.h ****   }
 3437               		.loc 2 146 0
 3438 1076 00C0      		rjmp .L196
 3439               	.L197:
 3440               	.LBB522:
 150:main_sim900.h ****         polozenie_polecenia_SIM900(polecenie_zegar) != NULL) {
 3441               		.loc 2 150 0
 3442 1078 D130      		cpi r29,lo8(1)
 3443 107a 01F0      		breq .+2
 3444 107c 00C0      		rjmp .L196
 151:main_sim900.h ****       const uchar *p1 =
 3445               		.loc 2 151 0 discriminator 1
 3446 107e 80E0      		ldi r24,lo8(polecenie_zegar.3214)
 3447 1080 90E0      		ldi r25,hi8(polecenie_zegar.3214)
 3448 1082 0E94 0000 		call polozenie_polecenia_SIM900
 3449               	.LVL302:
 150:main_sim900.h ****         polozenie_polecenia_SIM900(polecenie_zegar) != NULL) {
 3450               		.loc 2 150 0 discriminator 1
 3451 1086 0097      		sbiw r24,0
 3452 1088 01F4      		brne .+2
 3453 108a 00C0      		rjmp .L196
 3454               	.LBB523:
 152:main_sim900.h ****           strchr(polozenie_polecenia_SIM900(polecenie_zegar), '\"');
 3455               		.loc 2 152 0
 3456 108c 62E2      		ldi r22,lo8(34)
 3457 108e 70E0      		ldi r23,0
 3458 1090 0E94 0000 		call strchr
 3459               	.LVL303:
 154:main_sim900.h ****         const uchar *p2 = strchr(p1, '\"');
 3460               		.loc 2 154 0
 3461 1094 0097      		sbiw r24,0
 3462 1096 01F4      		brne .+2
 3463 1098 00C0      		rjmp .L196
 3464 109a EC01      		movw r28,r24
 3465 109c 2196      		adiw r28,1
 3466               	.LVL304:
 3467               	.LBB524:
 155:main_sim900.h ****         const uchar *p3 = strchr(p1, ',');
 3468               		.loc 2 155 0
 3469 109e 62E2      		ldi r22,lo8(34)
 3470 10a0 70E0      		ldi r23,0
 3471 10a2 CE01      		movw r24,r28
 3472 10a4 0E94 0000 		call strchr
 3473               	.LVL305:
 3474 10a8 8C01      		movw r16,r24
 3475               	.LVL306:
 156:main_sim900.h ****         if (p2 != NULL && p3++ != NULL && p2 > p3) {
 3476               		.loc 2 156 0
 3477 10aa 6CE2      		ldi r22,lo8(44)
 3478 10ac 70E0      		ldi r23,0
 3479 10ae CE01      		movw r24,r28
 3480 10b0 0E94 0000 		call strchr
 3481               	.LVL307:
 157:main_sim900.h ****           // const uchar g = atoi(p3);
 3482               		.loc 2 157 0
 3483 10b4 0115      		cp r16,__zero_reg__
 3484 10b6 1105      		cpc r17,__zero_reg__
 3485 10b8 01F4      		brne .+2
 3486 10ba 00C0      		rjmp .L196
 3487               	.LVL308:
 157:main_sim900.h ****           // const uchar g = atoi(p3);
 3488               		.loc 2 157 0 is_stmt 0 discriminator 1
 3489 10bc 0097      		sbiw r24,0
 3490 10be 01F4      		brne .+2
 3491 10c0 00C0      		rjmp .L196
 157:main_sim900.h ****           // const uchar g = atoi(p3);
 3492               		.loc 2 157 0 discriminator 2
 3493 10c2 EC01      		movw r28,r24
 3494               	.LVL309:
 3495 10c4 2196      		adiw r28,1
 3496               	.LVL310:
 3497 10c6 C017      		cp r28,r16
 3498 10c8 D107      		cpc r29,r17
 3499 10ca 00F0      		brlo .+2
 3500 10cc 00C0      		rjmp .L196
 159:main_sim900.h ****             // Pobierz czas z odpowiedzi +CCLK: "yy/MM/dd,hh:mm:ss+zz"
 3501               		.loc 2 159 0 is_stmt 1
 3502 10ce 6AE3      		ldi r22,lo8(58)
 3503 10d0 70E0      		ldi r23,0
 3504 10d2 CE01      		movw r24,r28
 3505 10d4 0E94 0000 		call strchr
 3506               	.LVL311:
 3507 10d8 0097      		sbiw r24,0
 3508 10da 01F4      		brne .+2
 3509 10dc 00C0      		rjmp .L196
 3510               	.LVL312:
 159:main_sim900.h ****             // Pobierz czas z odpowiedzi +CCLK: "yy/MM/dd,hh:mm:ss+zz"
 3511               		.loc 2 159 0 is_stmt 0 discriminator 1
 3512 10de 8017      		cp r24,r16
 3513 10e0 9107      		cpc r25,r17
 3514 10e2 00F0      		brlo .+2
 3515 10e4 00C0      		rjmp .L196
 3516               	.LVL313:
 3517               	.LBB525:
 170:main_sim900.h ****                 memcpy(rtc_czas, ptr_time, 8);
 3518               		.loc 2 170 0 is_stmt 1
 3519 10e6 FE01      		movw r30,r28
 3520               		0:
 3521 10e8 0190      		ld __tmp_reg__,Z+
 3522 10ea 0020      		tst __tmp_reg__
 3523 10ec 01F4      		brne 0b
 3524 10ee 3197      		sbiw r30,1
 3525 10f0 EC1B      		sub r30,r28
 3526 10f2 FD0B      		sbc r31,r29
 3527 10f4 3897      		sbiw r30,8
 3528 10f6 00F4      		brsh .+2
 3529 10f8 00C0      		rjmp .L196
 171:main_sim900.h ****                 rtc_czas[8] = '\0';
 3530               		.loc 2 171 0
 3531 10fa 88E0      		ldi r24,lo8(8)
 3532               	.LVL314:
 3533 10fc FE01      		movw r30,r28
 3534 10fe A0E0      		ldi r26,lo8(rtc_czas)
 3535 1100 B0E0      		ldi r27,hi8(rtc_czas)
 3536               		0:
 3537 1102 0190      		ld r0,Z+
 3538 1104 0D92      		st X+,r0
 3539 1106 8A95      		dec r24
 3540 1108 01F4      		brne 0b
 172:main_sim900.h **** 
 3541               		.loc 2 172 0
 3542 110a 1092 0000 		sts rtc_czas+8,__zero_reg__
 175:main_sim900.h ****                   blokada_sterowania_czasowa = FALSE;
 3543               		.loc 2 175 0
 3544 110e 7091 0000 		lds r23,czas_start_h
 3545 1112 7F3F      		cpi r23,lo8(-1)
 3546 1114 01F4      		brne .L226
 3547               	.L229:
 176:main_sim900.h ****                 } else {
 3548               		.loc 2 176 0
 3549 1116 1092 0000 		sts blokada_sterowania_czasowa,__zero_reg__
 3550 111a 00C0      		rjmp .L196
 3551               	.L226:
 3552               	.LVL315:
 3553               	.LBB526:
 179:main_sim900.h ****                   int curr_m = (rtc_czas[3] - '0') * 10 + (rtc_czas[4] - '0');
 3554               		.loc 2 179 0
 3555 111c 2091 0000 		lds r18,rtc_czas
 3556 1120 2053      		subi r18,48
 3557 1122 330B      		sbc r19,r19
 3558 1124 EAE0      		ldi r30,lo8(10)
 3559 1126 E29F      		mul r30,r18
 3560 1128 C001      		movw r24,r0
 3561 112a E39F      		mul r30,r19
 3562 112c 900D      		add r25,r0
 3563 112e 1124      		clr __zero_reg__
 3564 1130 2091 0000 		lds r18,rtc_czas+1
 3565 1134 2053      		subi r18,48
 3566 1136 330B      		sbc r19,r19
 3567 1138 820F      		add r24,r18
 3568 113a 931F      		adc r25,r19
 181:main_sim900.h **** 
 3569               		.loc 2 181 0
 3570 113c 6CE3      		ldi r22,lo8(60)
 3571 113e 689F      		mul r22,r24
 3572 1140 A001      		movw r20,r0
 3573 1142 699F      		mul r22,r25
 3574 1144 500D      		add r21,r0
 3575 1146 1124      		clr __zero_reg__
 180:main_sim900.h ****                   int curr_time = curr_h * 60 + curr_m;
 3576               		.loc 2 180 0
 3577 1148 2091 0000 		lds r18,rtc_czas+3
 3578 114c 2053      		subi r18,48
 3579 114e 330B      		sbc r19,r19
 3580 1150 E29F      		mul r30,r18
 3581 1152 C001      		movw r24,r0
 3582 1154 E39F      		mul r30,r19
 3583 1156 900D      		add r25,r0
 3584 1158 1124      		clr __zero_reg__
 3585 115a 2091 0000 		lds r18,rtc_czas+4
 3586 115e 2053      		subi r18,48
 3587 1160 330B      		sbc r19,r19
 3588 1162 820F      		add r24,r18
 3589 1164 931F      		adc r25,r19
 181:main_sim900.h **** 
 3590               		.loc 2 181 0
 3591 1166 480F      		add r20,r24
 3592 1168 591F      		adc r21,r25
 3593               	.LVL316:
 183:main_sim900.h ****                   int stop_time = czas_stop_h * 60 + czas_stop_m;
 3594               		.loc 2 183 0
 3595 116a 2091 0000 		lds r18,czas_start_m
 3596 116e 30E0      		ldi r19,0
 3597 1170 769F      		mul r23,r22
 3598 1172 200D      		add r18,r0
 3599 1174 311D      		adc r19,r1
 3600 1176 1124      		clr __zero_reg__
 3601               	.LVL317:
 184:main_sim900.h **** 
 3602               		.loc 2 184 0
 3603 1178 7091 0000 		lds r23,czas_stop_h
 3604 117c 8091 0000 		lds r24,czas_stop_m
 3605 1180 90E0      		ldi r25,0
 3606 1182 769F      		mul r23,r22
 3607 1184 800D      		add r24,r0
 3608 1186 911D      		adc r25,r1
 3609 1188 1124      		clr __zero_reg__
 3610               	.LVL318:
 186:main_sim900.h ****                     // Normalny przedzial (np. 08:00 - 16:00)
 3611               		.loc 2 186 0
 3612 118a 8217      		cp r24,r18
 3613 118c 9307      		cpc r25,r19
 3614 118e 04F0      		brlt .L227
 188:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 3615               		.loc 2 188 0
 3616 1190 4217      		cp r20,r18
 3617 1192 5307      		cpc r21,r19
 3618 1194 04F0      		brlt .L228
 3619               	.L388:
 194:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 3620               		.loc 2 194 0 discriminator 1
 3621 1196 8417      		cp r24,r20
 3622 1198 9507      		cpc r25,r21
 3623 119a 04F0      		brlt .+2
 3624 119c 00C0      		rjmp .L229
 3625               	.L228:
 191:main_sim900.h ****                   } else {
 3626               		.loc 2 191 0
 3627 119e 8FEF      		ldi r24,lo8(-1)
 3628               	.LVL319:
 3629 11a0 8093 0000 		sts blokada_sterowania_czasowa,r24
 3630 11a4 00C0      		rjmp .L196
 3631               	.LVL320:
 3632               	.L227:
 194:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 3633               		.loc 2 194 0
 3634 11a6 4217      		cp r20,r18
 3635 11a8 5307      		cpc r21,r19
 3636 11aa 04F0      		brlt .L388
 3637 11ac 00C0      		rjmp .L229
 3638               	.LVL321:
 3639               	.L216:
 3640               	.LBE526:
 3641               	.LBE525:
 3642               	.LBE524:
 3643               	.LBE523:
 3644               	.LBE522:
 3645               	.LBB527:
 211:main_sim900.h ****       if (polozenie_polecenia_SIM900(polecenie_pin_ready) != NULL) {
 3646               		.loc 2 211 0
 3647 11ae D130      		cpi r29,lo8(1)
 3648 11b0 01F4      		brne .L230
 212:main_sim900.h ****         podlaczona_karta_SIM_SIM900 = TRUE;
 3649               		.loc 2 212 0
 3650 11b2 80E0      		ldi r24,lo8(polecenie_pin_ready.3225)
 3651 11b4 90E0      		ldi r25,hi8(polecenie_pin_ready.3225)
 3652 11b6 0E94 0000 		call polozenie_polecenia_SIM900
 3653               	.LVL322:
 3654 11ba 892B      		or r24,r25
 3655 11bc 01F0      		breq .L231
 213:main_sim900.h ****         bledny_PIN = FALSE;
 3656               		.loc 2 213 0
 3657 11be 8FEF      		ldi r24,lo8(-1)
 3658 11c0 8093 0000 		sts podlaczona_karta_SIM_SIM900,r24
 214:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 3659               		.loc 2 214 0
 3660 11c4 1092 0000 		sts bledny_PIN,__zero_reg__
 215:main_sim900.h ****       } else
 3661               		.loc 2 215 0
 3662 11c8 81E9      		ldi r24,lo8(-111)
 3663               	.L389:
 217:main_sim900.h ****       nr_zapytania_o_pin = 0;
 3664               		.loc 2 217 0
 3665 11ca 0E94 0000 		call dodaj_komende
 3666               	.LVL323:
 3667               	.L393:
 225:main_sim900.h ****       } else {
 3668               		.loc 2 225 0
 3669 11ce 1092 0000 		sts nr_zapytania_o_pin.3226,__zero_reg__
 3670 11d2 00C0      		rjmp .L196
 3671               	.L231:
 217:main_sim900.h ****       nr_zapytania_o_pin = 0;
 3672               		.loc 2 217 0
 3673 11d4 8DE8      		ldi r24,lo8(-115)
 3674 11d6 00C0      		rjmp .L389
 3675               	.L230:
 219:main_sim900.h ****                numer_bledu_cme == CME_SIM_BUSY)
 3676               		.loc 2 219 0
 3677 11d8 D530      		cpi r29,lo8(5)
 3678 11da 01F4      		brne .L233
 219:main_sim900.h ****                numer_bledu_cme == CME_SIM_BUSY)
 3679               		.loc 2 219 0 is_stmt 0 discriminator 1
 3680 11dc 8091 0000 		lds r24,numer_bledu_cme
 3681 11e0 9091 0000 		lds r25,numer_bledu_cme+1
 3682 11e4 0E97      		sbiw r24,14
 3683 11e6 01F4      		brne .L234
 3684               	.L397:
 228:main_sim900.h ****       }
 3685               		.loc 2 228 0 is_stmt 1
 3686 11e8 8EE9      		ldi r24,lo8(-98)
 3687               	.L395:
 3688               	.LBE527:
 266:main_sim900.h ****     else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 3689               		.loc 2 266 0
 3690 11ea 0E94 0000 		call dodaj_komende
 3691               	.LVL324:
 3692 11ee 00C0      		rjmp .L196
 3693               	.L233:
 3694               	.LBB528:
 222:main_sim900.h ****       if (++nr_zapytania_o_pin >= 20) {
 3695               		.loc 2 222 0
 3696 11f0 D430      		cpi r29,lo8(4)
 3697 11f2 01F0      		breq .L235
 3698               	.L234:
 222:main_sim900.h ****       if (++nr_zapytania_o_pin >= 20) {
 3699               		.loc 2 222 0 is_stmt 0 discriminator 1
 3700 11f4 8091 0000 		lds r24,komenda_SIM900
 3701 11f8 8038      		cpi r24,lo8(-128)
 3702 11fa 01F4      		brne .L397
 3703               	.L235:
 223:main_sim900.h ****         reset_modulu_SIM900();
 3704               		.loc 2 223 0 is_stmt 1
 3705 11fc 8091 0000 		lds r24,nr_zapytania_o_pin.3226
 3706 1200 8F5F      		subi r24,lo8(-(1))
 3707 1202 8093 0000 		sts nr_zapytania_o_pin.3226,r24
 3708 1206 8431      		cpi r24,lo8(20)
 3709 1208 00F0      		brlo .L237
 224:main_sim900.h ****         nr_zapytania_o_pin = 0;
 3710               		.loc 2 224 0
 3711 120a 0E94 0000 		call reset_modulu_SIM900
 3712               	.LVL325:
 3713 120e 00C0      		rjmp .L393
 3714               	.L237:
 227:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3715               		.loc 2 227 0
 3716 1210 84E1      		ldi r24,lo8(20)
 3717 1212 8093 0000 		sts opoznienie_SIM900_100MS,r24
 3718 1216 00C0      		rjmp .L397
 3719               	.L204:
 3720               	.LBE528:
 235:main_sim900.h ****       podlaczona_karta_SIM_SIM900 = TRUE;
 3721               		.loc 2 235 0
 3722 1218 D130      		cpi r29,lo8(1)
 3723 121a 01F4      		brne .L238
 236:main_sim900.h ****       bledny_PIN = FALSE;
 3724               		.loc 2 236 0
 3725 121c 8FEF      		ldi r24,lo8(-1)
 3726 121e 8093 0000 		sts podlaczona_karta_SIM_SIM900,r24
 237:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 3727               		.loc 2 237 0
 3728 1222 1092 0000 		sts bledny_PIN,__zero_reg__
 238:main_sim900.h ****       opoznienie_SIM900_100MS = 50;
 3729               		.loc 2 238 0
 3730 1226 81E9      		ldi r24,lo8(-111)
 3731 1228 0E94 0000 		call dodaj_komende
 3732               	.LVL326:
 239:main_sim900.h ****     } else if (kom == CME_ERROR_KOMENDA_SIM900 &&
 3733               		.loc 2 239 0
 3734 122c 82E3      		ldi r24,lo8(50)
 3735               	.L394:
 534:main_sim900.h ****       break;
 3736               		.loc 2 534 0
 3737 122e 8093 0000 		sts opoznienie_SIM900_100MS,r24
 535:main_sim900.h ****     } // bez break
 3738               		.loc 2 535 0
 3739 1232 00C0      		rjmp .L196
 3740               	.L238:
 240:main_sim900.h ****                numer_bledu_cme == CME_SIM_INCORECT_PASWORD)
 3741               		.loc 2 240 0
 3742 1234 D530      		cpi r29,lo8(5)
 3743 1236 01F4      		brne .L239
 241:main_sim900.h ****       bledny_PIN = TRUE;
 3744               		.loc 2 241 0 discriminator 1
 3745 1238 8091 0000 		lds r24,numer_bledu_cme
 3746 123c 9091 0000 		lds r25,numer_bledu_cme+1
 240:main_sim900.h ****                numer_bledu_cme == CME_SIM_INCORECT_PASWORD)
 3747               		.loc 2 240 0 discriminator 1
 3748 1240 8031      		cpi r24,16
 3749 1242 9105      		cpc r25,__zero_reg__
 3750 1244 01F4      		brne .L240
 242:main_sim900.h ****     else if (kom == CME_ERROR_KOMENDA_SIM900 && numer_bledu_cme == CME_SIM_BUSY)
 3751               		.loc 2 242 0
 3752 1246 8FEF      		ldi r24,lo8(-1)
 3753 1248 8093 0000 		sts bledny_PIN,r24
 3754 124c 00C0      		rjmp .L196
 3755               	.L240:
 243:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3756               		.loc 2 243 0 discriminator 1
 3757 124e 0E97      		sbiw r24,14
 3758 1250 01F4      		brne .L241
 3759               	.L242:
 244:main_sim900.h ****     else if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900())
 3760               		.loc 2 244 0
 3761 1252 8DE8      		ldi r24,lo8(-115)
 3762 1254 00C0      		rjmp .L395
 3763               	.L239:
 245:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3764               		.loc 2 245 0
 3765 1256 D430      		cpi r29,lo8(4)
 3766 1258 01F0      		breq .L242
 3767               	.L241:
 245:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3768               		.loc 2 245 0 is_stmt 0 discriminator 1
 3769 125a 8091 0000 		lds r24,komenda_SIM900
 3770 125e 00C0      		rjmp .L242
 3771               	.L205:
 252:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW);
 3772               		.loc 2 252 0 is_stmt 1
 3773 1260 D130      		cpi r29,lo8(1)
 3774 1262 01F4      		brne .L243
 3775               	.L396:
 275:main_sim900.h ****     }
 3776               		.loc 2 275 0
 3777 1264 8FE9      		ldi r24,lo8(-97)
 3778 1266 00C0      		rjmp .L395
 3779               	.L243:
 254:main_sim900.h ****       if (numer_bledu_cms == CMS_SIM_BUSY ||
 3780               		.loc 2 254 0
 3781 1268 D630      		cpi r29,lo8(6)
 3782 126a 01F4      		brne .L244
 255:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 3783               		.loc 2 255 0
 3784 126c 8091 0000 		lds r24,numer_bledu_cms
 3785 1270 9091 0000 		lds r25,numer_bledu_cms+1
 3786 1274 8A33      		cpi r24,58
 3787 1276 21E0      		ldi r18,1
 3788 1278 9207      		cpc r25,r18
 3789 127a 01F0      		breq .L245
 255:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 3790               		.loc 2 255 0 is_stmt 0 discriminator 1
 3791 127c 8530      		cpi r24,5
 3792 127e 9240      		sbci r25,2
 3793 1280 01F0      		breq .+2
 3794 1282 00C0      		rjmp .L196
 3795               	.L245:
 257:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3796               		.loc 2 257 0 is_stmt 1
 3797 1284 8CE3      		ldi r24,lo8(60)
 3798 1286 8093 0000 		sts opoznienie_SIM900_100MS,r24
 3799               	.L246:
 261:main_sim900.h ****     break;
 3800               		.loc 2 261 0
 3801 128a 81E9      		ldi r24,lo8(-111)
 3802 128c 00C0      		rjmp .L395
 3803               	.L244:
 260:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3804               		.loc 2 260 0
 3805 128e D430      		cpi r29,lo8(4)
 3806 1290 01F0      		breq .L246
 260:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3807               		.loc 2 260 0 is_stmt 0 discriminator 1
 3808 1292 8091 0000 		lds r24,komenda_SIM900
 3809 1296 8038      		cpi r24,lo8(-128)
 3810 1298 01F0      		breq .+2
 3811 129a 00C0      		rjmp .L196
 3812 129c 00C0      		rjmp .L246
 3813               	.L247:
 267:main_sim900.h ****       if (numer_bledu_cms == CMS_SIM_BUSY ||
 3814               		.loc 2 267 0 is_stmt 1
 3815 129e D630      		cpi r29,lo8(6)
 3816 12a0 01F4      		brne .L248
 268:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 3817               		.loc 2 268 0
 3818 12a2 8091 0000 		lds r24,numer_bledu_cms
 3819 12a6 9091 0000 		lds r25,numer_bledu_cms+1
 3820 12aa 8A33      		cpi r24,58
 3821 12ac 21E0      		ldi r18,1
 3822 12ae 9207      		cpc r25,r18
 3823 12b0 01F0      		breq .L249
 268:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 3824               		.loc 2 268 0 is_stmt 0 discriminator 1
 3825 12b2 8530      		cpi r24,5
 3826 12b4 9240      		sbci r25,2
 3827 12b6 01F0      		breq .+2
 3828 12b8 00C0      		rjmp .L196
 3829               	.L249:
 270:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3830               		.loc 2 270 0 is_stmt 1
 3831 12ba 84E1      		ldi r24,lo8(20)
 3832               	.L398:
 274:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3833               		.loc 2 274 0
 3834 12bc 8093 0000 		sts opoznienie_SIM900_100MS,r24
 3835 12c0 00C0      		rjmp .L396
 3836               	.L248:
 3837 12c2 8AE0      		ldi r24,lo8(10)
 3838 12c4 00C0      		rjmp .L398
 3839               	.L218:
 280:main_sim900.h ****         (kom == CME_ERROR_KOMENDA_SIM900 &&
 3840               		.loc 2 280 0
 3841 12c6 D130      		cpi r29,lo8(1)
 3842 12c8 01F0      		breq .L250
 280:main_sim900.h ****         (kom == CME_ERROR_KOMENDA_SIM900 &&
 3843               		.loc 2 280 0 is_stmt 0 discriminator 1
 3844 12ca D530      		cpi r29,lo8(5)
 3845 12cc 01F4      		brne .L251
 282:main_sim900.h ****           numer_bledu_cme == CME_OPERATION_NOT_SUPPORTED))) {
 3846               		.loc 2 282 0 is_stmt 1
 3847 12ce 8091 0000 		lds r24,numer_bledu_cme
 3848 12d2 9091 0000 		lds r25,numer_bledu_cme+1
 3849 12d6 0397      		sbiw r24,3
 281:main_sim900.h ****          (numer_bledu_cme == CME_OPERATION_NOT_ALLOWED ||
 3850               		.loc 2 281 0
 3851 12d8 0297      		sbiw r24,2
 3852 12da 00F4      		brsh .L251
 3853               	.L250:
 284:main_sim900.h ****       nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 3854               		.loc 2 284 0
 3855 12dc 8091 0000 		lds r24,nastepne_wysylane_polecenie_SIM900
 3856 12e0 0E94 0000 		call dodaj_komende
 3857               	.LVL327:
 3858               	.L284:
 564:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 3859               		.loc 2 564 0
 3860 12e4 1092 0000 		sts nastepne_wysylane_polecenie_SIM900,__zero_reg__
 565:main_sim900.h ****     }
 3861               		.loc 2 565 0
 3862 12e8 1092 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,__zero_reg__
 3863 12ec 00C0      		rjmp .L252
 3864               	.L251:
 288:main_sim900.h ****                    MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 3865               		.loc 2 288 0 discriminator 1
 3866 12ee 8091 0000 		lds r24,liczba_wykonanych_komend_identycznego_polecenia
 3867 12f2 8F5F      		subi r24,lo8(-(1))
 287:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 3868               		.loc 2 287 0 discriminator 1
 3869 12f4 8093 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,r24
 3870 12f8 8330      		cpi r24,lo8(3)
 3871 12fa 00F4      		brsh .L252
 290:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 3872               		.loc 2 290 0
 3873 12fc 81EA      		ldi r24,lo8(-95)
 3874               	.L390:
 3875 12fe 0E94 0000 		call dodaj_komende
 3876               	.LVL328:
 3877               	.L252:
 291:main_sim900.h ****     break;
 3878               		.loc 2 291 0
 3879 1302 82E0      		ldi r24,lo8(2)
 3880 1304 00C0      		rjmp .L394
 3881               	.L211:
 295:main_sim900.h ****       static const uchar urc[] PROGMEM = "+CSQ:";
 3882               		.loc 2 295 0
 3883 1306 D130      		cpi r29,lo8(1)
 3884 1308 01F4      		brne .L254
 3885               	.LBB529:
 297:main_sim900.h ****       if (p1 != NULL) {
 3886               		.loc 2 297 0
 3887 130a 80E0      		ldi r24,lo8(urc.3232)
 3888 130c 90E0      		ldi r25,hi8(urc.3232)
 3889 130e 0E94 0000 		call polozenie_polecenia_SIM900
 3890               	.LVL329:
 298:main_sim900.h ****         p1 += strlen_R(urc) + 1;
 3891               		.loc 2 298 0
 3892 1312 0097      		sbiw r24,0
 3893 1314 01F4      		brne .+2
 3894 1316 00C0      		rjmp .L196
 3895               	.LVL330:
 300:main_sim900.h ****         // if ( poziom_sieci_gsm != POZIOM_SIECI_BLAD )
 3896               		.loc 2 300 0
 3897 1318 4AE0      		ldi r20,lo8(10)
 3898 131a 50E0      		ldi r21,0
 3899 131c 70E0      		ldi r23,0
 3900 131e 60E0      		ldi r22,0
 3901 1320 0696      		adiw r24,6
 3902               	.LVL331:
 3903 1322 0E94 0000 		call strtol
 3904               	.LVL332:
 3905 1326 6093 0000 		sts poziom_sieci_gsm,r22
 3906 132a 00C0      		rjmp .L196
 3907               	.L254:
 3908               	.LBE529:
 309:main_sim900.h ****     break;
 3909               		.loc 2 309 0
 3910 132c 83E6      		ldi r24,lo8(99)
 3911 132e 8093 0000 		sts poziom_sieci_gsm,r24
 3912 1332 00C0      		rjmp .L196
 3913               	.LVL333:
 3914               	.L255:
 3915               	.LBB530:
 3916               	.LBB521:
 319:main_sim900.h ****         if (*p1 != ',')
 3917               		.loc 2 319 0
 3918 1334 3896      		adiw r30,8
 3919               	.LVL334:
 3920 1336 00C0      		rjmp .L256
 3921               	.LVL335:
 3922               	.L260:
 329:main_sim900.h ****           modul_zalogowany_w_sieci = TRUE;
 3923               		.loc 2 329 0
 3924 1338 6B7F      		andi r22,lo8(-5)
 3925               	.LVL336:
 3926 133a 6130      		cpi r22,lo8(1)
 3927 133c 01F0      		breq .+2
 3928 133e 00C0      		rjmp .L196
 330:main_sim900.h ****         }
 3929               		.loc 2 330 0
 3930 1340 8FEF      		ldi r24,lo8(-1)
 3931 1342 8093 0000 		sts modul_zalogowany_w_sieci,r24
 3932 1346 00C0      		rjmp .L196
 3933               	.L207:
 3934               	.LBE521:
 3935               	.LBE530:
 337:main_sim900.h ****                                      (numer_bledu_cme == CME_INVALID_INDEX ||
 3936               		.loc 2 337 0
 3937 1348 D130      		cpi r29,lo8(1)
 3938 134a 01F0      		breq .L261
 337:main_sim900.h ****                                      (numer_bledu_cme == CME_INVALID_INDEX ||
 3939               		.loc 2 337 0 is_stmt 0 discriminator 1
 3940 134c D530      		cpi r29,lo8(5)
 3941 134e 01F4      		brne .L262
 338:main_sim900.h ****                                       numer_bledu_cme == CME_NOT_FOUND))) {
 3942               		.loc 2 338 0 is_stmt 1 discriminator 2
 3943 1350 8091 0000 		lds r24,numer_bledu_cme
 3944 1354 9091 0000 		lds r25,numer_bledu_cme+1
 3945 1358 4597      		sbiw r24,21
 337:main_sim900.h ****                                      (numer_bledu_cme == CME_INVALID_INDEX ||
 3946               		.loc 2 337 0 discriminator 2
 3947 135a 0297      		sbiw r24,2
 3948 135c 00F4      		brsh .L262
 3949               	.L261:
 340:main_sim900.h ****     } else {
 3950               		.loc 2 340 0
 3951 135e 1092 0000 		sts licznik_blad_stanu_karty_SIM,__zero_reg__
 3952 1362 00C0      		rjmp .L196
 3953               	.L262:
 342:main_sim900.h ****     }
 3954               		.loc 2 342 0
 3955 1364 8091 0000 		lds r24,licznik_blad_stanu_karty_SIM
 3956 1368 8F5F      		subi r24,lo8(-(1))
 3957 136a 8093 0000 		sts licznik_blad_stanu_karty_SIM,r24
 3958 136e 00C0      		rjmp .L196
 3959               	.L212:
 3960               	.LVL337:
 3961               	.LBB531:
 349:main_sim900.h ****       const uchar *p1 =
 3962               		.loc 2 349 0
 3963 1370 D130      		cpi r29,lo8(1)
 3964 1372 01F0      		breq .+2
 3965 1374 00C0      		rjmp .L263
 3966               	.LVL338:
 3967               	.LBB532:
 3968               	.LBB533:
  47:main_sim900.h **** }
 3969               		.loc 2 47 0
 3970 1376 46E0      		ldi r20,lo8(6)
 3971 1378 50E0      		ldi r21,0
 3972 137a 60E0      		ldi r22,lo8(polecenie_operator.3240)
 3973 137c 70E0      		ldi r23,hi8(polecenie_operator.3240)
 3974 137e 80E0      		ldi r24,lo8(odebrany_blok_SIM900+2)
 3975 1380 90E0      		ldi r25,hi8(odebrany_blok_SIM900+2)
 3976 1382 0E94 0000 		call strncmp_P
 3977               	.LVL339:
 3978               	.LBE533:
 3979               	.LBE532:
 349:main_sim900.h ****       const uchar *p1 =
 3980               		.loc 2 349 0
 3981 1386 892B      		or r24,r25
 3982 1388 01F4      		brne .L263
 3983               	.LBB534:
 351:main_sim900.h ****       if (p1 != NULL) {
 3984               		.loc 2 351 0
 3985 138a 80E0      		ldi r24,lo8(polecenie_operator.3240)
 3986 138c 90E0      		ldi r25,hi8(polecenie_operator.3240)
 3987 138e 0E94 0000 		call polozenie_polecenia_SIM900
 3988               	.LVL340:
 350:main_sim900.h ****           strchr(polozenie_polecenia_SIM900(polecenie_operator), ',');
 3989               		.loc 2 350 0
 3990 1392 6CE2      		ldi r22,lo8(44)
 3991 1394 70E0      		ldi r23,0
 3992 1396 0E94 0000 		call strchr
 3993               	.LVL341:
 352:main_sim900.h ****         p1 = strchr(p1, ',');
 3994               		.loc 2 352 0
 3995 139a 0097      		sbiw r24,0
 3996 139c 01F0      		breq .L263
 353:main_sim900.h ****         if (p1 != NULL) {
 3997               		.loc 2 353 0
 3998 139e 6CE2      		ldi r22,lo8(44)
 3999 13a0 70E0      		ldi r23,0
 4000 13a2 0E94 0000 		call strchr
 4001               	.LVL342:
 354:main_sim900.h ****           p1 = strchr(p1, '\"');
 4002               		.loc 2 354 0
 4003 13a6 0097      		sbiw r24,0
 4004 13a8 01F0      		breq .L263
 355:main_sim900.h ****           if (p1++ != NULL) {
 4005               		.loc 2 355 0
 4006 13aa 62E2      		ldi r22,lo8(34)
 4007 13ac 70E0      		ldi r23,0
 4008 13ae 0E94 0000 		call strchr
 4009               	.LVL343:
 356:main_sim900.h ****             const uchar *p2 = strchr(p1, '\"');
 4010               		.loc 2 356 0
 4011 13b2 0097      		sbiw r24,0
 4012 13b4 01F0      		breq .L263
 4013 13b6 8C01      		movw r16,r24
 4014 13b8 0F5F      		subi r16,-1
 4015 13ba 1F4F      		sbci r17,-1
 4016               	.LVL344:
 4017               	.LBB535:
 357:main_sim900.h ****             if (p2 != NULL && p1 != p2) {
 4018               		.loc 2 357 0
 4019 13bc 62E2      		ldi r22,lo8(34)
 4020 13be 70E0      		ldi r23,0
 4021 13c0 C801      		movw r24,r16
 4022 13c2 0E94 0000 		call strchr
 4023               	.LVL345:
 358:main_sim900.h ****               const uchar m = min(p2 - p1, ROZMIAR_NAZWA_OPERATORA);
 4024               		.loc 2 358 0
 4025 13c6 0097      		sbiw r24,0
 4026 13c8 01F0      		breq .L263
 358:main_sim900.h ****               const uchar m = min(p2 - p1, ROZMIAR_NAZWA_OPERATORA);
 4027               		.loc 2 358 0 is_stmt 0 discriminator 1
 4028 13ca 0817      		cp r16,r24
 4029 13cc 1907      		cpc r17,r25
 4030 13ce 01F0      		breq .L263
 4031               	.LVL346:
 4032               	.LBB536:
 359:main_sim900.h ****               memcpy(nazwa_operatora, p1, m);
 4033               		.loc 2 359 0 is_stmt 1
 4034 13d0 801B      		sub r24,r16
 4035 13d2 910B      		sbc r25,r17
 4036               	.LVL347:
 4037 13d4 8C30      		cpi r24,12
 4038 13d6 9105      		cpc r25,__zero_reg__
 4039 13d8 04F0      		brlt .L264
 4040 13da 8BE0      		ldi r24,lo8(11)
 4041 13dc 90E0      		ldi r25,0
 4042               	.L264:
 4043 13de EC01      		movw r28,r24
 4044 13e0 DD27      		clr r29
 360:main_sim900.h ****               nazwa_operatora[m] = '\0';
 4045               		.loc 2 360 0
 4046 13e2 AE01      		movw r20,r28
 4047 13e4 B801      		movw r22,r16
 4048 13e6 80E0      		ldi r24,lo8(nazwa_operatora)
 4049 13e8 90E0      		ldi r25,hi8(nazwa_operatora)
 4050 13ea 0E94 0000 		call memcpy
 4051               	.LVL348:
 361:main_sim900.h ****               w = TRUE;
 4052               		.loc 2 361 0
 4053 13ee C050      		subi r28,lo8(-(nazwa_operatora))
 4054 13f0 D040      		sbci r29,hi8(-(nazwa_operatora))
 4055 13f2 1882      		st Y,__zero_reg__
 4056               	.LVL349:
 4057               	.LBE536:
 4058               	.LBE535:
 4059               	.LBE534:
 369:main_sim900.h ****     else {
 4060               		.loc 2 369 0
 4061 13f4 1092 0000 		sts licznik_blad_zalogowania_u_operatora,__zero_reg__
 4062 13f8 00C0      		rjmp .L196
 4063               	.LVL350:
 4064               	.L263:
 371:main_sim900.h ****     }
 4065               		.loc 2 371 0
 4066 13fa 8091 0000 		lds r24,licznik_blad_zalogowania_u_operatora
 4067 13fe 8F5F      		subi r24,lo8(-(1))
 4068 1400 8093 0000 		sts licznik_blad_zalogowania_u_operatora,r24
 4069 1404 00C0      		rjmp .L196
 4070               	.LVL351:
 4071               	.L199:
 4072               	.LBE531:
 377:main_sim900.h ****         CMS_ERROR_KOMENDA_SIM900 /*&& numer_bledu_cms == CMS_SMS_ME_RESERVED*/) // co le interpretu
 4073               		.loc 2 377 0
 4074 1406 D630      		cpi r29,lo8(6)
 4075 1408 01F4      		brne .+2
 4076 140a 00C0      		rjmp .L252
 381:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 4077               		.loc 2 381 0
 4078 140c 84E9      		ldi r24,lo8(-108)
 380:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 4079               		.loc 2 380 0
 4080 140e D130      		cpi r29,lo8(1)
 4081 1410 01F0      		breq .+2
 4082 1412 00C0      		rjmp .L390
 4083 1414 00C0      		rjmp .L252
 4084               	.L209:
 386:main_sim900.h ****         czy_jest_komenda_uzytkownik_odebral_rozmowe()) {
 4085               		.loc 2 386 0
 4086 1416 D130      		cpi r29,lo8(1)
 4087 1418 01F0      		breq .L266
 387:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = TRUE;
 4088               		.loc 2 387 0 discriminator 1
 4089 141a 8091 0000 		lds r24,komenda_SIM900
 386:main_sim900.h ****         czy_jest_komenda_uzytkownik_odebral_rozmowe()) {
 4090               		.loc 2 386 0 discriminator 1
 4091 141e 8C30      		cpi r24,lo8(12)
 4092 1420 01F4      		brne .L267
 4093               	.L266:
 388:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 4094               		.loc 2 388 0
 4095 1422 8FEF      		ldi r24,lo8(-1)
 4096 1424 8093 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,r24
 389:main_sim900.h **** 
 4097               		.loc 2 389 0
 4098 1428 1092 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,__zero_reg__
 392:main_sim900.h ****         licznik_timeout_rozmowy_100ms = MAX_LICZNIK_TIMEOUT_ROZMOWY_100MS;
 4099               		.loc 2 392 0
 4100 142c 8091 0000 		lds r24,tryb_clip
 4101 1430 8111      		cpse r24,__zero_reg__
 4102 1432 00C0      		rjmp .L196
 393:main_sim900.h ****         opoznienie_SIM900_100MS =
 4103               		.loc 2 393 0
 4104 1434 8CE2      		ldi r24,lo8(44)
 4105 1436 91E0      		ldi r25,lo8(1)
 4106 1438 9093 0000 		sts licznik_timeout_rozmowy_100ms+1,r25
 4107 143c 8093 0000 		sts licznik_timeout_rozmowy_100ms,r24
 394:main_sim900.h ****             20; // 2 sekundy opoznienia przed wyslaniem tonu
 4108               		.loc 2 394 0
 4109 1440 84E1      		ldi r24,lo8(20)
 4110 1442 8093 0000 		sts opoznienie_SIM900_100MS,r24
 396:main_sim900.h ****       }
 4111               		.loc 2 396 0
 4112 1446 84EA      		ldi r24,lo8(-92)
 4113 1448 00C0      		rjmp .L395
 4114               	.L267:
 398:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 4115               		.loc 2 398 0
 4116 144a D430      		cpi r29,lo8(4)
 4117 144c 01F0      		breq .L268
 398:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 4118               		.loc 2 398 0 is_stmt 0 discriminator 2
 4119 144e 8091 0000 		lds r24,komenda_SIM900
 4120 1452 8038      		cpi r24,lo8(-128)
 4121 1454 01F4      		brne .L269
 4122               	.L268:
 399:main_sim900.h ****                    MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 4123               		.loc 2 399 0 is_stmt 1 discriminator 3
 4124 1456 8091 0000 		lds r24,liczba_wykonanych_komend_identycznego_polecenia
 4125 145a 8F5F      		subi r24,lo8(-(1))
 398:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 4126               		.loc 2 398 0 discriminator 3
 4127 145c 8093 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,r24
 4128 1460 8330      		cpi r24,lo8(3)
 4129 1462 00F4      		brsh .L269
 401:main_sim900.h ****     else if (kom == NO_CARRIER_KOMENDA_SIM900) {
 4130               		.loc 2 401 0
 4131 1464 85E9      		ldi r24,lo8(-107)
 4132 1466 00C0      		rjmp .L395
 4133               	.L269:
 402:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 4134               		.loc 2 402 0
 4135 1468 D330      		cpi r29,lo8(3)
 4136 146a 01F4      		brne .L270
 403:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 4137               		.loc 2 403 0
 4138 146c 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 4139               	.L270:
 406:main_sim900.h ****     break;
 4140               		.loc 2 406 0
 4141 1470 1092 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,__zero_reg__
 4142 1474 00C0      		rjmp .L196
 4143               	.L387:
 439:main_sim900.h ****       // odczytany sms
 4144               		.loc 2 439 0
 4145 1476 D130      		cpi r29,lo8(1)
 4146 1478 01F4      		brne .L272
 4147               	.LBB537:
 441:main_sim900.h ****       ptr = strchr(ptr, ZNAK_KONCA_ODBIERANIA_ZNAKOW_LF);            // (1)
 4148               		.loc 2 441 0
 4149 147a 80E0      		ldi r24,lo8(__c.3269)
 4150 147c 90E0      		ldi r25,hi8(__c.3269)
 4151 147e 0E94 0000 		call polozenie_polecenia_SIM900
 4152               	.LVL352:
 442:main_sim900.h ****       // const uchar* ptr = strchr(&odebrany_blok_SIM900[7],
 4153               		.loc 2 442 0
 4154 1482 6AE0      		ldi r22,lo8(10)
 4155 1484 70E0      		ldi r23,0
 4156 1486 0E94 0000 		call strchr
 4157               	.LVL353:
 445:main_sim900.h ****         ++ptr;
 4158               		.loc 2 445 0
 4159 148a 0097      		sbiw r24,0
 4160 148c 01F0      		breq .L273
 4161               	.LBB538:
 446:main_sim900.h ****         const uchar *ptr2 = strchr(ptr, ZNAK_KONCA_WYSYLANIA_ZNAKOW_CR);
 4162               		.loc 2 446 0
 4163 148e EC01      		movw r28,r24
 4164 1490 2196      		adiw r28,1
 4165               	.LVL354:
 447:main_sim900.h ****         if (ptr2 != NULL) {
 4166               		.loc 2 447 0
 4167 1492 6DE0      		ldi r22,lo8(13)
 4168 1494 70E0      		ldi r23,0
 4169 1496 CE01      		movw r24,r28
 4170 1498 0E94 0000 		call strchr
 4171               	.LVL355:
 448:main_sim900.h ****           dlugosc_pdu = (ptr2 - ptr) / 2;
 4172               		.loc 2 448 0
 4173 149c 0097      		sbiw r24,0
 4174 149e 01F0      		breq .L273
 4175               	.LBB539:
 449:main_sim900.h ****           if (dlugosc_pdu > MAX_DLUGOSC_PDU)
 4176               		.loc 2 449 0
 4177 14a0 8C1B      		sub r24,r28
 4178 14a2 9D0B      		sbc r25,r29
 4179               	.LVL356:
 4180 14a4 97FD      		sbrc r25,7
 4181 14a6 0196      		adiw r24,1
 4182               	.L274:
 4183 14a8 9595      		asr r25
 4184 14aa 8795      		ror r24
 450:main_sim900.h ****             dlugosc_pdu = MAX_DLUGOSC_PDU;
 4185               		.loc 2 450 0
 4186 14ac 893C      		cpi r24,lo8(-55)
 4187 14ae 00F4      		brsh .L275
 4188               	.L391:
 451:main_sim900.h ****           konwertuj_blok_dwa_znaki_na_znak_pdu(ptr, dlugosc_pdu, bufor_pdu);
 4189               		.loc 2 451 0
 4190 14b0 8093 0000 		sts dlugosc_pdu,r24
 452:main_sim900.h ****           dodaj_komende(KOMENDA_KOLEJKI_INTERPRETUJ_PDU);
 4191               		.loc 2 452 0
 4192 14b4 40E0      		ldi r20,lo8(bufor_pdu)
 4193 14b6 50E0      		ldi r21,hi8(bufor_pdu)
 4194 14b8 6091 0000 		lds r22,dlugosc_pdu
 4195 14bc CE01      		movw r24,r28
 4196 14be 0E94 0000 		call konwertuj_blok_dwa_znaki_na_znak_pdu
 4197               	.LVL357:
 453:main_sim900.h ****           const uchar nr_smsa = aktualnie_wysylane_polecenie_SIM900 -
 4198               		.loc 2 453 0
 4199 14c2 81ED      		ldi r24,lo8(-47)
 4200 14c4 0E94 0000 		call dodaj_komende
 4201               	.LVL358:
 456:main_sim900.h ****           flaga_odczytywanie_smsa = TRUE;
 4202               		.loc 2 456 0
 4203 14c8 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4204 14cc 8C5E      		subi r24,lo8(-(20))
 4205 14ce 0E94 0000 		call dodaj_komende
 4206               	.LVL359:
 457:main_sim900.h ****           POMOC_DODAJ2('#', 'O');
 4207               		.loc 2 457 0
 4208 14d2 8FEF      		ldi r24,lo8(-1)
 4209 14d4 8093 0000 		sts flaga_odczytywanie_smsa,r24
 4210               	.LVL360:
 4211 14d8 00C0      		rjmp .L196
 4212               	.LVL361:
 4213               	.L275:
 451:main_sim900.h ****           konwertuj_blok_dwa_znaki_na_znak_pdu(ptr, dlugosc_pdu, bufor_pdu);
 4214               		.loc 2 451 0
 4215 14da 88EC      		ldi r24,lo8(-56)
 4216 14dc 00C0      		rjmp .L391
 4217               	.LVL362:
 4218               	.L273:
 4219               	.LBE539:
 460:main_sim900.h ****       } else
 4220               		.loc 2 460 0
 4221 14de 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 4222 14e2 00C0      		rjmp .L196
 4223               	.L272:
 4224               	.LBE538:
 4225               	.LBE537:
 463:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 4226               		.loc 2 463 0
 4227 14e4 D630      		cpi r29,lo8(6)
 4228 14e6 01F0      		breq .L277
 4229               	.L399:
 468:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 4230               		.loc 2 468 0
 4231 14e8 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 469:main_sim900.h ****       POMOC_DODAJ2('#', 'P');
 4232               		.loc 2 469 0
 4233 14ec 8CE3      		ldi r24,lo8(60)
 4234 14ee 00C0      		rjmp .L394
 4235               	.L277:
 467:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 4236               		.loc 2 467 0
 4237 14f0 8C2F      		mov r24,r28
 4238 14f2 0E94 0000 		call dodaj_komende
 4239               	.LVL363:
 4240 14f6 00C0      		rjmp .L399
 4241               	.L278:
 502:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 4242               		.loc 2 502 0
 4243 14f8 D430      		cpi r29,lo8(4)
 4244 14fa 01F4      		brne .+2
 4245 14fc 00C0      		rjmp .L392
 4246               	.L279:
 504:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 4247               		.loc 2 504 0
 4248 14fe 8091 0000 		lds r24,komenda_SIM900
 4249 1502 8038      		cpi r24,lo8(-128)
 4250 1504 01F4      		brne .+2
 4251 1506 00C0      		rjmp .L392
 4252               	.L280:
 4253               	.LVL364:
 507:main_sim900.h ****     break;
 4254               		.loc 2 507 0
 4255 1508 89E1      		ldi r24,lo8(25)
 4256 150a 00C0      		rjmp .L394
 4257               	.LVL365:
 4258               	.L222:
 515:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 4259               		.loc 2 515 0
 4260 150c D430      		cpi r29,lo8(4)
 4261 150e 01F0      		breq .L281
 515:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 4262               		.loc 2 515 0 is_stmt 0 discriminator 1
 4263 1510 8091 0000 		lds r24,komenda_SIM900
 4264 1514 8038      		cpi r24,lo8(-128)
 4265 1516 01F0      		breq .+2
 4266 1518 00C0      		rjmp .L270
 4267               	.L281:
 516:main_sim900.h ****       if (++liczba_wykonanych_komend_identycznego_polecenia <
 4268               		.loc 2 516 0 is_stmt 1
 4269 151a 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 517:main_sim900.h ****           MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 4270               		.loc 2 517 0
 4271 151e 8091 0000 		lds r24,liczba_wykonanych_komend_identycznego_polecenia
 4272 1522 8F5F      		subi r24,lo8(-(1))
 4273 1524 8093 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,r24
 4274 1528 8330      		cpi r24,lo8(3)
 4275 152a 00F4      		brsh .L282
 519:main_sim900.h ****       else {
 4276               		.loc 2 519 0
 4277 152c 85ED      		ldi r24,lo8(-43)
 4278 152e 00C0      		rjmp .L395
 4279               	.L282:
 521:main_sim900.h ****         zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 4280               		.loc 2 521 0
 4281 1530 1092 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,__zero_reg__
 522:main_sim900.h ****         trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 4282               		.loc 2 522 0
 4283 1534 80E0      		ldi r24,0
 4284 1536 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 4285               	.LVL366:
 523:main_sim900.h ****         wykonywanie_rozmowy_telefonicznej = FALSE;
 4286               		.loc 2 523 0
 4287 153a 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 524:main_sim900.h ****         licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 4288               		.loc 2 524 0
 4289 153e 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 525:main_sim900.h ****       }
 4290               		.loc 2 525 0
 4291 1542 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 4292 1546 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 4293 154a 00C0      		rjmp .L196
 4294               	.L201:
 532:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 4295               		.loc 2 532 0
 4296 154c D130      		cpi r29,lo8(1)
 4297 154e 01F0      		breq .L283
 533:main_sim900.h ****       opoznienie_SIM900_100MS = 20;
 4298               		.loc 2 533 0
 4299 1550 8EE8      		ldi r24,lo8(-114)
 4300 1552 0E94 0000 		call dodaj_komende
 4301               	.LVL367:
 534:main_sim900.h ****       break;
 4302               		.loc 2 534 0
 4303 1556 84E1      		ldi r24,lo8(20)
 4304 1558 00C0      		rjmp .L394
 4305               	.L283:
 557:main_sim900.h ****       if (nastepne_wysylane_polecenie_SIM900 >=
 4306               		.loc 2 557 0
 4307 155a 8091 0000 		lds r24,nastepne_wysylane_polecenie_SIM900
 4308 155e 0E94 0000 		call dodaj_komende
 4309               	.LVL368:
 559:main_sim900.h ****           nastepne_wysylane_polecenie_SIM900 <=
 4310               		.loc 2 559 0
 4311 1562 8091 0000 		lds r24,nastepne_wysylane_polecenie_SIM900
 4312 1566 895A      		subi r24,lo8(-(87))
 558:main_sim900.h ****               KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 4313               		.loc 2 558 0
 4314 1568 8431      		cpi r24,lo8(20)
 4315 156a 00F0      		brlo .+2
 4316 156c 00C0      		rjmp .L284
 562:main_sim900.h ****       }
 4317               		.loc 2 562 0
 4318 156e 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 4319 1572 00C0      		rjmp .L284
 4320               		.cfi_endproc
 4321               	.LFE49:
 4323               	.global	obsluga_komendy_SIM900
 4325               	obsluga_komendy_SIM900:
 4326               	.LFB50:
 574:main_sim900.h **** 
 575:main_sim900.h **** void obsluga_komendy_SIM900(void) {
 4327               		.loc 2 575 0
 4328               		.cfi_startproc
 4329 1574 0F93      		push r16
 4330               	.LCFI61:
 4331               		.cfi_def_cfa_offset 3
 4332               		.cfi_offset 16, -2
 4333 1576 1F93      		push r17
 4334               	.LCFI62:
 4335               		.cfi_def_cfa_offset 4
 4336               		.cfi_offset 17, -3
 4337 1578 CF93      		push r28
 4338               	.LCFI63:
 4339               		.cfi_def_cfa_offset 5
 4340               		.cfi_offset 28, -4
 4341 157a DF93      		push r29
 4342               	.LCFI64:
 4343               		.cfi_def_cfa_offset 6
 4344               		.cfi_offset 29, -5
 4345               	/* prologue: function */
 4346               	/* frame size = 0 */
 4347               	/* stack size = 4 */
 4348               	.L__stack_usage = 4
 576:main_sim900.h ****   if (!czy_jest_bezczynny_SIM900())
 4349               		.loc 2 576 0
 4350 157c 8091 0000 		lds r24,komenda_SIM900
 577:main_sim900.h ****     POMOC_SIM900_DODAJ(odebrany_blok_SIM900);
 578:main_sim900.h **** 
 579:main_sim900.h ****   if (czy_jest_blad_SIM900() || oproznij_bufor_SIM900_po_bledzie) {
 4351               		.loc 2 579 0
 4352 1580 8091 0000 		lds r24,komenda_SIM900
 4353 1584 8038      		cpi r24,lo8(-128)
 4354 1586 01F0      		breq .L401
 4355               		.loc 2 579 0 is_stmt 0 discriminator 1
 4356 1588 8091 0000 		lds r24,oproznij_bufor_SIM900_po_bledzie
 4357 158c 8823      		tst r24
 4358 158e 01F0      		breq .L402
 4359               	.L401:
 580:main_sim900.h ****     komenda_SIM900 = BLAD_SIM900;
 4360               		.loc 2 580 0 is_stmt 1
 4361 1590 80E8      		ldi r24,lo8(-128)
 4362 1592 8093 0000 		sts komenda_SIM900,r24
 581:main_sim900.h ****     odpowiedz_na_polecenie();
 4363               		.loc 2 581 0
 4364 1596 0E94 0000 		call odpowiedz_na_polecenie
 4365               	.LVL369:
 582:main_sim900.h ****     opoznienie_SIM900_100MS = 50;
 4366               		.loc 2 582 0
 4367 159a 82E3      		ldi r24,lo8(50)
 4368 159c 8093 0000 		sts opoznienie_SIM900_100MS,r24
 583:main_sim900.h ****     oproznij_bufor_SIM900_po_bledzie = TRUE;
 4369               		.loc 2 583 0
 4370 15a0 8FEF      		ldi r24,lo8(-1)
 4371 15a2 8093 0000 		sts oproznij_bufor_SIM900_po_bledzie,r24
 4372               	.LVL370:
 4373               	.L400:
 4374               	/* epilogue start */
 584:main_sim900.h ****     POMOC_DODAJ2('*', 'd');
 585:main_sim900.h ****     return;
 586:main_sim900.h ****   }
 587:main_sim900.h **** 
 588:main_sim900.h ****   if (czy_jest_komenda_wyslane_polecenie_SIM900()) {
 589:main_sim900.h ****     if ((liczba_wysylanych_znakow_SIM900 != liczba_odebranych_znakow_SIM900 ||
 590:main_sim900.h ****          memcmp(odebrany_blok_SIM900, wysylany_blok_SIM900,
 591:main_sim900.h ****                 liczba_wysylanych_znakow_SIM900) != 0) &&
 592:main_sim900.h ****         !czekanie_na_odebranie_zachety) {
 593:main_sim900.h ****       komenda_SIM900 = BLAD_SIM900;
 594:main_sim900.h ****       oproznij_bufor_SIM900_po_bledzie = TRUE;
 595:main_sim900.h ****       opoznienie_SIM900_100MS = 50;
 596:main_sim900.h ****       POMOC_DODAJ2('*', 'e');
 597:main_sim900.h ****     }
 598:main_sim900.h ****     return;
 599:main_sim900.h ****   }
 600:main_sim900.h **** 
 601:main_sim900.h ****   if (czy_jest_komenda_rozmowa_telefoniczna()) {
 602:main_sim900.h ****     POMOC_DODAJ2('#', 'b');
 603:main_sim900.h ****     // numer_telefonu_ktory_dzwoni[0] = '\0';  // REMOVED: Niepotrzebne
 604:main_sim900.h ****     // czyszczenie - numer jest zaraz nadpisywany
 605:main_sim900.h ****     const uchar *p1 = strchr(polozenie_polecenia_SIM900(PSTR("+CLIP:")), '\"');
 606:main_sim900.h ****     if (p1++ != NULL) {
 607:main_sim900.h ****       const uchar *p2 = strchr(p1, '\"');
 608:main_sim900.h ****       if (p2 != NULL) {
 609:main_sim900.h ****         const uchar l = p2 - p1;
 610:main_sim900.h ****         if (l < MAX_LICZBA_ZNAKOW_TELEFON) {
 611:main_sim900.h ****           memcpy(numer_telefonu_ktory_dzwoni, p1, l);
 612:main_sim900.h ****           numer_telefonu_ktory_dzwoni[l] = '\0';
 613:main_sim900.h ****           POMOC_DODAJ_HEX(l);
 614:main_sim900.h ****           if (licznik_blad_zalogowania_u_operatora != 0)
 615:main_sim900.h ****             licznik_blad_zalogowania_u_operatora = 0;
 616:main_sim900.h ****           if (poziom_sieci_gsm == 0 || poziom_sieci_gsm == POZIOM_SIECI_BLAD)
 617:main_sim900.h ****             poziom_sieci_gsm = 16;
 618:main_sim900.h ****         }
 619:main_sim900.h ****       }
 620:main_sim900.h ****     }
 621:main_sim900.h ****     filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_PRZYCHODZACA_ROZMOWE);
 622:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 623:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 624:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 625:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 626:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 627:main_sim900.h ****     }
 628:main_sim900.h ****     wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 629:main_sim900.h ****     return;
 630:main_sim900.h ****   }
 631:main_sim900.h **** 
 632:main_sim900.h ****   if (czy_jest_komenda_zakonczenie_rozmowy_telefonicznej()) {
 633:main_sim900.h ****     POMOC_DODAJ2('#', 'c');
 634:main_sim900.h ****     zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 635:main_sim900.h ****     trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 636:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 637:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 638:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 ==
 639:main_sim900.h ****         KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE) {
 640:main_sim900.h ****       wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 641:main_sim900.h ****     }
 642:main_sim900.h ****     return;
 643:main_sim900.h ****   }
 644:main_sim900.h **** 
 645:main_sim900.h ****   if (czy_jest_komenda_uzytkownik_odebral_dzwonek()) {
 646:main_sim900.h ****     POMOC_DODAJ2('#', 'd');
 647:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 == KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE)
 648:main_sim900.h ****       odpowiedz_na_polecenie();
 649:main_sim900.h ****     if (ustaw_maksymalny_czas_dzwonienia == 0)
 650:main_sim900.h ****       maksymalny_czas_dzwonienia = 90; // standardowy czas czekania 9 sekund
 651:main_sim900.h ****     else {
 652:main_sim900.h ****       maksymalny_czas_dzwonienia = ustaw_maksymalny_czas_dzwonienia;
 653:main_sim900.h ****       ustaw_maksymalny_czas_dzwonienia = 0;
 654:main_sim900.h ****     }
 655:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = TRUE;
 656:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 657:main_sim900.h ****     return;
 658:main_sim900.h ****   }
 659:main_sim900.h **** 
 660:main_sim900.h ****   // Obsluga +DTMF:
 661:main_sim900.h ****   const uchar *ptr_dtmf = polozenie_polecenia_SIM900(PSTR("+DTMF:"));
 662:main_sim900.h ****   if (ptr_dtmf != NULL) {
 663:main_sim900.h ****     POMOC_DODAJ2('#', 'D');
 664:main_sim900.h ****     ptr_dtmf += 7; // Skip "+DTMF: "
 665:main_sim900.h ****     while (*ptr_dtmf == ' ')
 666:main_sim900.h ****       ++ptr_dtmf;
 667:main_sim900.h ****     const uchar dtmf_key = *ptr_dtmf;
 668:main_sim900.h ****     POMOC_DODAJ(dtmf_key);
 669:main_sim900.h **** 
 670:main_sim900.h ****     if (!tryb_clip) // Tylko w trybie DTMF
 671:main_sim900.h ****     {
 672:main_sim900.h ****       if (dtmf_key == '1') {
 673:main_sim900.h ****         stan_wyjscie[0] = TRUE;
 674:main_sim900.h ****         licznik_przelacznik_wyjscia[0] = 2 * 10ul; // 2 sekundy retrigger
 675:main_sim900.h ****         zapal_diode_led(10);
 676:main_sim900.h ****       }
 677:main_sim900.h ****     }
 678:main_sim900.h ****     resetuj_komende_SIM900(); // Krytyczne dla kolejnych znakow
 679:main_sim900.h ****     return;
 680:main_sim900.h ****   }
 681:main_sim900.h **** 
 682:main_sim900.h ****   if (czy_jest_komenda_uzytkownik_odebral_rozmowe()) {
 683:main_sim900.h ****     POMOC_DODAJ2('#', 'e');
 684:main_sim900.h ****     if (tryb_clip) {
 685:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 686:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
 687:main_sim900.h ****     }
 688:main_sim900.h ****     return;
 689:main_sim900.h ****   }
 690:main_sim900.h ****   if (czy_jest_komenda_brak_sygnalu_tonowego()) {
 691:main_sim900.h ****     POMOC_DODAJ2('#', 'f');
 692:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 == KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE)
 693:main_sim900.h ****       odpowiedz_na_polecenie();
 694:main_sim900.h ****     zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 695:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 696:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 697:main_sim900.h ****     return;
 698:main_sim900.h ****   }
 699:main_sim900.h **** 
 700:main_sim900.h ****   if (czy_jest_komenda_telefon_zajety()) {
 701:main_sim900.h ****     POMOC_DODAJ2('#', 'g');
 702:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 == KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE)
 703:main_sim900.h ****       odpowiedz_na_polecenie();
 704:main_sim900.h ****     zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 705:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 706:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 707:main_sim900.h ****     return;
 708:main_sim900.h ****   }
 709:main_sim900.h **** 
 710:main_sim900.h ****   if (czy_jest_komenda_nowy_SMS()) {
 711:main_sim900.h ****     const uchar *ptr = strchr(polozenie_polecenia_SIM900(PSTR("+CMTI:")), ',');
 712:main_sim900.h ****     if (ptr != NULL) {
 713:main_sim900.h ****       uint numer_smsa = (uint)strtoul(ptr + 1, NULL, 10);
 714:main_sim900.h ****       if (numer_smsa > 0 && numer_smsa <= 20) // Hardcoded 20
 715:main_sim900.h ****       {
 716:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 + numer_smsa - 1);
 717:main_sim900.h ****         opoznienie_SIM900_100MS = 1; // 20 (1)
 718:main_sim900.h ****       }
 719:main_sim900.h ****     }
 720:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 721:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 722:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 723:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 724:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 725:main_sim900.h ****       wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 726:main_sim900.h ****     }
 727:main_sim900.h ****     return;
 728:main_sim900.h ****   }
 729:main_sim900.h **** 
 730:main_sim900.h ****   if (czy_jest_komenda_otrzymano_sms_flash()) {
 731:main_sim900.h ****     opoznienie_SIM900_100MS = 20;
 732:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 733:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 734:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 735:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 736:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 737:main_sim900.h ****       wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 738:main_sim900.h ****     }
 739:main_sim900.h ****     const uchar *p1 = strchr(polozenie_polecenia_SIM900(PSTR("+CUSD:")), '\"');
 740:main_sim900.h ****     if (p1++ != NULL) {
 741:main_sim900.h ****       uchar *p2 = strchr(p1, '\"');
 742:main_sim900.h ****       if (p2 != NULL) {
 743:main_sim900.h ****         //*p2 = '\0';
 744:main_sim900.h ****         // tekst_wysylanego_smsa[0] = '*';
 745:main_sim900.h ****         // strncpy(&tekst_wysylanego_smsa[1], p1, MAX_LICZBA_ZNAKOW_SMS - 1);
 746:main_sim900.h ****         // tekst_wysylanego_smsa[MAX_LICZBA_ZNAKOW_SMS] = 0;
 747:main_sim900.h ****       }
 748:main_sim900.h ****     }
 749:main_sim900.h ****     return;
 750:main_sim900.h ****   }
 751:main_sim900.h **** 
 752:main_sim900.h ****   if (flaga_wysylanie_smsa)
 753:main_sim900.h ****     obsluga_wysylania_sms();
 754:main_sim900.h **** 
 755:main_sim900.h ****   if (liczba_odebranych_znakow_SIM900 != 0 &&
 756:main_sim900.h ****       komenda_SIM900 != BRAK_KOMENDY_SIM900)
 757:main_sim900.h ****     odpowiedz_na_polecenie();
 758:main_sim900.h **** }
 4375               		.loc 2 758 0
 4376 15a6 DF91      		pop r29
 4377 15a8 CF91      		pop r28
 4378 15aa 1F91      		pop r17
 4379 15ac 0F91      		pop r16
 4380 15ae 0895      		ret
 4381               	.L402:
 588:main_sim900.h ****     if ((liczba_wysylanych_znakow_SIM900 != liczba_odebranych_znakow_SIM900 ||
 4382               		.loc 2 588 0
 4383 15b0 8091 0000 		lds r24,komenda_SIM900
 4384 15b4 8138      		cpi r24,lo8(-127)
 4385 15b6 01F4      		brne .L404
 589:main_sim900.h ****          memcmp(odebrany_blok_SIM900, wysylany_blok_SIM900,
 4386               		.loc 2 589 0
 4387 15b8 2091 0000 		lds r18,liczba_wysylanych_znakow_SIM900
 4388 15bc 3091 0000 		lds r19,liczba_wysylanych_znakow_SIM900+1
 4389 15c0 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 4390 15c4 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
 4391 15c8 2817      		cp r18,r24
 4392 15ca 3907      		cpc r19,r25
 4393 15cc 01F4      		brne .L405
 590:main_sim900.h ****                 liczba_wysylanych_znakow_SIM900) != 0) &&
 4394               		.loc 2 590 0 discriminator 1
 4395 15ce 4091 0000 		lds r20,liczba_wysylanych_znakow_SIM900
 4396 15d2 5091 0000 		lds r21,liczba_wysylanych_znakow_SIM900+1
 4397 15d6 60E0      		ldi r22,lo8(wysylany_blok_SIM900)
 4398 15d8 70E0      		ldi r23,hi8(wysylany_blok_SIM900)
 4399 15da 80E0      		ldi r24,lo8(odebrany_blok_SIM900)
 4400 15dc 90E0      		ldi r25,hi8(odebrany_blok_SIM900)
 4401 15de 0E94 0000 		call memcmp
 4402               	.LVL371:
 589:main_sim900.h ****          memcmp(odebrany_blok_SIM900, wysylany_blok_SIM900,
 4403               		.loc 2 589 0 discriminator 1
 4404 15e2 892B      		or r24,r25
 4405 15e4 01F0      		breq .L400
 4406               	.L405:
 592:main_sim900.h ****       komenda_SIM900 = BLAD_SIM900;
 4407               		.loc 2 592 0
 4408 15e6 8091 0000 		lds r24,czekanie_na_odebranie_zachety
 591:main_sim900.h ****         !czekanie_na_odebranie_zachety) {
 4409               		.loc 2 591 0
 4410 15ea 8111      		cpse r24,__zero_reg__
 4411 15ec 00C0      		rjmp .L400
 593:main_sim900.h ****       oproznij_bufor_SIM900_po_bledzie = TRUE;
 4412               		.loc 2 593 0
 4413 15ee 80E8      		ldi r24,lo8(-128)
 4414 15f0 8093 0000 		sts komenda_SIM900,r24
 594:main_sim900.h ****       opoznienie_SIM900_100MS = 50;
 4415               		.loc 2 594 0
 4416 15f4 8FEF      		ldi r24,lo8(-1)
 4417 15f6 8093 0000 		sts oproznij_bufor_SIM900_po_bledzie,r24
 595:main_sim900.h ****       POMOC_DODAJ2('*', 'e');
 4418               		.loc 2 595 0
 4419 15fa 82E3      		ldi r24,lo8(50)
 4420 15fc 8093 0000 		sts opoznienie_SIM900_100MS,r24
 4421               	.LVL372:
 4422 1600 00C0      		rjmp .L400
 4423               	.LVL373:
 4424               	.L404:
 4425               	.LBB554:
 4426               	.LBB555:
 601:main_sim900.h ****     POMOC_DODAJ2('#', 'b');
 4427               		.loc 2 601 0
 4428 1602 8091 0000 		lds r24,komenda_SIM900
 4429 1606 8A30      		cpi r24,lo8(10)
 4430 1608 01F0      		breq .+2
 4431 160a 00C0      		rjmp .L407
 4432               	.LVL374:
 4433               	.LBB556:
 605:main_sim900.h ****     if (p1++ != NULL) {
 4434               		.loc 2 605 0
 4435 160c 80E0      		ldi r24,lo8(__c.3311)
 4436 160e 90E0      		ldi r25,hi8(__c.3311)
 4437 1610 0E94 0000 		call polozenie_polecenia_SIM900
 4438               	.LVL375:
 4439 1614 62E2      		ldi r22,lo8(34)
 4440 1616 70E0      		ldi r23,0
 4441 1618 0E94 0000 		call strchr
 4442               	.LVL376:
 606:main_sim900.h ****       const uchar *p2 = strchr(p1, '\"');
 4443               		.loc 2 606 0
 4444 161c 0097      		sbiw r24,0
 4445 161e 01F0      		breq .L409
 4446 1620 8C01      		movw r16,r24
 4447 1622 0F5F      		subi r16,-1
 4448 1624 1F4F      		sbci r17,-1
 4449               	.LVL377:
 4450               	.LBB557:
 607:main_sim900.h ****       if (p2 != NULL) {
 4451               		.loc 2 607 0
 4452 1626 62E2      		ldi r22,lo8(34)
 4453 1628 70E0      		ldi r23,0
 4454 162a C801      		movw r24,r16
 4455 162c 0E94 0000 		call strchr
 4456               	.LVL378:
 608:main_sim900.h ****         const uchar l = p2 - p1;
 4457               		.loc 2 608 0
 4458 1630 0097      		sbiw r24,0
 4459 1632 01F0      		breq .L409
 4460               	.LBB558:
 609:main_sim900.h ****         if (l < MAX_LICZBA_ZNAKOW_TELEFON) {
 4461               		.loc 2 609 0
 4462 1634 EC01      		movw r28,r24
 4463 1636 C01B      		sub r28,r16
 4464 1638 D10B      		sbc r29,r17
 4465               	.LVL379:
 610:main_sim900.h ****           memcpy(numer_telefonu_ktory_dzwoni, p1, l);
 4466               		.loc 2 610 0
 4467 163a C031      		cpi r28,lo8(16)
 4468 163c 00F4      		brsh .L409
 4469 163e DD27      		clr r29
 4470               	.LVL380:
 611:main_sim900.h ****           numer_telefonu_ktory_dzwoni[l] = '\0';
 4471               		.loc 2 611 0
 4472 1640 AE01      		movw r20,r28
 4473 1642 B801      		movw r22,r16
 4474 1644 80E0      		ldi r24,lo8(numer_telefonu_ktory_dzwoni)
 4475 1646 90E0      		ldi r25,hi8(numer_telefonu_ktory_dzwoni)
 4476               	.LVL381:
 4477 1648 0E94 0000 		call memcpy
 4478               	.LVL382:
 612:main_sim900.h ****           POMOC_DODAJ_HEX(l);
 4479               		.loc 2 612 0
 4480 164c C050      		subi r28,lo8(-(numer_telefonu_ktory_dzwoni))
 4481 164e D040      		sbci r29,hi8(-(numer_telefonu_ktory_dzwoni))
 4482 1650 1882      		st Y,__zero_reg__
 4483               	.LVL383:
 614:main_sim900.h ****             licznik_blad_zalogowania_u_operatora = 0;
 4484               		.loc 2 614 0
 4485 1652 8091 0000 		lds r24,licznik_blad_zalogowania_u_operatora
 4486 1656 8111      		cpse r24,__zero_reg__
 615:main_sim900.h ****           if (poziom_sieci_gsm == 0 || poziom_sieci_gsm == POZIOM_SIECI_BLAD)
 4487               		.loc 2 615 0
 4488 1658 1092 0000 		sts licznik_blad_zalogowania_u_operatora,__zero_reg__
 4489               	.L411:
 616:main_sim900.h ****             poziom_sieci_gsm = 16;
 4490               		.loc 2 616 0
 4491 165c 8091 0000 		lds r24,poziom_sieci_gsm
 4492 1660 8823      		tst r24
 4493 1662 01F0      		breq .L412
 4494 1664 8336      		cpi r24,lo8(99)
 4495 1666 01F4      		brne .L409
 4496               	.L412:
 617:main_sim900.h ****         }
 4497               		.loc 2 617 0
 4498 1668 80E1      		ldi r24,lo8(16)
 4499 166a 8093 0000 		sts poziom_sieci_gsm,r24
 4500               	.LVL384:
 4501               	.L409:
 4502               	.LBE558:
 4503               	.LBE557:
 621:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 4504               		.loc 2 621 0
 4505 166e 87E9      		ldi r24,lo8(-105)
 4506 1670 0E94 0000 		call filtruj_i_dodaj_komende
 4507               	.LVL385:
 623:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 4508               		.loc 2 623 0
 4509 1674 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4510 1678 895A      		subi r24,lo8(-(87))
 622:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 4511               		.loc 2 622 0
 4512 167a 8431      		cpi r24,lo8(20)
 4513 167c 00F4      		brsh .L413
 4514               	.LVL386:
 4515               	.L469:
 626:main_sim900.h ****     }
 4516               		.loc 2 626 0
 4517 167e 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 4518               	.L413:
 628:main_sim900.h ****     return;
 4519               		.loc 2 628 0
 4520 1682 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 4521 1686 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 4522 168a 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
 4523 168e 00C0      		rjmp .L400
 4524               	.L407:
 4525               	.LBE556:
 632:main_sim900.h ****     POMOC_DODAJ2('#', 'c');
 4526               		.loc 2 632 0
 4527 1690 8091 0000 		lds r24,komenda_SIM900
 4528 1694 8330      		cpi r24,lo8(3)
 4529 1696 01F4      		brne .L414
 4530               	.LVL387:
 634:main_sim900.h ****     trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 4531               		.loc 2 634 0
 4532 1698 80E0      		ldi r24,0
 4533 169a 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 4534               	.LVL388:
 635:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 4535               		.loc 2 635 0
 4536 169e 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 636:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 4537               		.loc 2 636 0
 4538 16a2 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 637:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 ==
 4539               		.loc 2 637 0
 4540 16a6 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 4541 16aa 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 638:main_sim900.h ****         KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE) {
 4542               		.loc 2 638 0
 4543 16ae 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4544 16b2 853D      		cpi r24,lo8(-43)
 4545 16b4 01F0      		breq .+2
 4546 16b6 00C0      		rjmp .L400
 4547 16b8 00C0      		rjmp .L413
 4548               	.LVL389:
 4549               	.L414:
 645:main_sim900.h ****     POMOC_DODAJ2('#', 'd');
 4550               		.loc 2 645 0
 4551 16ba 8091 0000 		lds r24,komenda_SIM900
 4552 16be 8230      		cpi r24,lo8(2)
 4553 16c0 01F4      		brne .L415
 4554               	.LVL390:
 647:main_sim900.h ****       odpowiedz_na_polecenie();
 4555               		.loc 2 647 0
 4556 16c2 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4557 16c6 853D      		cpi r24,lo8(-43)
 4558 16c8 01F4      		brne .L416
 648:main_sim900.h ****     if (ustaw_maksymalny_czas_dzwonienia == 0)
 4559               		.loc 2 648 0
 4560 16ca 0E94 0000 		call odpowiedz_na_polecenie
 4561               	.LVL391:
 4562               	.L416:
 649:main_sim900.h ****       maksymalny_czas_dzwonienia = 90; // standardowy czas czekania 9 sekund
 4563               		.loc 2 649 0
 4564 16ce 8091 0000 		lds r24,ustaw_maksymalny_czas_dzwonienia
 4565 16d2 8111      		cpse r24,__zero_reg__
 4566 16d4 00C0      		rjmp .L417
 650:main_sim900.h ****     else {
 4567               		.loc 2 650 0
 4568 16d6 8AE5      		ldi r24,lo8(90)
 4569 16d8 8093 0000 		sts maksymalny_czas_dzwonienia,r24
 4570               	.L418:
 655:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 4571               		.loc 2 655 0
 4572 16dc 8FEF      		ldi r24,lo8(-1)
 4573 16de 8093 0000 		sts wykonywanie_rozmowy_telefonicznej,r24
 4574               	.LVL392:
 4575               	.L470:
 696:main_sim900.h ****     return;
 4576               		.loc 2 696 0
 4577 16e2 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 4578 16e6 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 4579 16ea 00C0      		rjmp .L400
 4580               	.LVL393:
 4581               	.L417:
 652:main_sim900.h ****       ustaw_maksymalny_czas_dzwonienia = 0;
 4582               		.loc 2 652 0
 4583 16ec 8093 0000 		sts maksymalny_czas_dzwonienia,r24
 653:main_sim900.h ****     }
 4584               		.loc 2 653 0
 4585 16f0 1092 0000 		sts ustaw_maksymalny_czas_dzwonienia,__zero_reg__
 4586 16f4 00C0      		rjmp .L418
 4587               	.LVL394:
 4588               	.L415:
 661:main_sim900.h ****   if (ptr_dtmf != NULL) {
 4589               		.loc 2 661 0
 4590 16f6 80E0      		ldi r24,lo8(__c.3316)
 4591 16f8 90E0      		ldi r25,hi8(__c.3316)
 4592 16fa 0E94 0000 		call polozenie_polecenia_SIM900
 4593               	.LVL395:
 662:main_sim900.h ****     POMOC_DODAJ2('#', 'D');
 4594               		.loc 2 662 0
 4595 16fe 0097      		sbiw r24,0
 4596 1700 01F0      		breq .L419
 4597               	.LVL396:
 4598               	.LBB559:
 664:main_sim900.h ****     while (*ptr_dtmf == ' ')
 4599               		.loc 2 664 0
 4600 1702 FC01      		movw r30,r24
 4601 1704 3796      		adiw r30,7
 4602               	.LVL397:
 4603               	.L420:
 665:main_sim900.h ****       ++ptr_dtmf;
 4604               		.loc 2 665 0
 4605 1706 8191      		ld r24,Z+
 4606               	.LVL398:
 4607 1708 8032      		cpi r24,lo8(32)
 4608 170a 01F0      		breq .L420
 4609               	.LVL399:
 670:main_sim900.h ****     {
 4610               		.loc 2 670 0
 4611 170c 9091 0000 		lds r25,tryb_clip
 4612 1710 9111      		cpse r25,__zero_reg__
 4613 1712 00C0      		rjmp .L421
 672:main_sim900.h ****         stan_wyjscie[0] = TRUE;
 4614               		.loc 2 672 0
 4615 1714 8133      		cpi r24,lo8(49)
 4616 1716 01F4      		brne .L421
 673:main_sim900.h ****         licznik_przelacznik_wyjscia[0] = 2 * 10ul; // 2 sekundy retrigger
 4617               		.loc 2 673 0
 4618 1718 8FEF      		ldi r24,lo8(-1)
 4619               	.LVL400:
 4620 171a 8093 0000 		sts stan_wyjscie,r24
 4621               	.LVL401:
 674:main_sim900.h ****         zapal_diode_led(10);
 4622               		.loc 2 674 0
 4623 171e 84E1      		ldi r24,lo8(20)
 4624 1720 90E0      		ldi r25,0
 4625 1722 A0E0      		ldi r26,0
 4626 1724 B0E0      		ldi r27,0
 4627 1726 8093 0000 		sts licznik_przelacznik_wyjscia,r24
 4628 172a 9093 0000 		sts licznik_przelacznik_wyjscia+1,r25
 4629 172e A093 0000 		sts licznik_przelacznik_wyjscia+2,r26
 4630 1732 B093 0000 		sts licznik_przelacznik_wyjscia+3,r27
 675:main_sim900.h ****       }
 4631               		.loc 2 675 0
 4632 1736 8BE0      		ldi r24,lo8(11)
 4633 1738 8093 0000 		sts licznik_100ms_dioda_led,r24
 4634               	.L421:
 678:main_sim900.h ****     return;
 4635               		.loc 2 678 0
 4636 173c 1092 0000 		sts komenda_SIM900,__zero_reg__
 4637 1740 00C0      		rjmp .L400
 4638               	.LVL402:
 4639               	.L419:
 4640               	.LBE559:
 682:main_sim900.h ****     POMOC_DODAJ2('#', 'e');
 4641               		.loc 2 682 0
 4642 1742 8091 0000 		lds r24,komenda_SIM900
 4643               	.LVL403:
 4644 1746 8C30      		cpi r24,lo8(12)
 4645 1748 01F4      		brne .L422
 4646               	.LVL404:
 684:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 4647               		.loc 2 684 0
 4648 174a 8091 0000 		lds r24,tryb_clip
 4649 174e 8823      		tst r24
 4650 1750 01F4      		brne .+2
 4651 1752 00C0      		rjmp .L400
 685:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
 4652               		.loc 2 685 0
 4653 1754 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 686:main_sim900.h ****     }
 4654               		.loc 2 686 0
 4655 1758 86E9      		ldi r24,lo8(-106)
 4656               	/* epilogue start */
 4657               	.LBE555:
 4658               	.LBE554:
 4659               		.loc 2 758 0
 4660 175a DF91      		pop r29
 4661 175c CF91      		pop r28
 4662 175e 1F91      		pop r17
 4663 1760 0F91      		pop r16
 4664               	.LBB565:
 4665               	.LBB563:
 686:main_sim900.h ****     }
 4666               		.loc 2 686 0
 4667 1762 0C94 0000 		jmp dodaj_komende
 4668               	.LVL405:
 4669               	.L422:
 690:main_sim900.h ****     POMOC_DODAJ2('#', 'f');
 4670               		.loc 2 690 0
 4671 1766 8091 0000 		lds r24,komenda_SIM900
 4672 176a 8930      		cpi r24,lo8(9)
 4673 176c 01F4      		brne .L423
 4674               	.L467:
 4675               	.LVL406:
 692:main_sim900.h ****       odpowiedz_na_polecenie();
 4676               		.loc 2 692 0
 4677 176e 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4678 1772 853D      		cpi r24,lo8(-43)
 4679 1774 01F4      		brne .L424
 693:main_sim900.h ****     zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 4680               		.loc 2 693 0
 4681 1776 0E94 0000 		call odpowiedz_na_polecenie
 4682               	.LVL407:
 4683               	.L424:
 694:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 4684               		.loc 2 694 0
 4685 177a 80E0      		ldi r24,0
 4686 177c 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 4687               	.LVL408:
 695:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 4688               		.loc 2 695 0
 4689 1780 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 4690 1784 00C0      		rjmp .L470
 4691               	.LVL409:
 4692               	.L423:
 700:main_sim900.h ****     POMOC_DODAJ2('#', 'g');
 4693               		.loc 2 700 0
 4694 1786 8091 0000 		lds r24,komenda_SIM900
 4695 178a 8730      		cpi r24,lo8(7)
 4696 178c 01F0      		breq .L467
 710:main_sim900.h ****     const uchar *ptr = strchr(polozenie_polecenia_SIM900(PSTR("+CMTI:")), ',');
 4697               		.loc 2 710 0
 4698 178e 8091 0000 		lds r24,komenda_SIM900
 4699 1792 8830      		cpi r24,lo8(8)
 4700 1794 01F4      		brne .L427
 4701               	.LBB560:
 711:main_sim900.h ****     if (ptr != NULL) {
 4702               		.loc 2 711 0
 4703 1796 80E0      		ldi r24,lo8(__c.3323)
 4704 1798 90E0      		ldi r25,hi8(__c.3323)
 4705 179a 0E94 0000 		call polozenie_polecenia_SIM900
 4706               	.LVL410:
 4707 179e 6CE2      		ldi r22,lo8(44)
 4708 17a0 70E0      		ldi r23,0
 4709 17a2 0E94 0000 		call strchr
 4710               	.LVL411:
 712:main_sim900.h ****       uint numer_smsa = (uint)strtoul(ptr + 1, NULL, 10);
 4711               		.loc 2 712 0
 4712 17a6 0097      		sbiw r24,0
 4713 17a8 01F0      		breq .L429
 4714               	.LBB561:
 713:main_sim900.h ****       if (numer_smsa > 0 && numer_smsa <= 20) // Hardcoded 20
 4715               		.loc 2 713 0
 4716 17aa 4AE0      		ldi r20,lo8(10)
 4717 17ac 50E0      		ldi r21,0
 4718 17ae 70E0      		ldi r23,0
 4719 17b0 60E0      		ldi r22,0
 4720 17b2 0196      		adiw r24,1
 4721               	.LVL412:
 4722 17b4 0E94 0000 		call strtoul
 4723               	.LVL413:
 714:main_sim900.h ****       {
 4724               		.loc 2 714 0
 4725 17b8 9B01      		movw r18,r22
 4726 17ba 2150      		subi r18,1
 4727 17bc 3109      		sbc r19,__zero_reg__
 4728 17be 2431      		cpi r18,20
 4729 17c0 3105      		cpc r19,__zero_reg__
 4730 17c2 00F4      		brsh .L429
 716:main_sim900.h ****         opoznienie_SIM900_100MS = 1; // 20 (1)
 4731               		.loc 2 716 0
 4732 17c4 88EA      		ldi r24,lo8(-88)
 4733 17c6 860F      		add r24,r22
 4734 17c8 0E94 0000 		call dodaj_komende
 4735               	.LVL414:
 717:main_sim900.h ****       }
 4736               		.loc 2 717 0
 4737 17cc 81E0      		ldi r24,lo8(1)
 4738               	.L468:
 4739 17ce 8093 0000 		sts opoznienie_SIM900_100MS,r24
 4740               	.L429:
 4741               	.LBE561:
 721:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 4742               		.loc 2 721 0
 4743 17d2 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4744 17d6 895A      		subi r24,lo8(-(87))
 720:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 4745               		.loc 2 720 0
 4746 17d8 8431      		cpi r24,lo8(20)
 4747 17da 00F4      		brsh .+2
 4748 17dc 00C0      		rjmp .L469
 4749 17de 00C0      		rjmp .L400
 4750               	.L427:
 4751               	.LBE560:
 730:main_sim900.h ****     opoznienie_SIM900_100MS = 20;
 4752               		.loc 2 730 0
 4753 17e0 8091 0000 		lds r24,komenda_SIM900
 4754 17e4 8E30      		cpi r24,lo8(14)
 4755 17e6 01F4      		brne .L431
 4756               	.LBB562:
 731:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 4757               		.loc 2 731 0
 4758 17e8 84E1      		ldi r24,lo8(20)
 4759 17ea 00C0      		rjmp .L468
 4760               	.L431:
 4761               	.LBE562:
 752:main_sim900.h ****     obsluga_wysylania_sms();
 4762               		.loc 2 752 0
 4763 17ec 8091 0000 		lds r24,flaga_wysylanie_smsa
 4764 17f0 8111      		cpse r24,__zero_reg__
 753:main_sim900.h **** 
 4765               		.loc 2 753 0
 4766 17f2 0E94 0000 		call obsluga_wysylania_sms
 4767               	.LVL415:
 4768               	.L433:
 755:main_sim900.h ****       komenda_SIM900 != BRAK_KOMENDY_SIM900)
 4769               		.loc 2 755 0
 4770 17f6 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 4771 17fa 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
 4772 17fe 892B      		or r24,r25
 4773 1800 01F4      		brne .+2
 4774 1802 00C0      		rjmp .L400
 756:main_sim900.h ****     odpowiedz_na_polecenie();
 4775               		.loc 2 756 0
 4776 1804 8091 0000 		lds r24,komenda_SIM900
 755:main_sim900.h ****       komenda_SIM900 != BRAK_KOMENDY_SIM900)
 4777               		.loc 2 755 0
 4778 1808 8823      		tst r24
 4779 180a 01F4      		brne .+2
 4780 180c 00C0      		rjmp .L400
 4781               	/* epilogue start */
 4782               	.LBE563:
 4783               	.LBE565:
 4784               		.loc 2 758 0
 4785 180e DF91      		pop r29
 4786 1810 CF91      		pop r28
 4787 1812 1F91      		pop r17
 4788 1814 0F91      		pop r16
 4789               	.LBB566:
 4790               	.LBB564:
 757:main_sim900.h **** }
 4791               		.loc 2 757 0
 4792 1816 0C94 0000 		jmp odpowiedz_na_polecenie
 4793               	.LVL416:
 4794               	.LBE564:
 4795               	.LBE566:
 4796               		.cfi_endproc
 4797               	.LFE50:
 4799               	.global	wyslanie_polecenia_ROM
 4801               	wyslanie_polecenia_ROM:
 4802               	.LFB51:
 759:main_sim900.h **** 
 760:main_sim900.h **** uchar wyslanie_polecenia_ROM(const uchar czy_mozna_wysylac_dane_do_SIM900,
 761:main_sim900.h ****                              const komenda_typ wykonywana_komenda,
 762:main_sim900.h ****                              const komenda_typ nastepne_wysylane_polecenie,
 763:main_sim900.h ****                              PGM_P instrukcja) {
 4803               		.loc 2 763 0
 4804               		.cfi_startproc
 4805               	.LVL417:
 4806               	/* prologue: function */
 4807               	/* frame size = 0 */
 4808               	/* stack size = 0 */
 4809               	.L__stack_usage = 0
 764:main_sim900.h ****   if (!czy_mozna_wysylac_dane_do_SIM900) {
 4810               		.loc 2 764 0
 4811 181a 8111      		cpse r24,__zero_reg__
 4812 181c 00C0      		rjmp .L472
 765:main_sim900.h ****     dodaj_komende(wykonywana_komenda);
 4813               		.loc 2 765 0
 4814 181e 862F      		mov r24,r22
 4815               	.LVL418:
 4816 1820 0E94 0000 		call dodaj_komende
 4817               	.LVL419:
 766:main_sim900.h ****     return FALSE;
 4818               		.loc 2 766 0
 4819 1824 80E0      		ldi r24,0
 4820 1826 0895      		ret
 4821               	.LVL420:
 4822               	.L472:
 767:main_sim900.h ****   }
 768:main_sim900.h ****   wysylane_polecenie_SIM900 = wykonywana_komenda;
 4823               		.loc 2 768 0
 4824 1828 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 4825 182c 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 4826 1830 6093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r22
 769:main_sim900.h ****   nastepne_wysylane_polecenie_SIM900 = nastepne_wysylane_polecenie;
 4827               		.loc 2 769 0
 4828 1834 4093 0000 		sts nastepne_wysylane_polecenie_SIM900,r20
 770:main_sim900.h ****   wyslij_polecenie_ROM_SIM900(instrukcja);
 4829               		.loc 2 770 0
 4830 1838 C901      		movw r24,r18
 4831               	.LVL421:
 4832 183a 0E94 0000 		call wyslij_polecenie_ROM_SIM900
 4833               	.LVL422:
 771:main_sim900.h ****   return TRUE;
 4834               		.loc 2 771 0
 4835 183e 8FEF      		ldi r24,lo8(-1)
 4836               	/* epilogue start */
 772:main_sim900.h **** }
 4837               		.loc 2 772 0
 4838 1840 0895      		ret
 4839               		.cfi_endproc
 4840               	.LFE51:
 4842               	.global	wyslij_sms
 4844               	wyslij_sms:
 4845               	.LFB52:
 773:main_sim900.h **** 
 774:main_sim900.h **** #ifndef memcpy_E
 775:main_sim900.h **** #define memcpy_E(sink, source, l)                                              \
 776:main_sim900.h ****   eeprom_read_block((sink), (void *)(source), (l))
 777:main_sim900.h **** #endif
 778:main_sim900.h **** 
 779:main_sim900.h **** void wyslij_sms(const uchar wyslij_pdu) {
 4846               		.loc 2 779 0
 4847               		.cfi_startproc
 4848               	.LVL423:
 4849 1842 0F93      		push r16
 4850               	.LCFI65:
 4851               		.cfi_def_cfa_offset 3
 4852               		.cfi_offset 16, -2
 4853 1844 CF93      		push r28
 4854               	.LCFI66:
 4855               		.cfi_def_cfa_offset 4
 4856               		.cfi_offset 28, -3
 4857 1846 DF93      		push r29
 4858               	.LCFI67:
 4859               		.cfi_def_cfa_offset 5
 4860               		.cfi_offset 29, -4
 4861               	/* prologue: function */
 4862               	/* frame size = 0 */
 4863               	/* stack size = 3 */
 4864               	.L__stack_usage = 3
 780:main_sim900.h ****   czekanie_na_odebranie_zachety = TRUE;
 4865               		.loc 2 780 0
 4866 1848 9FEF      		ldi r25,lo8(-1)
 4867 184a 9093 0000 		sts czekanie_na_odebranie_zachety,r25
 781:main_sim900.h ****   flaga_odebrany_znak_zachety = FALSE;
 4868               		.loc 2 781 0
 4869 184e 1092 0000 		sts flaga_odebrany_znak_zachety,__zero_reg__
 782:main_sim900.h ****   if (!wyslij_pdu) {
 4870               		.loc 2 782 0
 4871 1852 8111      		cpse r24,__zero_reg__
 4872 1854 00C0      		rjmp .L475
 4873               	.LBB567:
 783:main_sim900.h ****     // Zmiana: 5 blyskow LED przy wysylaniu SMS
 784:main_sim900.h ****     zapal_diode_led_blyski(5);
 4874               		.loc 2 784 0
 4875 1856 85E0      		ldi r24,lo8(5)
 4876               	.LVL424:
 4877 1858 8093 0000 		sts liczba_blyskow_led,r24
 4878 185c 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 785:main_sim900.h ****     flaga_wysylanie_smsa = KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT;
 4879               		.loc 2 785 0
 4880 1860 82ED      		ldi r24,lo8(-46)
 4881 1862 8093 0000 		sts flaga_wysylanie_smsa,r24
 786:main_sim900.h ****     bufor_pdu[0] = 0xff; // memcpy_E(bufor_pdu, (void*)EEPROM_ADRES_CENTRUM_SMS,
 4882               		.loc 2 786 0
 4883 1866 9093 0000 		sts bufor_pdu,r25
 787:main_sim900.h ****                          // LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 788:main_sim900.h ****     konwertuj_blok_eeprom_na_telefon(
 4884               		.loc 2 788 0
 4885 186a 4AE0      		ldi r20,lo8(10)
 4886 186c 60E0      		ldi r22,lo8(bufor_eeprom)
 4887 186e 70E0      		ldi r23,hi8(bufor_eeprom)
 4888 1870 80E0      		ldi r24,lo8(bufor_pdu)
 4889 1872 90E0      		ldi r25,hi8(bufor_pdu)
 4890 1874 0E94 0000 		call konwertuj_blok_eeprom_na_telefon
 4891               	.LVL425:
 789:main_sim900.h ****         bufor_pdu, bufor_eeprom, 2 * LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 790:main_sim900.h ****     uchar *ptr = zapisz_naglowek_pdu(bufor_pdu, numer_telefonu_wysylanego_smsa,
 4892               		.loc 2 790 0
 4893 1878 00E0      		ldi r16,0
 4894 187a 20E0      		ldi r18,0
 4895 187c 40E0      		ldi r20,lo8(bufor_eeprom)
 4896 187e 50E0      		ldi r21,hi8(bufor_eeprom)
 4897 1880 60E0      		ldi r22,lo8(numer_telefonu_wysylanego_smsa)
 4898 1882 70E0      		ldi r23,hi8(numer_telefonu_wysylanego_smsa)
 4899 1884 80E0      		ldi r24,lo8(bufor_pdu)
 4900 1886 90E0      		ldi r25,hi8(bufor_pdu)
 4901 1888 0E94 0000 		call zapisz_naglowek_pdu
 4902               	.LVL426:
 791:main_sim900.h ****                                      bufor_eeprom, 0x00, 0x00);
 792:main_sim900.h ****     dlugosc_pdu = ascii_to_pdu(ptr, tekst_wysylanego_smsa) - bufor_pdu;
 4903               		.loc 2 792 0
 4904 188c 40E0      		ldi r20,lo8(tekst_wysylanego_smsa)
 4905 188e 50E0      		ldi r21,hi8(tekst_wysylanego_smsa)
 4906 1890 FA01      		movw r30,r20
 4907               		0:
 4908 1892 0190      		ld __tmp_reg__,Z+
 4909 1894 0020      		tst __tmp_reg__
 4910 1896 01F4      		brne 0b
 4911 1898 AF01      		movw r20,r30
 4912 189a 4150      		subi r20,1
 4913 189c 5109      		sbc r21,__zero_reg__
 4914 189e 60E0      		ldi r22,lo8(tekst_wysylanego_smsa)
 4915 18a0 70E0      		ldi r23,hi8(tekst_wysylanego_smsa)
 4916 18a2 0E94 0000 		call ascii_to_pdu_blok
 4917               	.LVL427:
 4918               	.L477:
 4919               	.LBE567:
 4920               	.LBB568:
 793:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 794:main_sim900.h ****     uchar l = strlen(numer_telefonu_wysylanego_smsa);
 795:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
 796:main_sim900.h ****       POMOC_DODAJ(numer_telefonu_wysylanego_smsa[i]);
 797:main_sim900.h ****     POMOC_DODAJ(' ');
 798:main_sim900.h ****     l = strlen(tekst_wysylanego_smsa);
 799:main_sim900.h ****     if (l > 20)
 800:main_sim900.h ****       l = 20;
 801:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
 802:main_sim900.h ****       POMOC_DODAJ(tekst_wysylanego_smsa[i]);
 803:main_sim900.h **** #endif
 804:main_sim900.h ****   } else {
 805:main_sim900.h ****     // Zmiana: 5 blyskow LED przy wysylaniu PDU
 806:main_sim900.h ****     zapal_diode_led_blyski(5);
 807:main_sim900.h ****     flaga_wysylanie_smsa = KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU;
 808:main_sim900.h ****     const uchar TP_DCS = tekst_wysylanego_smsa[0]; // message class
 809:main_sim900.h ****     bufor_pdu[0] = 0xff; // memcpy_E(bufor_pdu, (void*)EEPROM_ADRES_CENTRUM_SMS,
 810:main_sim900.h ****                          // LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 811:main_sim900.h ****     konwertuj_blok_eeprom_na_telefon(
 812:main_sim900.h ****         bufor_pdu, bufor_eeprom, 2 * LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 813:main_sim900.h ****     uchar *ptr = zapisz_naglowek_pdu(bufor_pdu, numer_telefonu_wysylanego_smsa,
 814:main_sim900.h ****                                      bufor_eeprom, 0x00, TP_DCS);
 815:main_sim900.h ****     memcpy(ptr, &tekst_wysylanego_smsa[2], tekst_wysylanego_smsa[1]);
 816:main_sim900.h ****     dlugosc_pdu = (ptr + tekst_wysylanego_smsa[1]) - bufor_pdu;
 4921               		.loc 2 816 0
 4922 18a6 8050      		subi r24,lo8(bufor_pdu)
 4923 18a8 9040      		sbci r25,hi8(bufor_pdu)
 4924 18aa 8093 0000 		sts dlugosc_pdu,r24
 4925               	.LBE568:
 817:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 818:main_sim900.h ****     uchar l = strlen(numer_telefonu_wysylanego_smsa);
 819:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
 820:main_sim900.h ****       POMOC_DODAJ(numer_telefonu_wysylanego_smsa[i]);
 821:main_sim900.h ****     POMOC_DODAJ(' ');
 822:main_sim900.h ****     POMOC_DODAJ('P');
 823:main_sim900.h ****     POMOC_DODAJ('D');
 824:main_sim900.h ****     POMOC_DODAJ('U');
 825:main_sim900.h **** #endif
 826:main_sim900.h ****   }
 827:main_sim900.h ****   const uchar oktety = dlugosc_pdu - 1 - bufor_pdu[0];
 4926               		.loc 2 827 0
 4927 18ae C091 0000 		lds r28,dlugosc_pdu
 4928 18b2 C150      		subi r28,lo8(-(-1))
 4929 18b4 8091 0000 		lds r24,bufor_pdu
 4930 18b8 C81B      		sub r28,r24
 4931               	.LVL428:
 828:main_sim900.h ****   static const char instrukcja_wyslij_smsa[] PROGMEM = "+cmgs=";
 829:main_sim900.h ****   memcpy_R(wysylane_dane_RAM_SIM900, instrukcja_wyslij_smsa);
 4932               		.loc 2 829 0
 4933 18ba 46E0      		ldi r20,lo8(6)
 4934 18bc 50E0      		ldi r21,0
 4935 18be 60E0      		ldi r22,lo8(instrukcja_wyslij_smsa.3343)
 4936 18c0 70E0      		ldi r23,hi8(instrukcja_wyslij_smsa.3343)
 4937 18c2 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 4938 18c4 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 4939 18c6 0E94 0000 		call memcpy_P
 4940               	.LVL429:
 4941               	.LBB569:
 4942               	.LBB570:
 4943               		.loc 6 527 0
 4944 18ca 4AE0      		ldi r20,lo8(10)
 4945 18cc 60E0      		ldi r22,lo8(wysylany_blok_SIM900+8)
 4946 18ce 70E0      		ldi r23,hi8(wysylany_blok_SIM900+8)
 4947               	.LVL430:
 4948 18d0 8C2F      		mov r24,r28
 4949 18d2 90E0      		ldi r25,0
 4950 18d4 0E94 0000 		call __utoa_ncheck
 4951               	.LVL431:
 4952               	.LBE570:
 4953               	.LBE569:
 830:main_sim900.h ****   utoa(oktety, wysylane_dane_RAM_SIM900 + strlen_R(instrukcja_wyslij_smsa), 10);
 831:main_sim900.h ****   max_oczekiwanie_na_odpowiedz = 250;
 4954               		.loc 2 831 0
 4955 18d8 8AEF      		ldi r24,lo8(-6)
 4956 18da 8093 0000 		sts max_oczekiwanie_na_odpowiedz,r24
 4957               	/* epilogue start */
 832:main_sim900.h ****   wyslij_polecenie_RAM_SIM900();
 833:main_sim900.h ****   POMOC_DODAJ2('#', 'S');
 834:main_sim900.h **** }
 4958               		.loc 2 834 0
 4959 18de DF91      		pop r29
 4960 18e0 CF91      		pop r28
 4961               	.LVL432:
 4962 18e2 0F91      		pop r16
 832:main_sim900.h ****   wyslij_polecenie_RAM_SIM900();
 4963               		.loc 2 832 0
 4964 18e4 0C94 0000 		jmp wyslij_polecenie_RAM_SIM900
 4965               	.LVL433:
 4966               	.L475:
 4967               	.LBB571:
 806:main_sim900.h ****     flaga_wysylanie_smsa = KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU;
 4968               		.loc 2 806 0
 4969 18e8 85E0      		ldi r24,lo8(5)
 4970               	.LVL434:
 4971 18ea 8093 0000 		sts liczba_blyskow_led,r24
 4972 18ee 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 807:main_sim900.h ****     const uchar TP_DCS = tekst_wysylanego_smsa[0]; // message class
 4973               		.loc 2 807 0
 4974 18f2 83ED      		ldi r24,lo8(-45)
 4975 18f4 8093 0000 		sts flaga_wysylanie_smsa,r24
 808:main_sim900.h ****     bufor_pdu[0] = 0xff; // memcpy_E(bufor_pdu, (void*)EEPROM_ADRES_CENTRUM_SMS,
 4976               		.loc 2 808 0
 4977 18f8 0091 0000 		lds r16,tekst_wysylanego_smsa
 4978               	.LVL435:
 809:main_sim900.h ****                          // LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 4979               		.loc 2 809 0
 4980 18fc 9093 0000 		sts bufor_pdu,r25
 811:main_sim900.h ****         bufor_pdu, bufor_eeprom, 2 * LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 4981               		.loc 2 811 0
 4982 1900 4AE0      		ldi r20,lo8(10)
 4983 1902 60E0      		ldi r22,lo8(bufor_eeprom)
 4984 1904 70E0      		ldi r23,hi8(bufor_eeprom)
 4985 1906 80E0      		ldi r24,lo8(bufor_pdu)
 4986 1908 90E0      		ldi r25,hi8(bufor_pdu)
 4987 190a 0E94 0000 		call konwertuj_blok_eeprom_na_telefon
 4988               	.LVL436:
 813:main_sim900.h ****                                      bufor_eeprom, 0x00, TP_DCS);
 4989               		.loc 2 813 0
 4990 190e 20E0      		ldi r18,0
 4991 1910 40E0      		ldi r20,lo8(bufor_eeprom)
 4992 1912 50E0      		ldi r21,hi8(bufor_eeprom)
 4993 1914 60E0      		ldi r22,lo8(numer_telefonu_wysylanego_smsa)
 4994 1916 70E0      		ldi r23,hi8(numer_telefonu_wysylanego_smsa)
 4995 1918 80E0      		ldi r24,lo8(bufor_pdu)
 4996 191a 90E0      		ldi r25,hi8(bufor_pdu)
 4997 191c 0E94 0000 		call zapisz_naglowek_pdu
 4998               	.LVL437:
 4999 1920 EC01      		movw r28,r24
 5000               	.LVL438:
 815:main_sim900.h ****     dlugosc_pdu = (ptr + tekst_wysylanego_smsa[1]) - bufor_pdu;
 5001               		.loc 2 815 0
 5002 1922 4091 0000 		lds r20,tekst_wysylanego_smsa+1
 5003 1926 50E0      		ldi r21,0
 5004 1928 60E0      		ldi r22,lo8(tekst_wysylanego_smsa+2)
 5005 192a 70E0      		ldi r23,hi8(tekst_wysylanego_smsa+2)
 5006 192c 0E94 0000 		call memcpy
 5007               	.LVL439:
 816:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 5008               		.loc 2 816 0
 5009 1930 8091 0000 		lds r24,tekst_wysylanego_smsa+1
 5010 1934 8C0F      		add r24,r28
 5011 1936 9D2F      		mov r25,r29
 5012 1938 911D      		adc r25,__zero_reg__
 5013 193a 00C0      		rjmp .L477
 5014               	.LBE571:
 5015               		.cfi_endproc
 5016               	.LFE52:
 5018               	.global	wykonanie_komend_SIM900
 5020               	wykonanie_komend_SIM900:
 5021               	.LFB53:
 835:main_sim900.h **** 
 836:main_sim900.h **** uchar wykonanie_komend_SIM900(void) {
 5022               		.loc 2 836 0
 5023               		.cfi_startproc
 5024 193c EF92      		push r14
 5025               	.LCFI68:
 5026               		.cfi_def_cfa_offset 3
 5027               		.cfi_offset 14, -2
 5028 193e FF92      		push r15
 5029               	.LCFI69:
 5030               		.cfi_def_cfa_offset 4
 5031               		.cfi_offset 15, -3
 5032 1940 0F93      		push r16
 5033               	.LCFI70:
 5034               		.cfi_def_cfa_offset 5
 5035               		.cfi_offset 16, -4
 5036 1942 1F93      		push r17
 5037               	.LCFI71:
 5038               		.cfi_def_cfa_offset 6
 5039               		.cfi_offset 17, -5
 5040 1944 CF93      		push r28
 5041               	.LCFI72:
 5042               		.cfi_def_cfa_offset 7
 5043               		.cfi_offset 28, -6
 5044 1946 DF93      		push r29
 5045               	.LCFI73:
 5046               		.cfi_def_cfa_offset 8
 5047               		.cfi_offset 29, -7
 5048 1948 00D0      		rcall .
 5049 194a 1F92      		push __zero_reg__
 5050               	.LCFI74:
 5051               		.cfi_def_cfa_offset 11
 5052 194c CDB7      		in r28,__SP_L__
 5053 194e DEB7      		in r29,__SP_H__
 5054               	.LCFI75:
 5055               		.cfi_def_cfa_register 28
 5056               	/* prologue: function */
 5057               	/* frame size = 3 */
 5058               	/* stack size = 9 */
 5059               	.L__stack_usage = 9
 837:main_sim900.h ****   const uchar czy_gsm_zajety =
 838:main_sim900.h ****       flaga_odczytywanie_smsa || flaga_wysylanie_smsa ||
 5060               		.loc 2 838 0
 5061 1950 9091 0000 		lds r25,flaga_odczytywanie_smsa
 839:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej ||
 840:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika ||
 841:main_sim900.h ****       aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
 842:main_sim900.h ****       opoznienie_SIM900_100MS || czekanie_na_odebranie_zachety;
 5062               		.loc 2 842 0
 5063 1954 9111      		cpse r25,__zero_reg__
 5064 1956 00C0      		rjmp .L580
 838:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej ||
 5065               		.loc 2 838 0
 5066 1958 8091 0000 		lds r24,flaga_wysylanie_smsa
 5067 195c 8111      		cpse r24,__zero_reg__
 5068 195e 00C0      		rjmp .L580
 838:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej ||
 5069               		.loc 2 838 0 is_stmt 0 discriminator 1
 5070 1960 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5071 1964 8111      		cpse r24,__zero_reg__
 5072 1966 00C0      		rjmp .L580
 839:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej ||
 5073               		.loc 2 839 0 is_stmt 1
 5074 1968 8091 0000 		lds r24,trwa_rozmowa_przychodzaca_od_uzytkownika
 5075 196c 8111      		cpse r24,__zero_reg__
 5076 196e 00C0      		rjmp .L580
 840:main_sim900.h ****       aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
 5077               		.loc 2 840 0
 5078 1970 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 5079 1974 8111      		cpse r24,__zero_reg__
 5080 1976 00C0      		rjmp .L580
 841:main_sim900.h ****       opoznienie_SIM900_100MS || czekanie_na_odebranie_zachety;
 5081               		.loc 2 841 0
 5082 1978 8091 0000 		lds r24,opoznienie_SIM900_100MS
 5083 197c 8111      		cpse r24,__zero_reg__
 5084 197e 00C0      		rjmp .L580
 5085               		.loc 2 842 0 discriminator 2
 5086 1980 2091 0000 		lds r18,czekanie_na_odebranie_zachety
 5087 1984 81E0      		ldi r24,lo8(1)
 5088 1986 2111      		cpse r18,__zero_reg__
 5089 1988 00C0      		rjmp .L480
 5090 198a 80E0      		ldi r24,0
 5091               	.L480:
 5092               	.LVL440:
 843:main_sim900.h **** 
 844:main_sim900.h ****   const uchar czy_mozna_wysylac_dane_do_SIM900 =
 845:main_sim900.h ****       !czy_gsm_zajety && CZY_MOZNA_WYSYLAC_DANE_SIM900() &&
 5093               		.loc 2 845 0 discriminator 2
 5094 198c 8111      		cpse r24,__zero_reg__
 5095 198e 00C0      		rjmp .L583
 5096               	.LVL441:
 5097               		.loc 2 845 0 is_stmt 0 discriminator 1
 5098 1990 2091 C100 		lds r18,193
 5099 1994 26FD      		sbrc r18,6
 5100 1996 00C0      		rjmp .L583
 5101               		.loc 2 845 0 discriminator 3
 5102 1998 2091 0000 		lds r18,podlaczony_modul_gsm_SIM900
 5103 199c 2223      		tst r18
 5104 199e 01F0      		breq .L583
 846:main_sim900.h ****       czy_jest_bezczynny_SIM900();
 5105               		.loc 2 846 0 is_stmt 1 discriminator 5
 5106 19a0 2091 0000 		lds r18,komenda_SIM900
 845:main_sim900.h ****       czy_jest_bezczynny_SIM900();
 5107               		.loc 2 845 0 discriminator 5
 5108 19a4 01E0      		ldi r16,lo8(1)
 5109 19a6 2111      		cpse r18,__zero_reg__
 5110 19a8 00C0      		rjmp .L583
 5111               	.LVL442:
 5112               	.L481:
 847:main_sim900.h **** 
 848:main_sim900.h ****   const komenda_typ wykonywana_komenda = komendy_kolejka[0];
 5113               		.loc 2 848 0
 5114 19aa 1091 0000 		lds r17,komendy_kolejka
 5115               	.LVL443:
 849:main_sim900.h ****   switch (wykonywana_komenda) {
 5116               		.loc 2 849 0
 5117 19ae E12E      		mov r14,r17
 5118 19b0 F12C      		mov r15,__zero_reg__
 5119 19b2 1C39      		cpi r17,lo8(-100)
 5120 19b4 01F4      		brne .+2
 5121 19b6 00C0      		rjmp .L484
 5122 19b8 00F0      		brlo .+2
 5123 19ba 00C0      		rjmp .L485
 5124 19bc 1139      		cpi r17,lo8(-111)
 5125 19be 01F4      		brne .+2
 5126 19c0 00C0      		rjmp .L486
 5127 19c2 00F4      		brsh .L487
 5128 19c4 1C38      		cpi r17,lo8(-116)
 5129 19c6 01F4      		brne .+2
 5130 19c8 00C0      		rjmp .L488
 5131 19ca 00F4      		brsh .L489
 5132 19cc 1A38      		cpi r17,lo8(-118)
 5133 19ce 01F4      		brne .+2
 5134 19d0 00C0      		rjmp .L490
 5135 19d2 00F0      		brlo .+2
 5136 19d4 00C0      		rjmp .L491
 5137 19d6 1938      		cpi r17,lo8(-119)
 5138 19d8 01F4      		brne .+2
 5139 19da 00C0      		rjmp .L492
 5140               	.L483:
 850:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 851:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU: {
 852:main_sim900.h ****     POWTORZ_JESLI(flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS);
 853:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 854:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 855:main_sim900.h ****     wyslij_sms(wykonywana_komenda == KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
 856:main_sim900.h ****     break;
 857:main_sim900.h ****   }
 858:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_PDU: {
 859:main_sim900.h ****     czekanie_na_odebranie_zachety = FALSE;
 860:main_sim900.h ****     konwertuj_pdu_na_blok_wysylany(wysylany_blok_SIM900, bufor_pdu,
 861:main_sim900.h ****                                    dlugosc_pdu);
 862:main_sim900.h ****     const uint liczba_znakow = 2 * dlugosc_pdu + 1;
 863:main_sim900.h ****     wysylany_blok_SIM900[liczba_znakow - 1] = ZNAK_CTRL_Z;
 864:main_sim900.h ****     wyslij_znaki_SIM900(liczba_znakow);
 865:main_sim900.h ****     break;
 866:main_sim900.h ****   }
 867:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1:
 868:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_2:
 869:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_3:
 870:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_4:
 871:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_5:
 872:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_6:
 873:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_7:
 874:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_8:
 875:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_9:
 876:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_10:
 877:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_11:
 878:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_12:
 879:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_13:
 880:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_14:
 881:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_15:
 882:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_16:
 883:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_17:
 884:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_18:
 885:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_19:
 886:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20: {
 887:main_sim900.h ****     POWTORZ_JESLI(flaga_odczytywanie_smsa || !modul_zalogowany_w_sieci ||
 888:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 889:main_sim900.h ****                   wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK ||
 890:main_sim900.h ****                   flaga_wysylanie_smsa ||
 891:main_sim900.h ****                   aktualnie_wysylane_polecenie_SIM900 ==
 892:main_sim900.h ****                       KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 893:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 894:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 895:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW,
 896:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW) ||
 897:main_sim900.h ****                   czy_sa_komendy_z_przedzialu(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT,
 898:main_sim900.h ****                                               KOMENDA_KOLEJKI_WYSLIJ_PDU) ||
 899:main_sim900.h ****                   czy_sa_komendy_z_przedzialu(
 900:main_sim900.h ****                       KOMENDA_KOLEJKI_ODBIERZ_ROZMOWE,
 901:main_sim900.h ****                       KOMENDA_KOLEJKI_SPRAWDZ_PRZYCHODZACA_ROZMOWE));
 902:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 903:main_sim900.h ****     flaga_odczytywanie_smsa = TRUE;
 904:main_sim900.h ****     static const char instrukcja_odczytaj_smsa[] PROGMEM = "+cmgr=";
 905:main_sim900.h ****     memcpy_R(wysylane_dane_RAM_SIM900, instrukcja_odczytaj_smsa);
 906:main_sim900.h ****     const uint nr_smsa =
 907:main_sim900.h ****         wykonywana_komenda - KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 + 1;
 908:main_sim900.h ****     utoa(nr_smsa, wysylane_dane_RAM_SIM900 + strlen_R(instrukcja_odczytaj_smsa),
 909:main_sim900.h ****          10);
 910:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 911:main_sim900.h ****     POMOC_DODAJ2('#', 'X');
 912:main_sim900.h ****     break;
 913:main_sim900.h ****   }
 914:main_sim900.h ****   case KOMENDA_KOLEJKI_INTERPRETUJ_PDU: {
 915:main_sim900.h ****     const uchar *ptr = pobierz_numer_telefonu_nadawcy_z_PDU(
 916:main_sim900.h ****         bufor_pdu, numer_telefonu_odebranego_smsa,
 917:main_sim900.h ****         &nie_wysylaj_echa_z_powodu_nietypowego_smsa);
 918:main_sim900.h ****     if (ptr == 0) // (1)
 919:main_sim900.h ****     {
 920:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 921:main_sim900.h ****       break;
 922:main_sim900.h ****     }
 923:main_sim900.h ****     {
 924:main_sim900.h ****       uchar rok, miesiac, dzien;
 925:main_sim900.h ****       ptr = pobierz_date_z_PDU(ptr, &rok, &miesiac, &dzien);
 926:main_sim900.h ****     }
 927:main_sim900.h ****     {
 928:main_sim900.h ****       uchar godzina, minuta, sekunda;
 929:main_sim900.h ****       ptr = pobierz_czas_z_PDU(ptr, &godzina, &minuta, &sekunda);
 930:main_sim900.h **** 
 931:main_sim900.h ****       // Zapisz timestamp z SMS do późniejszego użycia
 932:main_sim900.h ****       // (zostanie użyty w wykonanie_polecenia_sms jeśli kod ABCD jest poprawny)
 933:main_sim900.h ****       sms_timestamp_godzina = godzina;
 934:main_sim900.h ****       sms_timestamp_minuta = minuta;
 935:main_sim900.h ****       extern uchar sms_timestamp_sekunda;
 936:main_sim900.h ****       sms_timestamp_sekunda = sekunda;
 937:main_sim900.h ****     }
 938:main_sim900.h ****     ptr_start_pdu_z_wiadomoscia = (uchar *)ptr;
 939:main_sim900.h ****     pdu_to_ascii(ptr, tekst_odebranego_smsa, MAX_LICZBA_ZNAKOW_SMS + 1);
 940:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 941:main_sim900.h ****     const uchar l = min(strlen(tekst_odebranego_smsa), 20);
 942:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
 943:main_sim900.h ****       POMOC_DODAJ(tekst_odebranego_smsa[i]);
 944:main_sim900.h **** #endif
 945:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_INTERPRETUJ_ODEBRANEGO_SMSA);
 946:main_sim900.h ****     break;
 947:main_sim900.h ****   }
 948:main_sim900.h ****   case KOMENDA_KOLEJKI_INTERPRETUJ_ODEBRANEGO_SMSA: {
 949:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 950:main_sim900.h ****     zapal_diode_led(10);
 951:main_sim900.h ****     wykonanie_polecenia_sms();
 952:main_sim900.h ****     flaga_odczytywanie_smsa = FALSE;
 953:main_sim900.h ****     break;
 954:main_sim900.h ****   }
 955:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_1:
 956:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_2:
 957:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_3:
 958:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_4:
 959:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_5:
 960:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_6:
 961:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_7:
 962:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_8:
 963:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_9:
 964:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_10:
 965:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_11:
 966:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_12:
 967:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_13:
 968:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_14:
 969:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_15:
 970:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_16:
 971:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_17:
 972:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_18:
 973:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_19:
 974:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_20: {
 975:main_sim900.h ****     POWTORZ_JESLI(flaga_odczytywanie_smsa || flaga_trwa_rozmowa_wychodzaca ||
 976:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 977:main_sim900.h ****                   czekanie_na_odebranie_zachety)
 978:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 979:main_sim900.h ****     static const char instrukcja_usun_smsa[] PROGMEM = "+cmgd=";
 980:main_sim900.h ****     memcpy_R(wysylane_dane_RAM_SIM900, instrukcja_usun_smsa);
 981:main_sim900.h ****     const uint nr_smsa = wykonywana_komenda - KOMENDA_KOLEJKI_USUN_SMSA_1 + 1;
 982:main_sim900.h ****     utoa(nr_smsa, wysylane_dane_RAM_SIM900 + strlen_R(instrukcja_usun_smsa),
 983:main_sim900.h ****          10);
 984:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 985:main_sim900.h ****     POMOC_DODAJ2('#', 'Y');
 986:main_sim900.h ****     break;
 987:main_sim900.h ****   }
 988:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_PRZYCHODZACA_ROZMOWE: {
 989:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 990:main_sim900.h ****     zapal_diode_led(10);
 991:main_sim900.h **** 
 992:main_sim900.h ****     uchar status_ok =
 993:main_sim900.h ****         sprawdz_przychodzaca_rozmowe(); // Returns TRUE if number authorized
 994:main_sim900.h **** 
 995:main_sim900.h ****     if (status_ok) {
 996:main_sim900.h ****       if (tryb_clip) {
 997:main_sim900.h ****         // Tryb CLIP: wlacz wyjscie i ODRZUC polaczenie
 998:main_sim900.h ****         if (polozenie_polecenia_SIM900(PSTR("+CMTI:")) == NULL) {
 999:main_sim900.h ****           ustaw_wyjscie_clip();
1000:main_sim900.h ****         }
1001:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
1002:main_sim900.h ****       } else {
1003:main_sim900.h ****         // Tryb DTMF: ODBIERZ polaczenie
1004:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_ODBIERZ_ROZMOWE);
1005:main_sim900.h ****       }
1006:main_sim900.h ****     } else {
1007:main_sim900.h ****       // Status NIE OK - odrzuc
1008:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
1009:main_sim900.h ****     }
1010:main_sim900.h ****     blokada_clip = TRUE;
1011:main_sim900.h ****     break;
1012:main_sim900.h ****   }
1013:main_sim900.h ****   case KOMENDA_KOLEJKI_ODRZUC_ROZMOWE: {
1014:main_sim900.h ****     POWTORZ_JESLI(
1015:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
1016:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
1017:main_sim900.h ****         czekanie_na_odebranie_zachety || wykonywanie_rozmowy_telefonicznej ||
1018:main_sim900.h ****         !CZY_MOZNA_WYSYLAC_DANE_SIM900() || !czy_jest_bezczynny_SIM900());
1019:main_sim900.h ****     wysylane_polecenie_SIM900 = wykonywana_komenda;
1020:main_sim900.h ****     static const char instrukcja_odrzuc_rozmowe[] PROGMEM = "h";
1021:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_odrzuc_rozmowe);
1022:main_sim900.h ****     break;
1023:main_sim900.h ****   }
1024:main_sim900.h ****   case KOMENDA_KOLEJKI_ODBIERZ_ROZMOWE: {
1025:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1026:main_sim900.h ****     static const char instrukcja_odbierz_rozmowe[] PROGMEM = "a";
1027:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_odbierz_rozmowe);
1028:main_sim900.h ****     POMOC_DODAJ2('#', 'p');
1029:main_sim900.h ****     break;
1030:main_sim900.h ****   }
1031:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_TON_DTMF: {
1032:main_sim900.h ****     // Czekaj na koncowke inicjalizacji polaczenia/opoznienia?
1033:main_sim900.h ****     POWTORZ_JESLI(opoznienie_SIM900_100MS);
1034:main_sim900.h ****     if (!CZY_MOZNA_WYSYLAC_DANE_SIM900() || !czy_jest_bezczynny_SIM900() ||
1035:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
1036:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
1037:main_sim900.h ****       break;
1038:main_sim900.h ****     }
1039:main_sim900.h ****     wysylane_polecenie_SIM900 = wykonywana_komenda;
1040:main_sim900.h ****     static const char instrukcja_vts[] PROGMEM = "+vts=1";
1041:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_vts);
1042:main_sim900.h ****     POMOC_DODAJ2('#', 'V');
1043:main_sim900.h ****     break;
1044:main_sim900.h ****   }
1045:main_sim900.h ****   case KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE: {
1046:main_sim900.h ****     POWTORZ_JESLI(!modul_zalogowany_w_sieci || opoznienie_SIM900_100MS);
1047:main_sim900.h ****     if (wykonywanie_rozmowy_telefonicznej)
1048:main_sim900.h ****       break;
1049:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1050:main_sim900.h ****     zapal_diode_led(20);
1051:main_sim900.h ****     wysylane_dane_RAM_SIM900[0] = 'd';
1052:main_sim900.h ****     // static const char doladowanie[] PROGMEM = "*100*59484869838559#";
1053:main_sim900.h ****     // strcpy_P(numer_telefonu_do_ktorego_dzwonic, doladowanie);
1054:main_sim900.h ****     strcpy(wysylane_dane_RAM_SIM900 + 1, numer_telefonu_do_ktorego_dzwonic);
1055:main_sim900.h ****     uchar l = strlen(numer_telefonu_do_ktorego_dzwonic) + 1;
1056:main_sim900.h ****     wysylane_dane_RAM_SIM900[l] = ';';
1057:main_sim900.h ****     wysylane_dane_RAM_SIM900[l + 1] = '\0';
1058:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
1059:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 300;
1060:main_sim900.h ****     POMOC_DODAJ2('#', 'h');
1061:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
1062:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
1063:main_sim900.h ****       POMOC_DODAJ(numer_telefonu_do_ktorego_dzwonic[i]);
1064:main_sim900.h **** #endif
1065:main_sim900.h ****     break;
1066:main_sim900.h ****   }
1067:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_POZIOM_SIECI: {
1068:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1069:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1070:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1071:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1072:main_sim900.h ****       if (poziom_sieci_gsm == POZIOM_SIECI_BLAD ||
1073:main_sim900.h ****           poziom_sieci_gsm == 0) // poziom sieci bez zmian
1074:main_sim900.h ****         poziom_sieci_gsm = 16;
1075:main_sim900.h ****       break;
1076:main_sim900.h ****     }
1077:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1078:main_sim900.h ****     static const char instrukcja_poziom_sieci[] PROGMEM = "+csq";
1079:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_poziom_sieci);
1080:main_sim900.h ****     break;
1081:main_sim900.h ****   }
1082:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_ZAREJESTROWANIE: {
1083:main_sim900.h ****     // Usunięto warunek !modul_zalogowany_w_sieci - musimy sprawdzać ZAWSZE!
1084:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1085:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1086:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1087:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1088:main_sim900.h ****       break;
1089:main_sim900.h ****     }
1090:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1091:main_sim900.h ****     static const char instrukcja_creg[] PROGMEM = "+creg?";
1092:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_creg);
1093:main_sim900.h ****     break;
1094:main_sim900.h ****   }
1095:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_STAN_KARTY_SIM: {
1096:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1097:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1098:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1099:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1100:main_sim900.h ****       licznik_blad_stanu_karty_SIM = 0;
1101:main_sim900.h ****       break;
1102:main_sim900.h ****     }
1103:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1104:main_sim900.h ****     static const char instrukcja_odczyt_ksiazki[] PROGMEM = "+cpbr=26";
1105:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_odczyt_ksiazki);
1106:main_sim900.h ****     break;
1107:main_sim900.h ****   }
1108:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_ZALOGOWANIE_U_OPERATORA: {
1109:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1110:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1111:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1112:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1113:main_sim900.h ****       licznik_blad_zalogowania_u_operatora = 0;
1114:main_sim900.h ****       break;
1115:main_sim900.h ****     }
1116:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1117:main_sim900.h ****     static const char instrukcja_sprawdz_operatora[] PROGMEM = "+cops?";
1118:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_sprawdz_operatora);
1119:main_sim900.h ****     break;
1120:main_sim900.h ****   }
1121:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE: {
1122:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1123:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1124:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1125:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK)
1126:main_sim900.h ****       break;
1127:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1128:main_sim900.h ****     static const char instrukcja_cclk[] PROGMEM = "+cclk?";
1129:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_cclk);
1130:main_sim900.h ****     break;
1131:main_sim900.h ****   }
1132:main_sim900.h ****   case KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS: {
1133:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1134:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM = "+cdscb";
1135:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_ustawienie_pamieci);
1136:main_sim900.h ****     break;
1137:main_sim900.h ****   }
1138:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW: {
1139:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1140:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM =
1141:main_sim900.h ****         "+cpms=\"SM\",\"SM\",\"SM\"";
1142:main_sim900.h ****     nastepne_wysylane_polecenie_SIM900 =
1143:main_sim900.h ****         KOMENDA_KOLEJKI_WSTAWIENIE_MORING_GDY_DZWONI;
1144:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_ustawienie_pamieci);
1145:main_sim900.h ****     break;
1146:main_sim900.h ****   }
1147:main_sim900.h ****   case KOMENDA_KOLEJKI_PODLACZONY_MODUL_GSM: {
1148:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT);
1149:main_sim900.h ****     opoznienie_zatrzymaj_odpytywanie_urzadzenia = 20;
1150:main_sim900.h ****     ustaw_odbior_SIM900();
1151:main_sim900.h ****     break;
1152:main_sim900.h ****   }
1153:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: { // po wczeniu zasilania wysya 2
1154:main_sim900.h ****                                               // razy, bo za pierwszym razem nie
1155:main_sim900.h ****                                               // dziaa kontrola RTS / CTS w
1156:main_sim900.h ****                                               // SIM800
1157:main_sim900.h ****     if (max_oczekiwanie_na_odpowiedz_at)
1158:main_sim900.h ****       break;
1159:main_sim900.h ****     if (opoznienie_zatrzymaj_odpytywanie_urzadzenia) {
1160:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
1161:main_sim900.h ****       break;
1162:main_sim900.h ****     }
1163:main_sim900.h ****     if (CZY_WYSYLANIE_DANYCH_SIM900()) {
1164:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
1165:main_sim900.h ****       break;
1166:main_sim900.h ****     }
1167:main_sim900.h ****     ustaw_odbior_SIM900();
1168:main_sim900.h ****     wysylane_polecenie_SIM900 = wykonywana_komenda;
1169:main_sim900.h ****     max_oczekiwanie_na_odpowiedz_at = 20;
1170:main_sim900.h ****     static const char instrukcja_at[] PROGMEM = "+ifc=2,2";
1171:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_at);
1172:main_sim900.h ****     break;
1173:main_sim900.h ****   }
1174:main_sim900.h ****   case KOMENDA_KOLEJKI_ODEBRANO_POLECENIE_ROZPOCZYNAJACE: {
1175:main_sim900.h ****     podlaczony_modul_gsm_SIM900 = TRUE;
1176:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_PIN);
1177:main_sim900.h ****     opoznienie_SIM900_100MS = 40;
1178:main_sim900.h ****     break;
1179:main_sim900.h ****   }
1180:main_sim900.h ****   case KOMENDA_KOLEJKI_PODAJ_PIN: {
1181:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1182:main_sim900.h ****     static const char instrukcja_podaj_pin[] PROGMEM = "+cpin=\"1976\"";
1183:main_sim900.h ****     strcpy_P(wysylane_dane_RAM_SIM900, instrukcja_podaj_pin);
1184:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
1185:main_sim900.h ****     break;
1186:main_sim900.h ****   }
1187:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY: {
1188:main_sim900.h ****     static uchar drugi_raz = FALSE;
1189:main_sim900.h ****     if (drugi_raz) {
1190:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW);
1191:main_sim900.h ****       break;
1192:main_sim900.h ****     }
1193:main_sim900.h ****     drugi_raz = TRUE;
1194:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1195:main_sim900.h ****     static const char instrukcja_usun_wszystkie_smsy[] PROGMEM = "+cmgda=6";
1196:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_usun_wszystkie_smsy);
1197:main_sim900.h ****     break;
1198:main_sim900.h ****   }
1199:main_sim900.h ****   case KOMENDA_KOLEJKI_KOMENDA_SIM900: {
1200:main_sim900.h ****     obsluga_komendy_SIM900();
1201:main_sim900.h ****     if (komenda_SIM900 != KOMENDA_SIM900_WYSLANE_POLECENIE)
1202:main_sim900.h ****       max_oczekiwanie_na_odpowiedz = 20;
1203:main_sim900.h ****     resetuj_komende_SIM900();
1204:main_sim900.h ****     break;
1205:main_sim900.h ****   }
1206:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_WZMOCNIENIE_MIKROFONU: {
1207:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1208:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1209:main_sim900.h ****     static const char instrukcja[] PROGMEM =
1210:main_sim900.h ****         "+cmic=0,15"; // ustawienie od 0 ... 15
1211:main_sim900.h ****     strcpy_P(wysylane_dane_RAM_SIM900, instrukcja);
1212:main_sim900.h ****     nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_ROZPOCZNIJ_PRACE;
1213:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
1214:main_sim900.h ****     break;
1215:main_sim900.h ****   }
1216:main_sim900.h ****   case KOMENDA_KOLEJKI_ROZPOCZNIJ_PRACE: {
1217:main_sim900.h ****     POMOC_DODAJ2('*', 'h');
1218:main_sim900.h ****     if (podlaczona_karta_SIM_SIM900) {
1219:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS);
1220:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_MODUL_ZALOGOWANY);
1221:main_sim900.h ****     }
1222:main_sim900.h ****     break;
1223:main_sim900.h ****   }
1224:main_sim900.h ****   case KOMENDA_KOLEJKI_MODUL_ZALOGOWANY: {
1225:main_sim900.h ****     // Nie ustawiamy modul_zalogowany_w_sieci tutaj!
1226:main_sim900.h ****     // Flaga jest ustawiana tylko przez +CREG gdy faktycznie zalogowany
1227:main_sim900.h ****     break;
1228:main_sim900.h ****   }
1229:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_ZEGAR_SIM900: {
1230:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1231:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1232:main_sim900.h ****     strcpy(wysylane_dane_RAM_SIM900, bufor_ustaw_czas);
1233:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
1234:main_sim900.h ****     break;
1235:main_sim900.h ****   }
1236:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_PIN:
1237:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW:
1238:main_sim900.h ****   case KOMENDA_KOLEJKI_WSTAWIENIE_MORING_GDY_DZWONI:
1239:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_WYSYLANIE_INFO_O_DZWONIACYM:
1240:main_sim900.h ****   case KOMENDA_KOLEJKI_WLACZ_DETEKCJE_DTMF:
1241:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_CICHY_TRYB:
1242:main_sim900.h ****   case KOMENDA_KOLEJKI_WYCISZ_DZWONKI:
1243:main_sim900.h ****   case KOMENDA_KOLEJKI_ODBIERAJ_SMS_FLASH:
1244:main_sim900.h ****   case KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ:
1245:main_sim900.h ****   case KOMENDA_KOLEJKI_WLACZ_CZAS_Z_SIECI: {
1246:main_sim900.h **** 
1247:main_sim900.h **** #define MAX_ROZMIAR_POLECENIA_GSM 14
1248:main_sim900.h **** 
1249:main_sim900.h ****     static const char instrukcje[10][MAX_ROZMIAR_POLECENIA_GSM] PROGMEM = {
1250:main_sim900.h ****         "+cpin?",         "+cnmi=2,1,2,1", "+moring=1", "+clip=1",
1251:main_sim900.h ****         "+ddet=1,10,1",   "+calm=1",       "+crsl=1",   "+cusd=1",
1252:main_sim900.h ****         "+cpbw=26,\"1\"", "+clts=0",
1253:main_sim900.h ****     };
1254:main_sim900.h ****     static const komenda_typ nastepna_komenda[10] PROGMEM = {
1255:main_sim900.h ****         KOMENDA_KOLEJKI_BRAK_KOMENDY,
1256:main_sim900.h ****         KOMENDA_KOLEJKI_BRAK_KOMENDY,
1257:main_sim900.h ****         KOMENDA_KOLEJKI_USTAW_WYSYLANIE_INFO_O_DZWONIACYM,
1258:main_sim900.h ****         KOMENDA_KOLEJKI_WLACZ_DETEKCJE_DTMF,
1259:main_sim900.h ****         KOMENDA_KOLEJKI_USTAW_CICHY_TRYB,
1260:main_sim900.h ****         KOMENDA_KOLEJKI_WYCISZ_DZWONKI,
1261:main_sim900.h ****         KOMENDA_KOLEJKI_ODBIERAJ_SMS_FLASH,
1262:main_sim900.h ****         KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ,
1263:main_sim900.h ****         KOMENDA_KOLEJKI_WLACZ_CZAS_Z_SIECI,
1264:main_sim900.h ****         KOMENDA_KOLEJKI_USTAW_WZMOCNIENIE_MIKROFONU,
1265:main_sim900.h ****     };
1266:main_sim900.h ****     // RE-DOING THIS CHUNK TO BE SAFE AND CORRECT
1267:main_sim900.h **** 
1268:main_sim900.h ****     const uchar nr = wykonywana_komenda - KOMENDA_KOLEJKI_SPRAWDZ_PIN;
1269:main_sim900.h ****     if (!wyslanie_polecenia_ROM(
1270:main_sim900.h ****             czy_mozna_wysylac_dane_do_SIM900, wykonywana_komenda,
1271:main_sim900.h ****             pgm_read_word(&nastepna_komenda[nr]), &instrukcje[nr][0]))
1272:main_sim900.h ****       break;
1273:main_sim900.h ****     POMOC_DODAJ2('*', 's');
1274:main_sim900.h ****     POMOC_DODAJ_HEX(nr);
1275:main_sim900.h ****     break;
1276:main_sim900.h ****   }
1277:main_sim900.h ****   default:
1278:main_sim900.h ****     return FALSE;
 5141               		.loc 2 1278 0
 5142 19dc 80E0      		ldi r24,0
 5143               	.LVL444:
 5144               	.L478:
 5145               	/* epilogue start */
1279:main_sim900.h ****   }
1280:main_sim900.h ****   return TRUE;
1281:main_sim900.h **** }
 5146               		.loc 2 1281 0
 5147 19de 0F90      		pop __tmp_reg__
 5148 19e0 0F90      		pop __tmp_reg__
 5149 19e2 0F90      		pop __tmp_reg__
 5150 19e4 DF91      		pop r29
 5151 19e6 CF91      		pop r28
 5152 19e8 1F91      		pop r17
 5153 19ea 0F91      		pop r16
 5154               	.LVL445:
 5155 19ec FF90      		pop r15
 5156 19ee EF90      		pop r14
 5157               	.LVL446:
 5158 19f0 0895      		ret
 5159               	.L580:
 842:main_sim900.h **** 
 5160               		.loc 2 842 0
 5161 19f2 81E0      		ldi r24,lo8(1)
 5162               	.L583:
 845:main_sim900.h ****       czy_jest_bezczynny_SIM900();
 5163               		.loc 2 845 0
 5164 19f4 00E0      		ldi r16,0
 5165 19f6 00C0      		rjmp .L481
 5166               	.LVL447:
 5167               	.L489:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5168               		.loc 2 849 0
 5169 19f8 1E38      		cpi r17,lo8(-114)
 5170 19fa 01F4      		brne .+2
 5171 19fc 00C0      		rjmp .L493
 5172 19fe 00F4      		brsh .+2
 5173 1a00 00C0      		rjmp .L494
 5174 1a02 1F38      		cpi r17,lo8(-113)
 5175 1a04 01F4      		brne .+2
 5176 1a06 00C0      		rjmp .L495
 5177 1a08 1039      		cpi r17,lo8(-112)
 5178 1a0a 01F4      		brne .L483
 5179               	.L600:
1280:main_sim900.h **** }
 5180               		.loc 2 1280 0
 5181 1a0c 8FEF      		ldi r24,lo8(-1)
 5182 1a0e 00C0      		rjmp .L478
 5183               	.L487:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5184               		.loc 2 849 0
 5185 1a10 1639      		cpi r17,lo8(-106)
 5186 1a12 01F4      		brne .+2
 5187 1a14 00C0      		rjmp .L497
 5188 1a16 00F4      		brsh .L498
 5189 1a18 1439      		cpi r17,lo8(-108)
 5190 1a1a 01F4      		brne .+2
 5191 1a1c 00C0      		rjmp .L499
 5192 1a1e 00F0      		brlo .+2
 5193 1a20 00C0      		rjmp .L500
 5194 1a22 1339      		cpi r17,lo8(-109)
 5195 1a24 01F4      		brne .L483
 5196               	.LBB572:
1207:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5197               		.loc 2 1207 0
 5198 1a26 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5199 1a2a 8111      		cpse r24,__zero_reg__
 5200 1a2c 00C0      		rjmp .L571
1207:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5201               		.loc 2 1207 0 is_stmt 0 discriminator 2
 5202 1a2e 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5203 1a32 8111      		cpse r24,__zero_reg__
 5204 1a34 00C0      		rjmp .L571
1207:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5205               		.loc 2 1207 0 discriminator 4
 5206 1a36 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5207 1a3a 8111      		cpse r24,__zero_reg__
 5208 1a3c 00C0      		rjmp .L571
1207:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5209               		.loc 2 1207 0 discriminator 6
 5210 1a3e F99B      		sbis 0x1f,1
 5211 1a40 00C0      		rjmp .L572
 5212               	.L571:
1207:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5213               		.loc 2 1207 0 discriminator 7
 5214 1a42 83E9      		ldi r24,lo8(-109)
 5215 1a44 00C0      		rjmp .L641
 5216               	.L498:
 5217               	.LBE572:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5218               		.loc 2 849 0 is_stmt 1
 5219 1a46 1839      		cpi r17,lo8(-104)
 5220 1a48 01F4      		brne .+2
 5221 1a4a 00C0      		rjmp .L502
 5222 1a4c 00F4      		brsh .+2
 5223 1a4e 00C0      		rjmp .L503
 5224 1a50 1939      		cpi r17,lo8(-103)
 5225 1a52 01F4      		brne .+2
 5226 1a54 00C0      		rjmp .L504
 5227 1a56 1A39      		cpi r17,lo8(-102)
 5228 1a58 01F4      		brne .L483
 5229               	.LBB573:
1068:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5230               		.loc 2 1068 0
 5231 1a5a 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 5232 1a5e 9111      		cpse r25,__zero_reg__
 5233 1a60 00C0      		rjmp .L551
1068:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5234               		.loc 2 1068 0 is_stmt 0 discriminator 1
 5235 1a62 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 5236 1a66 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5237 1a6a 232B      		or r18,r19
 5238 1a6c 01F4      		brne .L551
1068:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5239               		.loc 2 1068 0 discriminator 2
 5240 1a6e 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 5241 1a72 9111      		cpse r25,__zero_reg__
 5242 1a74 00C0      		rjmp .L551
1069:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 5243               		.loc 2 1069 0 is_stmt 1
 5244 1a76 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 5245 1a7a 9111      		cpse r25,__zero_reg__
 5246 1a7c 00C0      		rjmp .L551
1070:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 5247               		.loc 2 1070 0
 5248 1a7e 8111      		cpse r24,__zero_reg__
 5249 1a80 00C0      		rjmp .L551
1070:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 5250               		.loc 2 1070 0 is_stmt 0 discriminator 1
 5251 1a82 8091 0000 		lds r24,wysylanie_smsa_clipa
 5252 1a86 8823      		tst r24
 5253 1a88 01F4      		brne .+2
 5254 1a8a 00C0      		rjmp .L552
 5255               	.L551:
1072:main_sim900.h ****           poziom_sieci_gsm == 0) // poziom sieci bez zmian
 5256               		.loc 2 1072 0 is_stmt 1
 5257 1a8c 8091 0000 		lds r24,poziom_sieci_gsm
 5258 1a90 8336      		cpi r24,lo8(99)
 5259 1a92 01F0      		breq .L553
1072:main_sim900.h ****           poziom_sieci_gsm == 0) // poziom sieci bez zmian
 5260               		.loc 2 1072 0 is_stmt 0 discriminator 1
 5261 1a94 8111      		cpse r24,__zero_reg__
 5262 1a96 00C0      		rjmp .L600
 5263               	.L553:
1074:main_sim900.h ****       break;
 5264               		.loc 2 1074 0 is_stmt 1
 5265 1a98 80E1      		ldi r24,lo8(16)
 5266 1a9a 8093 0000 		sts poziom_sieci_gsm,r24
 5267 1a9e 00C0      		rjmp .L600
 5268               	.L485:
 5269               	.LBE573:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5270               		.loc 2 849 0
 5271 1aa0 113D      		cpi r17,lo8(-47)
 5272 1aa2 00F0      		brlo .+2
 5273 1aa4 00C0      		rjmp .L506
 5274 1aa6 1D3B      		cpi r17,lo8(-67)
 5275 1aa8 00F0      		brlo .+2
 5276 1aaa 00C0      		rjmp .L507
 5277 1aac 143A      		cpi r17,lo8(-92)
 5278 1aae 01F4      		brne .+2
 5279 1ab0 00C0      		rjmp .L508
 5280 1ab2 00F4      		brsh .L509
 5281 1ab4 1D39      		cpi r17,lo8(-99)
 5282 1ab6 01F4      		brne .+2
 5283 1ab8 00C0      		rjmp .L510
 5284               	.L511:
 5285               	.LBB574:
1268:main_sim900.h ****     if (!wyslanie_polecenia_ROM(
 5286               		.loc 2 1268 0
 5287 1aba 22E6      		ldi r18,lo8(98)
 5288 1abc 210F      		add r18,r17
 5289               	.LVL448:
 5290               	.LBB575:
1271:main_sim900.h ****       break;
 5291               		.loc 2 1271 0
 5292 1abe E22F      		mov r30,r18
 5293 1ac0 F0E0      		ldi r31,0
 5294 1ac2 E050      		subi r30,lo8(-(nastepna_komenda.3462))
 5295 1ac4 F040      		sbci r31,hi8(-(nastepna_komenda.3462))
 5296               	.LVL449:
 5297               	/* #APP */
 5298               	 ;  1271 "main_sim900.h" 1
 5299 1ac6 4591      		lpm r20, Z+
 5300 1ac8 5491      		lpm r21, Z
 5301               		
 5302               	 ;  0 "" 2
 5303               	.LVL450:
 5304               	/* #NOAPP */
 5305               	.LBE575:
1269:main_sim900.h ****             czy_mozna_wysylac_dane_do_SIM900, wykonywana_komenda,
 5306               		.loc 2 1269 0
 5307 1aca FEE0      		ldi r31,lo8(14)
 5308 1acc 2F9F      		mul r18,r31
 5309 1ace 9001      		movw r18,r0
 5310 1ad0 1124      		clr __zero_reg__
 5311               	.LVL451:
 5312 1ad2 2050      		subi r18,lo8(-(instrukcje.3461))
 5313 1ad4 3040      		sbci r19,hi8(-(instrukcje.3461))
 5314 1ad6 612F      		mov r22,r17
 5315 1ad8 802F      		mov r24,r16
 5316 1ada 0E94 0000 		call wyslanie_polecenia_ROM
 5317               	.LVL452:
 5318 1ade 00C0      		rjmp .L600
 5319               	.LVL453:
 5320               	.L509:
 5321               	.LBE574:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5322               		.loc 2 849 0
 5323 1ae0 193A      		cpi r17,lo8(-87)
 5324 1ae2 00F0      		brlo .L511
 5325               	.LBB576:
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5326               		.loc 2 887 0
 5327 1ae4 9111      		cpse r25,__zero_reg__
 5328 1ae6 00C0      		rjmp .L647
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5329               		.loc 2 887 0 is_stmt 0 discriminator 2
 5330 1ae8 8091 0000 		lds r24,modul_zalogowany_w_sieci
 5331 1aec 8823      		tst r24
 5332 1aee 01F4      		brne .+2
 5333 1af0 00C0      		rjmp .L647
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5334               		.loc 2 887 0 discriminator 4
 5335 1af2 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5336 1af6 8111      		cpse r24,__zero_reg__
 5337 1af8 00C0      		rjmp .L647
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5338               		.loc 2 887 0 discriminator 6
 5339 1afa 8091 0000 		lds r24,licznik_bezpieczenstwa_wykonywana_rozmowa
 5340 1afe 9091 0000 		lds r25,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5341 1b02 892B      		or r24,r25
 5342 1b04 01F0      		breq .+2
 5343 1b06 00C0      		rjmp .L647
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5344               		.loc 2 887 0 discriminator 8
 5345 1b08 8091 0000 		lds r24,opoznienie_SIM900_100MS
 5346 1b0c 8111      		cpse r24,__zero_reg__
 5347 1b0e 00C0      		rjmp .L647
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5348               		.loc 2 887 0 discriminator 10
 5349 1b10 8091 0000 		lds r24,wysylanie_smsa_clipa
 5350 1b14 8111      		cpse r24,__zero_reg__
 5351 1b16 00C0      		rjmp .L647
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5352               		.loc 2 887 0 discriminator 12
 5353 1b18 8091 0000 		lds r24,flaga_wysylanie_smsa
 5354 1b1c 8111      		cpse r24,__zero_reg__
 5355 1b1e 00C0      		rjmp .L647
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5356               		.loc 2 887 0 discriminator 14
 5357 1b20 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 5358 1b24 8139      		cpi r24,lo8(-111)
 5359 1b26 01F4      		brne .+2
 5360 1b28 00C0      		rjmp .L647
 893:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 5361               		.loc 2 893 0 is_stmt 1
 5362 1b2a 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5363 1b2e 8111      		cpse r24,__zero_reg__
 5364 1b30 00C0      		rjmp .L647
 893:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 5365               		.loc 2 893 0 is_stmt 0 discriminator 2
 5366 1b32 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5367 1b36 8111      		cpse r24,__zero_reg__
 5368 1b38 00C0      		rjmp .L647
 893:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 5369               		.loc 2 893 0 discriminator 4
 5370 1b3a 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5371 1b3e 8111      		cpse r24,__zero_reg__
 5372 1b40 00C0      		rjmp .L647
 893:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 5373               		.loc 2 893 0 discriminator 6
 5374 1b42 F999      		sbic 0x1f,1
 5375 1b44 00C0      		rjmp .L647
 894:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW,
 5376               		.loc 2 894 0 is_stmt 1
 5377 1b46 61E0      		ldi r22,lo8(1)
 5378 1b48 81E0      		ldi r24,lo8(1)
 5379 1b4a 0E94 0000 		call czy_sa_komendy_z_przedzialu
 5380               	.LVL454:
 5381 1b4e 8111      		cpse r24,__zero_reg__
 5382 1b50 00C0      		rjmp .L647
 894:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW,
 5383               		.loc 2 894 0 is_stmt 0 discriminator 2
 5384 1b52 64ED      		ldi r22,lo8(-44)
 5385 1b54 82ED      		ldi r24,lo8(-46)
 5386 1b56 0E94 0000 		call czy_sa_komendy_z_przedzialu
 5387               	.LVL455:
 5388 1b5a 8111      		cpse r24,__zero_reg__
 5389 1b5c 00C0      		rjmp .L647
 894:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW,
 5390               		.loc 2 894 0 discriminator 4
 5391 1b5e 67E9      		ldi r22,lo8(-105)
 5392 1b60 85E9      		ldi r24,lo8(-107)
 5393 1b62 0E94 0000 		call czy_sa_komendy_z_przedzialu
 5394               	.LVL456:
 5395 1b66 8111      		cpse r24,__zero_reg__
 5396 1b68 00C0      		rjmp .L647
 902:main_sim900.h ****     flaga_odczytywanie_smsa = TRUE;
 5397               		.loc 2 902 0 is_stmt 1
 5398 1b6a 0023      		tst r16
 5399 1b6c 01F4      		brne .+2
 5400 1b6e 00C0      		rjmp .L647
 902:main_sim900.h ****     flaga_odczytywanie_smsa = TRUE;
 5401               		.loc 2 902 0 is_stmt 0 discriminator 2
 5402 1b70 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5403 1b74 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5404 1b78 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
 903:main_sim900.h ****     static const char instrukcja_odczytaj_smsa[] PROGMEM = "+cmgr=";
 5405               		.loc 2 903 0 is_stmt 1 discriminator 2
 5406 1b7c 8FEF      		ldi r24,lo8(-1)
 5407 1b7e 8093 0000 		sts flaga_odczytywanie_smsa,r24
 905:main_sim900.h ****     const uint nr_smsa =
 5408               		.loc 2 905 0 discriminator 2
 5409 1b82 46E0      		ldi r20,lo8(6)
 5410 1b84 50E0      		ldi r21,0
 5411 1b86 60E0      		ldi r22,lo8(instrukcja_odczytaj_smsa.3375)
 5412 1b88 70E0      		ldi r23,hi8(instrukcja_odczytaj_smsa.3375)
 5413 1b8a 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 5414 1b8c 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 5415 1b8e 0E94 0000 		call memcpy_P
 5416               	.LVL457:
 5417               	.LBB577:
 5418               	.LBB578:
 5419               		.loc 6 527 0 discriminator 2
 5420 1b92 4AE0      		ldi r20,lo8(10)
 5421 1b94 60E0      		ldi r22,lo8(wysylany_blok_SIM900+8)
 5422 1b96 70E0      		ldi r23,hi8(wysylany_blok_SIM900+8)
 5423               	.LVL458:
 5424 1b98 C701      		movw r24,r14
 5425 1b9a 885A      		subi r24,-88
 5426 1b9c 9109      		sbc r25,__zero_reg__
 5427               	.LVL459:
 5428               	.L648:
 5429               	.LBE578:
 5430               	.LBE577:
 5431               	.LBE576:
 5432               	.LBB579:
 5433               	.LBB580:
 5434               	.LBB581:
 5435 1b9e 0E94 0000 		call __utoa_ncheck
 5436               	.LVL460:
 5437               	.L642:
 5438               	.LBE581:
 5439               	.LBE580:
 5440               	.LBE579:
1233:main_sim900.h ****     break;
 5441               		.loc 2 1233 0 discriminator 2
 5442 1ba2 0E94 0000 		call wyslij_polecenie_RAM_SIM900
 5443               	.LVL461:
 5444 1ba6 00C0      		rjmp .L600
 5445               	.L506:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5446               		.loc 2 849 0
 5447 1ba8 143D      		cpi r17,lo8(-44)
 5448 1baa 01F4      		brne .+2
 5449 1bac 00C0      		rjmp .L513
 5450 1bae 00F4      		brsh .L514
 5451 1bb0 113D      		cpi r17,lo8(-47)
 5452 1bb2 01F4      		brne .L639
 5453               	.LBB584:
 915:main_sim900.h ****         bufor_pdu, numer_telefonu_odebranego_smsa,
 5454               		.loc 2 915 0
 5455 1bb4 40E0      		ldi r20,lo8(nie_wysylaj_echa_z_powodu_nietypowego_smsa)
 5456 1bb6 50E0      		ldi r21,hi8(nie_wysylaj_echa_z_powodu_nietypowego_smsa)
 5457 1bb8 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 5458 1bba 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 5459 1bbc 80E0      		ldi r24,lo8(bufor_pdu)
 5460 1bbe 90E0      		ldi r25,hi8(bufor_pdu)
 5461 1bc0 0E94 0000 		call pobierz_numer_telefonu_nadawcy_z_PDU
 5462               	.LVL462:
 918:main_sim900.h ****     {
 5463               		.loc 2 918 0
 5464 1bc4 0097      		sbiw r24,0
 5465 1bc6 01F0      		breq .+2
 5466 1bc8 00C0      		rjmp .L533
 5467               	.LVL463:
 5468               	.L643:
 5469               	.LBE584:
 952:main_sim900.h ****     break;
 5470               		.loc 2 952 0
 5471 1bca 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 5472 1bce 00C0      		rjmp .L600
 5473               	.L514:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5474               		.loc 2 849 0
 5475 1bd0 173D      		cpi r17,lo8(-41)
 5476 1bd2 01F4      		brne .+2
 5477 1bd4 00C0      		rjmp .L517
 5478 1bd6 1D3F      		cpi r17,lo8(-3)
 5479 1bd8 01F4      		brne .+2
 5480 1bda 00C0      		rjmp .L518
 5481 1bdc 153D      		cpi r17,lo8(-43)
 5482 1bde 01F0      		breq .+2
 5483 1be0 00C0      		rjmp .L483
 5484               	.LBB587:
1046:main_sim900.h ****     if (wykonywanie_rozmowy_telefonicznej)
 5485               		.loc 2 1046 0
 5486 1be2 8091 0000 		lds r24,modul_zalogowany_w_sieci
 5487 1be6 8823      		tst r24
 5488 1be8 01F0      		breq .L549
1046:main_sim900.h ****     if (wykonywanie_rozmowy_telefonicznej)
 5489               		.loc 2 1046 0 is_stmt 0 discriminator 2
 5490 1bea 8091 0000 		lds r24,opoznienie_SIM900_100MS
 5491 1bee 8823      		tst r24
 5492 1bf0 01F4      		brne .+2
 5493 1bf2 00C0      		rjmp .L550
 5494               	.L549:
1046:main_sim900.h ****     if (wykonywanie_rozmowy_telefonicznej)
 5495               		.loc 2 1046 0 discriminator 3
 5496 1bf4 85ED      		ldi r24,lo8(-43)
 5497 1bf6 00C0      		rjmp .L641
 5498               	.L639:
 5499               	.LBE587:
 852:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 5500               		.loc 2 852 0 is_stmt 1
 5501 1bf8 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5502 1bfc 8111      		cpse r24,__zero_reg__
 5503 1bfe 00C0      		rjmp .L647
 852:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 5504               		.loc 2 852 0 is_stmt 0 discriminator 2
 5505 1c00 8091 0000 		lds r24,licznik_bezpieczenstwa_wykonywana_rozmowa
 5506 1c04 9091 0000 		lds r25,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5507 1c08 892B      		or r24,r25
 5508 1c0a 01F4      		brne .L647
 852:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 5509               		.loc 2 852 0 discriminator 4
 5510 1c0c 8091 0000 		lds r24,opoznienie_SIM900_100MS
 5511 1c10 8823      		tst r24
 5512 1c12 01F0      		breq .L521
 5513               	.L647:
 5514               	.LBB588:
 978:main_sim900.h ****     static const char instrukcja_usun_smsa[] PROGMEM = "+cmgd=";
 5515               		.loc 2 978 0 is_stmt 1 discriminator 1
 5516 1c14 812F      		mov r24,r17
 5517 1c16 00C0      		rjmp .L641
 5518               	.L521:
 5519               	.LBE588:
 853:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5520               		.loc 2 853 0
 5521 1c18 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5522 1c1c 8111      		cpse r24,__zero_reg__
 5523 1c1e 00C0      		rjmp .L647
 853:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5524               		.loc 2 853 0 is_stmt 0 discriminator 2
 5525 1c20 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5526 1c24 8111      		cpse r24,__zero_reg__
 5527 1c26 00C0      		rjmp .L647
 853:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5528               		.loc 2 853 0 discriminator 4
 5529 1c28 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5530 1c2c 8111      		cpse r24,__zero_reg__
 5531 1c2e 00C0      		rjmp .L647
 853:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5532               		.loc 2 853 0 discriminator 6
 5533 1c30 F999      		sbic 0x1f,1
 5534 1c32 00C0      		rjmp .L647
 854:main_sim900.h ****     wyslij_sms(wykonywana_komenda == KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
 5535               		.loc 2 854 0 is_stmt 1
 5536 1c34 0023      		tst r16
 5537 1c36 01F0      		breq .L647
 854:main_sim900.h ****     wyslij_sms(wykonywana_komenda == KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
 5538               		.loc 2 854 0 is_stmt 0 discriminator 2
 5539 1c38 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5540 1c3c 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5541 1c40 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
 855:main_sim900.h ****     break;
 5542               		.loc 2 855 0 is_stmt 1 discriminator 2
 5543 1c44 81E0      		ldi r24,lo8(1)
 5544 1c46 133D      		cpi r17,lo8(-45)
 5545 1c48 01F0      		breq .L525
 5546 1c4a 80E0      		ldi r24,0
 5547               	.L525:
 5548 1c4c 0E94 0000 		call wyslij_sms
 5549               	.LVL464:
 5550 1c50 00C0      		rjmp .L600
 5551               	.L513:
 5552               	.LBB589:
 859:main_sim900.h ****     konwertuj_pdu_na_blok_wysylany(wysylany_blok_SIM900, bufor_pdu,
 5553               		.loc 2 859 0
 5554 1c52 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
 860:main_sim900.h ****                                    dlugosc_pdu);
 5555               		.loc 2 860 0
 5556 1c56 4091 0000 		lds r20,dlugosc_pdu
 5557 1c5a 60E0      		ldi r22,lo8(bufor_pdu)
 5558 1c5c 70E0      		ldi r23,hi8(bufor_pdu)
 5559 1c5e 80E0      		ldi r24,lo8(wysylany_blok_SIM900)
 5560 1c60 90E0      		ldi r25,hi8(wysylany_blok_SIM900)
 5561 1c62 0E94 0000 		call konwertuj_pdu_na_blok_wysylany
 5562               	.LVL465:
 862:main_sim900.h ****     wysylany_blok_SIM900[liczba_znakow - 1] = ZNAK_CTRL_Z;
 5563               		.loc 2 862 0
 5564 1c66 8091 0000 		lds r24,dlugosc_pdu
 5565 1c6a 90E0      		ldi r25,0
 5566 1c6c 880F      		lsl r24
 5567 1c6e 991F      		rol r25
 5568 1c70 0196      		adiw r24,1
 5569               	.LVL466:
 863:main_sim900.h ****     wyslij_znaki_SIM900(liczba_znakow);
 5570               		.loc 2 863 0
 5571 1c72 FC01      		movw r30,r24
 5572 1c74 E050      		subi r30,lo8(-(wysylany_blok_SIM900-1))
 5573 1c76 F040      		sbci r31,hi8(-(wysylany_blok_SIM900-1))
 5574 1c78 2AE1      		ldi r18,lo8(26)
 5575 1c7a 2083      		st Z,r18
 864:main_sim900.h ****     break;
 5576               		.loc 2 864 0
 5577 1c7c 0E94 0000 		call wyslij_znaki_SIM900
 5578               	.LVL467:
 5579 1c80 00C0      		rjmp .L600
 5580               	.LVL468:
 5581               	.L533:
 5582               	.LBE589:
 5583               	.LBB590:
 5584               	.LBB585:
 925:main_sim900.h ****     }
 5585               		.loc 2 925 0
 5586 1c82 9E01      		movw r18,r28
 5587 1c84 2F5F      		subi r18,-1
 5588 1c86 3F4F      		sbci r19,-1
 5589 1c88 AE01      		movw r20,r28
 5590 1c8a 4E5F      		subi r20,-2
 5591 1c8c 5F4F      		sbci r21,-1
 5592 1c8e BE01      		movw r22,r28
 5593 1c90 6D5F      		subi r22,-3
 5594 1c92 7F4F      		sbci r23,-1
 5595 1c94 0E94 0000 		call pobierz_date_z_PDU
 5596               	.LVL469:
 5597               	.LBE585:
 5598               	.LBB586:
 929:main_sim900.h **** 
 5599               		.loc 2 929 0
 5600 1c98 9E01      		movw r18,r28
 5601 1c9a 2F5F      		subi r18,-1
 5602 1c9c 3F4F      		sbci r19,-1
 5603 1c9e AE01      		movw r20,r28
 5604 1ca0 4E5F      		subi r20,-2
 5605 1ca2 5F4F      		sbci r21,-1
 5606 1ca4 BE01      		movw r22,r28
 5607 1ca6 6D5F      		subi r22,-3
 5608 1ca8 7F4F      		sbci r23,-1
 5609 1caa 0E94 0000 		call pobierz_czas_z_PDU
 5610               	.LVL470:
 933:main_sim900.h ****       sms_timestamp_minuta = minuta;
 5611               		.loc 2 933 0
 5612 1cae 2B81      		ldd r18,Y+3
 5613 1cb0 2093 0000 		sts sms_timestamp_godzina,r18
 934:main_sim900.h ****       extern uchar sms_timestamp_sekunda;
 5614               		.loc 2 934 0
 5615 1cb4 2A81      		ldd r18,Y+2
 5616 1cb6 2093 0000 		sts sms_timestamp_minuta,r18
 936:main_sim900.h ****     }
 5617               		.loc 2 936 0
 5618 1cba 2981      		ldd r18,Y+1
 5619 1cbc 2093 0000 		sts sms_timestamp_sekunda,r18
 5620               	.LBE586:
 938:main_sim900.h ****     pdu_to_ascii(ptr, tekst_odebranego_smsa, MAX_LICZBA_ZNAKOW_SMS + 1);
 5621               		.loc 2 938 0
 5622 1cc0 9093 0000 		sts ptr_start_pdu_z_wiadomoscia+1,r25
 5623 1cc4 8093 0000 		sts ptr_start_pdu_z_wiadomoscia,r24
 939:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 5624               		.loc 2 939 0
 5625 1cc8 41EA      		ldi r20,lo8(-95)
 5626 1cca 60E0      		ldi r22,lo8(wysylany_blok_SIM900+239)
 5627 1ccc 70E0      		ldi r23,hi8(wysylany_blok_SIM900+239)
 5628 1cce 0E94 0000 		call pdu_to_ascii
 5629               	.LVL471:
 5630               	.L534:
 5631               	.LBE590:
 949:main_sim900.h ****     zapal_diode_led(10);
 5632               		.loc 2 949 0 discriminator 7
 5633 1cd2 87ED      		ldi r24,lo8(-41)
 5634               	.L641:
1230:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5635               		.loc 2 1230 0 discriminator 7
 5636 1cd4 0E94 0000 		call dodaj_komende
 5637               	.LVL472:
 5638 1cd8 00C0      		rjmp .L600
 5639               	.L517:
 949:main_sim900.h ****     zapal_diode_led(10);
 5640               		.loc 2 949 0
 5641 1cda 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5642 1cde 8111      		cpse r24,__zero_reg__
 5643 1ce0 00C0      		rjmp .L534
 949:main_sim900.h ****     zapal_diode_led(10);
 5644               		.loc 2 949 0 is_stmt 0 discriminator 2
 5645 1ce2 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5646 1ce6 8111      		cpse r24,__zero_reg__
 5647 1ce8 00C0      		rjmp .L534
 949:main_sim900.h ****     zapal_diode_led(10);
 5648               		.loc 2 949 0 discriminator 4
 5649 1cea 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5650 1cee 8111      		cpse r24,__zero_reg__
 5651 1cf0 00C0      		rjmp .L534
 949:main_sim900.h ****     zapal_diode_led(10);
 5652               		.loc 2 949 0 discriminator 6
 5653 1cf2 F999      		sbic 0x1f,1
 5654 1cf4 00C0      		rjmp .L534
 950:main_sim900.h ****     wykonanie_polecenia_sms();
 5655               		.loc 2 950 0 is_stmt 1
 5656 1cf6 8BE0      		ldi r24,lo8(11)
 5657 1cf8 8093 0000 		sts licznik_100ms_dioda_led,r24
 951:main_sim900.h ****     flaga_odczytywanie_smsa = FALSE;
 5658               		.loc 2 951 0
 5659 1cfc 0E94 0000 		call wykonanie_polecenia_sms
 5660               	.LVL473:
 5661 1d00 00C0      		rjmp .L643
 5662               	.L507:
 5663               	.LBB591:
 975:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5664               		.loc 2 975 0
 5665 1d02 9111      		cpse r25,__zero_reg__
 5666 1d04 00C0      		rjmp .L647
 975:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5667               		.loc 2 975 0 is_stmt 0 discriminator 2
 5668 1d06 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5669 1d0a 8111      		cpse r24,__zero_reg__
 5670 1d0c 00C0      		rjmp .L647
 975:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5671               		.loc 2 975 0 discriminator 4
 5672 1d0e 8091 0000 		lds r24,licznik_bezpieczenstwa_wykonywana_rozmowa
 5673 1d12 9091 0000 		lds r25,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5674 1d16 892B      		or r24,r25
 5675 1d18 01F0      		breq .+2
 5676 1d1a 00C0      		rjmp .L647
 975:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5677               		.loc 2 975 0 discriminator 6
 5678 1d1c 8091 0000 		lds r24,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 5679 1d20 8111      		cpse r24,__zero_reg__
 5680 1d22 00C0      		rjmp .L647
 975:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5681               		.loc 2 975 0 discriminator 8
 5682 1d24 8091 0000 		lds r24,czekanie_na_odebranie_zachety
 5683 1d28 8111      		cpse r24,__zero_reg__
 5684 1d2a 00C0      		rjmp .L647
 978:main_sim900.h ****     static const char instrukcja_usun_smsa[] PROGMEM = "+cmgd=";
 5685               		.loc 2 978 0 is_stmt 1
 5686 1d2c 0023      		tst r16
 5687 1d2e 01F4      		brne .+2
 5688 1d30 00C0      		rjmp .L647
 978:main_sim900.h ****     static const char instrukcja_usun_smsa[] PROGMEM = "+cmgd=";
 5689               		.loc 2 978 0 is_stmt 0 discriminator 2
 5690 1d32 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5691 1d36 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5692 1d3a 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
 980:main_sim900.h ****     const uint nr_smsa = wykonywana_komenda - KOMENDA_KOLEJKI_USUN_SMSA_1 + 1;
 5693               		.loc 2 980 0 is_stmt 1 discriminator 2
 5694 1d3e 46E0      		ldi r20,lo8(6)
 5695 1d40 50E0      		ldi r21,0
 5696 1d42 60E0      		ldi r22,lo8(instrukcja_usun_smsa.3408)
 5697 1d44 70E0      		ldi r23,hi8(instrukcja_usun_smsa.3408)
 5698 1d46 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 5699 1d48 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 5700 1d4a 0E94 0000 		call memcpy_P
 5701               	.LVL474:
 5702               	.LBB583:
 5703               	.LBB582:
 5704               		.loc 6 527 0 discriminator 2
 5705 1d4e 4AE0      		ldi r20,lo8(10)
 5706 1d50 60E0      		ldi r22,lo8(wysylany_blok_SIM900+8)
 5707 1d52 70E0      		ldi r23,hi8(wysylany_blok_SIM900+8)
 5708               	.LVL475:
 5709 1d54 C701      		movw r24,r14
 5710 1d56 8C5B      		subi r24,-68
 5711 1d58 9109      		sbc r25,__zero_reg__
 5712               	.LVL476:
 5713 1d5a 00C0      		rjmp .L648
 5714               	.LVL477:
 5715               	.L503:
 5716               	.LBE582:
 5717               	.LBE583:
 5718               	.LBE591:
 5719               	.LBB592:
 989:main_sim900.h ****     zapal_diode_led(10);
 5720               		.loc 2 989 0
 5721 1d5c 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5722 1d60 8111      		cpse r24,__zero_reg__
 5723 1d62 00C0      		rjmp .L539
 989:main_sim900.h ****     zapal_diode_led(10);
 5724               		.loc 2 989 0 is_stmt 0 discriminator 2
 5725 1d64 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5726 1d68 8111      		cpse r24,__zero_reg__
 5727 1d6a 00C0      		rjmp .L539
 989:main_sim900.h ****     zapal_diode_led(10);
 5728               		.loc 2 989 0 discriminator 4
 5729 1d6c 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5730 1d70 8111      		cpse r24,__zero_reg__
 5731 1d72 00C0      		rjmp .L539
 989:main_sim900.h ****     zapal_diode_led(10);
 5732               		.loc 2 989 0 discriminator 6
 5733 1d74 F99B      		sbis 0x1f,1
 5734 1d76 00C0      		rjmp .L540
 5735               	.L539:
 989:main_sim900.h ****     zapal_diode_led(10);
 5736               		.loc 2 989 0 discriminator 7
 5737 1d78 87E9      		ldi r24,lo8(-105)
 5738 1d7a 00C0      		rjmp .L641
 5739               	.L540:
 990:main_sim900.h **** 
 5740               		.loc 2 990 0 is_stmt 1
 5741 1d7c 8BE0      		ldi r24,lo8(11)
 5742 1d7e 8093 0000 		sts licznik_100ms_dioda_led,r24
 992:main_sim900.h ****         sprawdz_przychodzaca_rozmowe(); // Returns TRUE if number authorized
 5743               		.loc 2 992 0
 5744 1d82 0E94 0000 		call sprawdz_przychodzaca_rozmowe
 5745               	.LVL478:
 995:main_sim900.h ****       if (tryb_clip) {
 5746               		.loc 2 995 0
 5747 1d86 8823      		tst r24
 5748 1d88 01F0      		breq .L541
 996:main_sim900.h ****         // Tryb CLIP: wlacz wyjscie i ODRZUC polaczenie
 5749               		.loc 2 996 0
 5750 1d8a 8091 0000 		lds r24,tryb_clip
 5751               	.LVL479:
 5752 1d8e 8823      		tst r24
 5753 1d90 01F0      		breq .L542
 998:main_sim900.h ****           ustaw_wyjscie_clip();
 5754               		.loc 2 998 0
 5755 1d92 80E0      		ldi r24,lo8(__c.3412)
 5756 1d94 90E0      		ldi r25,hi8(__c.3412)
 5757 1d96 0E94 0000 		call polozenie_polecenia_SIM900
 5758               	.LVL480:
 5759 1d9a 892B      		or r24,r25
 5760 1d9c 01F4      		brne .L541
 999:main_sim900.h ****         }
 5761               		.loc 2 999 0
 5762 1d9e 0E94 0000 		call ustaw_wyjscie_clip
 5763               	.LVL481:
 5764               	.L541:
1001:main_sim900.h ****       } else {
 5765               		.loc 2 1001 0
 5766 1da2 86E9      		ldi r24,lo8(-106)
 5767               	.L640:
1004:main_sim900.h ****       }
 5768               		.loc 2 1004 0
 5769 1da4 0E94 0000 		call dodaj_komende
 5770               	.LVL482:
1010:main_sim900.h ****     break;
 5771               		.loc 2 1010 0
 5772 1da8 8FEF      		ldi r24,lo8(-1)
 5773 1daa 8093 0000 		sts blokada_clip,r24
1011:main_sim900.h ****   }
 5774               		.loc 2 1011 0
 5775 1dae 00C0      		rjmp .L478
 5776               	.L542:
1004:main_sim900.h ****       }
 5777               		.loc 2 1004 0
 5778 1db0 85E9      		ldi r24,lo8(-107)
 5779 1db2 00C0      		rjmp .L640
 5780               	.L497:
 5781               	.LBE592:
 5782               	.LBB593:
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5783               		.loc 2 1014 0
 5784 1db4 8091 0000 		lds r24,flaga_wysylanie_smsa
 5785 1db8 8111      		cpse r24,__zero_reg__
 5786 1dba 00C0      		rjmp .L544
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5787               		.loc 2 1014 0 is_stmt 0 discriminator 2
 5788 1dbc 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5789 1dc0 8111      		cpse r24,__zero_reg__
 5790 1dc2 00C0      		rjmp .L544
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5791               		.loc 2 1014 0 discriminator 4
 5792 1dc4 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 5793 1dc8 8111      		cpse r24,__zero_reg__
 5794 1dca 00C0      		rjmp .L544
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5795               		.loc 2 1014 0 discriminator 6
 5796 1dcc 8091 0000 		lds r24,czekanie_na_odebranie_zachety
 5797 1dd0 8111      		cpse r24,__zero_reg__
 5798 1dd2 00C0      		rjmp .L544
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5799               		.loc 2 1014 0 discriminator 10
 5800 1dd4 8091 C100 		lds r24,193
 5801 1dd8 86FD      		sbrc r24,6
 5802 1dda 00C0      		rjmp .L544
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5803               		.loc 2 1014 0 discriminator 12
 5804 1ddc 8091 0000 		lds r24,podlaczony_modul_gsm_SIM900
 5805 1de0 8823      		tst r24
 5806 1de2 01F0      		breq .L544
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5807               		.loc 2 1014 0 discriminator 14
 5808 1de4 8091 0000 		lds r24,komenda_SIM900
 5809 1de8 8823      		tst r24
 5810 1dea 01F0      		breq .L545
 5811               	.L544:
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5812               		.loc 2 1014 0 discriminator 15
 5813 1dec 86E9      		ldi r24,lo8(-106)
 5814 1dee 00C0      		rjmp .L641
 5815               	.L545:
1019:main_sim900.h ****     static const char instrukcja_odrzuc_rozmowe[] PROGMEM = "h";
 5816               		.loc 2 1019 0 is_stmt 1
 5817 1df0 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5818 1df4 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5819 1df8 86E9      		ldi r24,lo8(-106)
 5820 1dfa 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1021:main_sim900.h ****     break;
 5821               		.loc 2 1021 0
 5822 1dfe 80E0      		ldi r24,lo8(instrukcja_odrzuc_rozmowe.3415)
 5823 1e00 90E0      		ldi r25,hi8(instrukcja_odrzuc_rozmowe.3415)
 5824               	.L644:
 5825               	.LBE593:
 5826               	.LBB594:
1196:main_sim900.h ****     break;
 5827               		.loc 2 1196 0 discriminator 2
 5828 1e02 0E94 0000 		call wyslij_polecenie_ROM_SIM900
 5829               	.LVL483:
 5830 1e06 00C0      		rjmp .L600
 5831               	.L500:
 5832               	.LBE594:
 5833               	.LBB595:
1025:main_sim900.h ****     static const char instrukcja_odbierz_rozmowe[] PROGMEM = "a";
 5834               		.loc 2 1025 0
 5835 1e08 85E9      		ldi r24,lo8(-107)
 5836 1e0a 0023      		tst r16
 5837 1e0c 01F4      		brne .+2
 5838 1e0e 00C0      		rjmp .L641
1025:main_sim900.h ****     static const char instrukcja_odbierz_rozmowe[] PROGMEM = "a";
 5839               		.loc 2 1025 0 is_stmt 0 discriminator 2
 5840 1e10 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5841 1e14 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5842 1e18 85E9      		ldi r24,lo8(-107)
 5843 1e1a 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1027:main_sim900.h ****     POMOC_DODAJ2('#', 'p');
 5844               		.loc 2 1027 0 is_stmt 1 discriminator 2
 5845 1e1e 80E0      		ldi r24,lo8(instrukcja_odbierz_rozmowe.3417)
 5846 1e20 90E0      		ldi r25,hi8(instrukcja_odbierz_rozmowe.3417)
 5847 1e22 00C0      		rjmp .L644
 5848               	.L508:
 5849               	.LBE595:
 5850               	.LBB596:
1033:main_sim900.h ****     if (!CZY_MOZNA_WYSYLAC_DANE_SIM900() || !czy_jest_bezczynny_SIM900() ||
 5851               		.loc 2 1033 0
 5852 1e24 8091 0000 		lds r24,opoznienie_SIM900_100MS
 5853 1e28 8823      		tst r24
 5854 1e2a 01F0      		breq .L547
 5855               	.L548:
1033:main_sim900.h ****     if (!CZY_MOZNA_WYSYLAC_DANE_SIM900() || !czy_jest_bezczynny_SIM900() ||
 5856               		.loc 2 1033 0 is_stmt 0 discriminator 1
 5857 1e2c 84EA      		ldi r24,lo8(-92)
 5858 1e2e 00C0      		rjmp .L641
 5859               	.L547:
1034:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 5860               		.loc 2 1034 0 is_stmt 1
 5861 1e30 8091 C100 		lds r24,193
 5862 1e34 86FD      		sbrc r24,6
 5863 1e36 00C0      		rjmp .L548
1034:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 5864               		.loc 2 1034 0 is_stmt 0 discriminator 1
 5865 1e38 8091 0000 		lds r24,podlaczony_modul_gsm_SIM900
 5866 1e3c 8823      		tst r24
 5867 1e3e 01F0      		breq .L548
1034:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 5868               		.loc 2 1034 0 discriminator 2
 5869 1e40 8091 0000 		lds r24,komenda_SIM900
 5870 1e44 8111      		cpse r24,__zero_reg__
 5871 1e46 00C0      		rjmp .L548
1034:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 5872               		.loc 2 1034 0 discriminator 3
 5873 1e48 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 5874 1e4c 8111      		cpse r24,__zero_reg__
 5875 1e4e 00C0      		rjmp .L548
1039:main_sim900.h ****     static const char instrukcja_vts[] PROGMEM = "+vts=1";
 5876               		.loc 2 1039 0 is_stmt 1
 5877 1e50 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5878 1e54 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5879 1e58 84EA      		ldi r24,lo8(-92)
 5880 1e5a 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1041:main_sim900.h ****     POMOC_DODAJ2('#', 'V');
 5881               		.loc 2 1041 0
 5882 1e5e 80E0      		ldi r24,lo8(instrukcja_vts.3419)
 5883 1e60 90E0      		ldi r25,hi8(instrukcja_vts.3419)
 5884 1e62 00C0      		rjmp .L644
 5885               	.L550:
 5886               	.LBE596:
 5887               	.LBB597:
1047:main_sim900.h ****       break;
 5888               		.loc 2 1047 0
 5889 1e64 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5890 1e68 8111      		cpse r24,__zero_reg__
 5891 1e6a 00C0      		rjmp .L600
1049:main_sim900.h ****     zapal_diode_led(20);
 5892               		.loc 2 1049 0
 5893 1e6c 0023      		tst r16
 5894 1e6e 01F4      		brne .+2
 5895 1e70 00C0      		rjmp .L549
1049:main_sim900.h ****     zapal_diode_led(20);
 5896               		.loc 2 1049 0 is_stmt 0 discriminator 2
 5897 1e72 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5898 1e76 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5899 1e7a 85ED      		ldi r24,lo8(-43)
 5900 1e7c 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1050:main_sim900.h ****     wysylane_dane_RAM_SIM900[0] = 'd';
 5901               		.loc 2 1050 0 is_stmt 1 discriminator 2
 5902 1e80 85E1      		ldi r24,lo8(21)
 5903 1e82 8093 0000 		sts licznik_100ms_dioda_led,r24
1051:main_sim900.h ****     // static const char doladowanie[] PROGMEM = "*100*59484869838559#";
 5904               		.loc 2 1051 0 discriminator 2
 5905 1e86 84E6      		ldi r24,lo8(100)
 5906 1e88 8093 0000 		sts wysylany_blok_SIM900+2,r24
1054:main_sim900.h ****     uchar l = strlen(numer_telefonu_do_ktorego_dzwonic) + 1;
 5907               		.loc 2 1054 0 discriminator 2
 5908 1e8c 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 5909 1e8e 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 5910 1e90 80E0      		ldi r24,lo8(wysylany_blok_SIM900+3)
 5911 1e92 90E0      		ldi r25,hi8(wysylany_blok_SIM900+3)
 5912 1e94 0E94 0000 		call strcpy
 5913               	.LVL484:
1055:main_sim900.h ****     wysylane_dane_RAM_SIM900[l] = ';';
 5914               		.loc 2 1055 0 discriminator 2
 5915 1e98 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 5916 1e9a 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 5917 1e9c FC01      		movw r30,r24
 5918               		0:
 5919 1e9e 0190      		ld __tmp_reg__,Z+
 5920 1ea0 0020      		tst __tmp_reg__
 5921 1ea2 01F4      		brne 0b
 5922 1ea4 CF01      		movw r24,r30
 5923 1ea6 8050      		subi r24,lo8(numer_telefonu_do_ktorego_dzwonic+1)
 5924 1ea8 9040      		sbci r25,hi8(numer_telefonu_do_ktorego_dzwonic+1)
 5925               	.LVL485:
 5926 1eaa 8F5F      		subi r24,lo8(-(1))
 5927               	.LVL486:
1056:main_sim900.h ****     wysylane_dane_RAM_SIM900[l + 1] = '\0';
 5928               		.loc 2 1056 0 discriminator 2
 5929 1eac 90E0      		ldi r25,0
 5930 1eae FC01      		movw r30,r24
 5931               	.LVL487:
 5932 1eb0 E050      		subi r30,lo8(-(wysylany_blok_SIM900+2))
 5933 1eb2 F040      		sbci r31,hi8(-(wysylany_blok_SIM900+2))
 5934 1eb4 2BE3      		ldi r18,lo8(59)
 5935 1eb6 2083      		st Z,r18
1057:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 5936               		.loc 2 1057 0 discriminator 2
 5937 1eb8 8050      		subi r24,lo8(-(wysylany_blok_SIM900+3))
 5938 1eba 9040      		sbci r25,hi8(-(wysylany_blok_SIM900+3))
 5939 1ebc FC01      		movw r30,r24
 5940 1ebe 1082      		st Z,__zero_reg__
1058:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 300;
 5941               		.loc 2 1058 0 discriminator 2
 5942 1ec0 0E94 0000 		call wyslij_polecenie_RAM_SIM900
 5943               	.LVL488:
1059:main_sim900.h ****     POMOC_DODAJ2('#', 'h');
 5944               		.loc 2 1059 0 discriminator 2
 5945 1ec4 8CE2      		ldi r24,lo8(44)
 5946 1ec6 91E0      		ldi r25,lo8(1)
 5947 1ec8 9093 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,r25
 5948 1ecc 8093 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,r24
 5949               	.LVL489:
 5950 1ed0 00C0      		rjmp .L600
 5951               	.LVL490:
 5952               	.L552:
 5953               	.LBE597:
 5954               	.LBB598:
1077:main_sim900.h ****     static const char instrukcja_poziom_sieci[] PROGMEM = "+csq";
 5955               		.loc 2 1077 0
 5956 1ed2 8AE9      		ldi r24,lo8(-102)
 5957 1ed4 0023      		tst r16
 5958 1ed6 01F4      		brne .+2
 5959 1ed8 00C0      		rjmp .L641
1077:main_sim900.h ****     static const char instrukcja_poziom_sieci[] PROGMEM = "+csq";
 5960               		.loc 2 1077 0 is_stmt 0 discriminator 2
 5961 1eda 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5962 1ede 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5963 1ee2 8AE9      		ldi r24,lo8(-102)
 5964 1ee4 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1079:main_sim900.h ****     break;
 5965               		.loc 2 1079 0 is_stmt 1 discriminator 2
 5966 1ee8 80E0      		ldi r24,lo8(instrukcja_poziom_sieci.3423)
 5967 1eea 90E0      		ldi r25,hi8(instrukcja_poziom_sieci.3423)
 5968 1eec 00C0      		rjmp .L644
 5969               	.L484:
 5970               	.LBE598:
 5971               	.LBB599:
1084:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5972               		.loc 2 1084 0
 5973 1eee 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 5974 1ef2 9111      		cpse r25,__zero_reg__
 5975 1ef4 00C0      		rjmp .L600
1084:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5976               		.loc 2 1084 0 is_stmt 0 discriminator 1
 5977 1ef6 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 5978 1efa 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5979 1efe 232B      		or r18,r19
 5980 1f00 01F0      		breq .+2
 5981 1f02 00C0      		rjmp .L600
1084:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5982               		.loc 2 1084 0 discriminator 2
 5983 1f04 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 5984 1f08 9111      		cpse r25,__zero_reg__
 5985 1f0a 00C0      		rjmp .L600
1085:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 5986               		.loc 2 1085 0 is_stmt 1
 5987 1f0c 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 5988 1f10 9111      		cpse r25,__zero_reg__
 5989 1f12 00C0      		rjmp .L600
1086:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 5990               		.loc 2 1086 0
 5991 1f14 8111      		cpse r24,__zero_reg__
 5992 1f16 00C0      		rjmp .L600
1086:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 5993               		.loc 2 1086 0 is_stmt 0 discriminator 1
 5994 1f18 8091 0000 		lds r24,wysylanie_smsa_clipa
 5995 1f1c 8111      		cpse r24,__zero_reg__
 5996 1f1e 00C0      		rjmp .L600
1090:main_sim900.h ****     static const char instrukcja_creg[] PROGMEM = "+creg?";
 5997               		.loc 2 1090 0 is_stmt 1
 5998 1f20 8CE9      		ldi r24,lo8(-100)
 5999 1f22 0023      		tst r16
 6000 1f24 01F4      		brne .+2
 6001 1f26 00C0      		rjmp .L641
1090:main_sim900.h ****     static const char instrukcja_creg[] PROGMEM = "+creg?";
 6002               		.loc 2 1090 0 is_stmt 0 discriminator 2
 6003 1f28 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6004 1f2c 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6005 1f30 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
1092:main_sim900.h ****     break;
 6006               		.loc 2 1092 0 is_stmt 1 discriminator 2
 6007 1f34 80E0      		ldi r24,lo8(instrukcja_creg.3425)
 6008 1f36 90E0      		ldi r25,hi8(instrukcja_creg.3425)
 6009 1f38 00C0      		rjmp .L644
 6010               	.L502:
 6011               	.LBE599:
 6012               	.LBB600:
1096:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6013               		.loc 2 1096 0
 6014 1f3a 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 6015 1f3e 9111      		cpse r25,__zero_reg__
 6016 1f40 00C0      		rjmp .L556
1096:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6017               		.loc 2 1096 0 is_stmt 0 discriminator 1
 6018 1f42 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 6019 1f46 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 6020 1f4a 232B      		or r18,r19
 6021 1f4c 01F4      		brne .L556
1096:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6022               		.loc 2 1096 0 discriminator 2
 6023 1f4e 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6024 1f52 9111      		cpse r25,__zero_reg__
 6025 1f54 00C0      		rjmp .L556
1097:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 6026               		.loc 2 1097 0 is_stmt 1
 6027 1f56 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 6028 1f5a 9111      		cpse r25,__zero_reg__
 6029 1f5c 00C0      		rjmp .L556
1098:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 6030               		.loc 2 1098 0
 6031 1f5e 8111      		cpse r24,__zero_reg__
 6032 1f60 00C0      		rjmp .L556
1098:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 6033               		.loc 2 1098 0 is_stmt 0 discriminator 1
 6034 1f62 8091 0000 		lds r24,wysylanie_smsa_clipa
 6035 1f66 8823      		tst r24
 6036 1f68 01F0      		breq .L557
 6037               	.L556:
1100:main_sim900.h ****       break;
 6038               		.loc 2 1100 0 is_stmt 1
 6039 1f6a 1092 0000 		sts licznik_blad_stanu_karty_SIM,__zero_reg__
 6040 1f6e 00C0      		rjmp .L600
 6041               	.L557:
1103:main_sim900.h ****     static const char instrukcja_odczyt_ksiazki[] PROGMEM = "+cpbr=26";
 6042               		.loc 2 1103 0
 6043 1f70 88E9      		ldi r24,lo8(-104)
 6044 1f72 0023      		tst r16
 6045 1f74 01F4      		brne .+2
 6046 1f76 00C0      		rjmp .L641
1103:main_sim900.h ****     static const char instrukcja_odczyt_ksiazki[] PROGMEM = "+cpbr=26";
 6047               		.loc 2 1103 0 is_stmt 0 discriminator 2
 6048 1f78 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6049 1f7c 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6050 1f80 88E9      		ldi r24,lo8(-104)
 6051 1f82 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1105:main_sim900.h ****     break;
 6052               		.loc 2 1105 0 is_stmt 1 discriminator 2
 6053 1f86 80E0      		ldi r24,lo8(instrukcja_odczyt_ksiazki.3427)
 6054 1f88 90E0      		ldi r25,hi8(instrukcja_odczyt_ksiazki.3427)
 6055 1f8a 00C0      		rjmp .L644
 6056               	.L504:
 6057               	.LBE600:
 6058               	.LBB601:
1109:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6059               		.loc 2 1109 0
 6060 1f8c 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 6061 1f90 9111      		cpse r25,__zero_reg__
 6062 1f92 00C0      		rjmp .L559
1109:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6063               		.loc 2 1109 0 is_stmt 0 discriminator 1
 6064 1f94 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 6065 1f98 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 6066 1f9c 232B      		or r18,r19
 6067 1f9e 01F4      		brne .L559
1109:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6068               		.loc 2 1109 0 discriminator 2
 6069 1fa0 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6070 1fa4 9111      		cpse r25,__zero_reg__
 6071 1fa6 00C0      		rjmp .L559
1110:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 6072               		.loc 2 1110 0 is_stmt 1
 6073 1fa8 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 6074 1fac 9111      		cpse r25,__zero_reg__
 6075 1fae 00C0      		rjmp .L559
1111:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 6076               		.loc 2 1111 0
 6077 1fb0 8111      		cpse r24,__zero_reg__
 6078 1fb2 00C0      		rjmp .L559
1111:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 6079               		.loc 2 1111 0 is_stmt 0 discriminator 1
 6080 1fb4 8091 0000 		lds r24,wysylanie_smsa_clipa
 6081 1fb8 8823      		tst r24
 6082 1fba 01F0      		breq .L560
 6083               	.L559:
1113:main_sim900.h ****       break;
 6084               		.loc 2 1113 0 is_stmt 1
 6085 1fbc 1092 0000 		sts licznik_blad_zalogowania_u_operatora,__zero_reg__
 6086 1fc0 00C0      		rjmp .L600
 6087               	.L560:
1116:main_sim900.h ****     static const char instrukcja_sprawdz_operatora[] PROGMEM = "+cops?";
 6088               		.loc 2 1116 0
 6089 1fc2 89E9      		ldi r24,lo8(-103)
 6090 1fc4 0023      		tst r16
 6091 1fc6 01F4      		brne .+2
 6092 1fc8 00C0      		rjmp .L641
1116:main_sim900.h ****     static const char instrukcja_sprawdz_operatora[] PROGMEM = "+cops?";
 6093               		.loc 2 1116 0 is_stmt 0 discriminator 2
 6094 1fca 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6095 1fce 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6096 1fd2 89E9      		ldi r24,lo8(-103)
 6097 1fd4 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1118:main_sim900.h ****     break;
 6098               		.loc 2 1118 0 is_stmt 1 discriminator 2
 6099 1fd8 80E0      		ldi r24,lo8(instrukcja_sprawdz_operatora.3429)
 6100 1fda 90E0      		ldi r25,hi8(instrukcja_sprawdz_operatora.3429)
 6101 1fdc 00C0      		rjmp .L644
 6102               	.L510:
 6103               	.LBE601:
 6104               	.LBB602:
1122:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6105               		.loc 2 1122 0
 6106 1fde 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 6107 1fe2 9111      		cpse r25,__zero_reg__
 6108 1fe4 00C0      		rjmp .L600
1122:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6109               		.loc 2 1122 0 is_stmt 0 discriminator 1
 6110 1fe6 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 6111 1fea 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 6112 1fee 232B      		or r18,r19
 6113 1ff0 01F0      		breq .+2
 6114 1ff2 00C0      		rjmp .L600
1122:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6115               		.loc 2 1122 0 discriminator 2
 6116 1ff4 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6117 1ff8 9111      		cpse r25,__zero_reg__
 6118 1ffa 00C0      		rjmp .L600
1123:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 6119               		.loc 2 1123 0 is_stmt 1
 6120 1ffc 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 6121 2000 9111      		cpse r25,__zero_reg__
 6122 2002 00C0      		rjmp .L600
1124:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK)
 6123               		.loc 2 1124 0
 6124 2004 8111      		cpse r24,__zero_reg__
 6125 2006 00C0      		rjmp .L600
1124:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK)
 6126               		.loc 2 1124 0 is_stmt 0 discriminator 1
 6127 2008 8091 0000 		lds r24,wysylanie_smsa_clipa
 6128 200c 8111      		cpse r24,__zero_reg__
 6129 200e 00C0      		rjmp .L600
1127:main_sim900.h ****     static const char instrukcja_cclk[] PROGMEM = "+cclk?";
 6130               		.loc 2 1127 0 is_stmt 1
 6131 2010 8DE9      		ldi r24,lo8(-99)
 6132 2012 0023      		tst r16
 6133 2014 01F4      		brne .+2
 6134 2016 00C0      		rjmp .L641
1127:main_sim900.h ****     static const char instrukcja_cclk[] PROGMEM = "+cclk?";
 6135               		.loc 2 1127 0 is_stmt 0 discriminator 2
 6136 2018 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6137 201c 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6138 2020 8DE9      		ldi r24,lo8(-99)
 6139 2022 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1129:main_sim900.h ****     break;
 6140               		.loc 2 1129 0 is_stmt 1 discriminator 2
 6141 2026 80E0      		ldi r24,lo8(instrukcja_cclk.3431)
 6142 2028 90E0      		ldi r25,hi8(instrukcja_cclk.3431)
 6143 202a 00C0      		rjmp .L644
 6144               	.L499:
 6145               	.LBE602:
 6146               	.LBB603:
1133:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM = "+cdscb";
 6147               		.loc 2 1133 0
 6148 202c 84E9      		ldi r24,lo8(-108)
 6149 202e 0023      		tst r16
 6150 2030 01F4      		brne .+2
 6151 2032 00C0      		rjmp .L641
1133:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM = "+cdscb";
 6152               		.loc 2 1133 0 is_stmt 0 discriminator 2
 6153 2034 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6154 2038 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6155 203c 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
1135:main_sim900.h ****     break;
 6156               		.loc 2 1135 0 is_stmt 1 discriminator 2
 6157 2040 80E0      		ldi r24,lo8(instrukcja_ustawienie_pamieci.3433)
 6158 2042 90E0      		ldi r25,hi8(instrukcja_ustawienie_pamieci.3433)
 6159 2044 00C0      		rjmp .L644
 6160               	.L493:
 6161               	.LBE603:
 6162               	.LBB604:
1139:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM =
 6163               		.loc 2 1139 0
 6164 2046 8EE8      		ldi r24,lo8(-114)
 6165 2048 0023      		tst r16
 6166 204a 01F4      		brne .+2
 6167 204c 00C0      		rjmp .L641
1139:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM =
 6168               		.loc 2 1139 0 is_stmt 0 discriminator 2
 6169 204e 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6170 2052 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6171 2056 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
1142:main_sim900.h ****         KOMENDA_KOLEJKI_WSTAWIENIE_MORING_GDY_DZWONI;
 6172               		.loc 2 1142 0 is_stmt 1 discriminator 2
 6173 205a 80EA      		ldi r24,lo8(-96)
 6174 205c 8093 0000 		sts nastepne_wysylane_polecenie_SIM900,r24
1144:main_sim900.h ****     break;
 6175               		.loc 2 1144 0 discriminator 2
 6176 2060 80E0      		ldi r24,lo8(instrukcja_ustawienie_pamieci.3435)
 6177 2062 90E0      		ldi r25,hi8(instrukcja_ustawienie_pamieci.3435)
 6178 2064 00C0      		rjmp .L644
 6179               	.L490:
 6180               	.LBE604:
1148:main_sim900.h ****     opoznienie_zatrzymaj_odpytywanie_urzadzenia = 20;
 6181               		.loc 2 1148 0
 6182 2066 8BE8      		ldi r24,lo8(-117)
 6183 2068 0E94 0000 		call dodaj_komende
 6184               	.LVL491:
1149:main_sim900.h ****     ustaw_odbior_SIM900();
 6185               		.loc 2 1149 0
 6186 206c 84E1      		ldi r24,lo8(20)
 6187 206e 8093 0000 		sts opoznienie_zatrzymaj_odpytywanie_urzadzenia,r24
1150:main_sim900.h ****     break;
 6188               		.loc 2 1150 0
 6189 2072 1092 0000 		sts liczba_odebranych_znakow_SIM900+1,__zero_reg__
 6190 2076 1092 0000 		sts liczba_odebranych_znakow_SIM900,__zero_reg__
 6191 207a 1092 0000 		sts licznik_opoznienie_oczekiwania_na_bajt_SIM900,__zero_reg__
 6192 207e 80B7      		in r24,0x30
 6193 2080 8260      		ori r24,lo8(2)
 6194 2082 80BF      		out 0x30,r24
 6195               	/* #APP */
 6196               	 ;  1150 "main_sim900.h" 1
 6197 2084 F894      		cli
 6198               	 ;  0 "" 2
 6199               	/* #NOAPP */
 6200 2086 8091 C100 		lds r24,193
 6201 208a 8068      		ori r24,lo8(-128)
 6202 208c 8093 C100 		sts 193,r24
 6203               	/* #APP */
 6204               	 ;  1150 "main_sim900.h" 1
 6205 2090 7894      		sei
 6206               	 ;  0 "" 2
 6207               	 ;  1150 "main_sim900.h" 1
 6208 2092 0000      		nop
 6209               	 ;  0 "" 2
 6210               	/* #NOAPP */
 6211 2094 4598      		cbi 0x8,5
 6212 2096 00C0      		rjmp .L600
 6213               	.L491:
 6214               	.LBB605:
1157:main_sim900.h ****       break;
 6215               		.loc 2 1157 0
 6216 2098 8091 0000 		lds r24,max_oczekiwanie_na_odpowiedz_at
 6217 209c 8111      		cpse r24,__zero_reg__
 6218 209e 00C0      		rjmp .L600
1159:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
 6219               		.loc 2 1159 0
 6220 20a0 8091 0000 		lds r24,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6221 20a4 8823      		tst r24
 6222 20a6 01F0      		breq .L565
 6223               	.L566:
1160:main_sim900.h ****       break;
 6224               		.loc 2 1160 0
 6225 20a8 8BE8      		ldi r24,lo8(-117)
 6226 20aa 00C0      		rjmp .L641
 6227               	.L565:
1163:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
 6228               		.loc 2 1163 0
 6229 20ac 8091 C100 		lds r24,193
 6230 20b0 86FD      		sbrc r24,6
 6231 20b2 00C0      		rjmp .L566
1167:main_sim900.h ****     wysylane_polecenie_SIM900 = wykonywana_komenda;
 6232               		.loc 2 1167 0
 6233 20b4 1092 0000 		sts liczba_odebranych_znakow_SIM900+1,__zero_reg__
 6234 20b8 1092 0000 		sts liczba_odebranych_znakow_SIM900,__zero_reg__
 6235 20bc 1092 0000 		sts licznik_opoznienie_oczekiwania_na_bajt_SIM900,__zero_reg__
 6236 20c0 80B7      		in r24,0x30
 6237 20c2 8260      		ori r24,lo8(2)
 6238 20c4 80BF      		out 0x30,r24
 6239               	/* #APP */
 6240               	 ;  1167 "main_sim900.h" 1
 6241 20c6 F894      		cli
 6242               	 ;  0 "" 2
 6243               	/* #NOAPP */
 6244 20c8 8091 C100 		lds r24,193
 6245 20cc 8068      		ori r24,lo8(-128)
 6246 20ce 8093 C100 		sts 193,r24
 6247               	/* #APP */
 6248               	 ;  1167 "main_sim900.h" 1
 6249 20d2 7894      		sei
 6250               	 ;  0 "" 2
 6251               	 ;  1167 "main_sim900.h" 1
 6252 20d4 0000      		nop
 6253               	 ;  0 "" 2
 6254               	/* #NOAPP */
 6255 20d6 4598      		cbi 0x8,5
1168:main_sim900.h ****     max_oczekiwanie_na_odpowiedz_at = 20;
 6256               		.loc 2 1168 0
 6257 20d8 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6258 20dc 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6259 20e0 8BE8      		ldi r24,lo8(-117)
 6260 20e2 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1169:main_sim900.h ****     static const char instrukcja_at[] PROGMEM = "+ifc=2,2";
 6261               		.loc 2 1169 0
 6262 20e6 84E1      		ldi r24,lo8(20)
 6263 20e8 8093 0000 		sts max_oczekiwanie_na_odpowiedz_at,r24
1171:main_sim900.h ****     break;
 6264               		.loc 2 1171 0
 6265 20ec 80E0      		ldi r24,lo8(instrukcja_at.3438)
 6266 20ee 90E0      		ldi r25,hi8(instrukcja_at.3438)
 6267 20f0 00C0      		rjmp .L644
 6268               	.L488:
 6269               	.LBE605:
1175:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_PIN);
 6270               		.loc 2 1175 0
 6271 20f2 8FEF      		ldi r24,lo8(-1)
 6272 20f4 8093 0000 		sts podlaczony_modul_gsm_SIM900,r24
1176:main_sim900.h ****     opoznienie_SIM900_100MS = 40;
 6273               		.loc 2 1176 0
 6274 20f8 8EE9      		ldi r24,lo8(-98)
 6275 20fa 0E94 0000 		call dodaj_komende
 6276               	.LVL492:
1177:main_sim900.h ****     break;
 6277               		.loc 2 1177 0
 6278 20fe 88E2      		ldi r24,lo8(40)
 6279 2100 8093 0000 		sts opoznienie_SIM900_100MS,r24
 6280 2104 00C0      		rjmp .L600
 6281               	.L494:
 6282               	.LBB606:
1181:main_sim900.h ****     static const char instrukcja_podaj_pin[] PROGMEM = "+cpin=\"1976\"";
 6283               		.loc 2 1181 0
 6284 2106 8DE8      		ldi r24,lo8(-115)
 6285 2108 0023      		tst r16
 6286 210a 01F4      		brne .+2
 6287 210c 00C0      		rjmp .L641
1181:main_sim900.h ****     static const char instrukcja_podaj_pin[] PROGMEM = "+cpin=\"1976\"";
 6288               		.loc 2 1181 0 is_stmt 0 discriminator 2
 6289 210e 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6290 2112 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6291 2116 8DE8      		ldi r24,lo8(-115)
 6292 2118 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1183:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 6293               		.loc 2 1183 0 is_stmt 1 discriminator 2
 6294 211c 60E0      		ldi r22,lo8(instrukcja_podaj_pin.3441)
 6295 211e 70E0      		ldi r23,hi8(instrukcja_podaj_pin.3441)
 6296 2120 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 6297 2122 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 6298 2124 0E94 0000 		call strcpy_P
 6299               	.LVL493:
 6300 2128 00C0      		rjmp .L642
 6301               	.L486:
 6302               	.LBE606:
 6303               	.LBB607:
1189:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW);
 6304               		.loc 2 1189 0
 6305 212a 8091 0000 		lds r24,drugi_raz.3443
 6306 212e 8823      		tst r24
 6307 2130 01F0      		breq .L568
1190:main_sim900.h ****       break;
 6308               		.loc 2 1190 0
 6309 2132 8FE9      		ldi r24,lo8(-97)
 6310 2134 00C0      		rjmp .L641
 6311               	.L568:
1193:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6312               		.loc 2 1193 0
 6313 2136 8FEF      		ldi r24,lo8(-1)
 6314 2138 8093 0000 		sts drugi_raz.3443,r24
1194:main_sim900.h ****     static const char instrukcja_usun_wszystkie_smsy[] PROGMEM = "+cmgda=6";
 6315               		.loc 2 1194 0
 6316 213c 81E9      		ldi r24,lo8(-111)
 6317 213e 0023      		tst r16
 6318 2140 01F4      		brne .+2
 6319 2142 00C0      		rjmp .L641
1194:main_sim900.h ****     static const char instrukcja_usun_wszystkie_smsy[] PROGMEM = "+cmgda=6";
 6320               		.loc 2 1194 0 is_stmt 0 discriminator 2
 6321 2144 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6322 2148 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6323 214c 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
1196:main_sim900.h ****     break;
 6324               		.loc 2 1196 0 is_stmt 1 discriminator 2
 6325 2150 80E0      		ldi r24,lo8(instrukcja_usun_wszystkie_smsy.3444)
 6326 2152 90E0      		ldi r25,hi8(instrukcja_usun_wszystkie_smsy.3444)
 6327 2154 00C0      		rjmp .L644
 6328               	.L492:
 6329               	.LBE607:
1200:main_sim900.h ****     if (komenda_SIM900 != KOMENDA_SIM900_WYSLANE_POLECENIE)
 6330               		.loc 2 1200 0
 6331 2156 0E94 0000 		call obsluga_komendy_SIM900
 6332               	.LVL494:
1201:main_sim900.h ****       max_oczekiwanie_na_odpowiedz = 20;
 6333               		.loc 2 1201 0
 6334 215a 8091 0000 		lds r24,komenda_SIM900
 6335 215e 8138      		cpi r24,lo8(-127)
 6336 2160 01F0      		breq .L570
1202:main_sim900.h ****     resetuj_komende_SIM900();
 6337               		.loc 2 1202 0
 6338 2162 84E1      		ldi r24,lo8(20)
 6339 2164 8093 0000 		sts max_oczekiwanie_na_odpowiedz,r24
 6340               	.L570:
1203:main_sim900.h ****     break;
 6341               		.loc 2 1203 0
 6342 2168 1092 0000 		sts komenda_SIM900,__zero_reg__
 6343 216c 00C0      		rjmp .L600
 6344               	.L572:
 6345               	.LBB608:
1208:main_sim900.h ****     static const char instrukcja[] PROGMEM =
 6346               		.loc 2 1208 0
 6347 216e 0023      		tst r16
 6348 2170 01F4      		brne .+2
 6349 2172 00C0      		rjmp .L571
1208:main_sim900.h ****     static const char instrukcja[] PROGMEM =
 6350               		.loc 2 1208 0 is_stmt 0 discriminator 2
 6351 2174 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6352 2178 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6353 217c 83E9      		ldi r24,lo8(-109)
 6354 217e 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1211:main_sim900.h ****     nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_ROZPOCZNIJ_PRACE;
 6355               		.loc 2 1211 0 is_stmt 1 discriminator 2
 6356 2182 60E0      		ldi r22,lo8(instrukcja.3447)
 6357 2184 70E0      		ldi r23,hi8(instrukcja.3447)
 6358 2186 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 6359 2188 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 6360 218a 0E94 0000 		call strcpy_P
 6361               	.LVL495:
1212:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 6362               		.loc 2 1212 0 discriminator 2
 6363 218e 8FE8      		ldi r24,lo8(-113)
 6364 2190 8093 0000 		sts nastepne_wysylane_polecenie_SIM900,r24
 6365 2194 00C0      		rjmp .L642
 6366               	.L495:
 6367               	.LVL496:
 6368               	.LBE608:
1218:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS);
 6369               		.loc 2 1218 0
 6370 2196 8091 0000 		lds r24,podlaczona_karta_SIM_SIM900
 6371 219a 8823      		tst r24
 6372 219c 01F4      		brne .+2
 6373 219e 00C0      		rjmp .L600
1219:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_MODUL_ZALOGOWANY);
 6374               		.loc 2 1219 0
 6375 21a0 84E9      		ldi r24,lo8(-108)
 6376 21a2 0E94 0000 		call dodaj_komende
 6377               	.LVL497:
1220:main_sim900.h ****     }
 6378               		.loc 2 1220 0
 6379 21a6 80E9      		ldi r24,lo8(-112)
 6380 21a8 00C0      		rjmp .L641
 6381               	.LVL498:
 6382               	.L518:
1230:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6383               		.loc 2 1230 0
 6384 21aa 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 6385 21ae 8111      		cpse r24,__zero_reg__
 6386 21b0 00C0      		rjmp .L573
1230:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6387               		.loc 2 1230 0 is_stmt 0 discriminator 2
 6388 21b2 8091 0000 		lds r24,liczba_znakow_do_zapisu
 6389 21b6 8111      		cpse r24,__zero_reg__
 6390 21b8 00C0      		rjmp .L573
1230:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6391               		.loc 2 1230 0 discriminator 4
 6392 21ba 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 6393 21be 8111      		cpse r24,__zero_reg__
 6394 21c0 00C0      		rjmp .L573
1230:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6395               		.loc 2 1230 0 discriminator 6
 6396 21c2 F99B      		sbis 0x1f,1
 6397 21c4 00C0      		rjmp .L574
 6398               	.L573:
1230:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6399               		.loc 2 1230 0 discriminator 7
 6400 21c6 8DEF      		ldi r24,lo8(-3)
 6401 21c8 00C0      		rjmp .L641
 6402               	.L574:
1231:main_sim900.h ****     strcpy(wysylane_dane_RAM_SIM900, bufor_ustaw_czas);
 6403               		.loc 2 1231 0 is_stmt 1
 6404 21ca 0023      		tst r16
 6405 21cc 01F0      		breq .L573
1231:main_sim900.h ****     strcpy(wysylane_dane_RAM_SIM900, bufor_ustaw_czas);
 6406               		.loc 2 1231 0 is_stmt 0 discriminator 2
 6407 21ce 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6408 21d2 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6409 21d6 8DEF      		ldi r24,lo8(-3)
 6410 21d8 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1232:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 6411               		.loc 2 1232 0 is_stmt 1 discriminator 2
 6412 21dc 60E0      		ldi r22,lo8(bufor_ustaw_czas)
 6413 21de 70E0      		ldi r23,hi8(bufor_ustaw_czas)
 6414 21e0 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 6415 21e2 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 6416 21e4 0E94 0000 		call strcpy
 6417               	.LVL499:
 6418 21e8 00C0      		rjmp .L642
 6419               		.cfi_endproc
 6420               	.LFE53:
 6422               	.global	steruj_SIM900_100MS
 6424               	steruj_SIM900_100MS:
 6425               	.LFB54:
1282:main_sim900.h **** 
1283:main_sim900.h **** void steruj_SIM900_100MS(void) {
 6426               		.loc 2 1283 0
 6427               		.cfi_startproc
 6428               	/* prologue: function */
 6429               	/* frame size = 0 */
 6430               	/* stack size = 0 */
 6431               	.L__stack_usage = 0
1284:main_sim900.h ****   if (opoznienie_SIM900_100MS && --opoznienie_SIM900_100MS == 0)
 6432               		.loc 2 1284 0
 6433 21ea 8091 0000 		lds r24,opoznienie_SIM900_100MS
 6434 21ee 8823      		tst r24
 6435 21f0 01F0      		breq .L651
 6436               		.loc 2 1284 0 is_stmt 0 discriminator 1
 6437 21f2 8150      		subi r24,lo8(-(-1))
 6438 21f4 8093 0000 		sts opoznienie_SIM900_100MS,r24
 6439 21f8 8111      		cpse r24,__zero_reg__
 6440 21fa 00C0      		rjmp .L651
1285:main_sim900.h ****     oproznij_bufor_SIM900_po_bledzie = FALSE;
 6441               		.loc 2 1285 0 is_stmt 1
 6442 21fc 1092 0000 		sts oproznij_bufor_SIM900_po_bledzie,__zero_reg__
 6443               	.L651:
1286:main_sim900.h **** 
1287:main_sim900.h ****   if (opoznienie_wysylania_clipow_100MS)
 6444               		.loc 2 1287 0
 6445 2200 8091 0000 		lds r24,opoznienie_wysylania_clipow_100MS
 6446 2204 9091 0000 		lds r25,opoznienie_wysylania_clipow_100MS+1
 6447 2208 0097      		sbiw r24,0
 6448 220a 01F0      		breq .L653
1288:main_sim900.h ****     --opoznienie_wysylania_clipow_100MS;
 6449               		.loc 2 1288 0
 6450 220c 0197      		sbiw r24,1
 6451 220e 9093 0000 		sts opoznienie_wysylania_clipow_100MS+1,r25
 6452 2212 8093 0000 		sts opoznienie_wysylania_clipow_100MS,r24
 6453               	.L653:
1289:main_sim900.h **** 
1290:main_sim900.h ****   // Timeout rozmowy - automatyczne rozlaczenie po 30 sekundach
1291:main_sim900.h ****   if (licznik_timeout_rozmowy_100ms) {
 6454               		.loc 2 1291 0
 6455 2216 8091 0000 		lds r24,licznik_timeout_rozmowy_100ms
 6456 221a 9091 0000 		lds r25,licznik_timeout_rozmowy_100ms+1
 6457 221e 0097      		sbiw r24,0
 6458 2220 01F0      		breq .L655
1292:main_sim900.h ****     if (--licznik_timeout_rozmowy_100ms == 0 &&
 6459               		.loc 2 1292 0
 6460 2222 0197      		sbiw r24,1
 6461 2224 9093 0000 		sts licznik_timeout_rozmowy_100ms+1,r25
 6462 2228 8093 0000 		sts licznik_timeout_rozmowy_100ms,r24
 6463 222c 892B      		or r24,r25
 6464 222e 01F4      		brne .L655
 6465               		.loc 2 1292 0 is_stmt 0 discriminator 1
 6466 2230 8091 0000 		lds r24,trwa_rozmowa_przychodzaca_od_uzytkownika
 6467 2234 8823      		tst r24
 6468 2236 01F0      		breq .L655
1293:main_sim900.h ****         trwa_rozmowa_przychodzaca_od_uzytkownika) {
1294:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
 6469               		.loc 2 1294 0 is_stmt 1
 6470 2238 86E9      		ldi r24,lo8(-106)
 6471 223a 0E94 0000 		call dodaj_komende
 6472               	.LVL500:
 6473               	.L655:
1295:main_sim900.h ****       POMOC_DODAJ2('#', 'X'); // Timeout marker
1296:main_sim900.h ****     }
1297:main_sim900.h ****   }
1298:main_sim900.h **** 
1299:main_sim900.h ****   if (max_oczekiwanie_na_odpowiedz_at) {
 6474               		.loc 2 1299 0
 6475 223e 8091 0000 		lds r24,max_oczekiwanie_na_odpowiedz_at
 6476 2242 8823      		tst r24
 6477 2244 01F0      		breq .L658
1300:main_sim900.h ****     if (--max_oczekiwanie_na_odpowiedz_at == 0) {
 6478               		.loc 2 1300 0
 6479 2246 8150      		subi r24,lo8(-(-1))
 6480 2248 8093 0000 		sts max_oczekiwanie_na_odpowiedz_at,r24
 6481 224c 8111      		cpse r24,__zero_reg__
 6482 224e 00C0      		rjmp .L658
1301:main_sim900.h ****       wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 6483               		.loc 2 1301 0
 6484 2250 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6485 2254 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6486 2258 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
1302:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT);
 6487               		.loc 2 1302 0
 6488 225c 8BE8      		ldi r24,lo8(-117)
 6489 225e 0E94 0000 		call dodaj_komende
 6490               	.LVL501:
1303:main_sim900.h ****       sprawdzaj_wejscie_CTS_SIM900 = FALSE;
 6491               		.loc 2 1303 0
 6492 2262 1092 0000 		sts sprawdzaj_wejscie_CTS_SIM900,__zero_reg__
1304:main_sim900.h ****       zakoncz_wysylanie_SIM900();
 6493               		.loc 2 1304 0
 6494               	/* #APP */
 6495               	 ;  1304 "main_sim900.h" 1
 6496 2266 F894      		cli
 6497               	 ;  0 "" 2
 6498               	/* #NOAPP */
 6499 2268 8091 C100 		lds r24,193
 6500 226c 8F7B      		andi r24,lo8(-65)
 6501 226e 8093 C100 		sts 193,r24
 6502               	/* #APP */
 6503               	 ;  1304 "main_sim900.h" 1
 6504 2272 7894      		sei
 6505               	 ;  0 "" 2
 6506               	 ;  1304 "main_sim900.h" 1
 6507 2274 0000      		nop
 6508               	 ;  0 "" 2
 6509               	/* #NOAPP */
 6510               	.L658:
1305:main_sim900.h ****     }
1306:main_sim900.h ****   }
1307:main_sim900.h **** 
1308:main_sim900.h ****   if (procedura_inicjalizacyjna_SIM900_100MS())
 6511               		.loc 2 1308 0
 6512 2276 0E94 0000 		call procedura_inicjalizacyjna_SIM900_100MS
 6513               	.LVL502:
 6514 227a 8823      		tst r24
 6515 227c 01F0      		breq .L660
1309:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_PODLACZONY_MODUL_GSM);
 6516               		.loc 2 1309 0
 6517 227e 8AE8      		ldi r24,lo8(-118)
 6518 2280 0E94 0000 		call dodaj_komende
 6519               	.LVL503:
 6520               	.L660:
1310:main_sim900.h **** 
1311:main_sim900.h ****   if (maksymalny_czas_dzwonienia) {
 6521               		.loc 2 1311 0
 6522 2284 8091 0000 		lds r24,maksymalny_czas_dzwonienia
 6523 2288 8823      		tst r24
 6524 228a 01F0      		breq .L662
1312:main_sim900.h ****     if (--maksymalny_czas_dzwonienia == 0) {
 6525               		.loc 2 1312 0
 6526 228c 8150      		subi r24,lo8(-(-1))
 6527 228e 8093 0000 		sts maksymalny_czas_dzwonienia,r24
 6528 2292 8111      		cpse r24,__zero_reg__
 6529 2294 00C0      		rjmp .L662
 6530               	.LVL504:
1313:main_sim900.h ****       POMOC_DODAJ2('#', 'i');
1314:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
 6531               		.loc 2 1314 0
 6532 2296 86E9      		ldi r24,lo8(-106)
 6533 2298 0E94 0000 		call dodaj_komende
 6534               	.LVL505:
 6535               	.L662:
1315:main_sim900.h ****     }
1316:main_sim900.h ****   }
1317:main_sim900.h **** 
1318:main_sim900.h ****   if (licznik_bezpieczenstwa_wykonywana_rozmowa) {
 6536               		.loc 2 1318 0
 6537 229c 8091 0000 		lds r24,licznik_bezpieczenstwa_wykonywana_rozmowa
 6538 22a0 9091 0000 		lds r25,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 6539 22a4 0097      		sbiw r24,0
 6540 22a6 01F0      		breq .L665
1319:main_sim900.h ****     if (--licznik_bezpieczenstwa_wykonywana_rozmowa == 0) {
 6541               		.loc 2 1319 0
 6542 22a8 0197      		sbiw r24,1
 6543 22aa 9093 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,r25
 6544 22ae 8093 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,r24
 6545 22b2 892B      		or r24,r25
 6546 22b4 01F4      		brne .L665
 6547               	.LVL506:
1320:main_sim900.h ****       POMOC_DODAJ2('#', 'j');
1321:main_sim900.h ****       zakonczono_rozmowe_telefoniczna(
 6548               		.loc 2 1321 0
 6549 22b6 82E0      		ldi r24,lo8(2)
 6550 22b8 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 6551               	.LVL507:
1322:main_sim900.h ****           powod_zakonczenia_rozmowy_przekroczony_czas);
1323:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 6552               		.loc 2 1323 0
 6553 22bc 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
1324:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 6554               		.loc 2 1324 0
 6555 22c0 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 6556               	.LVL508:
 6557               	.L665:
 6558               	.LBB609:
1325:main_sim900.h ****     }
1326:main_sim900.h ****   }
1327:main_sim900.h **** 
1328:main_sim900.h **** #ifndef WYLACZ_AUTOMATYCZNE_KONTROLOWANIE_SIMCOM
1329:main_sim900.h **** 
1330:main_sim900.h ****   { // poziom sieci i zalogowanie u operatora
1331:main_sim900.h ****     static uchar licznik_cyklu_8_sek = 0;
1332:main_sim900.h ****     if (++licznik_cyklu_8_sek == 48)
 6559               		.loc 2 1332 0
 6560 22c4 8091 0000 		lds r24,licznik_cyklu_8_sek.3471
 6561 22c8 8F5F      		subi r24,lo8(-(1))
 6562 22ca 8093 0000 		sts licznik_cyklu_8_sek.3471,r24
 6563 22ce 8033      		cpi r24,lo8(48)
 6564 22d0 01F0      		breq .+2
 6565 22d2 00C0      		rjmp .L667
1333:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_POZIOM_SIECI);
 6566               		.loc 2 1333 0
 6567 22d4 8AE9      		ldi r24,lo8(-102)
 6568               	.L709:
1334:main_sim900.h ****     else if (licznik_cyklu_8_sek == 52)
1335:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_ZAREJESTROWANIE);
1336:main_sim900.h ****     else if (licznik_cyklu_8_sek == 56)
1337:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_ZALOGOWANIE_U_OPERATORA);
1338:main_sim900.h ****     else if (licznik_cyklu_8_sek == 60) {
1339:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_STAN_KARTY_SIM);
1340:main_sim900.h ****     } else if (licznik_cyklu_8_sek >= 80) {
1341:main_sim900.h ****       licznik_cyklu_8_sek = 0;
1342:main_sim900.h ****       if (modul_zalogowany_w_sieci)
1343:main_sim900.h ****         filtruj_i_dodaj_komende(
 6569               		.loc 2 1343 0
 6570 22d6 0E94 0000 		call filtruj_i_dodaj_komende
 6571               	.LVL509:
 6572               	.L668:
 6573               	.LBE609:
1344:main_sim900.h ****             KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE);
1345:main_sim900.h ****     }
1346:main_sim900.h ****   }
1347:main_sim900.h **** 
1348:main_sim900.h ****   if (opoznienie_zatrzymaj_odpytywanie_urzadzenia)
 6574               		.loc 2 1348 0
 6575 22da 8091 0000 		lds r24,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6576 22de 8823      		tst r24
 6577 22e0 01F0      		breq .L674
1349:main_sim900.h ****     --opoznienie_zatrzymaj_odpytywanie_urzadzenia;
 6578               		.loc 2 1349 0
 6579 22e2 8150      		subi r24,lo8(-(-1))
 6580 22e4 8093 0000 		sts opoznienie_zatrzymaj_odpytywanie_urzadzenia,r24
 6581               	.L674:
1350:main_sim900.h **** 
1351:main_sim900.h ****   if (modul_zalogowany_w_sieci &&
 6582               		.loc 2 1351 0
 6583 22e8 8091 0000 		lds r24,modul_zalogowany_w_sieci
 6584 22ec 8823      		tst r24
 6585 22ee 01F4      		brne .+2
 6586 22f0 00C0      		rjmp .L675
1352:main_sim900.h ****       (poziom_sieci_gsm == POZIOM_SIECI_BLAD || poziom_sieci_gsm == 0)) {
 6587               		.loc 2 1352 0 discriminator 1
 6588 22f2 8091 0000 		lds r24,poziom_sieci_gsm
1351:main_sim900.h ****       (poziom_sieci_gsm == POZIOM_SIECI_BLAD || poziom_sieci_gsm == 0)) {
 6589               		.loc 2 1351 0 discriminator 1
 6590 22f6 8336      		cpi r24,lo8(99)
 6591 22f8 01F0      		breq .L676
 6592               		.loc 2 1352 0
 6593 22fa 8111      		cpse r24,__zero_reg__
 6594 22fc 00C0      		rjmp .L675
 6595               	.L676:
1353:main_sim900.h ****     if (licznik_awaria_brak_zasiegu < MAX_LICZNIK_AWARIA_BRAK_ZASIEGU) {
 6596               		.loc 2 1353 0
 6597 22fe 8091 0000 		lds r24,licznik_awaria_brak_zasiegu
 6598 2302 9091 0000 		lds r25,licznik_awaria_brak_zasiegu+1
 6599 2306 8835      		cpi r24,88
 6600 2308 22E0      		ldi r18,2
 6601 230a 9207      		cpc r25,r18
 6602 230c 00F4      		brsh .L678
1354:main_sim900.h ****       if (++licznik_awaria_brak_zasiegu == MAX_LICZNIK_AWARIA_BRAK_ZASIEGU) {
 6603               		.loc 2 1354 0
 6604 230e 0196      		adiw r24,1
 6605 2310 8835      		cpi r24,88
 6606 2312 22E0      		ldi r18,2
 6607 2314 9207      		cpc r25,r18
 6608 2316 01F4      		brne .+2
 6609 2318 00C0      		rjmp .L679
 6610 231a 9093 0000 		sts licznik_awaria_brak_zasiegu+1,r25
 6611 231e 8093 0000 		sts licznik_awaria_brak_zasiegu,r24
 6612               	.L678:
1355:main_sim900.h ****         licznik_awaria_brak_zasiegu = 0;
1356:main_sim900.h ****         POMOC_DODAJ2('*', 'j');
1357:main_sim900.h ****         reset_modulu_SIM900();
1358:main_sim900.h ****       }
1359:main_sim900.h ****     }
1360:main_sim900.h ****   } else
1361:main_sim900.h ****     licznik_awaria_brak_zasiegu = 0;
1362:main_sim900.h **** 
1363:main_sim900.h ****   if (CZY_BLAD_KARTY_SIM() || CZY_BLAD_ZALOGOWANIA_U_OPERATORA()) {
 6613               		.loc 2 1363 0
 6614 2322 8091 0000 		lds r24,licznik_blad_stanu_karty_SIM
 6615 2326 8630      		cpi r24,lo8(6)
 6616 2328 00F4      		brsh .L681
 6617               		.loc 2 1363 0 is_stmt 0 discriminator 1
 6618 232a 8091 0000 		lds r24,licznik_blad_zalogowania_u_operatora
 6619 232e 8431      		cpi r24,lo8(20)
 6620 2330 00F0      		brlo .L682
 6621               	.L681:
 6622               	.LVL510:
1364:main_sim900.h ****     POMOC_DODAJ2('*', 'k');
1365:main_sim900.h ****     reset_modulu_SIM900();
 6623               		.loc 2 1365 0 is_stmt 1
 6624 2332 0E94 0000 		call reset_modulu_SIM900
 6625               	.LVL511:
 6626               	.L682:
1366:main_sim900.h ****   }
1367:main_sim900.h **** #endif
1368:main_sim900.h **** 
1369:main_sim900.h ****   if (licznik_reset_modulu_SIM900) {
 6627               		.loc 2 1369 0
 6628 2336 8091 0000 		lds r24,licznik_reset_modulu_SIM900
 6629 233a 8823      		tst r24
 6630 233c 01F0      		breq .L684
1370:main_sim900.h ****     if (--licznik_reset_modulu_SIM900 == 0) {
 6631               		.loc 2 1370 0
 6632 233e 8150      		subi r24,lo8(-(-1))
 6633 2340 8093 0000 		sts licznik_reset_modulu_SIM900,r24
 6634 2344 8111      		cpse r24,__zero_reg__
 6635 2346 00C0      		rjmp .L684
 6636               	.LVL512:
1371:main_sim900.h ****       POMOC_DODAJ2('*', 'l');
1372:main_sim900.h ****       reset_modulu_SIM900();
 6637               		.loc 2 1372 0
 6638 2348 0E94 0000 		call reset_modulu_SIM900
 6639               	.LVL513:
 6640               	.L684:
1373:main_sim900.h ****     }
1374:main_sim900.h ****   }
1375:main_sim900.h **** 
1376:main_sim900.h ****   if (!modul_zalogowany_w_sieci) {
 6641               		.loc 2 1376 0
 6642 234c 8091 0000 		lds r24,modul_zalogowany_w_sieci
 6643 2350 8111      		cpse r24,__zero_reg__
 6644 2352 00C0      		rjmp .L686
1377:main_sim900.h ****     if (++licznik_ogolny_blad_zalogowania > MAX_LICZNIK_OGOLNY_BLAD_ZALOGOWANIA)
 6645               		.loc 2 1377 0
 6646 2354 8091 0000 		lds r24,licznik_ogolny_blad_zalogowania
 6647 2358 9091 0000 		lds r25,licznik_ogolny_blad_zalogowania+1
 6648 235c 0196      		adiw r24,1
 6649 235e 9093 0000 		sts licznik_ogolny_blad_zalogowania+1,r25
 6650 2362 8093 0000 		sts licznik_ogolny_blad_zalogowania,r24
 6651 2366 813B      		cpi r24,-79
 6652 2368 9440      		sbci r25,4
 6653 236a 00F0      		brlo .L649
1378:main_sim900.h ****       reset_modulu_SIM900();
 6654               		.loc 2 1378 0
 6655 236c 0C94 0000 		jmp reset_modulu_SIM900
 6656               	.LVL514:
 6657               	.L667:
 6658               	.LBB610:
1334:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_ZAREJESTROWANIE);
 6659               		.loc 2 1334 0
 6660 2370 8433      		cpi r24,lo8(52)
 6661 2372 01F4      		brne .L669
1335:main_sim900.h ****     else if (licznik_cyklu_8_sek == 56)
 6662               		.loc 2 1335 0
 6663 2374 8CE9      		ldi r24,lo8(-100)
 6664 2376 00C0      		rjmp .L709
 6665               	.L669:
1336:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_ZALOGOWANIE_U_OPERATORA);
 6666               		.loc 2 1336 0
 6667 2378 8833      		cpi r24,lo8(56)
 6668 237a 01F4      		brne .L670
1337:main_sim900.h ****     else if (licznik_cyklu_8_sek == 60) {
 6669               		.loc 2 1337 0
 6670 237c 89E9      		ldi r24,lo8(-103)
 6671 237e 00C0      		rjmp .L709
 6672               	.L670:
1338:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_STAN_KARTY_SIM);
 6673               		.loc 2 1338 0
 6674 2380 8C33      		cpi r24,lo8(60)
 6675 2382 01F4      		brne .L671
1339:main_sim900.h ****     } else if (licznik_cyklu_8_sek >= 80) {
 6676               		.loc 2 1339 0
 6677 2384 88E9      		ldi r24,lo8(-104)
 6678 2386 00C0      		rjmp .L709
 6679               	.L671:
1340:main_sim900.h ****       licznik_cyklu_8_sek = 0;
 6680               		.loc 2 1340 0
 6681 2388 8035      		cpi r24,lo8(80)
 6682 238a 00F4      		brsh .+2
 6683 238c 00C0      		rjmp .L668
 6684 238e 8091 0000 		lds r24,modul_zalogowany_w_sieci
1341:main_sim900.h ****       if (modul_zalogowany_w_sieci)
 6685               		.loc 2 1341 0
 6686 2392 1092 0000 		sts licznik_cyklu_8_sek.3471,__zero_reg__
1342:main_sim900.h ****         filtruj_i_dodaj_komende(
 6687               		.loc 2 1342 0
 6688 2396 8823      		tst r24
 6689 2398 01F4      		brne .+2
 6690 239a 00C0      		rjmp .L668
1343:main_sim900.h ****             KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE);
 6691               		.loc 2 1343 0
 6692 239c 8DE9      		ldi r24,lo8(-99)
 6693 239e 00C0      		rjmp .L709
 6694               	.L679:
 6695               	.LBE610:
1355:main_sim900.h ****         POMOC_DODAJ2('*', 'j');
 6696               		.loc 2 1355 0
 6697 23a0 1092 0000 		sts licznik_awaria_brak_zasiegu+1,__zero_reg__
 6698 23a4 1092 0000 		sts licznik_awaria_brak_zasiegu,__zero_reg__
 6699               	.LVL515:
1357:main_sim900.h ****       }
 6700               		.loc 2 1357 0
 6701 23a8 0E94 0000 		call reset_modulu_SIM900
 6702               	.LVL516:
 6703 23ac 00C0      		rjmp .L678
 6704               	.LVL517:
 6705               	.L675:
1361:main_sim900.h **** 
 6706               		.loc 2 1361 0
 6707 23ae 1092 0000 		sts licznik_awaria_brak_zasiegu+1,__zero_reg__
 6708 23b2 1092 0000 		sts licznik_awaria_brak_zasiegu,__zero_reg__
 6709 23b6 00C0      		rjmp .L678
 6710               	.L686:
1379:main_sim900.h ****   } else
1380:main_sim900.h ****     licznik_ogolny_blad_zalogowania = 0;
 6711               		.loc 2 1380 0
 6712 23b8 1092 0000 		sts licznik_ogolny_blad_zalogowania+1,__zero_reg__
 6713 23bc 1092 0000 		sts licznik_ogolny_blad_zalogowania,__zero_reg__
 6714               	.L649:
 6715               	/* epilogue start */
1381:main_sim900.h **** }
 6716               		.loc 2 1381 0
 6717 23c0 0895      		ret
 6718               		.cfi_endproc
 6719               	.LFE54:
 6721               	.global	steruj_SIM900_10MS
 6723               	steruj_SIM900_10MS:
 6724               	.LFB55:
1382:main_sim900.h **** 
1383:main_sim900.h **** void steruj_SIM900_10MS(void) {
 6725               		.loc 2 1383 0
 6726               		.cfi_startproc
 6727               	/* prologue: function */
 6728               	/* frame size = 0 */
 6729               	/* stack size = 0 */
 6730               	.L__stack_usage = 0
1384:main_sim900.h ****   if (czy_jest_komenda_SIM900())
 6731               		.loc 2 1384 0
 6732 23c2 8091 0000 		lds r24,komenda_SIM900
 6733 23c6 8823      		tst r24
 6734 23c8 01F4      		brne .+2
 6735 23ca 00C0      		rjmp .L711
 6736               	.L713:
1385:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_KOMENDA_SIM900);
 6737               		.loc 2 1385 0
 6738 23cc 89E8      		ldi r24,lo8(-119)
 6739 23ce 0E94 0000 		call dodaj_komende
 6740               	.LVL518:
 6741               	.L712:
1386:main_sim900.h **** 
1387:main_sim900.h ****   if (flaga_odebrany_znak_zachety) {
 6742               		.loc 2 1387 0
 6743 23d2 8091 0000 		lds r24,flaga_odebrany_znak_zachety
 6744 23d6 8823      		tst r24
 6745 23d8 01F0      		breq .L714
1388:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_PDU);
 6746               		.loc 2 1388 0
 6747 23da 84ED      		ldi r24,lo8(-44)
 6748 23dc 0E94 0000 		call dodaj_komende
 6749               	.LVL519:
1389:main_sim900.h ****     // czekanie_na_odebranie_zachety = FALSE;	// byo
1390:main_sim900.h ****     flaga_odebrany_znak_zachety = FALSE;
 6750               		.loc 2 1390 0
 6751 23e0 1092 0000 		sts flaga_odebrany_znak_zachety,__zero_reg__
 6752               	.LVL520:
 6753               	.L714:
 6754               	.LBB611:
1391:main_sim900.h ****     POMOC_DODAJ2('#', 'm');
1392:main_sim900.h ****   }
1393:main_sim900.h **** 
1394:main_sim900.h ****   { // kontrola wysyania sms-w i clipw
1395:main_sim900.h ****     static uint licznik_bezpieczenstwa = 0;
1396:main_sim900.h ****     if (modul_zalogowany_w_sieci && flaga_wysylanie_smsa) {
 6755               		.loc 2 1396 0
 6756 23e4 8091 0000 		lds r24,modul_zalogowany_w_sieci
 6757 23e8 8823      		tst r24
 6758 23ea 01F4      		brne .+2
 6759 23ec 00C0      		rjmp .L715
 6760               		.loc 2 1396 0 is_stmt 0 discriminator 1
 6761 23ee 8091 0000 		lds r24,flaga_wysylanie_smsa
 6762 23f2 8823      		tst r24
 6763 23f4 01F4      		brne .+2
 6764 23f6 00C0      		rjmp .L715
1397:main_sim900.h ****       if (++licznik_bezpieczenstwa >= 5000) // 50 sek
 6765               		.loc 2 1397 0 is_stmt 1
 6766 23f8 8091 0000 		lds r24,licznik_bezpieczenstwa.3475
 6767 23fc 9091 0000 		lds r25,licznik_bezpieczenstwa.3475+1
 6768 2400 0196      		adiw r24,1
 6769 2402 8838      		cpi r24,-120
 6770 2404 23E1      		ldi r18,19
 6771 2406 9207      		cpc r25,r18
 6772 2408 00F0      		brlo .+2
 6773 240a 00C0      		rjmp .L716
 6774 240c 9093 0000 		sts licznik_bezpieczenstwa.3475+1,r25
 6775 2410 8093 0000 		sts licznik_bezpieczenstwa.3475,r24
 6776               	.L717:
 6777               	.LBE611:
 6778               	.LBB612:
1398:main_sim900.h ****       {
1399:main_sim900.h ****         POMOC_DODAJ2('#', 'Z');
1400:main_sim900.h ****         licznik_bezpieczenstwa = 0;
1401:main_sim900.h ****         komenda_SIM900 = ERROR_KOMENDA_SIM900;
1402:main_sim900.h ****         obsluga_wysylania_sms();
1403:main_sim900.h ****       }
1404:main_sim900.h ****     } else
1405:main_sim900.h ****       licznik_bezpieczenstwa = 0;
1406:main_sim900.h ****   }
1407:main_sim900.h **** 
1408:main_sim900.h ****   { // kontrola programu: zbyt dugi okres wykonywania polecenia do SIM900 lub
1409:main_sim900.h ****     // jego brak
1410:main_sim900.h ****     static komenda_typ poprzednia_komenda;
1411:main_sim900.h ****     static uint licznik_poprzednia_komenda;
1412:main_sim900.h ****     static uint licznik_odebranych_znakow;
1413:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY &&
 6779               		.loc 2 1413 0
 6780 2414 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 6781 2418 9091 0000 		lds r25,trwa_rozmowa_przychodzaca_od_uzytkownika
 6782 241c 8823      		tst r24
 6783 241e 01F4      		brne .+2
 6784 2420 00C0      		rjmp .L718
 6785               		.loc 2 1413 0 is_stmt 0 discriminator 1
 6786 2422 2091 0000 		lds r18,poprzednia_komenda.3476
 6787 2426 8213      		cpse r24,r18
 6788 2428 00C0      		rjmp .L719
1414:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 == poprzednia_komenda &&
 6789               		.loc 2 1414 0 is_stmt 1
 6790 242a 9111      		cpse r25,__zero_reg__
 6791 242c 00C0      		rjmp .L720
 6792               	.LVL521:
 6793               	.LBB613:
1415:main_sim900.h ****         !trwa_rozmowa_przychodzaca_od_uzytkownika) {
1416:main_sim900.h ****       uint max_licznik_poprzednia_komenda = 5 * 100; // 5 sek;
1417:main_sim900.h ****       if (aktualnie_wysylane_polecenie_SIM900 ==
 6794               		.loc 2 1417 0
 6795 242e 8B38      		cpi r24,lo8(-117)
 6796 2430 01F0      		breq .L734
1418:main_sim900.h ****               KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT ||
 6797               		.loc 2 1418 0
 6798 2432 9CE2      		ldi r25,lo8(44)
 6799 2434 980F      		add r25,r24
1416:main_sim900.h ****       if (aktualnie_wysylane_polecenie_SIM900 ==
 6800               		.loc 2 1416 0
 6801 2436 44EF      		ldi r20,lo8(-12)
 6802 2438 51E0      		ldi r21,lo8(1)
 6803               		.loc 2 1418 0
 6804 243a 9230      		cpi r25,lo8(2)
 6805 243c 00F4      		brsh .L721
 6806               	.L734:
1419:main_sim900.h ****           aktualnie_wysylane_polecenie_SIM900 == KOMENDA_KOLEJKI_WYSLIJ_PDU ||
1420:main_sim900.h ****           aktualnie_wysylane_polecenie_SIM900 ==
1421:main_sim900.h ****               KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE)
1422:main_sim900.h ****         max_licznik_poprzednia_komenda = 2 * 60 * 100; // 2 minuty
 6807               		.loc 2 1422 0
 6808 243e 40EE      		ldi r20,lo8(-32)
 6809 2440 5EE2      		ldi r21,lo8(46)
 6810               	.L721:
 6811               	.LVL522:
1423:main_sim900.h **** 
1424:main_sim900.h ****       if (aktualnie_wysylane_polecenie_SIM900 ==
1425:main_sim900.h ****               KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT // zmienione (1)
1426:main_sim900.h ****           || aktualnie_wysylane_polecenie_SIM900 ==
 6812               		.loc 2 1426 0
 6813 2442 9EE2      		ldi r25,lo8(46)
 6814 2444 980F      		add r25,r24
1424:main_sim900.h ****               KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT // zmienione (1)
 6815               		.loc 2 1424 0
 6816 2446 9230      		cpi r25,lo8(2)
 6817 2448 00F4      		brsh .L722
1427:main_sim900.h ****                  KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
1428:main_sim900.h ****         max_licznik_poprzednia_komenda = 15 * 100;
 6818               		.loc 2 1428 0
 6819 244a 4CED      		ldi r20,lo8(-36)
 6820 244c 55E0      		ldi r21,lo8(5)
 6821               	.LVL523:
 6822               	.L722:
1429:main_sim900.h **** 
1430:main_sim900.h ****       if (++licznik_poprzednia_komenda >= max_licznik_poprzednia_komenda) {
 6823               		.loc 2 1430 0
 6824 244e 2091 0000 		lds r18,licznik_poprzednia_komenda.3477
 6825 2452 3091 0000 		lds r19,licznik_poprzednia_komenda.3477+1
 6826 2456 2F5F      		subi r18,-1
 6827 2458 3F4F      		sbci r19,-1
 6828 245a 2417      		cp r18,r20
 6829 245c 3507      		cpc r19,r21
 6830 245e 00F4      		brsh .L723
 6831 2460 3093 0000 		sts licznik_poprzednia_komenda.3477+1,r19
 6832 2464 2093 0000 		sts licznik_poprzednia_komenda.3477,r18
 6833               	.LVL524:
 6834               	.L724:
1431:main_sim900.h ****         licznik_poprzednia_komenda = 0;
1432:main_sim900.h ****         POMOC_DODAJ2('#', 'r');
1433:main_sim900.h ****         POMOC_DODAJ_HEX(aktualnie_wysylane_polecenie_SIM900 >> 8);
1434:main_sim900.h ****         POMOC_DODAJ_HEX(aktualnie_wysylane_polecenie_SIM900);
1435:main_sim900.h ****         if (aktualnie_wysylane_polecenie_SIM900 !=
1436:main_sim900.h ****             KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1) {
1437:main_sim900.h ****           if (aktualnie_wysylane_polecenie_SIM900 ==
1438:main_sim900.h ****                   KOMENDA_KOLEJKI_ODRZUC_ROZMOWE ||
1439:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
1440:main_sim900.h ****                   KOMENDA_KOLEJKI_PODAJ_PIN ||
1441:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
1442:main_sim900.h ****                   KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW ||
1443:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
1444:main_sim900.h ****                   KOMENDA_KOLEJKI_USTAW_WZMOCNIENIE_MIKROFONU ||
1445:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
1446:main_sim900.h ****                   KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS ||
1447:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
1448:main_sim900.h ****                    KOMENDA_KOLEJKI_SPRAWDZ_PIN &&
1449:main_sim900.h ****                aktualnie_wysylane_polecenie_SIM900 <=
1450:main_sim900.h ****                    KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ) ||
1451:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
1452:main_sim900.h ****                    KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
1453:main_sim900.h ****                aktualnie_wysylane_polecenie_SIM900 <=
1454:main_sim900.h ****                    KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) ||
1455:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
1456:main_sim900.h ****                    KOMENDA_KOLEJKI_USUN_SMSA_1 &&
1457:main_sim900.h ****                aktualnie_wysylane_polecenie_SIM900 <=
1458:main_sim900.h ****                    KOMENDA_KOLEJKI_USUN_SMSA_20)) {
1459:main_sim900.h ****             nastepne_wysylane_polecenie_SIM900 =
1460:main_sim900.h ****                 aktualnie_wysylane_polecenie_SIM900;
1461:main_sim900.h ****           } else
1462:main_sim900.h ****             nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
1463:main_sim900.h ****           wyzerowanie_danych_SIM900();
1464:main_sim900.h ****           wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1;
1465:main_sim900.h ****           wysylane_dane_RAM_SIM900[0] = '\0';
1466:main_sim900.h ****           wyslij_polecenie_RAM_SIM900();
1467:main_sim900.h ****         } else
1468:main_sim900.h ****           reset_modulu_SIM900();
1469:main_sim900.h ****       }
1470:main_sim900.h ****       licznik_odebranych_znakow = 0;
 6835               		.loc 2 1470 0
 6836 2468 1092 0000 		sts licznik_odebranych_znakow.3478+1,__zero_reg__
 6837 246c 1092 0000 		sts licznik_odebranych_znakow.3478,__zero_reg__
 6838               	.L728:
 6839               	.LBE613:
1471:main_sim900.h ****     } else if (aktualnie_wysylane_polecenie_SIM900 !=
1472:main_sim900.h ****                    KOMENDA_KOLEJKI_BRAK_KOMENDY &&
1473:main_sim900.h ****                trwa_rozmowa_przychodzaca_od_uzytkownika &&
1474:main_sim900.h ****                czy_jest_bezczynny_SIM900()) {
1475:main_sim900.h ****       {
1476:main_sim900.h ****         cli();
1477:main_sim900.h ****         const uint l = liczba_odebranych_znakow_SIM900;
1478:main_sim900.h ****         sei();
1479:main_sim900.h ****         if (licznik_odebranych_znakow < l)
1480:main_sim900.h ****           licznik_odebranych_znakow = l;
1481:main_sim900.h ****       }
1482:main_sim900.h ****       if (licznik_odebranych_znakow >=
1483:main_sim900.h ****           MIN_LICZBA_ODEBRANYCH_ZNAKOW_KONCZACYCH_ROZMOWE_W_TRAKCIE_PODSLUCHU) {
1484:main_sim900.h ****         if (++licznik_poprzednia_komenda >= 5 * 100) // 5 sek
1485:main_sim900.h ****         {
1486:main_sim900.h ****           licznik_poprzednia_komenda = 0;
1487:main_sim900.h ****           zakonczono_rozmowe_telefoniczna(
1488:main_sim900.h ****               powod_zakonczenia_rozmowy_zakonczenie);
1489:main_sim900.h ****           licznik_odebranych_znakow = 0;
1490:main_sim900.h ****           POMOC_DODAJ2('#', 'q');
1491:main_sim900.h ****           reset_modulu_SIM900();
1492:main_sim900.h ****         }
1493:main_sim900.h ****       }
1494:main_sim900.h ****     } else {
1495:main_sim900.h ****       licznik_poprzednia_komenda = 0;
1496:main_sim900.h ****       if (!trwa_rozmowa_przychodzaca_od_uzytkownika)
1497:main_sim900.h ****         licznik_odebranych_znakow = 0;
1498:main_sim900.h ****     }
1499:main_sim900.h **** 
1500:main_sim900.h ****     poprzednia_komenda = aktualnie_wysylane_polecenie_SIM900;
 6840               		.loc 2 1500 0
 6841 2470 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 6842 2474 8093 0000 		sts poprzednia_komenda.3476,r24
 6843               	/* epilogue start */
 6844               	.LBE612:
1501:main_sim900.h ****   }
1502:main_sim900.h **** }
 6845               		.loc 2 1502 0
 6846 2478 0895      		ret
 6847               	.L711:
1384:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_KOMENDA_SIM900);
 6848               		.loc 2 1384 0 discriminator 1
 6849 247a 0E94 0000 		call czy_jest_nowa_komenda_SIM900
 6850               	.LVL525:
 6851 247e 8111      		cpse r24,__zero_reg__
 6852 2480 00C0      		rjmp .L713
 6853 2482 00C0      		rjmp .L712
 6854               	.L716:
 6855               	.LVL526:
 6856               	.LBB616:
1400:main_sim900.h ****         komenda_SIM900 = ERROR_KOMENDA_SIM900;
 6857               		.loc 2 1400 0
 6858 2484 1092 0000 		sts licznik_bezpieczenstwa.3475+1,__zero_reg__
 6859 2488 1092 0000 		sts licznik_bezpieczenstwa.3475,__zero_reg__
1401:main_sim900.h ****         obsluga_wysylania_sms();
 6860               		.loc 2 1401 0
 6861 248c 84E0      		ldi r24,lo8(4)
 6862 248e 8093 0000 		sts komenda_SIM900,r24
1402:main_sim900.h ****       }
 6863               		.loc 2 1402 0
 6864 2492 0E94 0000 		call obsluga_wysylania_sms
 6865               	.LVL527:
 6866 2496 00C0      		rjmp .L717
 6867               	.LVL528:
 6868               	.L715:
1405:main_sim900.h ****   }
 6869               		.loc 2 1405 0
 6870 2498 1092 0000 		sts licznik_bezpieczenstwa.3475+1,__zero_reg__
 6871 249c 1092 0000 		sts licznik_bezpieczenstwa.3475,__zero_reg__
 6872 24a0 00C0      		rjmp .L717
 6873               	.LVL529:
 6874               	.L723:
 6875               	.LBE616:
 6876               	.LBB617:
 6877               	.LBB614:
1431:main_sim900.h ****         POMOC_DODAJ2('#', 'r');
 6878               		.loc 2 1431 0
 6879 24a2 1092 0000 		sts licznik_poprzednia_komenda.3477+1,__zero_reg__
 6880 24a6 1092 0000 		sts licznik_poprzednia_komenda.3477,__zero_reg__
 6881               	.LVL530:
1435:main_sim900.h ****             KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1) {
 6882               		.loc 2 1435 0
 6883 24aa 8C3F      		cpi r24,lo8(-4)
 6884 24ac 01F0      		breq .L725
1437:main_sim900.h ****                   KOMENDA_KOLEJKI_ODRZUC_ROZMOWE ||
 6885               		.loc 2 1437 0
 6886 24ae 8639      		cpi r24,lo8(-106)
 6887 24b0 01F0      		breq .L726
1438:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
 6888               		.loc 2 1438 0
 6889 24b2 93E7      		ldi r25,lo8(115)
 6890 24b4 980F      		add r25,r24
 6891 24b6 9230      		cpi r25,lo8(2)
 6892 24b8 00F0      		brlo .L726
1442:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
 6893               		.loc 2 1442 0
 6894 24ba 9DE6      		ldi r25,lo8(109)
 6895 24bc 980F      		add r25,r24
 6896 24be 9230      		cpi r25,lo8(2)
 6897 24c0 00F0      		brlo .L726
1448:main_sim900.h ****                aktualnie_wysylane_polecenie_SIM900 <=
 6898               		.loc 2 1448 0
 6899 24c2 92E6      		ldi r25,lo8(98)
 6900 24c4 980F      		add r25,r24
1446:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
 6901               		.loc 2 1446 0
 6902 24c6 9A30      		cpi r25,lo8(10)
 6903 24c8 00F0      		brlo .L726
1450:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
 6904               		.loc 2 1450 0
 6905 24ca 97E5      		ldi r25,lo8(87)
 6906 24cc 980F      		add r25,r24
 6907 24ce 9832      		cpi r25,lo8(40)
 6908 24d0 00F0      		brlo .L726
1462:main_sim900.h ****           wyzerowanie_danych_SIM900();
 6909               		.loc 2 1462 0
 6910 24d2 1092 0000 		sts nastepne_wysylane_polecenie_SIM900,__zero_reg__
 6911               	.L727:
1463:main_sim900.h ****           wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1;
 6912               		.loc 2 1463 0
 6913 24d6 0E94 0000 		call wyzerowanie_danych_SIM900
 6914               	.LVL531:
1464:main_sim900.h ****           wysylane_dane_RAM_SIM900[0] = '\0';
 6915               		.loc 2 1464 0
 6916 24da 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6917 24de 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6918 24e2 8CEF      		ldi r24,lo8(-4)
 6919 24e4 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1465:main_sim900.h ****           wyslij_polecenie_RAM_SIM900();
 6920               		.loc 2 1465 0
 6921 24e8 1092 0000 		sts wysylany_blok_SIM900+2,__zero_reg__
1466:main_sim900.h ****         } else
 6922               		.loc 2 1466 0
 6923 24ec 0E94 0000 		call wyslij_polecenie_RAM_SIM900
 6924               	.LVL532:
 6925 24f0 00C0      		rjmp .L724
 6926               	.LVL533:
 6927               	.L726:
1459:main_sim900.h ****                 aktualnie_wysylane_polecenie_SIM900;
 6928               		.loc 2 1459 0
 6929 24f2 8093 0000 		sts nastepne_wysylane_polecenie_SIM900,r24
 6930 24f6 00C0      		rjmp .L727
 6931               	.L725:
1468:main_sim900.h ****       }
 6932               		.loc 2 1468 0
 6933 24f8 0E94 0000 		call reset_modulu_SIM900
 6934               	.LVL534:
 6935 24fc 00C0      		rjmp .L724
 6936               	.LVL535:
 6937               	.L719:
 6938               	.LBE614:
1472:main_sim900.h ****                trwa_rozmowa_przychodzaca_od_uzytkownika &&
 6939               		.loc 2 1472 0
 6940 24fe 9923      		tst r25
 6941 2500 01F0      		breq .L718
 6942               	.L720:
1474:main_sim900.h ****       {
 6943               		.loc 2 1474 0
 6944 2502 8091 0000 		lds r24,komenda_SIM900
1473:main_sim900.h ****                czy_jest_bezczynny_SIM900()) {
 6945               		.loc 2 1473 0
 6946 2506 8111      		cpse r24,__zero_reg__
 6947 2508 00C0      		rjmp .L718
 6948               	.LBB615:
1476:main_sim900.h ****         const uint l = liczba_odebranych_znakow_SIM900;
 6949               		.loc 2 1476 0
 6950               	/* #APP */
 6951               	 ;  1476 "main_sim900.h" 1
 6952 250a F894      		cli
 6953               	 ;  0 "" 2
1477:main_sim900.h ****         sei();
 6954               		.loc 2 1477 0
 6955               	/* #NOAPP */
 6956 250c 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 6957 2510 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
 6958               	.LVL536:
1478:main_sim900.h ****         if (licznik_odebranych_znakow < l)
 6959               		.loc 2 1478 0
 6960               	/* #APP */
 6961               	 ;  1478 "main_sim900.h" 1
 6962 2514 7894      		sei
 6963               	 ;  0 "" 2
1479:main_sim900.h ****           licznik_odebranych_znakow = l;
 6964               		.loc 2 1479 0
 6965               	/* #NOAPP */
 6966 2516 2091 0000 		lds r18,licznik_odebranych_znakow.3478
 6967 251a 3091 0000 		lds r19,licznik_odebranych_znakow.3478+1
 6968 251e 2817      		cp r18,r24
 6969 2520 3907      		cpc r19,r25
 6970 2522 00F4      		brsh .L729
1480:main_sim900.h ****       }
 6971               		.loc 2 1480 0
 6972 2524 9093 0000 		sts licznik_odebranych_znakow.3478+1,r25
 6973 2528 8093 0000 		sts licznik_odebranych_znakow.3478,r24
 6974               	.L729:
 6975               	.LBE615:
1482:main_sim900.h ****           MIN_LICZBA_ODEBRANYCH_ZNAKOW_KONCZACYCH_ROZMOWE_W_TRAKCIE_PODSLUCHU) {
 6976               		.loc 2 1482 0
 6977 252c 8091 0000 		lds r24,licznik_odebranych_znakow.3478
 6978 2530 9091 0000 		lds r25,licznik_odebranych_znakow.3478+1
 6979               	.LVL537:
 6980 2534 0A97      		sbiw r24,10
 6981 2536 00F4      		brsh .+2
 6982 2538 00C0      		rjmp .L728
1484:main_sim900.h ****         {
 6983               		.loc 2 1484 0
 6984 253a 8091 0000 		lds r24,licznik_poprzednia_komenda.3477
 6985 253e 9091 0000 		lds r25,licznik_poprzednia_komenda.3477+1
 6986 2542 0196      		adiw r24,1
 6987 2544 843F      		cpi r24,-12
 6988 2546 21E0      		ldi r18,1
 6989 2548 9207      		cpc r25,r18
 6990 254a 00F4      		brsh .L731
 6991 254c 9093 0000 		sts licznik_poprzednia_komenda.3477+1,r25
 6992 2550 8093 0000 		sts licznik_poprzednia_komenda.3477,r24
 6993 2554 00C0      		rjmp .L728
 6994               	.L731:
1486:main_sim900.h ****           zakonczono_rozmowe_telefoniczna(
 6995               		.loc 2 1486 0
 6996 2556 1092 0000 		sts licznik_poprzednia_komenda.3477+1,__zero_reg__
 6997 255a 1092 0000 		sts licznik_poprzednia_komenda.3477,__zero_reg__
1487:main_sim900.h ****               powod_zakonczenia_rozmowy_zakonczenie);
 6998               		.loc 2 1487 0
 6999 255e 81E0      		ldi r24,lo8(1)
 7000 2560 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 7001               	.LVL538:
1489:main_sim900.h ****           POMOC_DODAJ2('#', 'q');
 7002               		.loc 2 1489 0
 7003 2564 1092 0000 		sts licznik_odebranych_znakow.3478+1,__zero_reg__
 7004 2568 1092 0000 		sts licznik_odebranych_znakow.3478,__zero_reg__
 7005               	.LVL539:
1491:main_sim900.h ****         }
 7006               		.loc 2 1491 0
 7007 256c 0E94 0000 		call reset_modulu_SIM900
 7008               	.LVL540:
 7009 2570 00C0      		rjmp .L728
 7010               	.LVL541:
 7011               	.L718:
1495:main_sim900.h ****       if (!trwa_rozmowa_przychodzaca_od_uzytkownika)
 7012               		.loc 2 1495 0
 7013 2572 1092 0000 		sts licznik_poprzednia_komenda.3477+1,__zero_reg__
 7014 2576 1092 0000 		sts licznik_poprzednia_komenda.3477,__zero_reg__
1496:main_sim900.h ****         licznik_odebranych_znakow = 0;
 7015               		.loc 2 1496 0
 7016 257a 9923      		tst r25
 7017 257c 01F4      		brne .+2
 7018 257e 00C0      		rjmp .L724
 7019 2580 00C0      		rjmp .L728
 7020               	.LBE617:
 7021               		.cfi_endproc
 7022               	.LFE55:
 7024               	.global	wykonanie_komend_powiadomien
 7026               	wykonanie_komend_powiadomien:
 7027               	.LFB59:
1275:main.c        ****   const komenda_typ aktualnie_wykonywana_komenda = komendy_kolejka[0];
 7028               		.loc 1 1275 0
 7029               		.cfi_startproc
 7030 2582 BF92      		push r11
 7031               	.LCFI76:
 7032               		.cfi_def_cfa_offset 3
 7033               		.cfi_offset 11, -2
 7034 2584 CF92      		push r12
 7035               	.LCFI77:
 7036               		.cfi_def_cfa_offset 4
 7037               		.cfi_offset 12, -3
 7038 2586 DF92      		push r13
 7039               	.LCFI78:
 7040               		.cfi_def_cfa_offset 5
 7041               		.cfi_offset 13, -4
 7042 2588 EF92      		push r14
 7043               	.LCFI79:
 7044               		.cfi_def_cfa_offset 6
 7045               		.cfi_offset 14, -5
 7046 258a FF92      		push r15
 7047               	.LCFI80:
 7048               		.cfi_def_cfa_offset 7
 7049               		.cfi_offset 15, -6
 7050 258c 0F93      		push r16
 7051               	.LCFI81:
 7052               		.cfi_def_cfa_offset 8
 7053               		.cfi_offset 16, -7
 7054 258e 1F93      		push r17
 7055               	.LCFI82:
 7056               		.cfi_def_cfa_offset 9
 7057               		.cfi_offset 17, -8
 7058 2590 CF93      		push r28
 7059               	.LCFI83:
 7060               		.cfi_def_cfa_offset 10
 7061               		.cfi_offset 28, -9
 7062 2592 DF93      		push r29
 7063               	.LCFI84:
 7064               		.cfi_def_cfa_offset 11
 7065               		.cfi_offset 29, -10
 7066               	/* prologue: function */
 7067               	/* frame size = 0 */
 7068               	/* stack size = 9 */
 7069               	.L__stack_usage = 9
1276:main.c        **** 
 7070               		.loc 1 1276 0
 7071 2594 8091 0000 		lds r24,komendy_kolejka
 7072               	.LVL542:
1283:main.c        **** 
 7073               		.loc 1 1283 0
 7074 2598 9091 0000 		lds r25,flaga_odczytywanie_smsa
 7075 259c 9111      		cpse r25,__zero_reg__
 7076 259e 00C0      		rjmp .L760
1279:main.c        ****       wykonywanie_rozmowy_telefonicznej ||
 7077               		.loc 1 1279 0
 7078 25a0 9091 0000 		lds r25,flaga_wysylanie_smsa
 7079 25a4 9111      		cpse r25,__zero_reg__
 7080 25a6 00C0      		rjmp .L760
1279:main.c        ****       wykonywanie_rozmowy_telefonicznej ||
 7081               		.loc 1 1279 0 is_stmt 0 discriminator 1
 7082 25a8 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 7083 25ac 9111      		cpse r25,__zero_reg__
 7084 25ae 00C0      		rjmp .L760
1280:main.c        ****       trwa_rozmowa_przychodzaca_od_uzytkownika ||
 7085               		.loc 1 1280 0 is_stmt 1
 7086 25b0 9091 0000 		lds r25,trwa_rozmowa_przychodzaca_od_uzytkownika
 7087 25b4 9111      		cpse r25,__zero_reg__
 7088 25b6 00C0      		rjmp .L760
1281:main.c        ****       aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
 7089               		.loc 1 1281 0
 7090 25b8 9091 0000 		lds r25,aktualnie_wysylane_polecenie_SIM900
 7091 25bc 9111      		cpse r25,__zero_reg__
 7092 25be 00C0      		rjmp .L760
1282:main.c        ****       opoznienie_SIM900_100MS || czekanie_na_odebranie_zachety;
 7093               		.loc 1 1282 0
 7094 25c0 9091 0000 		lds r25,opoznienie_SIM900_100MS
 7095 25c4 9111      		cpse r25,__zero_reg__
 7096 25c6 00C0      		rjmp .L760
1283:main.c        **** 
 7097               		.loc 1 1283 0 discriminator 2
 7098 25c8 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 7099 25cc 21E0      		ldi r18,lo8(1)
 7100 25ce 30E0      		ldi r19,0
 7101 25d0 9111      		cpse r25,__zero_reg__
 7102 25d2 00C0      		rjmp .L759
 7103 25d4 30E0      		ldi r19,0
 7104 25d6 20E0      		ldi r18,0
 7105               	.L759:
 7106               	.LVL543:
1286:main.c        ****       czy_jest_bezczynny_SIM900();
 7107               		.loc 1 1286 0 discriminator 2
 7108 25d8 232B      		or r18,r19
 7109 25da 01F4      		brne .L760
 7110               	.LVL544:
1286:main.c        ****       czy_jest_bezczynny_SIM900();
 7111               		.loc 1 1286 0 is_stmt 0 discriminator 1
 7112 25dc 9091 C100 		lds r25,193
 7113 25e0 96FD      		sbrc r25,6
 7114 25e2 00C0      		rjmp .L760
1286:main.c        ****       czy_jest_bezczynny_SIM900();
 7115               		.loc 1 1286 0 discriminator 3
 7116 25e4 9091 0000 		lds r25,podlaczony_modul_gsm_SIM900
 7117 25e8 9923      		tst r25
 7118 25ea 01F0      		breq .L760
1287:main.c        **** 
 7119               		.loc 1 1287 0 is_stmt 1 discriminator 5
 7120 25ec 9091 0000 		lds r25,komenda_SIM900
1286:main.c        ****       czy_jest_bezczynny_SIM900();
 7121               		.loc 1 1286 0 discriminator 5
 7122 25f0 9923      		tst r25
 7123 25f2 01F4      		brne .+2
 7124 25f4 00C0      		rjmp .L761
 7125               	.LVL545:
 7126               	.L760:
1289:main.c        ****   case KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW: {
 7127               		.loc 1 1289 0
 7128 25f6 8838      		cpi r24,lo8(-120)
 7129 25f8 01F0      		breq .+2
 7130 25fa 00C0      		rjmp .L796
 7131 25fc 00C0      		rjmp .L762
 7132               	.LVL546:
 7133               	.L794:
 7134               	.LBB618:
1296:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
 7135               		.loc 1 1296 0
 7136 25fe 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 7137 2602 8111      		cpse r24,__zero_reg__
 7138 2604 00C0      		rjmp .L762
1296:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
 7139               		.loc 1 1296 0 is_stmt 0 discriminator 2
 7140 2606 8091 0000 		lds r24,liczba_znakow_do_zapisu
 7141 260a 8111      		cpse r24,__zero_reg__
 7142 260c 00C0      		rjmp .L762
1296:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
 7143               		.loc 1 1296 0 discriminator 4
 7144 260e 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 7145 2612 8111      		cpse r24,__zero_reg__
 7146 2614 00C0      		rjmp .L762
1296:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
 7147               		.loc 1 1296 0 discriminator 6
 7148 2616 F999      		sbic 0x1f,1
 7149 2618 00C0      		rjmp .L762
 7150               	.LVL547:
1298:main.c        ****     for (;;) {
 7151               		.loc 1 1298 0 is_stmt 1
 7152 261a 8AE2      		ldi r24,lo8(42)
 7153 261c 8093 0000 		sts tekst_wysylanego_smsa,r24
 7154 2620 00E0      		ldi r16,lo8(tekst_wysylanego_smsa+1)
 7155 2622 10E0      		ldi r17,hi8(tekst_wysylanego_smsa+1)
 7156               	.LVL548:
1300:main.c        ****               numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama)) {
 7157               		.loc 1 1300 0
 7158 2624 85E0      		ldi r24,lo8(5)
 7159 2626 D82E      		mov r13,r24
1306:main.c        ****         *sms++ = '\n';
 7160               		.loc 1 1306 0
 7161 2628 93E2      		ldi r25,lo8(35)
 7162 262a C92E      		mov r12,r25
1307:main.c        ****         ++numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama;
 7163               		.loc 1 1307 0
 7164 262c 2AE0      		ldi r18,lo8(10)
 7165 262e B22E      		mov r11,r18
 7166               	.LVL549:
 7167               	.L764:
1300:main.c        ****               numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama)) {
 7168               		.loc 1 1300 0
 7169 2630 C091 0000 		lds r28,numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama
 7170 2634 CD9D      		mul r28,r13
 7171 2636 7001      		movw r14,r0
 7172 2638 1124      		clr __zero_reg__
 7173 263a 88E0      		ldi r24,8
 7174 263c E80E      		add r14,r24
 7175 263e F11C      		adc r15,__zero_reg__
 7176 2640 C701      		movw r24,r14
 7177 2642 0E94 0000 		call eeprom_read_byte
 7178               	.LVL550:
 7179 2646 8F3F      		cpi r24,lo8(-1)
 7180 2648 01F0      		breq .L765
1302:main.c        ****             (void *)EEPROM_NUMER_TELEFONU_BRAMA(
 7181               		.loc 1 1302 0
 7182 264a 4FEF      		ldi r20,lo8(-1)
 7183 264c B801      		movw r22,r16
 7184 264e C701      		movw r24,r14
 7185 2650 0E94 0000 		call kopiuj_blok_eeprom_na_telefon
 7186               	.LVL551:
 7187 2654 E801      		movw r28,r16
 7188 2656 C80F      		add r28,r24
 7189 2658 D11D      		adc r29,__zero_reg__
 7190               	.LVL552:
1306:main.c        ****         *sms++ = '\n';
 7191               		.loc 1 1306 0
 7192 265a C882      		st Y,r12
1307:main.c        ****         ++numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama;
 7193               		.loc 1 1307 0
 7194 265c 8E01      		movw r16,r28
 7195 265e 0E5F      		subi r16,-2
 7196 2660 1F4F      		sbci r17,-1
 7197               	.LVL553:
 7198 2662 B982      		std Y+1,r11
1308:main.c        ****         if ((sms + MAX_LICZBA_ZNAKOW_TELEFON + 1 >=
 7199               		.loc 1 1308 0
 7200 2664 8091 0000 		lds r24,numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama
 7201 2668 8F5F      		subi r24,lo8(-(1))
 7202 266a 8093 0000 		sts numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama,r24
1309:main.c        ****              &tekst_wysylanego_smsa[MAX_LICZBA_ZNAKOW_SMS]) ||
 7203               		.loc 1 1309 0
 7204 266e 9E01      		movw r18,r28
 7205 2670 2D5E      		subi r18,-19
 7206 2672 3F4F      		sbci r19,-1
 7207 2674 2050      		subi r18,lo8(tekst_wysylanego_smsa+160)
 7208 2676 3040      		sbci r19,hi8(tekst_wysylanego_smsa+160)
 7209 2678 00F4      		brsh .L766
1310:main.c        ****             (numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama >=
 7210               		.loc 1 1310 0
 7211 267a 8F3F      		cpi r24,lo8(-1)
 7212 267c 01F4      		brne .L764
 7213               	.L767:
1316:main.c        ****           dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 7214               		.loc 1 1316 0
 7215 267e 1A82      		std Y+2,__zero_reg__
1317:main.c        ****           wysylanie_smsa_clipa = WYSYLANIE_SMSA_WYSYLANIE;
 7216               		.loc 1 1317 0
 7217 2680 82ED      		ldi r24,lo8(-46)
 7218 2682 0E94 0000 		call dodaj_komende
 7219               	.LVL554:
1318:main.c        ****           break;
 7220               		.loc 1 1318 0
 7221 2686 81E0      		ldi r24,lo8(1)
 7222 2688 8093 0000 		sts wysylanie_smsa_clipa,r24
 7223 268c 00C0      		rjmp .L797
 7224               	.L766:
1313:main.c        ****                MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER))
 7225               		.loc 1 1313 0
 7226 268e 8F3F      		cpi r24,lo8(-1)
 7227 2690 01F0      		breq .L767
1315:main.c        ****           *sms = '\0';
 7228               		.loc 1 1315 0
 7229 2692 88E8      		ldi r24,lo8(-120)
 7230 2694 0E94 0000 		call dodaj_komende
 7231               	.LVL555:
 7232 2698 00C0      		rjmp .L767
 7233               	.L765:
1322:main.c        ****             MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER) {
 7234               		.loc 1 1322 0
 7235 269a CF5F      		subi r28,lo8(-(1))
 7236 269c C093 0000 		sts numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama,r28
 7237 26a0 CF3F      		cpi r28,lo8(-1)
 7238 26a2 01F4      		brne .L764
1324:main.c        ****             *sms = '\0';
 7239               		.loc 1 1324 0
 7240 26a4 E0E0      		ldi r30,hi8(tekst_wysylanego_smsa)
 7241 26a6 0030      		cpi r16,lo8(tekst_wysylanego_smsa)
 7242 26a8 1E07      		cpc r17,r30
 7243 26aa 01F0      		breq .L757
1325:main.c        ****             dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 7244               		.loc 1 1325 0
 7245 26ac F801      		movw r30,r16
 7246 26ae 1082      		st Z,__zero_reg__
1326:main.c        ****             wysylanie_smsa_clipa = WYSYLANIE_SMSA_WYSYLANIE;
 7247               		.loc 1 1326 0
 7248 26b0 82ED      		ldi r24,lo8(-46)
 7249 26b2 0E94 0000 		call dodaj_komende
 7250               	.LVL556:
1327:main.c        ****           }
 7251               		.loc 1 1327 0
 7252 26b6 81E0      		ldi r24,lo8(1)
 7253 26b8 8093 0000 		sts wysylanie_smsa_clipa,r24
 7254 26bc 00C0      		rjmp .L757
 7255               	.LVL557:
 7256               	.L769:
1291:main.c        ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 7257               		.loc 1 1291 0
 7258 26be 8091 0000 		lds r24,wysylanie_smsa_clipa
 7259               	.LVL558:
 7260 26c2 8823      		tst r24
 7261 26c4 01F4      		brne .+2
 7262 26c6 00C0      		rjmp .L794
 7263               	.LVL559:
 7264               	.L762:
1293:main.c        ****       break;
 7265               		.loc 1 1293 0
 7266 26c8 88E8      		ldi r24,lo8(-120)
 7267 26ca 0E94 0000 		call dodaj_komende
 7268               	.LVL560:
 7269               	.L797:
 7270               	.LBE618:
1338:main.c        **** }
 7271               		.loc 1 1338 0
 7272 26ce CFEF      		ldi r28,lo8(-1)
 7273               	.L757:
1339:main.c        **** 
 7274               		.loc 1 1339 0
 7275 26d0 8C2F      		mov r24,r28
 7276               	/* epilogue start */
 7277 26d2 DF91      		pop r29
 7278 26d4 CF91      		pop r28
 7279 26d6 1F91      		pop r17
 7280 26d8 0F91      		pop r16
 7281 26da FF90      		pop r15
 7282 26dc EF90      		pop r14
 7283 26de DF90      		pop r13
 7284 26e0 CF90      		pop r12
 7285 26e2 BF90      		pop r11
 7286 26e4 0895      		ret
 7287               	.LVL561:
 7288               	.L761:
1289:main.c        ****   case KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW: {
 7289               		.loc 1 1289 0
 7290 26e6 8838      		cpi r24,lo8(-120)
 7291 26e8 01F0      		breq .L769
 7292               	.LVL562:
 7293               	.L796:
1336:main.c        ****   }
 7294               		.loc 1 1336 0
 7295 26ea C0E0      		ldi r28,0
 7296 26ec 00C0      		rjmp .L757
 7297               		.cfi_endproc
 7298               	.LFE59:
 7300               	.global	test_sms_clip_100ms
 7302               	test_sms_clip_100ms:
 7303               	.LFB61:
1353:main.c        ****   // static ulong licznik_sms;
 7304               		.loc 1 1353 0
 7305               		.cfi_startproc
 7306               	/* prologue: function */
 7307               	/* frame size = 0 */
 7308               	/* stack size = 0 */
 7309               	.L__stack_usage = 0
 7310               	/* epilogue start */
1372:main.c        **** 
 7311               		.loc 1 1372 0
 7312 26ee 0895      		ret
 7313               		.cfi_endproc
 7314               	.LFE61:
 7316               	.global	steruj_wejscia_wyjscia_100ms
 7318               	steruj_wejscia_wyjscia_100ms:
 7319               	.LFB62:
1374:main.c        ****   aktualizuj_stan_wyzwolenia_wejsc_100ms();
 7320               		.loc 1 1374 0
 7321               		.cfi_startproc
 7322               	/* prologue: function */
 7323               	/* frame size = 0 */
 7324               	/* stack size = 0 */
 7325               	.L__stack_usage = 0
1375:main.c        ****   steruj_wejsciem_reset_100ms();
 7326               		.loc 1 1375 0
 7327 26f0 0E94 0000 		call aktualizuj_stan_wyzwolenia_wejsc_100ms
 7328               	.LVL563:
1376:main.c        ****   steruj_wyjscia_100ms();
 7329               		.loc 1 1376 0
 7330 26f4 0E94 0000 		call steruj_wejsciem_reset_100ms
 7331               	.LVL564:
1377:main.c        **** }
 7332               		.loc 1 1377 0
 7333 26f8 0C94 0000 		jmp steruj_wyjscia_100ms
 7334               	.LVL565:
 7335               		.cfi_endproc
 7336               	.LFE62:
 7338               	.global	zapis_w_eeprom_stanu_wyjsc
 7340               	zapis_w_eeprom_stanu_wyjsc:
 7341               	.LFB63:
1380:main.c        ****   if (not czy_wolny_eeprom())
 7342               		.loc 1 1380 0
 7343               		.cfi_startproc
 7344 26fc CF93      		push r28
 7345               	.LCFI85:
 7346               		.cfi_def_cfa_offset 3
 7347               		.cfi_offset 28, -2
 7348 26fe DF93      		push r29
 7349               	.LCFI86:
 7350               		.cfi_def_cfa_offset 4
 7351               		.cfi_offset 29, -3
 7352 2700 1F92      		push __zero_reg__
 7353               	.LCFI87:
 7354               		.cfi_def_cfa_offset 5
 7355 2702 CDB7      		in r28,__SP_L__
 7356 2704 DEB7      		in r29,__SP_H__
 7357               	.LCFI88:
 7358               		.cfi_def_cfa_register 28
 7359               	/* prologue: function */
 7360               	/* frame size = 1 */
 7361               	/* stack size = 3 */
 7362               	.L__stack_usage = 3
1381:main.c        ****     return;
 7363               		.loc 1 1381 0
 7364 2706 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 7365 270a 8111      		cpse r24,__zero_reg__
 7366 270c 00C0      		rjmp .L800
1381:main.c        ****     return;
 7367               		.loc 1 1381 0 is_stmt 0 discriminator 1
 7368 270e 8091 0000 		lds r24,liczba_znakow_do_zapisu
 7369 2712 8111      		cpse r24,__zero_reg__
 7370 2714 00C0      		rjmp .L800
1381:main.c        ****     return;
 7371               		.loc 1 1381 0 discriminator 2
 7372 2716 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 7373 271a 8111      		cpse r24,__zero_reg__
 7374 271c 00C0      		rjmp .L800
1381:main.c        ****     return;
 7375               		.loc 1 1381 0 discriminator 3
 7376 271e F999      		sbic 0x1f,1
 7377 2720 00C0      		rjmp .L800
 7378               	.LBB621:
 7379               	.LBB622:
1383:main.c        ****   if ((stan_wyjscie[0] != 0) ^ (licznik_przelacznik_wyjscia[0] != 0))
 7380               		.loc 1 1383 0 is_stmt 1
 7381 2722 1982      		std Y+1,__zero_reg__
1384:main.c        ****     par |= BIT(0);
 7382               		.loc 1 1384 0
 7383 2724 91E0      		ldi r25,lo8(1)
 7384 2726 8091 0000 		lds r24,stan_wyjscie
 7385 272a 8111      		cpse r24,__zero_reg__
 7386 272c 00C0      		rjmp .L803
 7387 272e 90E0      		ldi r25,0
 7388               	.L803:
 7389 2730 81E0      		ldi r24,lo8(1)
 7390 2732 4091 0000 		lds r20,licznik_przelacznik_wyjscia
 7391 2736 5091 0000 		lds r21,licznik_przelacznik_wyjscia+1
 7392 273a 6091 0000 		lds r22,licznik_przelacznik_wyjscia+2
 7393 273e 7091 0000 		lds r23,licznik_przelacznik_wyjscia+3
 7394 2742 452B      		or r20,r21
 7395 2744 462B      		or r20,r22
 7396 2746 472B      		or r20,r23
 7397 2748 01F4      		brne .L804
 7398 274a 80E0      		ldi r24,0
 7399               	.L804:
 7400 274c 9817      		cp r25,r24
 7401 274e 01F0      		breq .L802
1385:main.c        ****   if (par != eeprom_read_byte((void *)EEPROM_USTAWIENIE_STANOW_WYJSC))
 7402               		.loc 1 1385 0
 7403 2750 81E0      		ldi r24,lo8(1)
 7404 2752 8983      		std Y+1,r24
 7405               	.L802:
1386:main.c        ****     zapisz_znaki_w_eeprom(&par, (uint)EEPROM_USTAWIENIE_STANOW_WYJSC, 1);
 7406               		.loc 1 1386 0
 7407 2754 85E0      		ldi r24,lo8(5)
 7408 2756 90E0      		ldi r25,0
 7409 2758 0E94 0000 		call eeprom_read_byte
 7410               	.LVL566:
 7411 275c 9981      		ldd r25,Y+1
 7412 275e 8917      		cp r24,r25
 7413 2760 01F0      		breq .L800
1387:main.c        **** }
 7414               		.loc 1 1387 0
 7415 2762 41E0      		ldi r20,lo8(1)
 7416 2764 65E0      		ldi r22,lo8(5)
 7417 2766 70E0      		ldi r23,0
 7418 2768 CE01      		movw r24,r28
 7419 276a 0196      		adiw r24,1
 7420 276c 0E94 0000 		call zapisz_znaki_w_eeprom
 7421               	.LVL567:
 7422               	.L800:
 7423               	/* epilogue start */
 7424               	.LBE622:
 7425               	.LBE621:
1388:main.c        **** 
 7426               		.loc 1 1388 0
 7427 2770 0F90      		pop __tmp_reg__
 7428 2772 DF91      		pop r29
 7429 2774 CF91      		pop r28
 7430 2776 0895      		ret
 7431               		.cfi_endproc
 7432               	.LFE63:
 7434               	.global	steruj_urzadzeniem_100MS
 7436               	steruj_urzadzeniem_100MS:
 7437               	.LFB64:
1403:main.c        ****   steruj_wejscia_wyjscia_100ms();
 7438               		.loc 1 1403 0
 7439               		.cfi_startproc
 7440               	/* prologue: function */
 7441               	/* frame size = 0 */
 7442               	/* stack size = 0 */
 7443               	.L__stack_usage = 0
1404:main.c        ****   steruj_SIM900_100MS();
 7444               		.loc 1 1404 0
 7445 2778 0E94 0000 		call steruj_wejscia_wyjscia_100ms
 7446               	.LVL568:
1405:main.c        ****   if (licznik_100ms_dioda_led) {
 7447               		.loc 1 1405 0
 7448 277c 0E94 0000 		call steruj_SIM900_100MS
 7449               	.LVL569:
1406:main.c        ****     if (--licznik_100ms_dioda_led == 0)
 7450               		.loc 1 1406 0
 7451 2780 8091 0000 		lds r24,licznik_100ms_dioda_led
 7452 2784 8823      		tst r24
 7453 2786 01F0      		breq .L807
1407:main.c        ****       ustaw_stan_led(FALSE);
 7454               		.loc 1 1407 0
 7455 2788 8150      		subi r24,lo8(-(-1))
 7456 278a 8093 0000 		sts licznik_100ms_dioda_led,r24
 7457 278e 8111      		cpse r24,__zero_reg__
 7458 2790 00C0      		rjmp .L808
1408:main.c        ****     else
 7459               		.loc 1 1408 0 discriminator 1
 7460 2792 409A      		sbi 0x8,0
 7461               	.L807:
1414:main.c        ****     --timer_report_user_100ms;
 7462               		.loc 1 1414 0
 7463 2794 8091 0000 		lds r24,timer_report_user_100ms
 7464 2798 9091 0000 		lds r25,timer_report_user_100ms+1
 7465 279c 0097      		sbiw r24,0
 7466 279e 01F0      		breq .L809
1415:main.c        ****     if (timer_report_user_100ms == 0) {
 7467               		.loc 1 1415 0
 7468 27a0 0197      		sbiw r24,1
 7469 27a2 9093 0000 		sts timer_report_user_100ms+1,r25
 7470 27a6 8093 0000 		sts timer_report_user_100ms,r24
1416:main.c        ****       // Okno czasowe minelo - resetuj licznik
 7471               		.loc 1 1416 0
 7472 27aa 892B      		or r24,r25
 7473 27ac 01F4      		brne .L810
 7474               	.L809:
1418:main.c        ****     }
 7475               		.loc 1 1418 0
 7476 27ae 1092 0000 		sts licznik_report_user,__zero_reg__
 7477               	.L810:
1428:main.c        ****   if (pierwsza_komenda != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 7478               		.loc 1 1428 0
 7479 27b2 8091 0000 		lds r24,komendy_kolejka
 7480               	.LVL570:
1429:main.c        ****     // Sprawdz czy pierwsza komenda to SMS - jesli tak i stoi zbyt dlugo,
 7481               		.loc 1 1429 0
 7482 27b6 8823      		tst r24
 7483 27b8 01F4      		brne .+2
 7484 27ba 00C0      		rjmp .L811
1432:main.c        ****         pierwsza_komenda <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU) {
 7485               		.loc 1 1432 0
 7486 27bc 9EE2      		ldi r25,lo8(46)
 7487 27be 980F      		add r25,r24
 7488 27c0 9230      		cpi r25,lo8(2)
 7489 27c2 00F0      		brlo .+2
 7490 27c4 00C0      		rjmp .L812
1435:main.c        ****         // Ta sama komenda SMS jest na poczatku kolejki - kolejka moze stac
 7491               		.loc 1 1435 0
 7492 27c6 9091 0000 		lds r25,ostatnia_pierwsza_komenda
 7493 27ca 9813      		cpse r25,r24
 7494 27cc 00C0      		rjmp .L812
1437:main.c        ****           ++licznik_kolejka_stoi_100ms;
 7495               		.loc 1 1437 0
 7496 27ce 8091 0000 		lds r24,licznik_kolejka_stoi_100ms
 7497 27d2 9091 0000 		lds r25,licznik_kolejka_stoi_100ms+1
 7498               	.LVL571:
 7499 27d6 8639      		cpi r24,-106
 7500 27d8 9105      		cpc r25,__zero_reg__
 7501 27da 00F0      		brlo .+2
 7502 27dc 00C0      		rjmp .L814
1438:main.c        ****         else {
 7503               		.loc 1 1438 0
 7504 27de 0196      		adiw r24,1
 7505 27e0 9093 0000 		sts licznik_kolejka_stoi_100ms+1,r25
 7506 27e4 8093 0000 		sts licznik_kolejka_stoi_100ms,r24
 7507               	.LVL572:
 7508               	.L815:
1477:main.c        ****     if (licznik_watchdog_wysylanie_smsa_100ms < WATCHDOG_WYSYLANIA_SMS_100MS) {
 7509               		.loc 1 1477 0
 7510 27e8 8091 0000 		lds r24,flaga_wysylanie_smsa
 7511 27ec 8823      		tst r24
 7512 27ee 01F4      		brne .+2
 7513 27f0 00C0      		rjmp .L817
1478:main.c        ****       ++licznik_watchdog_wysylanie_smsa_100ms;
 7514               		.loc 1 1478 0
 7515 27f2 8091 0000 		lds r24,licznik_watchdog_wysylanie_smsa_100ms
 7516 27f6 9091 0000 		lds r25,licznik_watchdog_wysylanie_smsa_100ms+1
 7517 27fa 8C32      		cpi r24,44
 7518 27fc 21E0      		ldi r18,1
 7519 27fe 9207      		cpc r25,r18
 7520 2800 00F0      		brlo .+2
 7521 2802 00C0      		rjmp .L818
1479:main.c        ****     } else {
 7522               		.loc 1 1479 0
 7523 2804 0196      		adiw r24,1
 7524 2806 9093 0000 		sts licznik_watchdog_wysylanie_smsa_100ms+1,r25
 7525 280a 8093 0000 		sts licznik_watchdog_wysylanie_smsa_100ms,r24
 7526               	.L819:
1501:main.c        ****     if (watchdog_sms_licznik_100ms < WATCHDOG_SMS_TIMEOUT_100MS)
 7527               		.loc 1 1501 0
 7528 280e 8091 0000 		lds r24,watchdog_sms_aktywny
 7529 2812 8823      		tst r24
 7530 2814 01F4      		brne .+2
 7531 2816 00C0      		rjmp .L821
1502:main.c        ****       ++watchdog_sms_licznik_100ms;
 7532               		.loc 1 1502 0
 7533 2818 8091 0000 		lds r24,watchdog_sms_licznik_100ms
 7534 281c 9091 0000 		lds r25,watchdog_sms_licznik_100ms+1
 7535 2820 8436      		cpi r24,100
 7536 2822 9105      		cpc r25,__zero_reg__
 7537 2824 00F0      		brlo .+2
 7538 2826 00C0      		rjmp .L822
1503:main.c        ****     else {
 7539               		.loc 1 1503 0
 7540 2828 8091 0000 		lds r24,watchdog_sms_licznik_100ms
 7541 282c 9091 0000 		lds r25,watchdog_sms_licznik_100ms+1
 7542 2830 0196      		adiw r24,1
 7543 2832 9093 0000 		sts watchdog_sms_licznik_100ms+1,r25
 7544 2836 8093 0000 		sts watchdog_sms_licznik_100ms,r24
 7545               	.L823:
1516:main.c        ****     ++stan_cyklu_blysku;
 7546               		.loc 1 1516 0
 7547 283a 8091 0000 		lds r24,liczba_blyskow_led
 7548 283e 8823      		tst r24
 7549 2840 01F4      		brne .+2
 7550 2842 00C0      		rjmp .L825
1517:main.c        ****     if (stan_cyklu_blysku >= 6) {
 7551               		.loc 1 1517 0
 7552 2844 9091 0000 		lds r25,stan_cyklu_blysku
 7553 2848 9F5F      		subi r25,lo8(-(1))
 7554 284a 9093 0000 		sts stan_cyklu_blysku,r25
1518:main.c        ****       stan_cyklu_blysku = 0;
 7555               		.loc 1 1518 0
 7556 284e 9630      		cpi r25,lo8(6)
 7557 2850 00F0      		brlo .L826
1519:main.c        ****       --liczba_blyskow_led;
 7558               		.loc 1 1519 0
 7559 2852 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
1520:main.c        ****     }
 7560               		.loc 1 1520 0
 7561 2856 8150      		subi r24,lo8(-(-1))
 7562 2858 8093 0000 		sts liczba_blyskow_led,r24
 7563               	.L826:
1522:main.c        ****     return;
 7564               		.loc 1 1522 0
 7565 285c 8091 0000 		lds r24,stan_cyklu_blysku
 7566 2860 8230      		cpi r24,lo8(2)
 7567 2862 00F4      		brsh .+2
 7568 2864 00C0      		rjmp .L827
1522:main.c        ****     return;
 7569               		.loc 1 1522 0 is_stmt 0 discriminator 1
 7570 2866 409A      		sbi 0x8,0
 7571 2868 0895      		ret
 7572               	.L808:
1410:main.c        ****   }
 7573               		.loc 1 1410 0 is_stmt 1 discriminator 2
 7574 286a 4098      		cbi 0x8,0
 7575 286c 00C0      		rjmp .L807
 7576               	.LVL573:
 7577               	.L814:
1442:main.c        ****                                        KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
 7578               		.loc 1 1442 0
 7579 286e 63ED      		ldi r22,lo8(-45)
 7580 2870 82ED      		ldi r24,lo8(-46)
 7581 2872 0E94 0000 		call filtruj_komendy_z_przedzialu
 7582               	.LVL574:
1444:main.c        ****             ++licznik_awaryjnych_resetow_kolejki;
 7583               		.loc 1 1444 0
 7584 2876 8091 0000 		lds r24,licznik_awaryjnych_resetow_kolejki
 7585 287a 9091 0000 		lds r25,licznik_awaryjnych_resetow_kolejki+1
 7586 287e 8F3F      		cpi r24,-1
 7587 2880 9807      		cpc r25,r24
 7588 2882 01F0      		breq .L816
1445:main.c        **** 
 7589               		.loc 1 1445 0
 7590 2884 0196      		adiw r24,1
 7591 2886 9093 0000 		sts licznik_awaryjnych_resetow_kolejki+1,r25
 7592 288a 8093 0000 		sts licznik_awaryjnych_resetow_kolejki,r24
 7593               	.L816:
1447:main.c        **** 
 7594               		.loc 1 1447 0
 7595 288e 81E9      		ldi r24,lo8(-111)
 7596 2890 0E94 0000 		call filtruj_i_dodaj_komende
 7597               	.LVL575:
1450:main.c        ****           timer_report_user_100ms = 0;
 7598               		.loc 1 1450 0
 7599 2894 1092 0000 		sts licznik_report_user,__zero_reg__
1451:main.c        **** 
 7600               		.loc 1 1451 0
 7601 2898 1092 0000 		sts timer_report_user_100ms+1,__zero_reg__
 7602 289c 1092 0000 		sts timer_report_user_100ms,__zero_reg__
1454:main.c        ****           ostatnia_pierwsza_komenda = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 7603               		.loc 1 1454 0
 7604 28a0 1092 0000 		sts licznik_kolejka_stoi_100ms+1,__zero_reg__
 7605 28a4 1092 0000 		sts licznik_kolejka_stoi_100ms,__zero_reg__
1455:main.c        **** 
 7606               		.loc 1 1455 0
 7607 28a8 1092 0000 		sts ostatnia_pierwsza_komenda,__zero_reg__
1458:main.c        ****         }
 7608               		.loc 1 1458 0
 7609 28ac 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
 7610 28b0 00C0      		rjmp .L815
 7611               	.LVL576:
 7612               	.L812:
1467:main.c        ****       licznik_kolejka_stoi_100ms = 0;
 7613               		.loc 1 1467 0
 7614 28b2 8093 0000 		sts ostatnia_pierwsza_komenda,r24
 7615               	.L856:
1473:main.c        ****   }
 7616               		.loc 1 1473 0
 7617 28b6 1092 0000 		sts licznik_kolejka_stoi_100ms+1,__zero_reg__
 7618 28ba 1092 0000 		sts licznik_kolejka_stoi_100ms,__zero_reg__
 7619 28be 00C0      		rjmp .L815
 7620               	.L811:
1472:main.c        ****     licznik_kolejka_stoi_100ms = 0;
 7621               		.loc 1 1472 0
 7622 28c0 1092 0000 		sts ostatnia_pierwsza_komenda,__zero_reg__
 7623 28c4 00C0      		rjmp .L856
 7624               	.LVL577:
 7625               	.L818:
1481:main.c        ****       // Awaryjne odblokowanie
 7626               		.loc 1 1481 0
 7627 28c6 1092 0000 		sts licznik_watchdog_wysylanie_smsa_100ms+1,__zero_reg__
 7628 28ca 1092 0000 		sts licznik_watchdog_wysylanie_smsa_100ms,__zero_reg__
1483:main.c        ****       flaga_wysylanie_smsa = 0;
 7629               		.loc 1 1483 0
 7630 28ce 0E94 0000 		call watchdog_sms_disarm
 7631               	.LVL578:
1484:main.c        ****       liczba_prob_wyslania_smsa = 0;
 7632               		.loc 1 1484 0
 7633 28d2 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
1485:main.c        ****       czekanie_na_odebranie_zachety = FALSE;
 7634               		.loc 1 1485 0
 7635 28d6 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
1486:main.c        ****       wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
 7636               		.loc 1 1486 0
 7637 28da 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
1487:main.c        **** 
 7638               		.loc 1 1487 0
 7639 28de 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
1489:main.c        ****         ++liczba_kolejnych_watchdogow_wysylania;
 7640               		.loc 1 1489 0
 7641 28e2 8091 0000 		lds r24,liczba_kolejnych_watchdogow_wysylania
 7642 28e6 8F3F      		cpi r24,lo8(-1)
 7643 28e8 01F0      		breq .L820
1490:main.c        ****       if (liczba_kolejnych_watchdogow_wysylania >= 3) {
 7644               		.loc 1 1490 0
 7645 28ea 8F5F      		subi r24,lo8(-(1))
 7646 28ec 8093 0000 		sts liczba_kolejnych_watchdogow_wysylania,r24
 7647               	.L820:
1491:main.c        ****         liczba_kolejnych_watchdogow_wysylania = 0;
 7648               		.loc 1 1491 0
 7649 28f0 8091 0000 		lds r24,liczba_kolejnych_watchdogow_wysylania
 7650 28f4 8330      		cpi r24,lo8(3)
 7651 28f6 00F4      		brsh .+2
 7652 28f8 00C0      		rjmp .L819
1492:main.c        ****         reset_modulu_SIM900();
 7653               		.loc 1 1492 0
 7654 28fa 1092 0000 		sts liczba_kolejnych_watchdogow_wysylania,__zero_reg__
1493:main.c        ****       }
 7655               		.loc 1 1493 0
 7656 28fe 0E94 0000 		call reset_modulu_SIM900
 7657               	.LVL579:
 7658 2902 00C0      		rjmp .L819
 7659               	.L817:
1497:main.c        ****     liczba_kolejnych_watchdogow_wysylania = 0;
 7660               		.loc 1 1497 0
 7661 2904 1092 0000 		sts licznik_watchdog_wysylanie_smsa_100ms+1,__zero_reg__
 7662 2908 1092 0000 		sts licznik_watchdog_wysylanie_smsa_100ms,__zero_reg__
1498:main.c        ****   }
 7663               		.loc 1 1498 0
 7664 290c 1092 0000 		sts liczba_kolejnych_watchdogow_wysylania,__zero_reg__
 7665 2910 00C0      		rjmp .L819
 7666               	.L822:
1505:main.c        ****       cli();
 7667               		.loc 1 1505 0
 7668 2912 8FEF      		ldi r24,lo8(-1)
 7669 2914 8093 0000 		sts watchdog_sms_trwa_reset,r24
1506:main.c        ****       wdt_enable(WDTO_15MS);
 7670               		.loc 1 1506 0
 7671               	/* #APP */
 7672               	 ;  1506 "main.c" 1
 7673 2918 F894      		cli
 7674               	 ;  0 "" 2
 7675               	.LVL580:
 7676               	/* #NOAPP */
 7677               	.LBB623:
 7678               	.LBB624:
 7679               		.file 7 "/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h"
   1:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
   5:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
   8:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  11:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      distribution.
  15:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  16:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  20:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  32:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /* $Id$ */
  33:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  34:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /*
  35:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****  */
  37:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  38:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  41:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  44:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /** \file */
  45:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  48:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  57:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  61:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     the following:
  68:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  69:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     \code
  70:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  73:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  75:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     {
  80:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     }
  84:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     \endcode
  85:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  86:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** */
  91:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  92:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /**
  93:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** */
  98:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  99:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 101:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #ifndef __DOXYGEN__
 102:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 103:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined(WDP3)
 104:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 105:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else
 106:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 107:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif
 108:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 109:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 110:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 111:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 112:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 113:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else
 114:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 115:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif
 116:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 117:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined(WDTOE)
 118:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 119:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else
 120:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 121:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif
 122:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 123:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif	/* !__DOXYGEN__ */
 124:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 125:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 126:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /**
 127:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 128:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 129:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 130:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 131:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 132:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 133:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 134:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 135:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** */
 136:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 137:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 138:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 139:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 140:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined (WDT_CTRLA) && !defined(RAMPD)
 141:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 142:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 143:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** do { \
 144:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** uint8_t temp; \
 145:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 146:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"wdr"									"\n\t" \
 147:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]"		"\n\t" \
 148:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"				"\n\t" \
 149:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"sbr %[tmp], %[wdt_enable_timeout]"		"\n\t" \
 150:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"				"\n\t" \
 151:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"1:lds %[tmp], %[wdt_status_reg]"		"\n\t" \
 152:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"sbrc %[tmp], %[wdt_syncbusy_bit]"		"\n\t" \
 153:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"rjmp 1b"								"\n\t" \
 154:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	: [tmp]					"=r" (temp) \
 155:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	: [ccp_reg]				"I"  (_SFR_IO_ADDR(CCP)), \
 156:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [ioreg_cen_mask]		"r"  ((uint8_t)CCP_IOREG_gc), \
 157:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [wdt_reg]				"n"  (_SFR_MEM_ADDR(WDT_CTRLA)), \
 158:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [wdt_enable_timeout]	"M"  (timeout), \
 159:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [wdt_status_reg]		"n"  (_SFR_MEM_ADDR(WDT_STATUS)), \
 160:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [wdt_syncbusy_bit]	"I"  (WDT_SYNCBUSY_bm) \
 161:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ); \
 162:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** } while(0)
 163:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 164:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_disable() \
 165:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** do { \
 166:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** uint8_t temp; \
 167:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 168:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"wdr"								"\n\t" \
 169:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 170:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"			"\n\t" \
 171:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"cbr %[tmp], %[timeout_mask]"       "\n\t" \
 172:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"			"\n\t" \
 173:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [tmp]            "=r" (temp) \
 174:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [ccp_reg]        "I" (_SFR_IO_ADDR(CCP)),       \
 175:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ioreg_cen_mask] "r" ((uint8_t)CCP_IOREG_gc),   \
 176:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_reg]        "n" (_SFR_MEM_ADDR(WDT_CTRLA)),\
 177:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [timeout_mask]   "I" (WDT_PERIOD_gm) \
 178:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ); \
 179:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** } while(0)
 180:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 181:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else // defined (WDT_CTRLA) && !defined(RAMPD)
 182:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 183:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /*
 184:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 185:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 186:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    registers to the CCP register
 187:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ** At the same time,
 188:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 189:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 190:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 191:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 192:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 193:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    sync is finished).
 194:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** */
 195:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 196:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** do { \
 197:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** uint8_t temp; \
 198:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 199:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 200:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 201:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 202:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 203:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 204:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 205:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 206:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 207:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 208:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 209:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 210:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 211:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 212:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 213:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 214:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 215:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : "r0" \
 216:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ); \
 217:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** } while(0)
 218:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 219:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_disable() \
 220:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 221:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 222:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 223:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 224:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 225:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 226:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : \
 227:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 228:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 229:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 230:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 231:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 232:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : "r0" \
 233:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** );
 234:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 235:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif // defined (WDT_CTRLA) && !defined(RAMPD)
 236:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 237:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 238:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 239:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 240:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 241:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 242:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 243:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 244:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 245:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 246:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 247:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : /* no outputs */  \
 248:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 249:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 250:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 251:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 252:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 253:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : "r16" \
 254:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** )
 255:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 256:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_disable() \
 257:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** do { \
 258:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 259:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 260:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 261:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 262:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 263:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 264:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 265:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 266:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 267:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 268:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : /*no output */ \
 269:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 270:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 271:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 272:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 273:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 274:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : "r16" \
 275:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ); \
 276:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** }while(0)
 277:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 278:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #elif defined(CCP)
 279:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 280:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** static __inline__
 281:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 282:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 283:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** {
 284:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 285:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 286:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 287:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 288:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 289:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 290:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 291:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 292:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 293:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: /* no outputs */
 294:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 295:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 296:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 297:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 298:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 299:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: "r0"
 300:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			);
 301:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 302:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 303:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 304:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 305:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 306:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 307:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 308:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 309:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 310:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 311:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: /* no outputs */
 312:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 313:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 314:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 315:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 316:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 317:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: "r0"
 318:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			);
 319:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 320:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 321:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 322:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 323:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 324:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 325:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 326:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 327:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 328:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 329:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: /* no outputs */
 330:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 331:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 332:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 333:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 334:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 335:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: "r0"
 336:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			);
 337:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 338:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else
 339:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****  	{
 340:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 341:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 342:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 343:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 344:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 345:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 346:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 347:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: /* no outputs */
 348:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 349:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 350:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 351:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 352:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 353:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: "r0"
 354:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			);
 355:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 356:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** }
 357:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 358:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** static __inline__
 359:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 360:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** void wdt_disable (void)
 361:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** {
 362:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 363:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 364:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 365:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 366:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 367:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 368:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 369:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 370:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 371:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 372:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 373:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 374:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /*no output */
 375:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 376:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 377:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 378:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 379:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 380:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 381:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				);
 382:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 383:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 384:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 385:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 386:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 387:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 388:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 389:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 390:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 391:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 392:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 393:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 394:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 395:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /*no output */
 396:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 397:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 398:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 399:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 400:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 401:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 402:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				);
 403:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 404:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 405:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 406:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 407:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 408:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 409:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 410:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 411:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 412:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 413:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 414:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 415:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 416:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /*no output */
 417:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 418:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 419:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 420:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 421:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 422:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 423:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				);
 424:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 425:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else
 426:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 427:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 428:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 429:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 430:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 431:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 432:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 433:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 434:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 435:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 436:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 437:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /*no output */
 438:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 439:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 440:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 441:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 442:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 443:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 444:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				);
 445:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 446:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** }
 447:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 448:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else
 449:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 450:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** static __inline__
 451:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 452:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 453:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** {
 454:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 455:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 456:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 457:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 458:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 459:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 460:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 461:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 462:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 463:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /* no outputs */
 464:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 465:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 466:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 467:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 468:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 469:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		);
 470:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 471:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else
 472:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 473:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 7680               		.loc 7 473 0
 7681 291a 88E1      		ldi r24,lo8(24)
 7682 291c 98E0      		ldi r25,lo8(8)
 7683               	/* #APP */
 7684               	 ;  473 "/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h" 1
 7685 291e 0FB6      		in __tmp_reg__,__SREG__
 7686 2920 F894      		cli
 7687 2922 A895      		wdr
 7688 2924 8093 6000 		sts 96, r24
 7689 2928 0FBE      		out __SREG__,__tmp_reg__
 7690 292a 9093 6000 		sts 96, r25
 7691               	 	
 7692               	 ;  0 "" 2
 7693               	/* #NOAPP */
 7694               	.L824:
 7695 292e 00C0      		rjmp .L824
 7696               	.LVL581:
 7697               	.L821:
 7698               	.LBE624:
 7699               	.LBE623:
1511:main.c        ****     --watchdog_sms_safe_mode_100ms;
 7700               		.loc 1 1511 0
 7701 2930 8091 0000 		lds r24,watchdog_sms_safe_mode_100ms
 7702 2934 9091 0000 		lds r25,watchdog_sms_safe_mode_100ms+1
 7703 2938 892B      		or r24,r25
 7704 293a 01F4      		brne .+2
 7705 293c 00C0      		rjmp .L823
1512:main.c        ****   }
 7706               		.loc 1 1512 0
 7707 293e 8091 0000 		lds r24,watchdog_sms_safe_mode_100ms
 7708 2942 9091 0000 		lds r25,watchdog_sms_safe_mode_100ms+1
 7709 2946 0197      		sbiw r24,1
 7710 2948 9093 0000 		sts watchdog_sms_safe_mode_100ms+1,r25
 7711 294c 8093 0000 		sts watchdog_sms_safe_mode_100ms,r24
 7712 2950 00C0      		rjmp .L823
 7713               	.L827:
1522:main.c        ****     return;
 7714               		.loc 1 1522 0 discriminator 2
 7715 2952 4098      		cbi 0x8,0
 7716               	/* epilogue start */
1552:main.c        **** 
 7717               		.loc 1 1552 0 discriminator 2
 7718 2954 0895      		ret
 7719               	.L825:
1528:main.c        ****     // Nie zalogowany - dioda swiecei ciagle
 7720               		.loc 1 1528 0
 7721 2956 8091 0000 		lds r24,modul_zalogowany_w_sieci
 7722 295a 8111      		cpse r24,__zero_reg__
 7723 295c 00C0      		rjmp .L829
 7724               	.L834:
 7725               	.LBB625:
1545:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7726               		.loc 1 1545 0 discriminator 6
 7727 295e 4098      		cbi 0x8,0
 7728 2960 00C0      		rjmp .L830
 7729               	.L829:
 7730               	.LBE625:
1533:main.c        ****       // Mrugniecie (SMS, etc.)
 7731               		.loc 1 1533 0
 7732 2962 8091 0000 		lds r24,licznik_100ms_dioda_led
 7733 2966 8111      		cpse r24,__zero_reg__
 7734 2968 00C0      		rjmp .L834
 7735               	.LBB626:
1539:main.c        ****         if (++licznik_dioda_led_poziom_sieci >= 50)
 7736               		.loc 1 1539 0
 7737 296a 8091 0000 		lds r24,poziom_sieci_gsm
 7738 296e 8031      		cpi r24,lo8(16)
 7739 2970 00F4      		brsh .L832
1540:main.c        ****           licznik_dioda_led_poziom_sieci = 1;
 7740               		.loc 1 1540 0
 7741 2972 8091 0000 		lds r24,licznik_dioda_led_poziom_sieci.3717
 7742 2976 8F5F      		subi r24,lo8(-(1))
 7743 2978 8093 0000 		sts licznik_dioda_led_poziom_sieci.3717,r24
 7744 297c 8233      		cpi r24,lo8(50)
 7745 297e 00F0      		brlo .L833
1541:main.c        ****       } else
 7746               		.loc 1 1541 0
 7747 2980 81E0      		ldi r24,lo8(1)
 7748 2982 8093 0000 		sts licznik_dioda_led_poziom_sieci.3717,r24
 7749               	.L833:
1545:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7750               		.loc 1 1545 0
 7751 2986 8091 0000 		lds r24,licznik_dioda_led_poziom_sieci.3717
 7752 298a 8832      		cpi r24,lo8(40)
 7753 298c 01F0      		breq .L834
1545:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7754               		.loc 1 1545 0 is_stmt 0 discriminator 1
 7755 298e 8B32      		cpi r24,lo8(43)
 7756 2990 01F0      		breq .L834
1545:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7757               		.loc 1 1545 0 discriminator 3
 7758 2992 8E52      		subi r24,lo8(-(-46))
 7759 2994 8430      		cpi r24,lo8(4)
 7760 2996 00F0      		brlo .L834
1545:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7761               		.loc 1 1545 0 discriminator 5
 7762 2998 409A      		sbi 0x8,0
 7763               	.L830:
 7764               	.LBE626:
1551:main.c        **** }
 7765               		.loc 1 1551 0 is_stmt 1
 7766 299a 0C94 0000 		jmp zapis_w_eeprom_stanu_wyjsc
 7767               	.LVL582:
 7768               	.L832:
 7769               	.LBB627:
1543:main.c        **** 
 7770               		.loc 1 1543 0
 7771 299e 1092 0000 		sts licznik_dioda_led_poziom_sieci.3717,__zero_reg__
 7772 29a2 00C0      		rjmp .L833
 7773               	.LBE627:
 7774               		.cfi_endproc
 7775               	.LFE64:
 7777               	.global	steruj_urzadzeniem_10MS
 7779               	steruj_urzadzeniem_10MS:
 7780               	.LFB65:
1554:main.c        ****   steruj_wejscia_10ms();
 7781               		.loc 1 1554 0
 7782               		.cfi_startproc
 7783               	/* prologue: function */
 7784               	/* frame size = 0 */
 7785               	/* stack size = 0 */
 7786               	.L__stack_usage = 0
1555:main.c        ****   steruj_SIM900_10MS();
 7787               		.loc 1 1555 0
 7788 29a4 0E94 0000 		call steruj_wejscia_10ms
 7789               	.LVL583:
1556:main.c        ****   zapisz_bajt_w_EEPROM();
 7790               		.loc 1 1556 0
 7791 29a8 0E94 0000 		call steruj_SIM900_10MS
 7792               	.LVL584:
1557:main.c        ****   // test_dioda_wyjscia();
 7793               		.loc 1 1557 0
 7794 29ac 0C94 0000 		jmp zapisz_bajt_w_EEPROM
 7795               	.LVL585:
 7796               		.cfi_endproc
 7797               	.LFE65:
 7799               	.global	wolne_zdarzenie_timer
 7801               	wolne_zdarzenie_timer:
 7802               	.LFB66:
1562:main.c        ****   WYKONAJ_CLI_SEI(WYLACZ_PRZERWANIE_TIMER());
 7803               		.loc 1 1562 0
 7804               		.cfi_startproc
 7805               	/* prologue: function */
 7806               	/* frame size = 0 */
 7807               	/* stack size = 0 */
 7808               	.L__stack_usage = 0
1563:main.c        ****   if (!CZY_WYKONAC_ZDARZENIE_TIMER()) {
 7809               		.loc 1 1563 0
 7810               	/* #APP */
 7811               	 ;  1563 "main.c" 1
 7812 29b0 F894      		cli
 7813               	 ;  0 "" 2
 7814               	/* #NOAPP */
 7815 29b2 8091 6E00 		lds r24,110
 7816 29b6 8D7F      		andi r24,lo8(-3)
 7817 29b8 8093 6E00 		sts 110,r24
 7818               	/* #APP */
 7819               	 ;  1563 "main.c" 1
 7820 29bc 7894      		sei
 7821               	 ;  0 "" 2
 7822               	 ;  1563 "main.c" 1
 7823 29be 0000      		nop
 7824               	 ;  0 "" 2
1564:main.c        ****     WYKONAJ_CLI_SEI(WLACZ_PRZERWANIE_TIMER());
 7825               		.loc 1 1564 0
 7826               	/* #NOAPP */
 7827 29c0 8091 0000 		lds r24,wykonaj_zdarzenie_timer
 7828 29c4 8111      		cpse r24,__zero_reg__
 7829 29c6 00C0      		rjmp .L859
1565:main.c        ****     return;
 7830               		.loc 1 1565 0
 7831               	/* #APP */
 7832               	 ;  1565 "main.c" 1
 7833 29c8 F894      		cli
 7834               	 ;  0 "" 2
 7835               	/* #NOAPP */
 7836 29ca 8091 6E00 		lds r24,110
 7837 29ce 8260      		ori r24,lo8(2)
 7838 29d0 8093 6E00 		sts 110,r24
 7839               	/* #APP */
 7840               	 ;  1565 "main.c" 1
 7841 29d4 7894      		sei
 7842               	 ;  0 "" 2
 7843               	 ;  1565 "main.c" 1
 7844 29d6 0000      		nop
 7845               	 ;  0 "" 2
1566:main.c        ****   }
 7846               		.loc 1 1566 0
 7847               	/* #NOAPP */
 7848 29d8 0895      		ret
 7849               	.L859:
1568:main.c        ****   if (wykonac_watki_10MS) {
 7850               		.loc 1 1568 0
 7851 29da 1092 0000 		sts wykonaj_zdarzenie_timer,__zero_reg__
1569:main.c        ****     wykonac_watki = WYKONAJ_WATKI_10MS;
 7852               		.loc 1 1569 0
 7853 29de 8091 0000 		lds r24,wykonac_watki_10MS
 7854 29e2 8823      		tst r24
 7855 29e4 01F0      		breq .L861
1570:main.c        ****     wykonac_watki_10MS = FALSE;
 7856               		.loc 1 1570 0
 7857 29e6 81E0      		ldi r24,lo8(1)
 7858 29e8 8093 0000 		sts wykonac_watki,r24
1571:main.c        ****   }
 7859               		.loc 1 1571 0
 7860 29ec 1092 0000 		sts wykonac_watki_10MS,__zero_reg__
 7861               	.L861:
1573:main.c        ****   if (CZY_WYKONAC_WATKI_10MS()) {
 7862               		.loc 1 1573 0
 7863               	/* #APP */
 7864               	 ;  1573 "main.c" 1
 7865 29f0 F894      		cli
 7866               	 ;  0 "" 2
 7867               	/* #NOAPP */
 7868 29f2 8091 6E00 		lds r24,110
 7869 29f6 8260      		ori r24,lo8(2)
 7870 29f8 8093 6E00 		sts 110,r24
 7871               	/* #APP */
 7872               	 ;  1573 "main.c" 1
 7873 29fc 7894      		sei
 7874               	 ;  0 "" 2
 7875               	 ;  1573 "main.c" 1
 7876 29fe 0000      		nop
 7877               	 ;  0 "" 2
1574:main.c        ****     static uchar licznik_wybuc_watki_100MS = 0;
 7878               		.loc 1 1574 0
 7879               	/* #NOAPP */
 7880 2a00 8091 0000 		lds r24,wykonac_watki
 7881 2a04 80FF      		sbrs r24,0
 7882 2a06 00C0      		rjmp .L858
 7883               	.LBB631:
1577:main.c        ****       licznik_wybuc_watki_100MS = 0;
 7884               		.loc 1 1577 0
 7885 2a08 8091 0000 		lds r24,licznik_wybuc_watki_100MS.3724
 7886 2a0c 8F5F      		subi r24,lo8(-(1))
 7887 2a0e 8A30      		cpi r24,lo8(10)
 7888 2a10 01F0      		breq .L862
 7889 2a12 8093 0000 		sts licznik_wybuc_watki_100MS.3724,r24
 7890               	.L863:
1581:main.c        ****     cli();
 7891               		.loc 1 1581 0
 7892               	/* #APP */
 7893               	 ;  1581 "main.c" 1
 7894 2a16 0000      		nop
 7895               	 ;  0 "" 2
1582:main.c        ****     if (CZY_ODBIERANIE_DANYCH_SIM900()) {
 7896               		.loc 1 1582 0
 7897               	 ;  1582 "main.c" 1
 7898 2a18 F894      		cli
 7899               	 ;  0 "" 2
1583:main.c        ****       WYLACZ_PRZERWANIE_ODBIORU_DANYCH_SIM900();
 7900               		.loc 1 1583 0
 7901               	/* #NOAPP */
 7902 2a1a 00B6      		in __tmp_reg__,0x30
 7903 2a1c 01FE      		sbrs __tmp_reg__,1
 7904 2a1e 00C0      		rjmp .L864
1584:main.c        ****       sei();
 7905               		.loc 1 1584 0
 7906 2a20 8091 C100 		lds r24,193
 7907 2a24 8F77      		andi r24,lo8(127)
 7908 2a26 8093 C100 		sts 193,r24
1585:main.c        ****       if (liczba_odebranych_znakow_SIM900 != 0 &&
 7909               		.loc 1 1585 0
 7910               	/* #APP */
 7911               	 ;  1585 "main.c" 1
 7912 2a2a 7894      		sei
 7913               	 ;  0 "" 2
1586:main.c        ****           ++licznik_opoznienie_oczekiwania_na_bajt_SIM900 >
 7914               		.loc 1 1586 0
 7915               	/* #NOAPP */
 7916 2a2c 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 7917 2a30 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
 7918 2a34 892B      		or r24,r25
 7919 2a36 01F0      		breq .L865
1587:main.c        ****               MAX_OPOZNIENIE_OCZEKIWANIA_NA_BAJT_SIM900_500_MS) {
 7920               		.loc 1 1587 0
 7921 2a38 8091 0000 		lds r24,licznik_opoznienie_oczekiwania_na_bajt_SIM900
 7922 2a3c 8F5F      		subi r24,lo8(-(1))
1586:main.c        ****           ++licznik_opoznienie_oczekiwania_na_bajt_SIM900 >
 7923               		.loc 1 1586 0
 7924 2a3e 8093 0000 		sts licznik_opoznienie_oczekiwania_na_bajt_SIM900,r24
 7925 2a42 8333      		cpi r24,lo8(51)
 7926 2a44 00F0      		brlo .L865
1589:main.c        ****       } else {
 7927               		.loc 1 1589 0
 7928 2a46 459A      		sbi 0x8,5
 7929 2a48 8091 C100 		lds r24,193
 7930 2a4c 8F77      		andi r24,lo8(127)
 7931 2a4e 8093 C100 		sts 193,r24
 7932 2a52 80B7      		in r24,0x30
 7933 2a54 8D7F      		andi r24,lo8(-3)
 7934 2a56 80BF      		out 0x30,r24
 7935 2a58 1092 0000 		sts poczatek_polecenia_SIM900+1,__zero_reg__
 7936 2a5c 1092 0000 		sts poczatek_polecenia_SIM900,__zero_reg__
 7937 2a60 1092 0000 		sts zakonczenie_polecenia_SIM900+1,__zero_reg__
 7938 2a64 1092 0000 		sts zakonczenie_polecenia_SIM900,__zero_reg__
 7939 2a68 1092 0000 		sts czy_jest_nowe_polecenie_SIM900,__zero_reg__
 7940               	.L864:
1594:main.c        ****   }
 7941               		.loc 1 1594 0
 7942               	/* #APP */
 7943               	 ;  1594 "main.c" 1
 7944 2a6c 7894      		sei
 7945               	 ;  0 "" 2
 7946               	/* #NOAPP */
 7947               	.L858:
 7948               	/* epilogue start */
 7949               	.LBE631:
1596:main.c        **** 
 7950               		.loc 1 1596 0
 7951 2a6e 0895      		ret
 7952               	.L862:
 7953               	.LBB632:
1578:main.c        ****       wykonac_watki = WYKONAJ_WATKI_100MS | WYKONAJ_WATKI_10MS;
 7954               		.loc 1 1578 0
 7955 2a70 1092 0000 		sts licznik_wybuc_watki_100MS.3724,__zero_reg__
1579:main.c        ****     }
 7956               		.loc 1 1579 0
 7957 2a74 83E0      		ldi r24,lo8(3)
 7958 2a76 8093 0000 		sts wykonac_watki,r24
 7959 2a7a 00C0      		rjmp .L863
 7960               	.L865:
1591:main.c        ****       }
 7961               		.loc 1 1591 0
 7962               	/* #APP */
 7963               	 ;  1591 "main.c" 1
 7964 2a7c F894      		cli
 7965               	 ;  0 "" 2
 7966               	/* #NOAPP */
 7967 2a7e 8091 C100 		lds r24,193
 7968 2a82 8068      		ori r24,lo8(-128)
 7969 2a84 8093 C100 		sts 193,r24
 7970               	/* #APP */
 7971               	 ;  1591 "main.c" 1
 7972 2a88 7894      		sei
 7973               	 ;  0 "" 2
 7974               	 ;  1591 "main.c" 1
 7975 2a8a 0000      		nop
 7976               	 ;  0 "" 2
 7977               	/* #NOAPP */
 7978 2a8c 00C0      		rjmp .L864
 7979               	.LBE632:
 7980               		.cfi_endproc
 7981               	.LFE66:
 7983               	.global	ustaw_parametry_dla_bezpieczenstwa
 7985               	ustaw_parametry_dla_bezpieczenstwa:
 7986               	.LFB67:
1598:main.c        ****   wdt_reset();
 7987               		.loc 1 1598 0
 7988               		.cfi_startproc
 7989               	/* prologue: function */
 7990               	/* frame size = 0 */
 7991               	/* stack size = 0 */
 7992               	.L__stack_usage = 0
1599:main.c        ****   ustaw_parametry_dla_bezpieczenstwa_rejestry();
 7993               		.loc 1 1599 0
 7994               	/* #APP */
 7995               	 ;  1599 "main.c" 1
 7996 2a8e A895      		wdr
 7997               	 ;  0 "" 2
1600:main.c        ****   set_sleep_mode(SLEEP_MODE_IDLE);
 7998               		.loc 1 1600 0
 7999               	/* #NOAPP */
 8000 2a90 82E0      		ldi r24,lo8(2)
 8001 2a92 84BD      		out 0x24,r24
 8002 2a94 83E0      		ldi r24,lo8(3)
 8003 2a96 85BD      		out 0x25,r24
 8004 2a98 8FE3      		ldi r24,lo8(63)
 8005 2a9a 87BD      		out 0x27,r24
 8006 2a9c EEE6      		ldi r30,lo8(110)
 8007 2a9e F0E0      		ldi r31,0
 8008 2aa0 8081      		ld r24,Z
 8009 2aa2 8260      		ori r24,lo8(2)
 8010 2aa4 8083      		st Z,r24
1601:main.c        **** }
 8011               		.loc 1 1601 0
 8012 2aa6 83B7      		in r24,0x33
 8013 2aa8 817F      		andi r24,lo8(-15)
 8014 2aaa 83BF      		out 0x33,r24
 8015               	/* epilogue start */
1602:main.c        **** 
 8016               		.loc 1 1602 0
 8017 2aac 0895      		ret
 8018               		.cfi_endproc
 8019               	.LFE67:
 8021               	.global	inicjalizuj_parametry_modulu
 8023               	inicjalizuj_parametry_modulu:
 8024               	.LFB68:
1604:main.c        ****   memcpy_E(kod_modulu, ADRES_EEPROM_KOD_DOSTEPU, LICZBA_BAJTOW_KODU_DOSTEPU);
 8025               		.loc 1 1604 0
 8026               		.cfi_startproc
 8027 2aae CF93      		push r28
 8028               	.LCFI89:
 8029               		.cfi_def_cfa_offset 3
 8030               		.cfi_offset 28, -2
 8031 2ab0 DF93      		push r29
 8032               	.LCFI90:
 8033               		.cfi_def_cfa_offset 4
 8034               		.cfi_offset 29, -3
 8035               	/* prologue: function */
 8036               	/* frame size = 0 */
 8037               	/* stack size = 2 */
 8038               	.L__stack_usage = 2
1605:main.c        **** 
 8039               		.loc 1 1605 0
 8040 2ab2 44E0      		ldi r20,lo8(4)
 8041 2ab4 50E0      		ldi r21,0
 8042 2ab6 61E0      		ldi r22,lo8(1)
 8043 2ab8 70E0      		ldi r23,0
 8044 2aba 80E0      		ldi r24,lo8(kod_modulu)
 8045 2abc 90E0      		ldi r25,hi8(kod_modulu)
 8046 2abe 0E94 0000 		call eeprom_read_block
 8047               	.LVL586:
1608:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8048               		.loc 1 1608 0
 8049 2ac2 8091 0000 		lds r24,kod_modulu
 8050 2ac6 8150      		subi r24,lo8(-(-1))
 8051 2ac8 8E3F      		cpi r24,lo8(-2)
 8052 2aca 00F0      		brlo .L880
1609:main.c        ****     kod_modulu[1] = bufor_eeprom[1] = 'B';
 8053               		.loc 1 1609 0
 8054 2acc 81E4      		ldi r24,lo8(65)
 8055 2ace 8093 0000 		sts bufor_eeprom,r24
 8056 2ad2 8093 0000 		sts kod_modulu,r24
1610:main.c        ****     kod_modulu[2] = bufor_eeprom[2] = 'C';
 8057               		.loc 1 1610 0
 8058 2ad6 82E4      		ldi r24,lo8(66)
 8059 2ad8 8093 0000 		sts bufor_eeprom+1,r24
 8060 2adc 8093 0000 		sts kod_modulu+1,r24
1611:main.c        ****     kod_modulu[3] = bufor_eeprom[3] = 'D';
 8061               		.loc 1 1611 0
 8062 2ae0 83E4      		ldi r24,lo8(67)
 8063 2ae2 8093 0000 		sts bufor_eeprom+2,r24
 8064 2ae6 8093 0000 		sts kod_modulu+2,r24
1612:main.c        ****     // Zapisz do EEPROM natychmiast (BLOCKING)
 8065               		.loc 1 1612 0
 8066 2aea 84E4      		ldi r24,lo8(68)
 8067 2aec 8093 0000 		sts bufor_eeprom+3,r24
 8068 2af0 8093 0000 		sts kod_modulu+3,r24
 8069               	.L881:
1614:main.c        ****       ;
 8070               		.loc 1 1614 0 discriminator 1
 8071 2af4 F999      		sbic 0x1f,1
 8072 2af6 00C0      		rjmp .L881
1616:main.c        ****                         LICZBA_BAJTOW_KODU_DOSTEPU);
 8073               		.loc 1 1616 0
 8074 2af8 44E0      		ldi r20,lo8(4)
 8075 2afa 50E0      		ldi r21,0
 8076 2afc 61E0      		ldi r22,lo8(1)
 8077 2afe 70E0      		ldi r23,0
 8078 2b00 80E0      		ldi r24,lo8(kod_modulu)
 8079 2b02 90E0      		ldi r25,hi8(kod_modulu)
 8080 2b04 0E94 0000 		call eeprom_update_block
 8081               	.LVL587:
 8082               	.L880:
1622:main.c        ****   if (tryb_pracy == 0xFF) {
 8083               		.loc 1 1622 0
 8084 2b08 8EEF      		ldi r24,lo8(-2)
 8085 2b0a 9FE0      		ldi r25,lo8(15)
 8086 2b0c 0E94 0000 		call eeprom_read_byte
 8087               	.LVL588:
1623:main.c        ****     tryb_pracy = 1; // Domyślnie Publiczny
 8088               		.loc 1 1623 0
 8089 2b10 8F3F      		cpi r24,lo8(-1)
 8090 2b12 01F4      		brne .+2
 8091 2b14 00C0      		rjmp .L882
1622:main.c        ****   if (tryb_pracy == 0xFF) {
 8092               		.loc 1 1622 0
 8093 2b16 8093 0000 		sts tryb_pracy,r24
 8094               	.L883:
1631:main.c        ****   if (tryb_clip == 0xFF) {
 8095               		.loc 1 1631 0
 8096 2b1a 8FEF      		ldi r24,lo8(-1)
 8097 2b1c 9FE0      		ldi r25,lo8(15)
 8098 2b1e 0E94 0000 		call eeprom_read_byte
 8099               	.LVL589:
1632:main.c        ****     tryb_clip = 1; // Domyślnie CLIP (1)
 8100               		.loc 1 1632 0
 8101 2b22 8F3F      		cpi r24,lo8(-1)
 8102 2b24 01F4      		brne .+2
 8103 2b26 00C0      		rjmp .L885
1631:main.c        ****   if (tryb_clip == 0xFF) {
 8104               		.loc 1 1631 0
 8105 2b28 8093 0000 		sts tryb_clip,r24
 8106               	.L886:
1640:main.c        ****   czas_start_m = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_START_M);
 8107               		.loc 1 1640 0
 8108 2b2c 8AEF      		ldi r24,lo8(-6)
 8109 2b2e 9FE0      		ldi r25,lo8(15)
 8110 2b30 0E94 0000 		call eeprom_read_byte
 8111               	.LVL590:
 8112 2b34 8093 0000 		sts czas_start_h,r24
1641:main.c        ****   czas_stop_h = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_STOP_H);
 8113               		.loc 1 1641 0
 8114 2b38 8BEF      		ldi r24,lo8(-5)
 8115 2b3a 9FE0      		ldi r25,lo8(15)
 8116 2b3c 0E94 0000 		call eeprom_read_byte
 8117               	.LVL591:
 8118 2b40 8093 0000 		sts czas_start_m,r24
1642:main.c        ****   czas_stop_m = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_STOP_M);
 8119               		.loc 1 1642 0
 8120 2b44 8CEF      		ldi r24,lo8(-4)
 8121 2b46 9FE0      		ldi r25,lo8(15)
 8122 2b48 0E94 0000 		call eeprom_read_byte
 8123               	.LVL592:
 8124 2b4c 8093 0000 		sts czas_stop_h,r24
1643:main.c        **** 
 8125               		.loc 1 1643 0
 8126 2b50 8DEF      		ldi r24,lo8(-3)
 8127 2b52 9FE0      		ldi r25,lo8(15)
 8128 2b54 0E94 0000 		call eeprom_read_byte
 8129               	.LVL593:
 8130 2b58 8093 0000 		sts czas_stop_m,r24
1646:main.c        ****   if (skryba_wlaczona == 0xFF)
 8131               		.loc 1 1646 0
 8132 2b5c 89EF      		ldi r24,lo8(-7)
 8133 2b5e 9FE0      		ldi r25,lo8(15)
 8134 2b60 0E94 0000 		call eeprom_read_byte
 8135               	.LVL594:
1647:main.c        ****     skryba_wlaczona = FALSE;
 8136               		.loc 1 1647 0
 8137 2b64 8F3F      		cpi r24,lo8(-1)
 8138 2b66 01F4      		brne .+2
 8139 2b68 00C0      		rjmp .L888
1646:main.c        ****   if (skryba_wlaczona == 0xFF)
 8140               		.loc 1 1646 0
 8141 2b6a 8093 0000 		sts skryba_wlaczona,r24
 8142               	.L889:
1651:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA_LIMIT_L);
 8143               		.loc 1 1651 0
 8144 2b6e 85EF      		ldi r24,lo8(-11)
 8145 2b70 9FE0      		ldi r25,lo8(15)
 8146 2b72 0E94 0000 		call eeprom_read_byte
 8147               	.LVL595:
 8148 2b76 C82F      		mov r28,r24
 8149               	.LVL596:
1653:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA_LIMIT_H);
 8150               		.loc 1 1653 0
 8151 2b78 86EF      		ldi r24,lo8(-10)
 8152 2b7a 9FE0      		ldi r25,lo8(15)
 8153               	.LVL597:
 8154 2b7c 0E94 0000 		call eeprom_read_byte
 8155               	.LVL598:
1655:main.c        ****     // Nie ustawiono - domyslnie 800
 8156               		.loc 1 1655 0
 8157 2b80 CF3F      		cpi r28,lo8(-1)
 8158 2b82 01F0      		breq .+2
 8159 2b84 00C0      		rjmp .L890
1655:main.c        ****     // Nie ustawiono - domyslnie 800
 8160               		.loc 1 1655 0 is_stmt 0 discriminator 1
 8161 2b86 8F3F      		cpi r24,lo8(-1)
 8162 2b88 01F0      		breq .+2
 8163 2b8a 00C0      		rjmp .L890
 8164               	.LVL599:
 8165               	.L892:
1657:main.c        ****   } else {
 8166               		.loc 1 1657 0 is_stmt 1
 8167 2b8c 80E2      		ldi r24,lo8(32)
 8168 2b8e 93E0      		ldi r25,lo8(3)
 8169 2b90 9093 0000 		sts skryba_limit+1,r25
 8170 2b94 8093 0000 		sts skryba_limit,r24
 8171               	.L891:
1666:main.c        **** 
 8172               		.loc 1 1666 0
 8173 2b98 81E0      		ldi r24,lo8(1)
 8174 2b9a 9091 0000 		lds r25,skryba_wlaczona
 8175 2b9e 9111      		cpse r25,__zero_reg__
 8176 2ba0 00C0      		rjmp .L893
 8177 2ba2 80E0      		ldi r24,0
 8178               	.L893:
 8179 2ba4 6091 0000 		lds r22,skryba_limit
 8180 2ba8 0E94 0000 		call zapisz_debug_do_eeprom
 8181               	.LVL600:
1670:main.c        ****       (czas_start_m > 59 && czas_start_m != 0xFF) ||
 8182               		.loc 1 1670 0
 8183 2bac 8091 0000 		lds r24,czas_start_h
 8184 2bb0 8851      		subi r24,lo8(-(-24))
 8185 2bb2 873E      		cpi r24,lo8(-25)
 8186 2bb4 00F0      		brlo .L912
1671:main.c        ****       (czas_stop_h > 23 && czas_stop_h != 0xFF) ||
 8187               		.loc 1 1671 0 discriminator 1
 8188 2bb6 8091 0000 		lds r24,czas_start_m
 8189 2bba 8C53      		subi r24,lo8(-(-60))
1670:main.c        ****       (czas_start_m > 59 && czas_start_m != 0xFF) ||
 8190               		.loc 1 1670 0 discriminator 1
 8191 2bbc 833C      		cpi r24,lo8(-61)
 8192 2bbe 00F0      		brlo .L912
1672:main.c        ****       (czas_stop_m > 59 && czas_stop_m != 0xFF)) {
 8193               		.loc 1 1672 0
 8194 2bc0 8091 0000 		lds r24,czas_stop_h
 8195 2bc4 8851      		subi r24,lo8(-(-24))
1671:main.c        ****       (czas_stop_h > 23 && czas_stop_h != 0xFF) ||
 8196               		.loc 1 1671 0
 8197 2bc6 873E      		cpi r24,lo8(-25)
 8198 2bc8 00F0      		brlo .L912
1673:main.c        ****     // Zapisz wartosci wylaczajace (0xFF) - BLOCKING
 8199               		.loc 1 1673 0
 8200 2bca 8091 0000 		lds r24,czas_stop_m
 8201 2bce 8C53      		subi r24,lo8(-(-60))
1672:main.c        ****       (czas_stop_m > 59 && czas_stop_m != 0xFF)) {
 8202               		.loc 1 1672 0
 8203 2bd0 833C      		cpi r24,lo8(-61)
 8204 2bd2 00F4      		brsh .L895
 8205               	.L912:
1675:main.c        ****       ;
 8206               		.loc 1 1675 0 discriminator 1
 8207 2bd4 F999      		sbic 0x1f,1
 8208 2bd6 00C0      		rjmp .L912
1677:main.c        ****     while (!eeprom_is_ready())
 8209               		.loc 1 1677 0
 8210 2bd8 6FEF      		ldi r22,lo8(-1)
 8211 2bda 8AEF      		ldi r24,lo8(-6)
 8212 2bdc 9FE0      		ldi r25,lo8(15)
 8213 2bde 0E94 0000 		call eeprom_update_byte
 8214               	.LVL601:
 8215               	.L896:
1678:main.c        ****       ;
 8216               		.loc 1 1678 0 discriminator 1
 8217 2be2 F999      		sbic 0x1f,1
 8218 2be4 00C0      		rjmp .L896
1680:main.c        ****     while (!eeprom_is_ready())
 8219               		.loc 1 1680 0
 8220 2be6 6FEF      		ldi r22,lo8(-1)
 8221 2be8 8BEF      		ldi r24,lo8(-5)
 8222 2bea 9FE0      		ldi r25,lo8(15)
 8223 2bec 0E94 0000 		call eeprom_update_byte
 8224               	.LVL602:
 8225               	.L897:
1681:main.c        ****       ;
 8226               		.loc 1 1681 0 discriminator 1
 8227 2bf0 F999      		sbic 0x1f,1
 8228 2bf2 00C0      		rjmp .L897
1683:main.c        ****     while (!eeprom_is_ready())
 8229               		.loc 1 1683 0
 8230 2bf4 6FEF      		ldi r22,lo8(-1)
 8231 2bf6 8CEF      		ldi r24,lo8(-4)
 8232 2bf8 9FE0      		ldi r25,lo8(15)
 8233 2bfa 0E94 0000 		call eeprom_update_byte
 8234               	.LVL603:
 8235               	.L898:
1684:main.c        ****       ;
 8236               		.loc 1 1684 0 discriminator 1
 8237 2bfe F999      		sbic 0x1f,1
 8238 2c00 00C0      		rjmp .L898
1686:main.c        **** 
 8239               		.loc 1 1686 0
 8240 2c02 6FEF      		ldi r22,lo8(-1)
 8241 2c04 8DEF      		ldi r24,lo8(-3)
 8242 2c06 9FE0      		ldi r25,lo8(15)
 8243 2c08 0E94 0000 		call eeprom_update_byte
 8244               	.LVL604:
1688:main.c        ****     czas_start_m = 0xFF;
 8245               		.loc 1 1688 0
 8246 2c0c 8FEF      		ldi r24,lo8(-1)
 8247 2c0e 8093 0000 		sts czas_start_h,r24
1689:main.c        ****     czas_stop_h = 0xFF;
 8248               		.loc 1 1689 0
 8249 2c12 8093 0000 		sts czas_start_m,r24
1690:main.c        ****     czas_stop_m = 0xFF;
 8250               		.loc 1 1690 0
 8251 2c16 8093 0000 		sts czas_stop_h,r24
1691:main.c        ****   }
 8252               		.loc 1 1691 0
 8253 2c1a 8093 0000 		sts czas_stop_m,r24
 8254               	.L895:
1694:main.c        ****       FALSE; // Domyślnie odblokowane, zaktualizuje sie przy odczycie czasu
 8255               		.loc 1 1694 0
 8256 2c1e 1092 0000 		sts blokada_sterowania_czasowa,__zero_reg__
1699:main.c        ****   if (blokada_systemu == 0xFF) {
 8257               		.loc 1 1699 0
 8258 2c22 87EF      		ldi r24,lo8(-9)
 8259 2c24 9FE0      		ldi r25,lo8(15)
 8260 2c26 0E94 0000 		call eeprom_read_byte
 8261               	.LVL605:
1700:main.c        ****     blokada_systemu = FALSE; // Domyślnie odblokowany
 8262               		.loc 1 1700 0
 8263 2c2a 8F3F      		cpi r24,lo8(-1)
 8264 2c2c 01F4      		brne .+2
 8265 2c2e 00C0      		rjmp .L899
1698:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_BLOKADA_SYSTEMU);
 8266               		.loc 1 1698 0
 8267 2c30 8093 0000 		sts blokada_systemu,r24
 8268               	.L900:
1604:main.c        ****   memcpy_E(kod_modulu, ADRES_EEPROM_KOD_DOSTEPU, LICZBA_BAJTOW_KODU_DOSTEPU);
 8269               		.loc 1 1604 0
 8270 2c34 C0EF      		ldi r28,lo8(-16)
 8271 2c36 DFE0      		ldi r29,lo8(15)
 8272               	.LVL606:
 8273               	.L903:
 8274               	.LBB633:
1707:main.c        ****       while (!eeprom_is_ready())
 8275               		.loc 1 1707 0
 8276 2c38 CE01      		movw r24,r28
 8277 2c3a 0E94 0000 		call eeprom_read_byte
 8278               	.LVL607:
 8279 2c3e 8F3F      		cpi r24,lo8(-1)
 8280 2c40 01F4      		brne .L901
 8281               	.L902:
1708:main.c        ****         ;
 8282               		.loc 1 1708 0 discriminator 1
 8283 2c42 F999      		sbic 0x1f,1
 8284 2c44 00C0      		rjmp .L902
1710:main.c        ****     }
 8285               		.loc 1 1710 0
 8286 2c46 60E0      		ldi r22,0
 8287 2c48 CE01      		movw r24,r28
 8288 2c4a 0E94 0000 		call eeprom_update_byte
 8289               	.LVL608:
 8290               	.L901:
1706:main.c        ****     if (eeprom_read_byte((const uint8_t *)addr) == 0xFF) {
 8291               		.loc 1 1706 0
 8292 2c4e 2196      		adiw r28,1
 8293               	.LVL609:
1705:main.c        ****        addr <= ADRES_EEPROM_DEBUG_SKRYBA_5; ++addr) {
 8294               		.loc 1 1705 0
 8295 2c50 C53F      		cpi r28,-11
 8296 2c52 8FE0      		ldi r24,15
 8297 2c54 D807      		cpc r29,r24
 8298 2c56 01F4      		brne .L903
 8299               	.LBE633:
 8300               	.LBB634:
1715:main.c        ****        addr <= ADRES_EEPROM_DEBUG_USER_7; ++addr) {
 8301               		.loc 1 1715 0
 8302 2c58 C6EE      		ldi r28,lo8(-26)
 8303 2c5a DFE0      		ldi r29,lo8(15)
 8304               	.LVL610:
 8305               	.L906:
1717:main.c        ****       while (!eeprom_is_ready())
 8306               		.loc 1 1717 0
 8307 2c5c CE01      		movw r24,r28
 8308 2c5e 0E94 0000 		call eeprom_read_byte
 8309               	.LVL611:
 8310 2c62 8F3F      		cpi r24,lo8(-1)
 8311 2c64 01F4      		brne .L904
 8312               	.L905:
1718:main.c        ****         ;
 8313               		.loc 1 1718 0 discriminator 1
 8314 2c66 F999      		sbic 0x1f,1
 8315 2c68 00C0      		rjmp .L905
1720:main.c        ****     }
 8316               		.loc 1 1720 0
 8317 2c6a 60E0      		ldi r22,0
 8318 2c6c CE01      		movw r24,r28
 8319 2c6e 0E94 0000 		call eeprom_update_byte
 8320               	.LVL612:
 8321               	.L904:
1716:main.c        ****     if (eeprom_read_byte((const uint8_t *)addr) == 0xFF) {
 8322               		.loc 1 1716 0
 8323 2c72 2196      		adiw r28,1
 8324               	.LVL613:
1715:main.c        ****        addr <= ADRES_EEPROM_DEBUG_USER_7; ++addr) {
 8325               		.loc 1 1715 0
 8326 2c74 CD3E      		cpi r28,-19
 8327 2c76 2FE0      		ldi r18,15
 8328 2c78 D207      		cpc r29,r18
 8329 2c7a 01F4      		brne .L906
 8330               	.LBE634:
1726:main.c        ****   timer_report_user_100ms = 0;
 8331               		.loc 1 1726 0
 8332 2c7c 1092 0000 		sts licznik_report_user,__zero_reg__
1727:main.c        **** 
 8333               		.loc 1 1727 0
 8334 2c80 1092 0000 		sts timer_report_user_100ms+1,__zero_reg__
 8335 2c84 1092 0000 		sts timer_report_user_100ms,__zero_reg__
1730:main.c        **** 
 8336               		.loc 1 1730 0
 8337 2c88 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
1734:main.c        ****     ++licznik_resetow;
 8338               		.loc 1 1734 0
 8339 2c8c 8091 0000 		lds r24,licznik_resetow.3768
 8340 2c90 8F3F      		cpi r24,lo8(-1)
 8341 2c92 01F0      		breq .L908
1735:main.c        ****   while (!eeprom_is_ready())
 8342               		.loc 1 1735 0
 8343 2c94 8F5F      		subi r24,lo8(-(1))
 8344 2c96 8093 0000 		sts licznik_resetow.3768,r24
 8345               	.L908:
1736:main.c        ****     ;
 8346               		.loc 1 1736 0 discriminator 1
 8347 2c9a F999      		sbic 0x1f,1
 8348 2c9c 00C0      		rjmp .L908
1738:main.c        ****   while (!eeprom_is_ready())
 8349               		.loc 1 1738 0
 8350 2c9e 6091 0000 		lds r22,licznik_resetow.3768
 8351 2ca2 8CED      		ldi r24,lo8(-36)
 8352 2ca4 9FE0      		ldi r25,lo8(15)
 8353 2ca6 0E94 0000 		call eeprom_update_byte
 8354               	.LVL614:
 8355               	.L909:
1739:main.c        ****     ;
 8356               		.loc 1 1739 0 discriminator 1
 8357 2caa F999      		sbic 0x1f,1
 8358 2cac 00C0      		rjmp .L909
1741:main.c        **** }
 8359               		.loc 1 1741 0
 8360 2cae 62E0      		ldi r22,lo8(2)
 8361 2cb0 80E0      		ldi r24,0
 8362               	/* epilogue start */
1742:main.c        **** 
 8363               		.loc 1 1742 0
 8364 2cb2 DF91      		pop r29
 8365 2cb4 CF91      		pop r28
 8366               	.LVL615:
1741:main.c        **** }
 8367               		.loc 1 1741 0
 8368 2cb6 0C94 0000 		jmp zapisz_debug_do_eeprom
 8369               	.LVL616:
 8370               	.L882:
1624:main.c        ****     while (!eeprom_is_ready())
 8371               		.loc 1 1624 0
 8372 2cba 81E0      		ldi r24,lo8(1)
 8373 2cbc 8093 0000 		sts tryb_pracy,r24
 8374               	.L884:
1625:main.c        ****       ;
 8375               		.loc 1 1625 0 discriminator 1
 8376 2cc0 F999      		sbic 0x1f,1
 8377 2cc2 00C0      		rjmp .L884
1627:main.c        ****   }
 8378               		.loc 1 1627 0
 8379 2cc4 61E0      		ldi r22,lo8(1)
 8380 2cc6 8EEF      		ldi r24,lo8(-2)
 8381 2cc8 9FE0      		ldi r25,lo8(15)
 8382 2cca 0E94 0000 		call eeprom_update_byte
 8383               	.LVL617:
 8384 2cce 00C0      		rjmp .L883
 8385               	.L885:
1633:main.c        ****     while (!eeprom_is_ready())
 8386               		.loc 1 1633 0
 8387 2cd0 81E0      		ldi r24,lo8(1)
 8388 2cd2 8093 0000 		sts tryb_clip,r24
 8389               	.L887:
1634:main.c        ****       ;
 8390               		.loc 1 1634 0 discriminator 1
 8391 2cd6 F999      		sbic 0x1f,1
 8392 2cd8 00C0      		rjmp .L887
1636:main.c        ****   }
 8393               		.loc 1 1636 0
 8394 2cda 61E0      		ldi r22,lo8(1)
 8395 2cdc 8FEF      		ldi r24,lo8(-1)
 8396 2cde 9FE0      		ldi r25,lo8(15)
 8397 2ce0 0E94 0000 		call eeprom_update_byte
 8398               	.LVL618:
 8399 2ce4 00C0      		rjmp .L886
 8400               	.L888:
1648:main.c        **** 
 8401               		.loc 1 1648 0
 8402 2ce6 1092 0000 		sts skryba_wlaczona,__zero_reg__
 8403 2cea 00C0      		rjmp .L889
 8404               	.LVL619:
 8405               	.L890:
1659:main.c        ****     // Walidacja zakresu
 8406               		.loc 1 1659 0
 8407 2cec 982F      		mov r25,r24
 8408 2cee 8C2F      		mov r24,r28
 8409               	.LVL620:
 8410 2cf0 9093 0000 		sts skryba_limit+1,r25
 8411 2cf4 8093 0000 		sts skryba_limit,r24
1661:main.c        ****       skryba_limit = 800;
 8412               		.loc 1 1661 0
 8413 2cf8 0197      		sbiw r24,1
 8414 2cfa 8032      		cpi r24,32
 8415 2cfc 9340      		sbci r25,3
 8416 2cfe 00F0      		brlo .+2
 8417 2d00 00C0      		rjmp .L892
 8418 2d02 00C0      		rjmp .L891
 8419               	.LVL621:
 8420               	.L899:
1701:main.c        ****   }
 8421               		.loc 1 1701 0
 8422 2d04 1092 0000 		sts blokada_systemu,__zero_reg__
 8423 2d08 00C0      		rjmp .L900
 8424               		.cfi_endproc
 8425               	.LFE68:
 8427               	.global	wykonanie_komend_ukladow
 8429               	wykonanie_komend_ukladow:
 8430               	.LFB58:
 847:main.c        ****   const komenda_typ aktualnie_wykonywana_komenda = komendy_kolejka[0];
 8431               		.loc 1 847 0
 8432               		.cfi_startproc
 8433 2d0a DF92      		push r13
 8434               	.LCFI91:
 8435               		.cfi_def_cfa_offset 3
 8436               		.cfi_offset 13, -2
 8437 2d0c EF92      		push r14
 8438               	.LCFI92:
 8439               		.cfi_def_cfa_offset 4
 8440               		.cfi_offset 14, -3
 8441 2d0e FF92      		push r15
 8442               	.LCFI93:
 8443               		.cfi_def_cfa_offset 5
 8444               		.cfi_offset 15, -4
 8445 2d10 0F93      		push r16
 8446               	.LCFI94:
 8447               		.cfi_def_cfa_offset 6
 8448               		.cfi_offset 16, -5
 8449 2d12 1F93      		push r17
 8450               	.LCFI95:
 8451               		.cfi_def_cfa_offset 7
 8452               		.cfi_offset 17, -6
 8453 2d14 CF93      		push r28
 8454               	.LCFI96:
 8455               		.cfi_def_cfa_offset 8
 8456               		.cfi_offset 28, -7
 8457 2d16 DF93      		push r29
 8458               	.LCFI97:
 8459               		.cfi_def_cfa_offset 9
 8460               		.cfi_offset 29, -8
 8461 2d18 CDB7      		in r28,__SP_L__
 8462 2d1a DEB7      		in r29,__SP_H__
 8463               	.LCFI98:
 8464               		.cfi_def_cfa_register 28
 8465 2d1c A597      		sbiw r28,37
 8466               	.LCFI99:
 8467               		.cfi_def_cfa_offset 46
 8468 2d1e 0FB6      		in __tmp_reg__,__SREG__
 8469 2d20 F894      		cli
 8470 2d22 DEBF      		out __SP_H__,r29
 8471 2d24 0FBE      		out __SREG__,__tmp_reg__
 8472 2d26 CDBF      		out __SP_L__,r28
 8473               	/* prologue: function */
 8474               	/* frame size = 37 */
 8475               	/* stack size = 44 */
 8476               	.L__stack_usage = 44
 848:main.c        **** 
 8477               		.loc 1 848 0
 8478 2d28 1091 0000 		lds r17,komendy_kolejka
 8479               	.LVL622:
 850:main.c        ****   case KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU: {
 8480               		.loc 1 850 0
 8481 2d2c 1338      		cpi r17,lo8(-125)
 8482 2d2e 01F4      		brne .+2
 8483 2d30 00C0      		rjmp .L929
 8484 2d32 00F4      		brsh .L930
 8485 2d34 1230      		cpi r17,lo8(2)
 8486 2d36 01F0      		breq .L931
 8487 2d38 00F0      		brlo .+2
 8488 2d3a 00C0      		rjmp .L1024
 8489               	.L991:
1270:main.c        ****   }
 8490               		.loc 1 1270 0
 8491 2d3c 80E0      		ldi r24,0
 8492 2d3e 00C0      		rjmp .L927
 8493               	.L930:
 850:main.c        ****   case KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU: {
 8494               		.loc 1 850 0
 8495 2d40 1538      		cpi r17,lo8(-123)
 8496 2d42 01F4      		brne .+2
 8497 2d44 00C0      		rjmp .L933
 8498 2d46 00F4      		brsh .+2
 8499 2d48 00C0      		rjmp .L934
 8500 2d4a 1638      		cpi r17,lo8(-122)
 8501 2d4c 01F4      		brne .+2
 8502 2d4e 00C0      		rjmp .L935
 8503 2d50 1738      		cpi r17,lo8(-121)
 8504 2d52 01F4      		brne .L991
1244:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8505               		.loc 1 1244 0
 8506 2d54 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8507 2d58 8111      		cpse r24,__zero_reg__
 8508 2d5a 00C0      		rjmp .L987
1244:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8509               		.loc 1 1244 0 is_stmt 0 discriminator 2
 8510 2d5c 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8511 2d60 8111      		cpse r24,__zero_reg__
 8512 2d62 00C0      		rjmp .L987
1244:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8513               		.loc 1 1244 0 discriminator 4
 8514 2d64 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 8515 2d68 8111      		cpse r24,__zero_reg__
 8516 2d6a 00C0      		rjmp .L987
1244:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8517               		.loc 1 1244 0 discriminator 6
 8518 2d6c F99B      		sbis 0x1f,1
 8519 2d6e 00C0      		rjmp .L988
 8520               	.L987:
1244:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8521               		.loc 1 1244 0 discriminator 7
 8522 2d70 87E8      		ldi r24,lo8(-121)
 8523 2d72 00C0      		rjmp .L1027
 8524               	.L931:
 852:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8525               		.loc 1 852 0 is_stmt 1
 8526 2d74 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8527 2d78 8111      		cpse r24,__zero_reg__
 8528 2d7a 00C0      		rjmp .L937
 852:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8529               		.loc 1 852 0 is_stmt 0 discriminator 2
 8530 2d7c 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8531 2d80 8111      		cpse r24,__zero_reg__
 8532 2d82 00C0      		rjmp .L937
 852:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8533               		.loc 1 852 0 discriminator 4
 8534 2d84 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 8535 2d88 8111      		cpse r24,__zero_reg__
 8536 2d8a 00C0      		rjmp .L937
 852:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8537               		.loc 1 852 0 discriminator 6
 8538 2d8c F99B      		sbis 0x1f,1
 8539 2d8e 00C0      		rjmp .L938
 8540               	.L937:
 852:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8541               		.loc 1 852 0 discriminator 7
 8542 2d90 82E0      		ldi r24,lo8(2)
 8543               	.LVL623:
 8544               	.L1027:
1244:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8545               		.loc 1 1244 0 is_stmt 1 discriminator 7
 8546 2d92 0E94 0000 		call dodaj_komende
 8547               	.LVL624:
 8548 2d96 00C0      		rjmp .L1026
 8549               	.LVL625:
 8550               	.L938:
 853:main.c        ****     kod_modulu[1] = bufor_eeprom[1] = 'B';
 8551               		.loc 1 853 0
 8552 2d98 81E4      		ldi r24,lo8(65)
 8553 2d9a 8093 0000 		sts bufor_eeprom,r24
 8554 2d9e 8093 0000 		sts kod_modulu,r24
 854:main.c        ****     kod_modulu[2] = bufor_eeprom[2] = 'C';
 8555               		.loc 1 854 0
 8556 2da2 82E4      		ldi r24,lo8(66)
 8557 2da4 8093 0000 		sts bufor_eeprom+1,r24
 8558 2da8 8093 0000 		sts kod_modulu+1,r24
 855:main.c        ****     kod_modulu[3] = bufor_eeprom[3] = 'D';
 8559               		.loc 1 855 0
 8560 2dac 83E4      		ldi r24,lo8(67)
 8561 2dae 8093 0000 		sts bufor_eeprom+2,r24
 8562 2db2 8093 0000 		sts kod_modulu+2,r24
 856:main.c        ****     zapisz_znaki_w_eeprom_bez_kopiowania(ADRES_EEPROM_KOD_DOSTEPU,
 8563               		.loc 1 856 0
 8564 2db6 84E4      		ldi r24,lo8(68)
 8565 2db8 8093 0000 		sts bufor_eeprom+3,r24
 8566 2dbc 8093 0000 		sts kod_modulu+3,r24
 857:main.c        ****                                          LICZBA_BAJTOW_KODU_DOSTEPU);
 8567               		.loc 1 857 0
 8568 2dc0 64E0      		ldi r22,lo8(4)
 8569 2dc2 81E0      		ldi r24,lo8(1)
 8570 2dc4 90E0      		ldi r25,0
 8571 2dc6 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 8572               	.LVL626:
 8573               	.L1029:
 8574               	.LBB655:
1008:main.c        ****     break;
 8575               		.loc 1 1008 0
 8576 2dca 83E3      		ldi r24,lo8(51)
 8577 2dcc 8093 0000 		sts licznik_100ms_dioda_led,r24
 8578               	.LVL627:
 8579               	.L1026:
 8580               	.LBE655:
1272:main.c        **** }
 8581               		.loc 1 1272 0
 8582 2dd0 8FEF      		ldi r24,lo8(-1)
 8583               	.L927:
 8584               	/* epilogue start */
1273:main.c        **** 
 8585               		.loc 1 1273 0
 8586 2dd2 A596      		adiw r28,37
 8587 2dd4 0FB6      		in __tmp_reg__,__SREG__
 8588 2dd6 F894      		cli
 8589 2dd8 DEBF      		out __SP_H__,r29
 8590 2dda 0FBE      		out __SREG__,__tmp_reg__
 8591 2ddc CDBF      		out __SP_L__,r28
 8592 2dde DF91      		pop r29
 8593 2de0 CF91      		pop r28
 8594 2de2 1F91      		pop r17
 8595 2de4 0F91      		pop r16
 8596 2de6 FF90      		pop r15
 8597 2de8 EF90      		pop r14
 8598 2dea DF90      		pop r13
 8599 2dec 0895      		ret
 8600               	.LVL628:
 8601               	.L1024:
 8602               	.LBB656:
 990:main.c        ****     const uchar nr_bloku =
 8603               		.loc 1 990 0
 8604 2dee 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8605 2df2 8111      		cpse r24,__zero_reg__
 8606 2df4 00C0      		rjmp .L939
 990:main.c        ****     const uchar nr_bloku =
 8607               		.loc 1 990 0 is_stmt 0 discriminator 2
 8608 2df6 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8609 2dfa 8111      		cpse r24,__zero_reg__
 8610 2dfc 00C0      		rjmp .L939
 990:main.c        ****     const uchar nr_bloku =
 8611               		.loc 1 990 0 discriminator 4
 8612 2dfe 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 8613 2e02 8111      		cpse r24,__zero_reg__
 8614 2e04 00C0      		rjmp .L939
 990:main.c        ****     const uchar nr_bloku =
 8615               		.loc 1 990 0 discriminator 6
 8616 2e06 F99B      		sbis 0x1f,1
 8617 2e08 00C0      		rjmp .L940
 8618               	.L939:
 990:main.c        ****     const uchar nr_bloku =
 8619               		.loc 1 990 0 discriminator 7
 8620 2e0a 812F      		mov r24,r17
 8621 2e0c 00C0      		rjmp .L1027
 8622               	.L940:
 991:main.c        ****         aktualnie_wykonywana_komenda - KOMENDA_KOLEJKI_RESET_USTAWIEN_0;
 8623               		.loc 1 991 0 is_stmt 1
 8624 2e0e 0DEF      		ldi r16,lo8(-3)
 8625 2e10 010F      		add r16,r17
 8626               	.LVL629:
 994:main.c        ****     if (nr_bloku == 0) {
 8627               		.loc 1 994 0
 8628 2e12 40E2      		ldi r20,lo8(32)
 8629 2e14 50E0      		ldi r21,0
 8630 2e16 6FEF      		ldi r22,lo8(-1)
 8631 2e18 70E0      		ldi r23,0
 8632 2e1a 80E0      		ldi r24,lo8(bufor_eeprom)
 8633 2e1c 90E0      		ldi r25,hi8(bufor_eeprom)
 8634 2e1e 0E94 0000 		call memset
 8635               	.LVL630:
 995:main.c        ****       kod_modulu[0] = bufor_eeprom[1] = 'A';
 8636               		.loc 1 995 0
 8637 2e22 0111      		cpse r16,__zero_reg__
 8638 2e24 00C0      		rjmp .L941
 996:main.c        ****       kod_modulu[1] = bufor_eeprom[2] = 'B';
 8639               		.loc 1 996 0
 8640 2e26 81E4      		ldi r24,lo8(65)
 8641 2e28 8093 0000 		sts bufor_eeprom+1,r24
 8642 2e2c 8093 0000 		sts kod_modulu,r24
 997:main.c        ****       kod_modulu[2] = bufor_eeprom[3] = 'C';
 8643               		.loc 1 997 0
 8644 2e30 82E4      		ldi r24,lo8(66)
 8645 2e32 8093 0000 		sts bufor_eeprom+2,r24
 8646 2e36 8093 0000 		sts kod_modulu+1,r24
 998:main.c        ****       kod_modulu[3] = bufor_eeprom[4] = 'D';
 8647               		.loc 1 998 0
 8648 2e3a 83E4      		ldi r24,lo8(67)
 8649 2e3c 8093 0000 		sts bufor_eeprom+3,r24
 8650 2e40 8093 0000 		sts kod_modulu+2,r24
 999:main.c        ****       bufor_eeprom[5] = 0;
 8651               		.loc 1 999 0
 8652 2e44 84E4      		ldi r24,lo8(68)
 8653 2e46 8093 0000 		sts bufor_eeprom+4,r24
 8654 2e4a 8093 0000 		sts kod_modulu+3,r24
1000:main.c        ****       stan_wyjscie[0] = 0;
 8655               		.loc 1 1000 0
 8656 2e4e 1092 0000 		sts bufor_eeprom+5,__zero_reg__
1001:main.c        ****       licznik_przelacznik_wyjscia[0] = 0;
 8657               		.loc 1 1001 0
 8658 2e52 1092 0000 		sts stan_wyjscie,__zero_reg__
1002:main.c        ****     }
 8659               		.loc 1 1002 0
 8660 2e56 1092 0000 		sts licznik_przelacznik_wyjscia,__zero_reg__
 8661 2e5a 1092 0000 		sts licznik_przelacznik_wyjscia+1,__zero_reg__
 8662 2e5e 1092 0000 		sts licznik_przelacznik_wyjscia+2,__zero_reg__
 8663 2e62 1092 0000 		sts licznik_przelacznik_wyjscia+3,__zero_reg__
 8664               	.L941:
1004:main.c        ****         nr_bloku * LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE,
 8665               		.loc 1 1004 0
 8666 2e66 60E2      		ldi r22,lo8(32)
 8667 2e68 20E2      		ldi r18,lo8(32)
 8668 2e6a 029F      		mul r16,r18
 8669 2e6c C001      		movw r24,r0
 8670 2e6e 1124      		clr __zero_reg__
 8671 2e70 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 8672               	.LVL631:
1007:main.c        ****     zapal_diode_led(50);
 8673               		.loc 1 1007 0
 8674 2e74 81E0      		ldi r24,lo8(1)
 8675 2e76 810F      		add r24,r17
 8676 2e78 0E94 0000 		call dodaj_komende
 8677               	.LVL632:
 8678 2e7c 00C0      		rjmp .L1029
 8679               	.LVL633:
 8680               	.L929:
 8681               	.LBE656:
 8682               	.LBB657:
1012:main.c        ****     uchar bledny_zapis = FALSE;
 8683               		.loc 1 1012 0
 8684 2e7e 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8685 2e82 8111      		cpse r24,__zero_reg__
 8686 2e84 00C0      		rjmp .L942
1012:main.c        ****     uchar bledny_zapis = FALSE;
 8687               		.loc 1 1012 0 is_stmt 0 discriminator 2
 8688 2e86 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8689 2e8a 8111      		cpse r24,__zero_reg__
 8690 2e8c 00C0      		rjmp .L942
1012:main.c        ****     uchar bledny_zapis = FALSE;
 8691               		.loc 1 1012 0 discriminator 4
 8692 2e8e F090 0000 		lds r15,czy_zajety_bufor_eeprom
 8693 2e92 F110      		cpse r15,__zero_reg__
 8694 2e94 00C0      		rjmp .L942
1012:main.c        ****     uchar bledny_zapis = FALSE;
 8695               		.loc 1 1012 0 discriminator 6
 8696 2e96 F99B      		sbis 0x1f,1
 8697 2e98 00C0      		rjmp .L992
 8698               	.L942:
1012:main.c        ****     uchar bledny_zapis = FALSE;
 8699               		.loc 1 1012 0 discriminator 7
 8700 2e9a 83E8      		ldi r24,lo8(-125)
 8701 2e9c 00C0      		rjmp .L1027
 8702               	.L992:
 8703               	.LBB658:
1017:main.c        ****       if (eeprom_read_byte((void *)i) !=
 8704               		.loc 1 1017 0 is_stmt 1
 8705 2e9e 10E0      		ldi r17,0
 8706               	.LVL634:
 8707 2ea0 00E0      		ldi r16,0
 8708               	.LVL635:
 8709               	.L943:
1018:main.c        ****           pgm_read_byte(tab_eeprom_fabryczny + i))
 8710               		.loc 1 1018 0
 8711 2ea2 C801      		movw r24,r16
 8712 2ea4 0E94 0000 		call eeprom_read_byte
 8713               	.LVL636:
 8714               	.LBB659:
1019:main.c        ****         bledny_zapis = TRUE;
 8715               		.loc 1 1019 0
 8716 2ea8 F801      		movw r30,r16
 8717 2eaa E050      		subi r30,lo8(-(tab_eeprom_fabryczny.3633))
 8718 2eac F040      		sbci r31,hi8(-(tab_eeprom_fabryczny.3633))
 8719               	.LVL637:
 8720               	/* #APP */
 8721               	 ;  1019 "main.c" 1
 8722 2eae E491      		lpm r30, Z
 8723               		
 8724               	 ;  0 "" 2
 8725               	.LVL638:
 8726               	/* #NOAPP */
 8727               	.LBE659:
1018:main.c        ****           pgm_read_byte(tab_eeprom_fabryczny + i))
 8728               		.loc 1 1018 0
 8729 2eb0 8E17      		cp r24,r30
 8730 2eb2 01F0      		breq .L944
1020:main.c        ****     }
 8731               		.loc 1 1020 0
 8732 2eb4 FF24      		clr r15
 8733 2eb6 FA94      		dec r15
 8734               	.LVL639:
 8735               	.L944:
1017:main.c        ****       if (eeprom_read_byte((void *)i) !=
 8736               		.loc 1 1017 0 discriminator 2
 8737 2eb8 0F5F      		subi r16,-1
 8738 2eba 1F4F      		sbci r17,-1
 8739               	.LVL640:
 8740 2ebc 0630      		cpi r16,6
 8741 2ebe 1105      		cpc r17,__zero_reg__
 8742 2ec0 01F4      		brne .L943
 8743               	.LBE658:
 8744               	.LBB660:
1022:main.c        ****          i < EEPROM_NUMER_TELEFONU_BRAMA_0 +
 8745               		.loc 1 1022 0
 8746 2ec2 08E0      		ldi r16,lo8(8)
 8747 2ec4 10E0      		ldi r17,0
 8748               	.LVL641:
 8749               	.L946:
1027:main.c        ****         bledny_zapis = TRUE;
 8750               		.loc 1 1027 0
 8751 2ec6 C801      		movw r24,r16
 8752 2ec8 0E94 0000 		call eeprom_read_byte
 8753               	.LVL642:
 8754 2ecc 8F3F      		cpi r24,lo8(-1)
 8755 2ece 01F4      		brne .L945
1026:main.c        ****       if (eeprom_read_byte((void *)i) != 0xff) {
 8756               		.loc 1 1026 0
 8757 2ed0 0F5F      		subi r16,-1
 8758 2ed2 1F4F      		sbci r17,-1
 8759               	.LVL643:
1022:main.c        ****          i < EEPROM_NUMER_TELEFONU_BRAMA_0 +
 8760               		.loc 1 1022 0
 8761 2ed4 083A      		cpi r16,-88
 8762 2ed6 8FE0      		ldi r24,15
 8763 2ed8 1807      		cpc r17,r24
 8764 2eda 01F4      		brne .L946
 8765               	.LBE660:
1032:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
 8766               		.loc 1 1032 0
 8767 2edc FF20      		tst r15
 8768 2ede 01F0      		breq .L947
 8769               	.L945:
 8770               	.LVL644:
1033:main.c        ****       break;
 8771               		.loc 1 1033 0
 8772 2ee0 83E0      		ldi r24,lo8(3)
 8773 2ee2 00C0      		rjmp .L1027
 8774               	.LVL645:
 8775               	.L947:
1036:main.c        ****     ustaw_stan_led(FALSE); // Wylacz diode po zakonczeniu resetu
 8776               		.loc 1 1036 0
 8777 2ee4 0E94 0000 		call inicjalizuj_parametry_modulu
 8778               	.LVL646:
1037:main.c        ****     break;
 8779               		.loc 1 1037 0
 8780 2ee8 409A      		sbi 0x8,0
 8781 2eea 00C0      		rjmp .L1026
 8782               	.LVL647:
 8783               	.L934:
 8784               	.LBE657:
 8785               	.LBB661:
1041:main.c        **** 
 8786               		.loc 1 1041 0
 8787 2eec 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8788 2ef0 8111      		cpse r24,__zero_reg__
 8789 2ef2 00C0      		rjmp .L948
1041:main.c        **** 
 8790               		.loc 1 1041 0 is_stmt 0 discriminator 2
 8791 2ef4 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8792 2ef8 8111      		cpse r24,__zero_reg__
 8793 2efa 00C0      		rjmp .L948
1041:main.c        **** 
 8794               		.loc 1 1041 0 discriminator 4
 8795 2efc 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 8796 2f00 8111      		cpse r24,__zero_reg__
 8797 2f02 00C0      		rjmp .L948
1041:main.c        **** 
 8798               		.loc 1 1041 0 discriminator 6
 8799 2f04 F99B      		sbis 0x1f,1
 8800 2f06 00C0      		rjmp .L949
 8801               	.L948:
1041:main.c        **** 
 8802               		.loc 1 1041 0 discriminator 7
 8803 2f08 84E8      		ldi r24,lo8(-124)
 8804 2f0a 00C0      		rjmp .L1027
 8805               	.L949:
1043:main.c        ****       // Poza dozwolonym czasem - ignoruj
 8806               		.loc 1 1043 0 is_stmt 1
 8807 2f0c D090 0000 		lds r13,blokada_sterowania_czasowa
 8808 2f10 D110      		cpse r13,__zero_reg__
 8809 2f12 00C0      		rjmp .L1026
1051:main.c        **** 
 8810               		.loc 1 1051 0
 8811 2f14 8E01      		movw r16,r28
 8812 2f16 0B5E      		subi r16,-21
 8813 2f18 1F4F      		sbci r17,-1
 8814 2f1a 60E0      		ldi r22,lo8(numer_telefonu_ktory_dzwoni)
 8815 2f1c 70E0      		ldi r23,hi8(numer_telefonu_ktory_dzwoni)
 8816 2f1e C801      		movw r24,r16
 8817 2f20 0E94 0000 		call strcpy
 8818               	.LVL648:
1055:main.c        ****         &bufor_eeprom[0]);
 8819               		.loc 1 1055 0
 8820 2f24 F801      		movw r30,r16
 8821               		0:
 8822 2f26 0190      		ld __tmp_reg__,Z+
 8823 2f28 0020      		tst __tmp_reg__
 8824 2f2a 01F4      		brne 0b
 8825 2f2c BF01      		movw r22,r30
 8826 2f2e 6150      		subi r22,1
 8827 2f30 7109      		sbc r23,__zero_reg__
1054:main.c        ****         &numer_lokalny[0], &numer_lokalny[strlen((char *)numer_lokalny)],
 8828               		.loc 1 1054 0
 8829 2f32 40E0      		ldi r20,lo8(bufor_eeprom)
 8830 2f34 50E0      		ldi r21,hi8(bufor_eeprom)
 8831 2f36 C801      		movw r24,r16
 8832 2f38 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 8833               	.LVL649:
1060:main.c        ****       // Tylko w trybie prywatnym sprawdzamy listę
 8834               		.loc 1 1060 0
 8835 2f3c 8091 0000 		lds r24,tryb_pracy
 8836 2f40 8130      		cpi r24,lo8(1)
 8837 2f42 01F0      		breq .L953
 8838 2f44 98E0      		ldi r25,lo8(8)
 8839 2f46 E92E      		mov r14,r25
 8840 2f48 F12C      		mov r15,__zero_reg__
 8841               	.L954:
 8842               	.LBB662:
1064:main.c        ****                 &bufor_eeprom[0],
 8843               		.loc 1 1064 0
 8844 2f4a B701      		movw r22,r14
 8845 2f4c 80E0      		ldi r24,lo8(bufor_eeprom)
 8846 2f4e 90E0      		ldi r25,hi8(bufor_eeprom)
 8847 2f50 0E94 0000 		call porownaj_numer_telefonu_blok
 8848               	.LVL650:
 8849 2f54 8111      		cpse r24,__zero_reg__
 8850 2f56 00C0      		rjmp .L993
 8851               	.LVL651:
 8852 2f58 F5E0      		ldi r31,5
 8853 2f5a EF0E      		add r14,r31
 8854 2f5c F11C      		adc r15,__zero_reg__
1062:main.c        ****            nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 8855               		.loc 1 1062 0
 8856 2f5e 28EA      		ldi r18,-88
 8857 2f60 E216      		cp r14,r18
 8858 2f62 2FE0      		ldi r18,15
 8859 2f64 F206      		cpc r15,r18
 8860 2f66 01F4      		brne .L954
 8861               	.L953:
 8862               	.LVL652:
 8863               	.LBE662:
1075:main.c        ****       wyciagnij_ostatnie_cyfry(numer_lokalny, numer_skrocony, 9);
 8864               		.loc 1 1075 0
 8865 2f68 8091 0000 		lds r24,skryba_wlaczona
 8866 2f6c 8823      		tst r24
 8867 2f6e 01F0      		breq .L955
1075:main.c        ****       wyciagnij_ostatnie_cyfry(numer_lokalny, numer_skrocony, 9);
 8868               		.loc 1 1075 0 is_stmt 0 discriminator 1
 8869 2f70 DD20      		tst r13
 8870 2f72 01F4      		brne .+2
 8871 2f74 00C0      		rjmp .L956
 8872               	.L960:
 8873 2f76 DD24      		clr r13
 8874 2f78 DA94      		dec r13
 8875               	.LVL653:
 8876               	.L955:
1098:main.c        ****                          ADRES_EEPROM_DEBUG_SKRYBA_2); // DEBUG
 8877               		.loc 1 1098 0 is_stmt 1
 8878 2f7a 81E0      		ldi r24,lo8(1)
 8879 2f7c 9091 0000 		lds r25,skryba_wlaczona
 8880 2f80 9111      		cpse r25,__zero_reg__
 8881 2f82 00C0      		rjmp .L962
 8882 2f84 80E0      		ldi r24,0
 8883               	.L962:
 8884 2f86 61EF      		ldi r22,lo8(-15)
 8885 2f88 7FE0      		ldi r23,lo8(15)
 8886 2f8a 0E94 0000 		call zapisz_znak_w_eeprom
 8887               	.LVL654:
1100:main.c        ****                          ADRES_EEPROM_DEBUG_SKRYBA_3); // DEBUG
 8888               		.loc 1 1100 0
 8889 2f8e 81E0      		ldi r24,lo8(1)
 8890 2f90 D110      		cpse r13,__zero_reg__
 8891 2f92 80E0      		ldi r24,0
 8892               	.L963:
 8893 2f94 62EF      		ldi r22,lo8(-14)
 8894 2f96 7FE0      		ldi r23,lo8(15)
 8895 2f98 0E94 0000 		call zapisz_znak_w_eeprom
 8896               	.LVL655:
1103:main.c        ****       uchar len_full = strlen((char *)numer_lokalny);
 8897               		.loc 1 1103 0
 8898 2f9c 8091 0000 		lds r24,skryba_wlaczona
 8899 2fa0 8823      		tst r24
 8900 2fa2 01F0      		breq .L965
1103:main.c        ****       uchar len_full = strlen((char *)numer_lokalny);
 8901               		.loc 1 1103 0 is_stmt 0 discriminator 1
 8902 2fa4 D110      		cpse r13,__zero_reg__
 8903 2fa6 00C0      		rjmp .L965
 8904               	.LBB663:
1104:main.c        **** 
 8905               		.loc 1 1104 0 is_stmt 1
 8906 2fa8 F801      		movw r30,r16
 8907               		0:
 8908 2faa 0190      		ld __tmp_reg__,Z+
 8909 2fac 0020      		tst __tmp_reg__
 8910 2fae 01F4      		brne 0b
 8911 2fb0 3197      		sbiw r30,1
 8912 2fb2 CF01      		movw r24,r30
 8913 2fb4 801B      		sub r24,r16
 8914 2fb6 910B      		sbc r25,r17
 8915 2fb8 182F      		mov r17,r24
 8916               	.LVL656:
1107:main.c        **** 
 8917               		.loc 1 1107 0
 8918 2fba 64EF      		ldi r22,lo8(-12)
 8919 2fbc 7FE0      		ldi r23,lo8(15)
 8920 2fbe 0E94 0000 		call zapisz_znak_w_eeprom
 8921               	.LVL657:
1109:main.c        ****         // Skopiuj skrócony numer do numer_telefonu_skryba
 8922               		.loc 1 1109 0
 8923 2fc2 1330      		cpi r17,lo8(3)
 8924 2fc4 00F0      		brlo .L965
1111:main.c        **** 
 8925               		.loc 1 1111 0
 8926 2fc6 BE01      		movw r22,r28
 8927 2fc8 6F5F      		subi r22,-1
 8928 2fca 7F4F      		sbci r23,-1
 8929 2fcc 80E0      		ldi r24,lo8(numer_telefonu_skryba)
 8930 2fce 90E0      		ldi r25,hi8(numer_telefonu_skryba)
 8931 2fd0 0E94 0000 		call strcpy
 8932               	.LVL658:
1114:main.c        ****           zapisz_znak_w_eeprom(
 8933               		.loc 1 1114 0
 8934 2fd4 80E0      		ldi r24,lo8(numer_telefonu_skryba)
 8935 2fd6 90E0      		ldi r25,hi8(numer_telefonu_skryba)
 8936 2fd8 FC01      		movw r30,r24
 8937               		0:
 8938 2fda 0190      		ld __tmp_reg__,Z+
 8939 2fdc 0020      		tst __tmp_reg__
 8940 2fde 01F4      		brne 0b
 8941 2fe0 CF01      		movw r24,r30
 8942 2fe2 8050      		subi r24,lo8(numer_telefonu_skryba+1)
 8943 2fe4 9040      		sbci r25,hi8(numer_telefonu_skryba+1)
 8944 2fe6 0397      		sbiw r24,3
 8945 2fe8 00F0      		brlo .L965
1115:main.c        ****               1, ADRES_EEPROM_DEBUG_SKRYBA_4); // DEBUG: komenda dodana
 8946               		.loc 1 1115 0
 8947 2fea 63EF      		ldi r22,lo8(-13)
 8948 2fec 7FE0      		ldi r23,lo8(15)
 8949 2fee 81E0      		ldi r24,lo8(1)
 8950 2ff0 0E94 0000 		call zapisz_znak_w_eeprom
 8951               	.LVL659:
1119:main.c        ****         }
 8952               		.loc 1 1119 0
 8953 2ff4 86E8      		ldi r24,lo8(-122)
 8954 2ff6 0E94 0000 		call dodaj_komende
 8955               	.LVL660:
 8956               	.L965:
 8957               	.LBE663:
1125:main.c        ****       if (tryb_pracy == 1) {
 8958               		.loc 1 1125 0
 8959 2ffa 8091 0000 		lds r24,tryb_clip
 8960 2ffe 8823      		tst r24
 8961 3000 01F4      		brne .+2
 8962 3002 00C0      		rjmp .L1026
1126:main.c        ****         // Tryb publiczny - otwórz dla każdego
 8963               		.loc 1 1126 0
 8964 3004 8091 0000 		lds r24,tryb_pracy
 8965 3008 8130      		cpi r24,lo8(1)
 8966 300a 01F0      		breq .+2
 8967 300c 00C0      		rjmp .L968
 8968               	.L969:
1128:main.c        ****       } else if (znaleziono) {
 8969               		.loc 1 1128 0
 8970 300e 0E94 0000 		call ustaw_wyjscie_clip
 8971               	.LVL661:
 8972 3012 00C0      		rjmp .L1026
 8973               	.LVL662:
 8974               	.L993:
 8975               	.LBB664:
1067:main.c        ****           break;
 8976               		.loc 1 1067 0
 8977 3014 DD24      		clr r13
 8978 3016 DA94      		dec r13
 8979 3018 00C0      		rjmp .L953
 8980               	.LVL663:
 8981               	.L956:
 8982               	.LBE664:
 8983               	.LBB665:
 8984               	.LBB666:
 814:main.c        **** 
 8985               		.loc 1 814 0
 8986 301a F801      		movw r30,r16
 8987               		0:
 8988 301c 0190      		ld __tmp_reg__,Z+
 8989 301e 0020      		tst __tmp_reg__
 8990 3020 01F4      		brne 0b
 8991 3022 3197      		sbiw r30,1
 8992 3024 E01B      		sub r30,r16
 8993 3026 F10B      		sbc r31,r17
 8994               	.LVL664:
 8995 3028 CE01      		movw r24,r28
 8996 302a 0196      		adiw r24,1
 8997 302c 7C01      		movw r14,r24
 816:main.c        ****     // Take last max_digits
 8998               		.loc 1 816 0
 8999 302e EA30      		cpi r30,lo8(10)
 9000 3030 00F0      		brlo .L957
 818:main.c        ****   } else {
 9001               		.loc 1 818 0
 9002 3032 E950      		subi r30,9
 9003 3034 FF0B      		sbc r31,r31
 9004               	.LVL665:
 9005 3036 B801      		movw r22,r16
 9006 3038 6E0F      		add r22,r30
 9007 303a 7F1F      		adc r23,r31
 9008               	.L1025:
 821:main.c        ****   }
 9009               		.loc 1 821 0
 9010 303c 0E94 0000 		call strcpy
 9011               	.LVL666:
 9012               	.LBE666:
 9013               	.LBE665:
1080:main.c        ****           &bufor_eeprom[0]);
 9014               		.loc 1 1080 0
 9015 3040 F701      		movw r30,r14
 9016               		0:
 9017 3042 0190      		ld __tmp_reg__,Z+
 9018 3044 0020      		tst __tmp_reg__
 9019 3046 01F4      		brne 0b
 9020 3048 BF01      		movw r22,r30
 9021 304a 6150      		subi r22,1
 9022 304c 7109      		sbc r23,__zero_reg__
1079:main.c        ****           &numer_skrocony[0], &numer_skrocony[strlen((char *)numer_skrocony)],
 9023               		.loc 1 1079 0
 9024 304e 40E0      		ldi r20,lo8(bufor_eeprom)
 9025 3050 50E0      		ldi r21,hi8(bufor_eeprom)
 9026 3052 C701      		movw r24,r14
 9027 3054 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9028               	.LVL667:
1083:main.c        ****         for (uint nr_uzyt_clip = 0;
 9029               		.loc 1 1083 0
 9030 3058 8091 0000 		lds r24,tryb_pracy
 9031 305c 8130      		cpi r24,lo8(1)
 9032 305e 01F4      		brne .+2
 9033 3060 00C0      		rjmp .L955
 9034 3062 88E0      		ldi r24,lo8(8)
 9035 3064 E82E      		mov r14,r24
 9036 3066 F12C      		mov r15,__zero_reg__
 9037               	.L959:
 9038               	.LBB668:
1087:main.c        ****                   &bufor_eeprom[0],
 9039               		.loc 1 1087 0
 9040 3068 B701      		movw r22,r14
 9041 306a 80E0      		ldi r24,lo8(bufor_eeprom)
 9042 306c 90E0      		ldi r25,hi8(bufor_eeprom)
 9043 306e 0E94 0000 		call porownaj_numer_telefonu_blok
 9044               	.LVL668:
 9045 3072 8111      		cpse r24,__zero_reg__
 9046 3074 00C0      		rjmp .L960
 9047               	.LVL669:
 9048 3076 F5E0      		ldi r31,5
 9049 3078 EF0E      		add r14,r31
 9050 307a F11C      		adc r15,__zero_reg__
1084:main.c        ****              nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 9051               		.loc 1 1084 0
 9052 307c 28EA      		ldi r18,-88
 9053 307e E216      		cp r14,r18
 9054 3080 2FE0      		ldi r18,15
 9055 3082 F206      		cpc r15,r18
 9056 3084 01F4      		brne .L959
 9057 3086 00C0      		rjmp .L955
 9058               	.LVL670:
 9059               	.L957:
 9060               	.LBE668:
 9061               	.LBB669:
 9062               	.LBB667:
 821:main.c        ****   }
 9063               		.loc 1 821 0
 9064 3088 B801      		movw r22,r16
 9065 308a 00C0      		rjmp .L1025
 9066               	.LVL671:
 9067               	.L968:
 9068               	.LBE667:
 9069               	.LBE669:
1129:main.c        ****         // Tryb prywatny - otwórz tylko dla znalezionych
 9070               		.loc 1 1129 0
 9071 308c DD20      		tst r13
 9072 308e 01F4      		brne .+2
 9073 3090 00C0      		rjmp .L1026
 9074 3092 00C0      		rjmp .L969
 9075               	.LVL672:
 9076               	.L933:
 9077               	.LBE661:
 9078               	.LBB670:
1139:main.c        **** 
 9079               		.loc 1 1139 0
 9080 3094 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 9081 3098 8111      		cpse r24,__zero_reg__
 9082 309a 00C0      		rjmp .L970
1139:main.c        **** 
 9083               		.loc 1 1139 0 is_stmt 0 discriminator 2
 9084 309c 8091 0000 		lds r24,liczba_znakow_do_zapisu
 9085 30a0 8111      		cpse r24,__zero_reg__
 9086 30a2 00C0      		rjmp .L970
1139:main.c        **** 
 9087               		.loc 1 1139 0 discriminator 4
 9088 30a4 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 9089 30a8 8111      		cpse r24,__zero_reg__
 9090 30aa 00C0      		rjmp .L970
1139:main.c        **** 
 9091               		.loc 1 1139 0 discriminator 6
 9092 30ac F99B      		sbis 0x1f,1
 9093 30ae 00C0      		rjmp .L971
 9094               	.L970:
1139:main.c        **** 
 9095               		.loc 1 1139 0 discriminator 7
 9096 30b0 85E8      		ldi r24,lo8(-123)
 9097 30b2 00C0      		rjmp .L1027
 9098               	.L971:
1142:main.c        ****       return TRUE; // Duplicate found, abort
 9099               		.loc 1 1142 0 is_stmt 1
 9100 30b4 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 9101 30b6 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 9102 30b8 0E94 0000 		call czy_numer_istnieje
 9103               	.LVL673:
 9104 30bc 8111      		cpse r24,__zero_reg__
 9105 30be 00C0      		rjmp .L1026
1151:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
 9106               		.loc 1 1151 0
 9107 30c0 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 9108 30c2 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 9109 30c4 FB01      		movw r30,r22
 9110               		0:
 9111 30c6 0190      		ld __tmp_reg__,Z+
 9112 30c8 0020      		tst __tmp_reg__
 9113 30ca 01F4      		brne 0b
 9114 30cc BF01      		movw r22,r30
 9115 30ce 6150      		subi r22,1
 9116 30d0 7109      		sbc r23,__zero_reg__
1149:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
 9117               		.loc 1 1149 0
 9118 30d2 40E0      		ldi r20,lo8(bufor_eeprom)
 9119 30d4 50E0      		ldi r21,hi8(bufor_eeprom)
 9120 30d6 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 9121 30d8 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 9122 30da 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9123               	.LVL674:
 9124 30de 08E0      		ldi r16,lo8(8)
 9125 30e0 10E0      		ldi r17,0
 9126               	.LVL675:
 9127               	.L976:
 9128               	.LBB671:
1158:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
 9129               		.loc 1 1158 0
 9130 30e2 C801      		movw r24,r16
 9131 30e4 0E94 0000 		call eeprom_read_byte
 9132               	.LVL676:
 9133 30e8 8F3F      		cpi r24,lo8(-1)
 9134 30ea 01F4      		brne .L973
1159:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
 9135               		.loc 1 1159 0
 9136 30ec 65E0      		ldi r22,lo8(5)
 9137 30ee C801      		movw r24,r16
 9138 30f0 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 9139               	.LVL677:
 9140               	.LBE671:
1168:main.c        ****       // Policz aktywnych uzytkownikow
 9141               		.loc 1 1168 0
 9142 30f4 8091 0000 		lds r24,skryba_wlaczona
 9143 30f8 08E0      		ldi r16,lo8(8)
 9144 30fa 10E0      		ldi r17,0
 9145               	.LBB672:
1170:main.c        ****       for (uint i = 0; i < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++i) {
 9146               		.loc 1 1170 0
 9147 30fc F12C      		mov r15,__zero_reg__
 9148 30fe E12C      		mov r14,__zero_reg__
 9149               	.LBE672:
1168:main.c        ****       // Policz aktywnych uzytkownikow
 9150               		.loc 1 1168 0
 9151 3100 8823      		tst r24
 9152 3102 01F4      		brne .+2
 9153 3104 00C0      		rjmp .L1026
 9154               	.L974:
 9155               	.LVL678:
 9156               	.LBB674:
 9157               	.LBB673:
1172:main.c        ****           ++aktywne_numery;
 9158               		.loc 1 1172 0
 9159 3106 C801      		movw r24,r16
 9160 3108 0E94 0000 		call eeprom_read_byte
 9161               	.LVL679:
 9162 310c 8F3F      		cpi r24,lo8(-1)
 9163 310e 01F0      		breq .L977
1173:main.c        ****         }
 9164               		.loc 1 1173 0
 9165 3110 2FEF      		ldi r18,-1
 9166 3112 E21A      		sub r14,r18
 9167 3114 F20A      		sbc r15,r18
 9168               	.LVL680:
 9169               	.L977:
 9170 3116 0B5F      		subi r16,-5
 9171 3118 1F4F      		sbci r17,-1
1171:main.c        ****         if (czy_aktywny_numer_telefonu_brama(i)) {
 9172               		.loc 1 1171 0 discriminator 2
 9173 311a 083A      		cpi r16,-88
 9174 311c 8FE0      		ldi r24,15
 9175 311e 1807      		cpc r17,r24
 9176 3120 01F4      		brne .L974
 9177               	.LVL681:
 9178               	.L1031:
 9179               	.LBE673:
 9180               	.LBE674:
 9181               	.LBE670:
 9182               	.LBB676:
 9183               	.LBB677:
1234:main.c        ****         skryba_wlaczona = FALSE;
 9184               		.loc 1 1234 0
 9185 3122 8091 0000 		lds r24,skryba_limit
 9186 3126 9091 0000 		lds r25,skryba_limit+1
 9187 312a E816      		cp r14,r24
 9188 312c F906      		cpc r15,r25
 9189 312e 00F4      		brsh .+2
 9190 3130 00C0      		rjmp .L1026
1235:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_SKRYBA);
 9191               		.loc 1 1235 0
 9192 3132 1092 0000 		sts skryba_wlaczona,__zero_reg__
1236:main.c        **** 
 9193               		.loc 1 1236 0
 9194 3136 69EF      		ldi r22,lo8(-7)
 9195 3138 7FE0      		ldi r23,lo8(15)
 9196 313a 80E0      		ldi r24,0
 9197 313c 0E94 0000 		call zapisz_znak_w_eeprom
 9198               	.LVL682:
1238:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_TRYB_PRACY);
 9199               		.loc 1 1238 0
 9200 3140 1092 0000 		sts tryb_pracy,__zero_reg__
1239:main.c        ****       }
 9201               		.loc 1 1239 0
 9202 3144 6EEF      		ldi r22,lo8(-2)
 9203 3146 7FE0      		ldi r23,lo8(15)
 9204 3148 80E0      		ldi r24,0
 9205 314a 0E94 0000 		call zapisz_znak_w_eeprom
 9206               	.LVL683:
 9207 314e 00C0      		rjmp .L1026
 9208               	.LVL684:
 9209               	.L973:
 9210 3150 0B5F      		subi r16,-5
 9211 3152 1F4F      		sbci r17,-1
 9212               	.LBE677:
 9213               	.LBE676:
 9214               	.LBB683:
 9215               	.LBB675:
1156:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 9216               		.loc 1 1156 0
 9217 3154 083A      		cpi r16,-88
 9218 3156 FFE0      		ldi r31,15
 9219 3158 1F07      		cpc r17,r31
 9220 315a 01F4      		brne .L976
 9221 315c 00C0      		rjmp .L1026
 9222               	.LVL685:
 9223               	.L935:
 9224               	.LBE675:
 9225               	.LBE683:
 9226               	.LBB684:
1189:main.c        **** 
 9227               		.loc 1 1189 0
 9228 315e 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 9229 3162 8111      		cpse r24,__zero_reg__
 9230 3164 00C0      		rjmp .L978
1189:main.c        **** 
 9231               		.loc 1 1189 0 is_stmt 0 discriminator 2
 9232 3166 8091 0000 		lds r24,liczba_znakow_do_zapisu
 9233 316a 8111      		cpse r24,__zero_reg__
 9234 316c 00C0      		rjmp .L978
1189:main.c        **** 
 9235               		.loc 1 1189 0 discriminator 4
 9236 316e 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 9237 3172 8111      		cpse r24,__zero_reg__
 9238 3174 00C0      		rjmp .L978
1189:main.c        **** 
 9239               		.loc 1 1189 0 discriminator 6
 9240 3176 F99B      		sbis 0x1f,1
 9241 3178 00C0      		rjmp .L979
 9242               	.L978:
1189:main.c        **** 
 9243               		.loc 1 1189 0 discriminator 7
 9244 317a 86E8      		ldi r24,lo8(-122)
 9245 317c 00C0      		rjmp .L1027
 9246               	.L979:
1197:main.c        ****         bufor_skryba);
 9247               		.loc 1 1197 0 is_stmt 1
 9248 317e 60E0      		ldi r22,lo8(numer_telefonu_skryba)
 9249 3180 70E0      		ldi r23,hi8(numer_telefonu_skryba)
 9250 3182 FB01      		movw r30,r22
 9251               		0:
 9252 3184 0190      		ld __tmp_reg__,Z+
 9253 3186 0020      		tst __tmp_reg__
 9254 3188 01F4      		brne 0b
 9255 318a BF01      		movw r22,r30
 9256 318c 6150      		subi r22,1
 9257 318e 7109      		sbc r23,__zero_reg__
1195:main.c        ****         &numer_telefonu_skryba[0],
 9258               		.loc 1 1195 0
 9259 3190 AE01      		movw r20,r28
 9260 3192 4F5F      		subi r20,-1
 9261 3194 5F4F      		sbci r21,-1
 9262 3196 80E0      		ldi r24,lo8(numer_telefonu_skryba)
 9263 3198 90E0      		ldi r25,hi8(numer_telefonu_skryba)
 9264 319a 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9265               	.LVL686:
1203:main.c        ****       return TRUE; // Duplicate found, abort
 9266               		.loc 1 1203 0
 9267 319e 80E0      		ldi r24,lo8(numer_telefonu_skryba)
 9268 31a0 90E0      		ldi r25,hi8(numer_telefonu_skryba)
 9269 31a2 0E94 0000 		call czy_numer_istnieje
 9270               	.LVL687:
 9271 31a6 8111      		cpse r24,__zero_reg__
 9272 31a8 00C0      		rjmp .L1026
1208:main.c        **** 
 9273               		.loc 1 1208 0
 9274 31aa 85E0      		ldi r24,lo8(5)
 9275 31ac FE01      		movw r30,r28
 9276 31ae 3196      		adiw r30,1
 9277 31b0 A0E0      		ldi r26,lo8(bufor_eeprom)
 9278 31b2 B0E0      		ldi r27,hi8(bufor_eeprom)
 9279               		0:
 9280 31b4 0190      		ld r0,Z+
 9281 31b6 0D92      		st X+,r0
 9282 31b8 8A95      		dec r24
 9283 31ba 01F4      		brne 0b
 9284               	.LVL688:
 9285 31bc 08E0      		ldi r16,lo8(8)
 9286 31be 10E0      		ldi r17,0
 9287               	.LVL689:
 9288               	.L984:
 9289               	.LBB679:
1213:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
 9290               		.loc 1 1213 0
 9291 31c0 C801      		movw r24,r16
 9292 31c2 0E94 0000 		call eeprom_read_byte
 9293               	.LVL690:
 9294 31c6 8F3F      		cpi r24,lo8(-1)
 9295 31c8 01F4      		brne .L981
1214:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
 9296               		.loc 1 1214 0
 9297 31ca 65E0      		ldi r22,lo8(5)
 9298 31cc C801      		movw r24,r16
 9299 31ce 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 9300               	.LVL691:
 9301               	.LBE679:
1224:main.c        ****       // Policz aktywnych uzytkownikow
 9302               		.loc 1 1224 0
 9303 31d2 8091 0000 		lds r24,skryba_wlaczona
 9304 31d6 08E0      		ldi r16,lo8(8)
 9305 31d8 10E0      		ldi r17,0
 9306               	.LBB680:
1226:main.c        ****       for (uint i = 0; i < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++i) {
 9307               		.loc 1 1226 0
 9308 31da F12C      		mov r15,__zero_reg__
 9309 31dc E12C      		mov r14,__zero_reg__
 9310               	.LBE680:
1224:main.c        ****       // Policz aktywnych uzytkownikow
 9311               		.loc 1 1224 0
 9312 31de 8823      		tst r24
 9313 31e0 01F4      		brne .+2
 9314 31e2 00C0      		rjmp .L1026
 9315               	.L982:
 9316               	.LVL692:
 9317               	.LBB681:
 9318               	.LBB678:
1228:main.c        ****           ++aktywne_numery;
 9319               		.loc 1 1228 0
 9320 31e4 C801      		movw r24,r16
 9321 31e6 0E94 0000 		call eeprom_read_byte
 9322               	.LVL693:
 9323 31ea 8F3F      		cpi r24,lo8(-1)
 9324 31ec 01F0      		breq .L986
1229:main.c        ****         }
 9325               		.loc 1 1229 0
 9326 31ee 2FEF      		ldi r18,-1
 9327 31f0 E21A      		sub r14,r18
 9328 31f2 F20A      		sbc r15,r18
 9329               	.LVL694:
 9330               	.L986:
 9331 31f4 0B5F      		subi r16,-5
 9332 31f6 1F4F      		sbci r17,-1
1227:main.c        ****         if (czy_aktywny_numer_telefonu_brama(i)) {
 9333               		.loc 1 1227 0 discriminator 2
 9334 31f8 083A      		cpi r16,-88
 9335 31fa 8FE0      		ldi r24,15
 9336 31fc 1807      		cpc r17,r24
 9337 31fe 01F4      		brne .L982
 9338 3200 00C0      		rjmp .L1031
 9339               	.LVL695:
 9340               	.L981:
 9341 3202 0B5F      		subi r16,-5
 9342 3204 1F4F      		sbci r17,-1
 9343               	.LBE678:
 9344               	.LBE681:
 9345               	.LBB682:
1211:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 9346               		.loc 1 1211 0
 9347 3206 083A      		cpi r16,-88
 9348 3208 FFE0      		ldi r31,15
 9349 320a 1F07      		cpc r17,r31
 9350 320c 01F4      		brne .L984
 9351 320e 00C0      		rjmp .L1026
 9352               	.LVL696:
 9353               	.L988:
 9354               	.LBE682:
 9355               	.LBE684:
1246:main.c        ****                                          numer_telefonu_do_ktorego_dzwonic)],
 9356               		.loc 1 1246 0
 9357 3210 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 9358 3212 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 9359 3214 FB01      		movw r30,r22
 9360               		0:
 9361 3216 0190      		ld __tmp_reg__,Z+
 9362 3218 0020      		tst __tmp_reg__
 9363 321a 01F4      		brne 0b
 9364 321c BF01      		movw r22,r30
 9365 321e 6150      		subi r22,1
 9366 3220 7109      		sbc r23,__zero_reg__
1245:main.c        ****                                      &numer_telefonu_do_ktorego_dzwonic[strlen(
 9367               		.loc 1 1245 0
 9368 3222 40E0      		ldi r20,lo8(bufor_eeprom)
 9369 3224 50E0      		ldi r21,hi8(bufor_eeprom)
 9370 3226 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 9371 3228 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 9372 322a 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9373               	.LVL697:
 9374 322e 08E0      		ldi r16,lo8(8)
 9375 3230 10E0      		ldi r17,0
 9376               	.LVL698:
 9377               	.L990:
 9378               	.LBB685:
1253:main.c        ****               &bufor_eeprom[0], // 1 porwnanie zajmuje ~10us, czyli 170 numerw ~
 9379               		.loc 1 1253 0
 9380 3232 B801      		movw r22,r16
 9381 3234 80E0      		ldi r24,lo8(bufor_eeprom)
 9382 3236 90E0      		ldi r25,hi8(bufor_eeprom)
 9383 3238 0E94 0000 		call porownaj_numer_telefonu_blok
 9384               	.LVL699:
 9385 323c 8823      		tst r24
 9386 323e 01F0      		breq .L989
1257:main.c        ****         konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 9387               		.loc 1 1257 0
 9388 3240 1092 0000 		sts numer_telefonu_do_ktorego_dzwonic,__zero_reg__
1258:main.c        ****                                          &numer_telefonu_do_ktorego_dzwonic[1],
 9389               		.loc 1 1258 0
 9390 3244 40E0      		ldi r20,lo8(bufor_eeprom)
 9391 3246 50E0      		ldi r21,hi8(bufor_eeprom)
 9392 3248 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic+1)
 9393 324a 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic+1)
 9394 324c 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 9395 324e 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 9396 3250 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9397               	.LVL700:
1261:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
 9398               		.loc 1 1261 0
 9399 3254 65E0      		ldi r22,lo8(5)
 9400 3256 C801      		movw r24,r16
 9401 3258 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 9402               	.LVL701:
 9403 325c 00C0      		rjmp .L1026
 9404               	.L989:
 9405 325e 0B5F      		subi r16,-5
 9406 3260 1F4F      		sbci r17,-1
1251:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 9407               		.loc 1 1251 0
 9408 3262 083A      		cpi r16,-88
 9409 3264 FFE0      		ldi r31,15
 9410 3266 1F07      		cpc r17,r31
 9411 3268 01F4      		brne .L990
 9412 326a 00C0      		rjmp .L1026
 9413               	.LBE685:
 9414               		.cfi_endproc
 9415               	.LFE58:
 9417               	.global	wykonanie_komend
 9419               	wykonanie_komend:
 9420               	.LFB60:
1341:main.c        ****   if (wykonanie_komend_SIM900())
 9421               		.loc 1 1341 0
 9422               		.cfi_startproc
 9423               	/* prologue: function */
 9424               	/* frame size = 0 */
 9425               	/* stack size = 0 */
 9426               	.L__stack_usage = 0
1342:main.c        ****     ;
 9427               		.loc 1 1342 0
 9428 326c 0E94 0000 		call wykonanie_komend_SIM900
 9429               	.LVL702:
 9430 3270 8111      		cpse r24,__zero_reg__
 9431 3272 00C0      		rjmp .L1034
1344:main.c        ****     ;
 9432               		.loc 1 1344 0
 9433 3274 0E94 0000 		call wykonanie_komend_ukladow
 9434               	.LVL703:
 9435 3278 8111      		cpse r24,__zero_reg__
 9436 327a 00C0      		rjmp .L1034
1346:main.c        ****     ;
 9437               		.loc 1 1346 0
 9438 327c 0E94 0000 		call wykonanie_komend_powiadomien
 9439               	.LVL704:
 9440               	.L1034:
1350:main.c        **** }
 9441               		.loc 1 1350 0
 9442 3280 0C94 0000 		jmp usun_komende
 9443               	.LVL705:
 9444               		.cfi_endproc
 9445               	.LFE60:
 9447               		.section	.text.startup,"ax",@progbits
 9448               	.global	main
 9450               	main:
 9451               	.LFB70:
1749:main.c        **** 
1750:main.c        **** #include "test_debug.h"
1751:main.c        **** 
1752:main.c        **** int main(void) {
 9452               		.loc 1 1752 0
 9453               		.cfi_startproc
 9454               	/* prologue: function */
 9455               	/* frame size = 0 */
 9456               	/* stack size = 0 */
 9457               	.L__stack_usage = 0
 9458               	.LVL706:
 9459               	.LBB686:
 9460               	.LBB687:
 9461               		.loc 7 473 0
 9462 0000 88E1      		ldi r24,lo8(24)
 9463 0002 9BE0      		ldi r25,lo8(11)
 9464               	/* #APP */
 9465               	 ;  473 "/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h" 1
 9466 0004 0FB6      		in __tmp_reg__,__SREG__
 9467 0006 F894      		cli
 9468 0008 A895      		wdr
 9469 000a 8093 6000 		sts 96, r24
 9470 000e 0FBE      		out __SREG__,__tmp_reg__
 9471 0010 9093 6000 		sts 96, r25
 9472               	 	
 9473               	 ;  0 "" 2
 9474               	.LVL707:
 9475               	/* #NOAPP */
 9476               	.LBE687:
 9477               	.LBE686:
1753:main.c        ****   // POMOC_DODAJ2('*', 'u');
1754:main.c        ****   { // inicjalizacja
1755:main.c        **** #ifndef DEBUG
1756:main.c        ****     wdt_enable(WDTO_120MS);
1757:main.c        ****     opoznienie_startowe();
 9478               		.loc 1 1757 0
 9479 0014 0E94 0000 		call opoznienie_startowe
 9480               	.LVL708:
1758:main.c        ****     opoznienie_startowe();
 9481               		.loc 1 1758 0
 9482 0018 0E94 0000 		call opoznienie_startowe
 9483               	.LVL709:
1759:main.c        ****     opoznienie_startowe();
 9484               		.loc 1 1759 0
 9485 001c 0E94 0000 		call opoznienie_startowe
 9486               	.LVL710:
1760:main.c        ****     opoznienie_startowe();
 9487               		.loc 1 1760 0
 9488 0020 0E94 0000 		call opoznienie_startowe
 9489               	.LVL711:
1761:main.c        **** #endif
1762:main.c        ****     inicjalizacja_portow();
 9490               		.loc 1 1762 0
 9491 0024 81E0      		ldi r24,lo8(1)
 9492 0026 87B9      		out 0x7,r24
 9493 0028 88B9      		out 0x8,r24
 9494 002a 80E2      		ldi r24,lo8(32)
 9495 002c 8AB9      		out 0xa,r24
1763:main.c        ****     inicjalizuj_parametry_modulu();
 9496               		.loc 1 1763 0
 9497 002e 0E94 0000 		call inicjalizuj_parametry_modulu
 9498               	.LVL712:
1764:main.c        ****     inicjalizacja_SIM900();
 9499               		.loc 1 1764 0
 9500 0032 0E94 0000 		call inicjalizacja_SIM900
 9501               	.LVL713:
1765:main.c        **** #ifdef DEBUG
1766:main.c        ****     debug_main();
1767:main.c        **** #endif
1768:main.c        ****     ustaw_parametry_dla_bezpieczenstwa();
 9502               		.loc 1 1768 0
 9503 0036 0E94 0000 		call ustaw_parametry_dla_bezpieczenstwa
 9504               	.LVL714:
1769:main.c        ****   }
1770:main.c        **** 
1771:main.c        ****   sei();
 9505               		.loc 1 1771 0
 9506               	/* #APP */
 9507               	 ;  1771 "main.c" 1
 9508 003a 7894      		sei
 9509               	 ;  0 "" 2
 9510               	/* #NOAPP */
 9511               	.L1041:
1772:main.c        **** 
1773:main.c        ****   for (;;) {
1774:main.c        ****     // wykonanie watkw moe trwa maksymalnie 10 ms
1775:main.c        ****     if (CZY_WYKONAC_WATKI_10MS())
 9512               		.loc 1 1775 0
 9513 003c 8091 0000 		lds r24,wykonac_watki
 9514 0040 80FD      		sbrc r24,0
1776:main.c        ****       ustaw_parametry_dla_bezpieczenstwa();
 9515               		.loc 1 1776 0
 9516 0042 0E94 0000 		call ustaw_parametry_dla_bezpieczenstwa
 9517               	.LVL715:
 9518               	.L1037:
1777:main.c        ****     if (CZY_WYKONAC_WATKI_100MS()) {
 9519               		.loc 1 1777 0
 9520 0046 8091 0000 		lds r24,wykonac_watki
 9521 004a 81FD      		sbrc r24,1
1778:main.c        ****       steruj_urzadzeniem_100MS();
 9522               		.loc 1 1778 0
 9523 004c 0E94 0000 		call steruj_urzadzeniem_100MS
 9524               	.LVL716:
 9525               	.L1038:
1779:main.c        **** #ifdef TEST_PCB
1780:main.c        ****       testPCB();
1781:main.c        **** #endif
1782:main.c        ****     }
1783:main.c        ****     if (CZY_WYKONAC_WATKI_10MS()) {
 9526               		.loc 1 1783 0
 9527 0050 8091 0000 		lds r24,wykonac_watki
 9528 0054 80FF      		sbrs r24,0
 9529 0056 00C0      		rjmp .L1039
1784:main.c        ****       steruj_urzadzeniem_10MS();
 9530               		.loc 1 1784 0
 9531 0058 0E94 0000 		call steruj_urzadzeniem_10MS
 9532               	.LVL717:
1785:main.c        ****       wykonanie_komend();
 9533               		.loc 1 1785 0
 9534 005c 0E94 0000 		call wykonanie_komend
 9535               	.LVL718:
1786:main.c        **** 
1787:main.c        ****       RESETUJ_WYKONANIE_WATKOW();
 9536               		.loc 1 1787 0
 9537 0060 1092 0000 		sts wykonac_watki,__zero_reg__
 9538               	.L1039:
1788:main.c        ****     }
1789:main.c        **** 
1790:main.c        ****     { // tryb SLEEP
1791:main.c        ****       cli();
 9539               		.loc 1 1791 0
 9540               	/* #APP */
 9541               	 ;  1791 "main.c" 1
 9542 0064 F894      		cli
 9543               	 ;  0 "" 2
1792:main.c        ****       if (!wykonaj_zdarzenie_timer) {
 9544               		.loc 1 1792 0
 9545               	/* #NOAPP */
 9546 0066 8091 0000 		lds r24,wykonaj_zdarzenie_timer
 9547 006a 8111      		cpse r24,__zero_reg__
 9548 006c 00C0      		rjmp .L1040
1793:main.c        ****         sleep_enable();
 9549               		.loc 1 1793 0
 9550 006e 83B7      		in r24,0x33
 9551 0070 8160      		ori r24,lo8(1)
 9552 0072 83BF      		out 0x33,r24
1794:main.c        ****         sei();
 9553               		.loc 1 1794 0
 9554               	/* #APP */
 9555               	 ;  1794 "main.c" 1
 9556 0074 7894      		sei
 9557               	 ;  0 "" 2
1795:main.c        ****         sleep_cpu();
 9558               		.loc 1 1795 0
 9559               	 ;  1795 "main.c" 1
 9560 0076 8895      		sleep
 9561               		
 9562               	 ;  0 "" 2
1796:main.c        ****         cli();
 9563               		.loc 1 1796 0
 9564               	 ;  1796 "main.c" 1
 9565 0078 F894      		cli
 9566               	 ;  0 "" 2
1797:main.c        ****         sleep_disable();
 9567               		.loc 1 1797 0
 9568               	/* #NOAPP */
 9569 007a 83B7      		in r24,0x33
 9570 007c 8E7F      		andi r24,lo8(-2)
 9571 007e 83BF      		out 0x33,r24
 9572               	.L1040:
1798:main.c        ****       }
1799:main.c        ****       sei();
 9573               		.loc 1 1799 0
 9574               	/* #APP */
 9575               	 ;  1799 "main.c" 1
 9576 0080 7894      		sei
 9577               	 ;  0 "" 2
1800:main.c        ****       wolne_zdarzenie_timer();
 9578               		.loc 1 1800 0
 9579               	/* #NOAPP */
 9580 0082 0E94 0000 		call wolne_zdarzenie_timer
 9581               	.LVL719:
1775:main.c        ****       ustaw_parametry_dla_bezpieczenstwa();
 9582               		.loc 1 1775 0
 9583 0086 00C0      		rjmp .L1041
 9584               		.cfi_endproc
 9585               	.LFE70:
 9587               		.local	licznik_resetow.3768
 9588               		.comm	licznik_resetow.3768,1,1
 9589               		.local	licznik_wybuc_watki_100MS.3724
 9590               		.comm	licznik_wybuc_watki_100MS.3724,1,1
 9591               		.local	licznik_dioda_led_poziom_sieci.3717
 9592               		.comm	licznik_dioda_led_poziom_sieci.3717,1,1
 9593               		.section	.progmem.data,"a",@progbits
 9596               	tab_eeprom_fabryczny.3633:
 9597 0000 FF        		.byte	-1
 9598 0001 41        		.byte	65
 9599 0002 42        		.byte	66
 9600 0003 43        		.byte	67
 9601 0004 44        		.byte	68
 9602 0005 00        		.byte	0
 9603               		.local	licznik_odebranych_znakow.3478
 9604               		.comm	licznik_odebranych_znakow.3478,2,1
 9605               		.local	licznik_poprzednia_komenda.3477
 9606               		.comm	licznik_poprzednia_komenda.3477,2,1
 9607               		.local	poprzednia_komenda.3476
 9608               		.comm	poprzednia_komenda.3476,1,1
 9609               		.local	licznik_bezpieczenstwa.3475
 9610               		.comm	licznik_bezpieczenstwa.3475,2,1
 9611               		.local	licznik_cyklu_8_sek.3471
 9612               		.comm	licznik_cyklu_8_sek.3471,1,1
 9615               	nastepna_komenda.3462:
 9616 0006 00        		.byte	0
 9617 0007 00        		.byte	0
 9618 0008 A1        		.byte	-95
 9619 0009 A2        		.byte	-94
 9620 000a A3        		.byte	-93
 9621 000b A5        		.byte	-91
 9622 000c A6        		.byte	-90
 9623 000d A7        		.byte	-89
 9624 000e A8        		.byte	-88
 9625 000f 93        		.byte	-109
 9628               	instrukcje.3461:
 9629 0010 2B63 7069 		.string	"+cpin?"
 9629      6E3F 00
 9630 0017 0000 0000 		.zero	7
 9630      0000 00
 9631 001e 2B63 6E6D 		.string	"+cnmi=2,1,2,1"
 9631      693D 322C 
 9631      312C 322C 
 9631      3100 
 9632 002c 2B6D 6F72 		.string	"+moring=1"
 9632      696E 673D 
 9632      3100 
 9633 0036 0000 0000 		.zero	4
 9634 003a 2B63 6C69 		.string	"+clip=1"
 9634      703D 3100 
 9635 0042 0000 0000 		.zero	6
 9635      0000 
 9636 0048 2B64 6465 		.string	"+ddet=1,10,1"
 9636      743D 312C 
 9636      3130 2C31 
 9636      00
 9637 0055 00        		.zero	1
 9638 0056 2B63 616C 		.string	"+calm=1"
 9638      6D3D 3100 
 9639 005e 0000 0000 		.zero	6
 9639      0000 
 9640 0064 2B63 7273 		.string	"+crsl=1"
 9640      6C3D 3100 
 9641 006c 0000 0000 		.zero	6
 9641      0000 
 9642 0072 2B63 7573 		.string	"+cusd=1"
 9642      643D 3100 
 9643 007a 0000 0000 		.zero	6
 9643      0000 
 9644 0080 2B63 7062 		.string	"+cpbw=26,\"1\""
 9644      773D 3236 
 9644      2C22 3122 
 9644      00
 9645 008d 00        		.zero	1
 9646 008e 2B63 6C74 		.string	"+clts=0"
 9646      733D 3000 
 9647 0096 0000 0000 		.zero	6
 9647      0000 
 9650               	instrukcja.3447:
 9651 009c 2B63 6D69 		.string	"+cmic=0,15"
 9651      633D 302C 
 9651      3135 00
 9654               	instrukcja_usun_wszystkie_smsy.3444:
 9655 00a7 2B63 6D67 		.string	"+cmgda=6"
 9655      6461 3D36 
 9655      00
 9656               		.local	drugi_raz.3443
 9657               		.comm	drugi_raz.3443,1,1
 9660               	instrukcja_podaj_pin.3441:
 9661 00b0 2B63 7069 		.string	"+cpin=\"1976\""
 9661      6E3D 2231 
 9661      3937 3622 
 9661      00
 9664               	instrukcja_at.3438:
 9665 00bd 2B69 6663 		.string	"+ifc=2,2"
 9665      3D32 2C32 
 9665      00
 9668               	instrukcja_ustawienie_pamieci.3435:
 9669 00c6 2B63 706D 		.string	"+cpms=\"SM\",\"SM\",\"SM\""
 9669      733D 2253 
 9669      4D22 2C22 
 9669      534D 222C 
 9669      2253 4D22 
 9672               	instrukcja_ustawienie_pamieci.3433:
 9673 00db 2B63 6473 		.string	"+cdscb"
 9673      6362 00
 9676               	instrukcja_cclk.3431:
 9677 00e2 2B63 636C 		.string	"+cclk?"
 9677      6B3F 00
 9680               	instrukcja_sprawdz_operatora.3429:
 9681 00e9 2B63 6F70 		.string	"+cops?"
 9681      733F 00
 9684               	instrukcja_odczyt_ksiazki.3427:
 9685 00f0 2B63 7062 		.string	"+cpbr=26"
 9685      723D 3236 
 9685      00
 9688               	instrukcja_creg.3425:
 9689 00f9 2B63 7265 		.string	"+creg?"
 9689      673F 00
 9692               	instrukcja_poziom_sieci.3423:
 9693 0100 2B63 7371 		.string	"+csq"
 9693      00
 9696               	instrukcja_vts.3419:
 9697 0105 2B76 7473 		.string	"+vts=1"
 9697      3D31 00
 9700               	instrukcja_odbierz_rozmowe.3417:
 9701 010c 6100      		.string	"a"
 9704               	instrukcja_odrzuc_rozmowe.3415:
 9705 010e 6800      		.string	"h"
 9708               	__c.3412:
 9709 0110 2B43 4D54 		.string	"+CMTI:"
 9709      493A 00
 9712               	instrukcja_usun_smsa.3408:
 9713 0117 2B63 6D67 		.string	"+cmgd="
 9713      643D 00
 9716               	instrukcja_odczytaj_smsa.3375:
 9717 011e 2B63 6D67 		.string	"+cmgr="
 9717      723D 00
 9720               	instrukcja_wyslij_smsa.3343:
 9721 0125 2B63 6D67 		.string	"+cmgs="
 9721      733D 00
 9724               	__c.3323:
 9725 012c 2B43 4D54 		.string	"+CMTI:"
 9725      493A 00
 9728               	__c.3316:
 9729 0133 2B44 544D 		.string	"+DTMF:"
 9729      463A 00
 9732               	__c.3311:
 9733 013a 2B43 4C49 		.string	"+CLIP:"
 9733      503A 00
 9736               	__c.3298:
 9737 0141 3E00      		.string	">"
 9740               	__c.3269:
 9741 0143 2B43 4D47 		.string	"+CMGR:"
 9741      523A 00
 9744               	polecenie_operator.3240:
 9745 014a 2B43 4F50 		.string	"+COPS:"
 9745      533A 00
 9748               	urc.3235:
 9749 0151 2B43 5245 		.string	"+CREG:"
 9749      473A 00
 9752               	urc.3232:
 9753 0158 2B43 5351 		.string	"+CSQ:"
 9753      3A00 
 9754               		.local	nr_zapytania_o_pin.3226
 9755               		.comm	nr_zapytania_o_pin.3226,1,1
 9758               	polecenie_pin_ready.3225:
 9759 015e 2B43 5049 		.string	"+CPIN: READY"
 9759      4E3A 2052 
 9759      4541 4459 
 9759      00
 9762               	polecenie_zegar.3214:
 9763 016b 2B43 434C 		.string	"+CCLK:"
 9763      4B3A 00
 9764               		.local	licznik_reset.3161
 9765               		.comm	licznik_reset.3161,1,1
 9768               	__c.3141:
 9769 0172 313D 5243 		.string	"1=RCV 2=BSY 3=CNT 4=QSM 5=QAL 6=FND 7=ADD"
 9769      5620 323D 
 9769      4253 5920 
 9769      333D 434E 
 9769      5420 343D 
 9772               	__c.3139:
 9773 019c 2055 373D 		.string	" U7="
 9773      00
 9776               	__c.3137:
 9777 01a1 2055 363D 		.string	" U6="
 9777      00
 9780               	__c.3135:
 9781 01a6 2055 353D 		.string	" U5="
 9781      00
 9784               	__c.3133:
 9785 01ab 5534 3D00 		.string	"U4="
 9788               	__c.3131:
 9789 01af 2055 333D 		.string	" U3="
 9789      00
 9792               	__c.3129:
 9793 01b4 2055 323D 		.string	" U2="
 9793      00
 9796               	__c.3127:
 9797 01b9 5531 3D00 		.string	"U1="
 9800               	__c.3125:
 9801 01bd 534B 5259 		.string	"SKRYBA:"
 9801      4241 3A00 
 9804               	__c.3122:
 9805 01c5 4445 4255 		.string	"DEBUG\n"
 9805      470A 00
 9808               	tekst_demo.3056:
 9809 01cc 7777 772E 		.string	"www.sonfy.pl"
 9809      736F 6E66 
 9809      792E 706C 
 9809      00
 9812               	__c.3054:
 9813 01d9 536B 7279 		.string	"Skryba: Wylaczony"
 9813      6261 3A20 
 9813      5779 6C61 
 9813      637A 6F6E 
 9813      7900 
 9816               	__c.3046:
 9817 01eb 4861 726D 		.string	"Harmonogram: Wylaczony"
 9817      6F6E 6F67 
 9817      7261 6D3A 
 9817      2057 796C 
 9817      6163 7A6F 
 9820               	__c.3044:
 9821 0202 2044 544D 		.string	" DTMF"
 9821      4600 
 9824               	__c.3042:
 9825 0208 2043 4C49 		.string	" CLIP"
 9825      5000 
 9828               	__c.3040:
 9829 020e 5472 7962 		.string	"Tryb: Publiczny"
 9829      3A20 5075 
 9829      626C 6963 
 9829      7A6E 7900 
 9832               	__c.3038:
 9833 021e 5472 7962 		.string	"Tryb: Prywatny"
 9833      3A20 5072 
 9833      7977 6174 
 9833      6E79 00
 9836               	__c.3036:
 9837 022d 5374 6174 		.string	"Status: Aktywny"
 9837      7573 3A20 
 9837      416B 7479 
 9837      776E 7900 
 9840               	__c.3034:
 9841 023d 5374 6174 		.string	"Status: Zablokowany"
 9841      7573 3A20 
 9841      5A61 626C 
 9841      6F6B 6F77 
 9841      616E 7900 
 9844               	tekst_gsm.3020:
 9845 0251 557A 7974 		.string	"Uzytkownicy "
 9845      6B6F 776E 
 9845      6963 7920 
 9845      00
 9848               	tekst_gsm.3009:
 9849 025e 557A 7974 		.string	"Uzytkownicy "
 9849      6B6F 776E 
 9849      6963 7920 
 9849      00
 9852               	text_sygnal.3005:
 9853 026b 5379 676E 		.string	"Sygnal GSM "
 9853      616C 2047 
 9853      534D 2000 
 9856               	__c.3003:
 9857 0277 437A 6173 		.string	"Czas: "
 9857      3A20 00
 9860               	tekst_gsm.3001:
 9861 027e 4143 3830 		.string	"AC800-TS"
 9861      302D 5453 
 9861      00
 9862               		.local	stan.2970
 9863               		.comm	stan.2970,1,1
 9864               		.local	opoznienie_1s.2969
 9865               		.comm	opoznienie_1s.2969,1,1
 9866               	.global	wysylanie_smsa_clipa
 9867               		.section .bss
 9870               	wysylanie_smsa_clipa:
 9871 0000 00        		.zero	1
 9872               		.comm	ptr_start_pdu_z_wiadomoscia,2,1
 9873               	.global	wysylanie_echa_przez_pdu
 9876               	wysylanie_echa_przez_pdu:
 9877 0001 00        		.zero	1
 9878               		.local	liczba_kolejnych_watchdogow_wysylania
 9879               		.comm	liczba_kolejnych_watchdogow_wysylania,1,1
 9880               		.local	licznik_watchdog_wysylanie_smsa_100ms
 9881               		.comm	licznik_watchdog_wysylanie_smsa_100ms,2,1
 9882               		.local	licznik_awaryjnych_resetow_kolejki
 9883               		.comm	licznik_awaryjnych_resetow_kolejki,2,1
 9884               		.local	licznik_usunietych_sms_przez_limit
 9885               		.comm	licznik_usunietych_sms_przez_limit,2,1
 9886               		.local	licznik_kolejka_stoi_100ms
 9887               		.comm	licznik_kolejka_stoi_100ms,2,1
 9888               		.local	ostatnia_pierwsza_komenda
 9889               		.comm	ostatnia_pierwsza_komenda,1,1
 9890               		.local	timer_report_user_100ms
 9891               		.comm	timer_report_user_100ms,2,1
 9892               		.local	licznik_report_user
 9893               		.comm	licznik_report_user,1,1
 9894               		.comm	numer_telefonu_skryba,20,1
 9895               		.comm	numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama,1,1
 9896               		.comm	nie_wysylaj_echa_z_powodu_nietypowego_smsa,1,1
 9897               		.comm	kod_modulu,4,1
 9898               	.global	tryb_pracy
 9899               		.data
 9902               	tryb_pracy:
 9903 0000 01        		.byte	1
 9904               	.global	blokada_systemu
 9905               		.section .bss
 9908               	blokada_systemu:
 9909 0002 00        		.zero	1
 9910               	.global	opoznienie_wysylania_clipow_100MS
 9913               	opoznienie_wysylania_clipow_100MS:
 9914 0003 0000      		.zero	2
 9915               	.global	licznik_reset_urzadzenia
 9918               	licznik_reset_urzadzenia:
 9919 0005 00        		.zero	1
 9920               	.global	licznik_reset_modulu_SIM900
 9923               	licznik_reset_modulu_SIM900:
 9924 0006 00        		.zero	1
 9925               	.global	modul_zalogowany_w_sieci
 9928               	modul_zalogowany_w_sieci:
 9929 0007 00        		.zero	1
 9930               	.global	licznik_wybudz_watki_10MS
 9933               	licznik_wybudz_watki_10MS:
 9934 0008 00        		.zero	1
 9935               	.global	wykonac_watki
 9938               	wykonac_watki:
 9939 0009 00        		.zero	1
 9940               	.global	wykonac_watki_10MS
 9943               	wykonac_watki_10MS:
 9944 000a 00        		.zero	1
 9945               	.global	wykonaj_zdarzenie_timer
 9948               	wykonaj_zdarzenie_timer:
 9949 000b 00        		.zero	1
 9950               	.global	stan_cyklu_blysku
 9953               	stan_cyklu_blysku:
 9954 000c 00        		.zero	1
 9955               	.global	liczba_blyskow_led
 9958               	liczba_blyskow_led:
 9959 000d 00        		.zero	1
 9960               		.comm	licznik_100ms_dioda_led,1,1
 9961               	.global	g_czas_systemowy_100ms
 9964               	g_czas_systemowy_100ms:
 9965 000e 0000 0000 		.zero	4
 9966               	.global	licznik_timeout_rozmowy_100ms
 9969               	licznik_timeout_rozmowy_100ms:
 9970 0012 0000      		.zero	2
 9971               	.global	tryb_clip
 9972               		.data
 9975               	tryb_clip:
 9976 0001 FF        		.byte	-1
 9977               	.global	skryba_limit
 9980               	skryba_limit:
 9981 0002 2003      		.word	800
 9982               	.global	skryba_wlaczona
 9983               		.section .bss
 9986               	skryba_wlaczona:
 9987 0014 00        		.zero	1
 9988               		.comm	stan_wyjscie,1,1
 9989               	.global	sms_pomijaj_aktualizacje_czasu
 9992               	sms_pomijaj_aktualizacje_czasu:
 9993 0015 00        		.zero	1
 9994               	.global	sms_timestamp_sekunda
 9997               	sms_timestamp_sekunda:
 9998 0016 00        		.zero	1
 9999               	.global	sms_timestamp_minuta
 10002               	sms_timestamp_minuta:
 10003 0017 00        		.zero	1
 10004               	.global	sms_timestamp_godzina
 10007               	sms_timestamp_godzina:
 10008 0018 00        		.zero	1
 10009               	.global	watchdog_sms_safe_mode_100ms
 10012               	watchdog_sms_safe_mode_100ms:
 10013 0019 0000      		.zero	2
 10014               	.global	watchdog_sms_trwa_reset
 10017               	watchdog_sms_trwa_reset:
 10018 001b 00        		.zero	1
 10019               	.global	watchdog_sms_licznik_100ms
 10022               	watchdog_sms_licznik_100ms:
 10023 001c 0000      		.zero	2
 10024               	.global	watchdog_sms_aktywny
 10027               	watchdog_sms_aktywny:
 10028 001e 00        		.zero	1
 10029               		.comm	opoznienie_zatrzymaj_odpytywanie_urzadzenia,1,1
 10030               	.global	blokada_clip
 10033               	blokada_clip:
 10034 001f 00        		.zero	1
 10035               	.global	max_oczekiwanie_na_odpowiedz_at
 10038               	max_oczekiwanie_na_odpowiedz_at:
 10039 0020 00        		.zero	1
 10040               		.comm	licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow,1,1
 10041               	.global	licznik_bezpieczenstwa_opoznienie_wysylania_sms
 10044               	licznik_bezpieczenstwa_opoznienie_wysylania_sms:
 10045 0021 0000      		.zero	2
 10046               	.global	licznik_ogolny_blad_zalogowania
 10049               	licznik_ogolny_blad_zalogowania:
 10050 0023 0000      		.zero	2
 10051               	.global	licznik_blad_zalogowania_u_operatora
 10054               	licznik_blad_zalogowania_u_operatora:
 10055 0025 00        		.zero	1
 10056               	.global	licznik_blad_stanu_karty_SIM
 10059               	licznik_blad_stanu_karty_SIM:
 10060 0026 00        		.zero	1
 10061               	.global	licznik_awaria_brak_zasiegu
 10064               	licznik_awaria_brak_zasiegu:
 10065 0027 0000      		.zero	2
 10066               	.global	liczba_smsow_ech_do_wyslania
 10069               	liczba_smsow_ech_do_wyslania:
 10070 0029 00        		.zero	1
 10071               	.global	ustaw_maksymalny_czas_dzwonienia
 10074               	ustaw_maksymalny_czas_dzwonienia:
 10075 002a 00        		.zero	1
 10076               	.global	maksymalny_czas_dzwonienia
 10079               	maksymalny_czas_dzwonienia:
 10080 002b 00        		.zero	1
 10081               		.comm	numer_telefonu_do_ktorego_dzwonic,33,1
 10082               		.comm	numer_telefonu_ktory_dzwoni,17,1
 10083               	.global	liczba_prob_wyslania_smsa
 10086               	liczba_prob_wyslania_smsa:
 10087 002c 00        		.zero	1
 10088               	.global	flaga_wysylanie_smsa
 10091               	flaga_wysylanie_smsa:
 10092 002d 00        		.zero	1
 10093               		.comm	numer_telefonu_wysylanego_smsa,33,1
 10094               	.global	flaga_odczytywanie_smsa
 10097               	flaga_odczytywanie_smsa:
 10098 002e 00        		.zero	1
 10099               		.comm	numer_telefonu_odebranego_smsa,17,1
 10100               	.global	dlugosc_pdu
 10103               	dlugosc_pdu:
 10104 002f 00        		.zero	1
 10105               		.comm	bufor_pdu,200,1
 10106               	.global	licznik_bezpieczenstwa_wykonywana_rozmowa
 10109               	licznik_bezpieczenstwa_wykonywana_rozmowa:
 10110 0030 0000      		.zero	2
 10111               	.global	trwa_rozmowa_przychodzaca_od_uzytkownika
 10114               	trwa_rozmowa_przychodzaca_od_uzytkownika:
 10115 0032 00        		.zero	1
 10116               	.global	max_oczekiwanie_na_odpowiedz
 10117               		.data
 10120               	max_oczekiwanie_na_odpowiedz:
 10121 0004 03        		.byte	3
 10122               		.comm	liczba_wykonanych_komend_identycznego_polecenia,1,1
 10123               	.global	nastepne_wysylane_polecenie_SIM900
 10124               		.section .bss
 10127               	nastepne_wysylane_polecenie_SIM900:
 10128 0033 00        		.zero	1
 10129               	.global	licznik_wysylane_polecenie_SIM900
 10132               	licznik_wysylane_polecenie_SIM900:
 10133 0034 0000      		.zero	2
 10134               	.global	aktualnie_wysylane_polecenie_SIM900
 10137               	aktualnie_wysylane_polecenie_SIM900:
 10138 0036 00        		.zero	1
 10139               		.comm	nazwa_operatora,11,1
 10140               	.global	oproznij_bufor_SIM900_po_bledzie
 10143               	oproznij_bufor_SIM900_po_bledzie:
 10144 0037 00        		.zero	1
 10145               	.global	opoznienie_SIM900_100MS
 10148               	opoznienie_SIM900_100MS:
 10149 0038 00        		.zero	1
 10150               		.text
 10151               	.Letext0:
 10152               		.file 8 "narzedzia.h"
 10153               		.file 9 "/usr/local/avr8-gnu-toolchain/avr/include/stdint.h"
 10154               		.file 10 "/usr/local/avr8-gnu-toolchain/lib/gcc/avr/7.3.0/include/stddef.h"
 10155               		.file 11 "/usr/local/avr8-gnu-toolchain/avr/include/stdio.h"
 10156               		.file 12 "enumkomendy.h"
 10157               		.file 13 "data_sim900.h"
 10158               		.file 14 "pamiec_ram.h"
 10159               		.file 15 "interpretacjaSMS.h"
 10160               		.file 16 "komendy.h"
 10161               		.file 17 "poleceniagsm.h"
 10162               		.file 18 "sim900.h"
 10163               		.file 19 "zapiseeprom.h"
 10164               		.file 20 "bufpomoc.h"
 10165               		.file 21 "/usr/local/avr8-gnu-toolchain/avr/include/avr/eeprom.h"
 10166               		.file 22 "konfiguracja.h"
 10167               		.file 23 "/usr/local/avr8-gnu-toolchain/avr/include/string.h"
 10168               		.file 24 "pdu.h"
 10169               		.file 25 "/usr/local/avr8-gnu-toolchain/avr/include/avr/pgmspace.h"
 10170               		.file 26 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:4      *ABS*:000000000000003f __SREG__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:5      *ABS*:000000000000003b __RAMPZ__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:6      *ABS*:0000000000000000 __tmp_reg__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:7      *ABS*:0000000000000001 __zero_reg__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:12     .text:0000000000000000 watchdog_sms_disarm
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10027  .bss:000000000000001e watchdog_sms_aktywny
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10022  .bss:000000000000001c watchdog_sms_licznik_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:33     .text:000000000000000e czy_numer_istnieje
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:100    .text:000000000000004e usun_zablokowany_sms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10137  .bss:0000000000000036 aktualnie_wysylane_polecenie_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:128    .text:0000000000000062 zareaguj_na_usuniety_sms_z_powodu_limitu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9883   .bss:000000000000004e licznik_usunietych_sms_przez_limit
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9958   .bss:000000000000000d liczba_blyskow_led
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9953   .bss:000000000000000c stan_cyklu_blysku
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:166    .text:000000000000008e polozenie_polecenia_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:187    .text:0000000000000098 opoznienie_startowe
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:252    .text:00000000000000d8 zapisz_debug_do_eeprom
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9891   .bss:0000000000000055 licznik_report_user
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9889   .bss:0000000000000053 timer_report_user_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10091  .bss:000000000000002d flaga_wysylanie_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:368    .text:000000000000015c test_dioda_wyjscia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9863   .bss:0000000000000048 opoznienie_1s.2969
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9765   .bss:0000000000000047 stan.2970
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:411    .text:000000000000018a test_wejscie
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:443    .text:000000000000019a __vector_16
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9933   .bss:0000000000000008 licznik_wybudz_watki_10MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9943   .bss:000000000000000a wykonac_watki_10MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9948   .bss:000000000000000b wykonaj_zdarzenie_timer
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:658    .text:000000000000029c generuj_raport_sieci
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9860   .progmem.data:000000000000027e tekst_gsm.3001
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9856   .progmem.data:0000000000000277 __c.3003
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9852   .progmem.data:000000000000026b text_sygnal.3005
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9928   .bss:0000000000000007 modul_zalogowany_w_sieci
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:840    .text:0000000000000364 generuj_raport_uzytkownikow_1
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9848   .progmem.data:000000000000025e tekst_gsm.3009
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:1026   .text:0000000000000416 generuj_raport_uzytkownikow
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9844   .progmem.data:0000000000000251 tekst_gsm.3020
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:1204   .text:00000000000004b8 generuj_raport_stanu_urzadzenia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9908   .bss:0000000000000002 blokada_systemu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9840   .progmem.data:000000000000023d __c.3034
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9836   .progmem.data:000000000000022d __c.3036
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9902   .data:0000000000000000 tryb_pracy
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9832   .progmem.data:000000000000021e __c.3038
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9828   .progmem.data:000000000000020e __c.3040
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9975   .data:0000000000000001 tryb_clip
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9824   .progmem.data:0000000000000208 __c.3042
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9820   .progmem.data:0000000000000202 __c.3044
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9816   .progmem.data:00000000000001eb __c.3046
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9986   .bss:0000000000000014 skryba_wlaczona
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9980   .data:0000000000000002 skryba_limit
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9808   .progmem.data:00000000000001cc tekst_demo.3056
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9812   .progmem.data:00000000000001d9 __c.3054
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:1536   .text:000000000000069e ustaw_wyjscie_clip
                            *COM*:0000000000000001 stan_wyjscie
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:1578   .text:00000000000006be wykonanie_polecenia_sms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9992   .bss:0000000000000015 sms_pomijaj_aktualizacje_czasu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9997   .bss:0000000000000016 sms_timestamp_sekunda
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10002  .bss:0000000000000017 sms_timestamp_minuta
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10007  .bss:0000000000000018 sms_timestamp_godzina
                            *COM*:0000000000000011 numer_telefonu_odebranego_smsa
                            *COM*:0000000000000021 numer_telefonu_wysylanego_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9804   .progmem.data:00000000000001c5 __c.3122
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9800   .progmem.data:00000000000001bd __c.3125
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9796   .progmem.data:00000000000001b9 __c.3127
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9792   .progmem.data:00000000000001b4 __c.3129
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9788   .progmem.data:00000000000001af __c.3131
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9784   .progmem.data:00000000000001ab __c.3133
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9780   .progmem.data:00000000000001a6 __c.3135
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9776   .progmem.data:00000000000001a1 __c.3137
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9772   .progmem.data:000000000000019c __c.3139
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9768   .progmem.data:0000000000000172 __c.3141
                            *COM*:0000000000000021 numer_telefonu_do_ktorego_dzwonic
                            *COM*:0000000000000001 numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:2577   .text:0000000000000c3a steruj_wejsciem_reset_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9755   .bss:0000000000000046 licznik_reset.3161
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:2648   .text:0000000000000c82 sprawdz_przychodzaca_rozmowe
                            *COM*:0000000000000011 numer_telefonu_ktory_dzwoni
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:2770   .text:0000000000000d16 zakonczono_rozmowe_telefoniczna
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10148  .bss:0000000000000038 opoznienie_SIM900_100MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10109  .bss:0000000000000030 licznik_bezpieczenstwa_wykonywana_rozmowa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10074  .bss:000000000000002a ustaw_maksymalny_czas_dzwonienia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10079  .bss:000000000000002b maksymalny_czas_dzwonienia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10033  .bss:000000000000001f blokada_clip
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:2800   .text:0000000000000d32 zakonczono_wysylanie_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9870   .bss:0000000000000000 wysylanie_smsa_clipa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:2823   .text:0000000000000d3e problem_z_wyslaniem_powiadomienia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10132  .bss:0000000000000034 licznik_wysylane_polecenie_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:2855   .text:0000000000000d66 wyzerowanie_danych_SIM900
                            *COM*:0000000000000001 licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10114  .bss:0000000000000032 trwa_rozmowa_przychodzaca_od_uzytkownika
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10097  .bss:000000000000002e flaga_odczytywanie_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:2894   .text:0000000000000d94 reset_modulu_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10059  .bss:0000000000000026 licznik_blad_stanu_karty_SIM
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10054  .bss:0000000000000025 licznik_blad_zalogowania_u_operatora
                            *COM*:000000000000000b nazwa_operatora
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10049  .bss:0000000000000023 licznik_ogolny_blad_zalogowania
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10127  .bss:0000000000000033 nastepne_wysylane_polecenie_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:2958   .text:0000000000000dee obsluga_wysylania_sms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10086  .bss:000000000000002c liczba_prob_wyslania_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:3170   .text:0000000000000ef8 odpowiedz_na_polecenie
                            *COM*:0000000000000001 liczba_wykonanych_komend_identycznego_polecenia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9748   .progmem.data:0000000000000151 urc.3235
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9736   .progmem.data:0000000000000141 __c.3298
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10038  .bss:0000000000000020 max_oczekiwanie_na_odpowiedz_at
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9762   .progmem.data:000000000000016b polecenie_zegar.3214
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9758   .progmem.data:000000000000015e polecenie_pin_ready.3225
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9657   .bss:0000000000000045 nr_zapytania_o_pin.3226
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9752   .progmem.data:0000000000000158 urc.3232
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9744   .progmem.data:000000000000014a polecenie_operator.3240
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9969   .bss:0000000000000012 licznik_timeout_rozmowy_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9740   .progmem.data:0000000000000143 __c.3269
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10103  .bss:000000000000002f dlugosc_pdu
                            *COM*:00000000000000c8 bufor_pdu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:4325   .text:0000000000001574 obsluga_komendy_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10143  .bss:0000000000000037 oproznij_bufor_SIM900_po_bledzie
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9732   .progmem.data:000000000000013a __c.3311
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9728   .progmem.data:0000000000000133 __c.3316
                            *COM*:0000000000000001 licznik_100ms_dioda_led
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9724   .progmem.data:000000000000012c __c.3323
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:4801   .text:000000000000181a wyslanie_polecenia_ROM
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:4844   .text:0000000000001842 wyslij_sms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9720   .progmem.data:0000000000000125 instrukcja_wyslij_smsa.3343
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10120  .data:0000000000000004 max_oczekiwanie_na_odpowiedz
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:5020   .text:000000000000193c wykonanie_komend_SIM900
                            *COM*:0000000000000001 opoznienie_zatrzymaj_odpytywanie_urzadzenia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9615   .progmem.data:0000000000000006 nastepna_komenda.3462
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9628   .progmem.data:0000000000000010 instrukcje.3461
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9716   .progmem.data:000000000000011e instrukcja_odczytaj_smsa.3375
                            *COM*:0000000000000001 nie_wysylaj_echa_z_powodu_nietypowego_smsa
                            *COM*:0000000000000002 ptr_start_pdu_z_wiadomoscia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9712   .progmem.data:0000000000000117 instrukcja_usun_smsa.3408
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9708   .progmem.data:0000000000000110 __c.3412
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9704   .progmem.data:000000000000010e instrukcja_odrzuc_rozmowe.3415
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9700   .progmem.data:000000000000010c instrukcja_odbierz_rozmowe.3417
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9696   .progmem.data:0000000000000105 instrukcja_vts.3419
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9692   .progmem.data:0000000000000100 instrukcja_poziom_sieci.3423
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9688   .progmem.data:00000000000000f9 instrukcja_creg.3425
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9684   .progmem.data:00000000000000f0 instrukcja_odczyt_ksiazki.3427
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9680   .progmem.data:00000000000000e9 instrukcja_sprawdz_operatora.3429
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9676   .progmem.data:00000000000000e2 instrukcja_cclk.3431
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9672   .progmem.data:00000000000000db instrukcja_ustawienie_pamieci.3433
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9668   .progmem.data:00000000000000c6 instrukcja_ustawienie_pamieci.3435
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9664   .progmem.data:00000000000000bd instrukcja_at.3438
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9660   .progmem.data:00000000000000b0 instrukcja_podaj_pin.3441
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9612   .bss:0000000000000044 drugi_raz.3443
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9654   .progmem.data:00000000000000a7 instrukcja_usun_wszystkie_smsy.3444
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9650   .progmem.data:000000000000009c instrukcja.3447
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:6424   .text:00000000000021ea steruj_SIM900_100MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9913   .bss:0000000000000003 opoznienie_wysylania_clipow_100MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9610   .bss:0000000000000043 licznik_cyklu_8_sek.3471
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10064  .bss:0000000000000027 licznik_awaria_brak_zasiegu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9923   .bss:0000000000000006 licznik_reset_modulu_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:6723   .text:00000000000023c2 steruj_SIM900_10MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9608   .bss:0000000000000041 licznik_bezpieczenstwa.3475
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9606   .bss:0000000000000040 poprzednia_komenda.3476
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9604   .bss:000000000000003e licznik_poprzednia_komenda.3477
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9592   .bss:000000000000003c licznik_odebranych_znakow.3478
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:7026   .text:0000000000002582 wykonanie_komend_powiadomien
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:7302   .text:00000000000026ee test_sms_clip_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:7318   .text:00000000000026f0 steruj_wejscia_wyjscia_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:7340   .text:00000000000026fc zapis_w_eeprom_stanu_wyjsc
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:7436   .text:0000000000002778 steruj_urzadzeniem_100MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9887   .bss:0000000000000052 ostatnia_pierwsza_komenda
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9885   .bss:0000000000000050 licznik_kolejka_stoi_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9879   .bss:000000000000004a licznik_watchdog_wysylanie_smsa_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9881   .bss:000000000000004c licznik_awaryjnych_resetow_kolejki
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9865   .bss:0000000000000049 liczba_kolejnych_watchdogow_wysylania
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10017  .bss:000000000000001b watchdog_sms_trwa_reset
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10012  .bss:0000000000000019 watchdog_sms_safe_mode_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9590   .bss:000000000000003b licznik_dioda_led_poziom_sieci.3717
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:7779   .text:00000000000029a4 steruj_urzadzeniem_10MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:7801   .text:00000000000029b0 wolne_zdarzenie_timer
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9938   .bss:0000000000000009 wykonac_watki
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9588   .bss:000000000000003a licznik_wybuc_watki_100MS.3724
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:7985   .text:0000000000002a8e ustaw_parametry_dla_bezpieczenstwa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:8023   .text:0000000000002aae inicjalizuj_parametry_modulu
                            *COM*:0000000000000004 kod_modulu
                             .bss:0000000000000039 licznik_resetow.3768
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:8429   .text:0000000000002d0a wykonanie_komend_ukladow
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9596   .progmem.data:0000000000000000 tab_eeprom_fabryczny.3633
                            *COM*:0000000000000014 numer_telefonu_skryba
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9419   .text:000000000000326c wykonanie_komend
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9450   .text.startup:0000000000000000 main
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9876   .bss:0000000000000001 wysylanie_echa_przez_pdu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9918   .bss:0000000000000005 licznik_reset_urzadzenia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:9964   .bss:000000000000000e g_czas_systemowy_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10044  .bss:0000000000000021 licznik_bezpieczenstwa_opoznienie_wysylania_sms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccK5IGza.s:10069  .bss:0000000000000029 liczba_smsow_ech_do_wyslania

UNDEFINED SYMBOLS
bufor_eeprom
konwertuj_telefon_na_blok_eeprom
porownaj_numer_telefonu_blok
filtruj_i_dodaj_komende
odebrany_blok_SIM900
strstr_P
bufor_pomoc_liczba_znakow_do_zapisu
liczba_znakow_do_zapisu
czy_zajety_bufor_eeprom
komendy_kolejka
zapisz_znaki_w_eeprom
licznik_wejscie
komenda_SIM900
liczba_odebranych_znakow_SIM900
licznik_opoznienie_oczekiwania_na_bajt_SIM900
sprawdzaj_wejscie_CTS_SIM900
podlaczony_modul_gsm_SIM900
nr_wyslanego_znaku_SIM900
wysylany_blok_SIM900
memcpy_P
strcpy_P
rtc_czas
strcat
poziom_sieci_gsm
__divmodhi4
__utoa_ncheck
eeprom_read_byte
tekst_wysylanego_smsa
czas_start_h
sprintf
czas_stop_m
czas_stop_h
czas_start_m
licznik_przelacznik_wyjscia
interpretuj_wiadomosc_sms
bufor_ustaw_czas
dodaj_komende
blokada_sterowania_czasowa
__tablejump2__
strcpy
czy_sa_komendy_z_przedzialu
stan_logiczny_na_wejsciu
wykonywanie_rozmowy_telefonicznej
czekanie_na_odebranie_zachety
liczba_komend_w_kolejce_SIM900
flaga_odebrany_znak_zachety
licznik_100ms_procedura_inicjalizacyjna_SIM900
podlaczona_karta_SIM_SIM900
filtruj_komendy_z_przedzialu
numer_bledu_cms
numer_bledu_cme
strtol
strchr
bledny_PIN
strncmp_P
memcpy
konwertuj_blok_dwa_znaki_na_znak_pdu
liczba_wysylanych_znakow_SIM900
memcmp
strtoul
wyslij_polecenie_ROM_SIM900
konwertuj_blok_eeprom_na_telefon
zapisz_naglowek_pdu
ascii_to_pdu_blok
wyslij_polecenie_RAM_SIM900
pobierz_numer_telefonu_nadawcy_z_PDU
konwertuj_pdu_na_blok_wysylany
wyslij_znaki_SIM900
pobierz_date_z_PDU
pobierz_czas_z_PDU
pdu_to_ascii
procedura_inicjalizacyjna_SIM900_100MS
czy_jest_nowa_komenda_SIM900
kopiuj_blok_eeprom_na_telefon
aktualizuj_stan_wyzwolenia_wejsc_100ms
steruj_wyjscia_100ms
steruj_wejscia_10ms
zapisz_bajt_w_EEPROM
poczatek_polecenia_SIM900
zakonczenie_polecenia_SIM900
czy_jest_nowe_polecenie_SIM900
eeprom_read_block
eeprom_update_block
eeprom_update_byte
zapisz_znaki_w_eeprom_bez_kopiowania
memset
zapisz_znak_w_eeprom
usun_komende
inicjalizacja_SIM900
__do_copy_data
__do_clear_bss
