   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	watchdog_sms_disarm:
  13               	.LFB34:
  14               		.file 1 "main.c"
   1:main.c        **** 
   2:main.c        **** #ifndef INCLUDE
   3:main.c        **** #include "narzedzia.h"
   4:main.c        **** #include <avr/eeprom.h>
   5:main.c        **** #include <avr/interrupt.h>
   6:main.c        **** #include <avr/io.h>
   7:main.c        **** #include <avr/pgmspace.h>
   8:main.c        **** #include <avr/sleep.h>
   9:main.c        **** #include <avr/wdt.h>
  10:main.c        **** #include <ctype.h>
  11:main.c        **** #include <stdio.h>
  12:main.c        **** #include <stdlib.h>
  13:main.c        **** #include <string.h>
  14:main.c        **** #include <util/crc16.h>
  15:main.c        **** #include <util/delay.h>
  16:main.c        **** 
  17:main.c        **** #ifndef TEST_ATMEGA128
  18:main.c        **** #include "pin_ATmega328.h"
  19:main.c        **** #else
  20:main.c        **** #include "pin_ATmega128.h"
  21:main.c        **** #endif
  22:main.c        **** #include "bufpomoc.h"
  23:main.c        **** #include "data_sim900.h"
  24:main.c        **** #include "interpretacjaSMS.h"
  25:main.c        **** #include "komendy.h"
  26:main.c        **** #include "konfiguracja.h"
  27:main.c        **** #include "pdu.h"
  28:main.c        **** #include "sim900.h"
  29:main.c        **** #include "wewy.h"
  30:main.c        **** #include "zapiseeprom.h"
  31:main.c        **** 
  32:main.c        **** #include "test_pcb.h"
  33:main.c        **** 
  34:main.c        **** #endif
  35:main.c        **** 
  36:main.c        **** // static const char nazwa_urzadzenia[12 + 1] PROGMEM = "BRAMA";
  37:main.c        **** 
  38:main.c        **** uchar skryba_wlaczona = FALSE;
  39:main.c        **** uint skryba_limit = 795; // Domyslny limit uzytkownikow dla Skryby (795 max,
  40:main.c        ****                          // pozycje 796-800 dla Super Userow)
  41:main.c        **** uchar tryb_clip = TRUE;
  42:main.c        **** uint licznik_timeout_rozmowy_100ms = 0;
  43:main.c        **** 
  44:main.c        **** volatile uint32_t g_czas_systemowy_100ms = 0;
  45:main.c        **** 
  46:main.c        **** #define INFORMACJA_W_RAPORCIE "www.sonfy.pl"
  47:main.c        **** 
  48:main.c        **** uchar licznik_100ms_dioda_led;
  49:main.c        **** uchar liczba_blyskow_led = 0;
  50:main.c        **** uchar stan_cyklu_blysku =
  51:main.c        ****     0; // 0-5: 0-1=ON (200ms), 2-5=OFF (400ms), 1 blysk=600ms
  52:main.c        **** 
  53:main.c        **** #define zapal_diode_led(czas_100ms) (licznik_100ms_dioda_led = (czas_100ms) + 1)
  54:main.c        **** #define zapal_diode_led_blyski(liczba)                                         \
  55:main.c        ****   (liczba_blyskow_led = (liczba), stan_cyklu_blysku = 0)
  56:main.c        **** // #define zapal_diode_led(czas_100ms)
  57:main.c        **** 
  58:main.c        **** volatile uchar wykonaj_zdarzenie_timer = FALSE;
  59:main.c        **** #define CZY_WYKONAC_ZDARZENIE_TIMER() wykonaj_zdarzenie_timer
  60:main.c        **** 
  61:main.c        **** #define WYKONAJ_WATKI_BRAK 0
  62:main.c        **** #define WYKONAJ_WATKI_10MS BIT(0)
  63:main.c        **** #define WYKONAJ_WATKI_100MS BIT(1)
  64:main.c        **** volatile uchar wykonac_watki_10MS = FALSE;
  65:main.c        **** uchar wykonac_watki = WYKONAJ_WATKI_BRAK;
  66:main.c        **** #define CZY_WYKONAC_WATKI_10MS() (wykonac_watki & WYKONAJ_WATKI_10MS)
  67:main.c        **** #define CZY_WYKONAC_WATKI_100MS() (wykonac_watki & WYKONAJ_WATKI_100MS)
  68:main.c        **** #define RESETUJ_WYKONANIE_WATKOW() (wykonac_watki = 0)
  69:main.c        **** 
  70:main.c        **** volatile uchar licznik_wybudz_watki_10MS = 0;
  71:main.c        **** #define OPOZNIENIE_TIMERA_0 18
  72:main.c        **** #define czy_pozostal_czas(procent)                                             \
  73:main.c        ****   (licznik_wybudz_watki_10MS < (100 - (procent)) * OPOZNIENIE_TIMERA_0 / 100)
  74:main.c        **** 
  75:main.c        **** przerwanie_timer() {
  76:main.c        ****   if (++licznik_wybudz_watki_10MS >= OPOZNIENIE_TIMERA_0) {
  77:main.c        ****     licznik_wybudz_watki_10MS = 0;
  78:main.c        ****     wykonac_watki_10MS = TRUE;
  79:main.c        ****   }
  80:main.c        **** 
  81:main.c        ****   if (STATUS_WLACZONY_SIM900()) {
  82:main.c        ****     if (!CZY_ODBIERANIE_DANYCH_SIM900() && czy_jest_bezczynny_SIM900()) {
  83:main.c        ****       ustaw_odbior_SIM900();
  84:main.c        ****     }
  85:main.c        ****     if (CZY_HANDSHAKING_CTS_ZEZWALA_NA_TRANSMISJE_SIM900()) {
  86:main.c        ****       cli();
  87:main.c        ****       if (CZY_WYSYLANIE_DANYCH_SIM900()) {
  88:main.c        ****         WYLACZ_PRZERWANIE_WYSYLANIA_DANYCH_SIM900();
  89:main.c        ****         sei();
  90:main.c        ****         uchar p = sprawdzaj_wejscie_CTS_SIM900;
  91:main.c        ****         if (p && (podlaczony_modul_gsm_SIM900 ||
  92:main.c        ****                   aktualnie_wysylane_polecenie_SIM900 ==
  93:main.c        ****                       KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT)) {
  94:main.c        ****           p = FALSE;
  95:main.c        ****           sprawdzaj_wejscie_CTS_SIM900 = p;
  96:main.c        ****           WSTAW_ZNAK_DO_BUFORA_SIM900();
  97:main.c        ****         }
  98:main.c        ****         cli();
  99:main.c        ****         WLACZ_PRZERWANIE_WYSYLANIA_DANYCH_SIM900();
 100:main.c        ****       }
 101:main.c        ****       sei();
 102:main.c        ****     }
 103:main.c        ****   } else {
 104:main.c        ****     zakoncz_przesylanie_SIM900();
 105:main.c        ****   }
 106:main.c        **** 
 107:main.c        ****   wykonaj_zdarzenie_timer =
 108:main.c        ****       TRUE; // uruchamia zdarzenie_timer, ktra korzysta z pozostaych zmiennych
 109:main.c        **** }
 110:main.c        **** 
 111:main.c        **** uchar modul_zalogowany_w_sieci = FALSE;
 112:main.c        **** 
 113:main.c        **** uchar licznik_reset_modulu_SIM900 = 0;
 114:main.c        **** #define START_LICZNIK_RESET_MODULU_SIM900 30
 115:main.c        **** 
 116:main.c        **** uchar licznik_reset_urzadzenia = 0;
 117:main.c        **** #define LICZNIK_RESET_URZADZENIA_RESET_SIM900 200
 118:main.c        **** #define START_LICZNIK_RESET_URZADZENIA 220
 119:main.c        **** 
 120:main.c        **** uint opoznienie_wysylania_clipow_100MS = 0;
 121:main.c        **** 
 122:main.c        **** // Auto-sync czasu po restarcie
 123:main.c        **** uchar autosync_czas_aktywny =
 124:main.c        ****     FALSE; // TRUE gdy oczekujemy na SMS do synchronizacji
 125:main.c        **** uchar moj_numer_telefonu[MAX_LICZBA_ZNAKOW_TELEFON +
 126:main.c        ****                          1]; // Numer własny urządzenia
 127:main.c        **** 
 128:main.c        **** void generuj_raport_sieci(uchar **buf_sms) {
 129:main.c        ****   static const char tekst_gsm[] PROGMEM = "AC800-DTM-TS";
 130:main.c        ****   uchar *ptr = *buf_sms;
 131:main.c        **** 
 132:main.c        ****   memcpy_R(ptr, tekst_gsm);
 133:main.c        ****   ptr += sizeof tekst_gsm - 1;
 134:main.c        ****   *ptr++ = '\n';
 135:main.c        **** 
 136:main.c        ****   strcpy_P((char *)ptr, PSTR("Czas: "));
 137:main.c        ****   ptr += strlen((char *)ptr);
 138:main.c        ****   strcat((char *)ptr, rtc_czas);
 139:main.c        ****   ptr += strlen((char *)ptr);
 140:main.c        ****   *ptr++ = '\n';
 141:main.c        **** 
 142:main.c        ****   static const char text_sygnal[] PROGMEM = "GSM: ";
 143:main.c        ****   memcpy_R(ptr, text_sygnal);
 144:main.c        ****   ptr += sizeof text_sygnal - 1;
 145:main.c        **** 
 146:main.c        ****   if (poziom_sieci_gsm <= 31 && modul_zalogowany_w_sieci) {
 147:main.c        ****     utoa(poziom_sieci_gsm * 100 / 31, ptr, 10);
 148:main.c        ****     ptr += strlen(ptr);
 149:main.c        ****     *ptr++ = '%';
 150:main.c        ****   } else {
 151:main.c        ****     *ptr++ = '-';
 152:main.c        ****     *ptr++ = '-';
 153:main.c        ****     *ptr++ = '-';
 154:main.c        ****   }
 155:main.c        ****   *ptr = 0;
 156:main.c        ****   *buf_sms = ptr;
 157:main.c        **** }
 158:main.c        **** 
 159:main.c        **** void generuj_raport_uzytkownikow_1(uchar **buf_sms) {
 160:main.c        ****   static const char tekst_gsm[] PROGMEM = "Uzyt: ";
 161:main.c        ****   uchar *ptr = *buf_sms;
 162:main.c        **** 
 163:main.c        ****   memcpy_R(ptr, tekst_gsm);
 164:main.c        ****   ptr += sizeof tekst_gsm - 1;
 165:main.c        ****   uint aktywne_numery = 0;
 166:main.c        ****   uint wolne_numery = 0;
 167:main.c        ****   // for (uchar nr_uzyt_clip = 0; nr_uzyt_clip <
 168:main.c        ****   // MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip)
 169:main.c        ****   for (uint nr_uzyt_clip = 0; nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 170:main.c        ****        ++nr_uzyt_clip) {
 171:main.c        ****     if (czy_aktywny_numer_telefonu_brama(nr_uzyt_clip))
 172:main.c        ****       ++aktywne_numery;
 173:main.c        ****     else
 174:main.c        ****       ++wolne_numery;
 175:main.c        ****   }
 176:main.c        **** 
 177:main.c        ****   utoa(aktywne_numery, ptr, 10);
 178:main.c        ****   ptr += strlen(ptr);
 179:main.c        ****   *ptr++ = '/';
 180:main.c        ****   utoa(wolne_numery, ptr, 10);
 181:main.c        ****   ptr += strlen(ptr);
 182:main.c        ****   *buf_sms = ptr;
 183:main.c        **** }
 184:main.c        **** 
 185:main.c        **** void generuj_raport_uzytkownikow(uchar **buf_sms) {
 186:main.c        ****   static const char tekst_gsm[] PROGMEM = "Uzytkownicy ";
 187:main.c        ****   uchar *ptr = *buf_sms;
 188:main.c        **** 
 189:main.c        ****   memcpy_R(ptr, tekst_gsm);
 190:main.c        ****   ptr += sizeof tekst_gsm - 1;
 191:main.c        ****   uchar aktywne_numery = 0;
 192:main.c        ****   uchar wolne_numery = 0;
 193:main.c        ****   for (uint nr_uzyt_clip = 0; nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 194:main.c        ****        ++nr_uzyt_clip) {
 195:main.c        ****     if (czy_aktywny_numer_telefonu_brama(nr_uzyt_clip))
 196:main.c        ****       ++aktywne_numery;
 197:main.c        ****     else
 198:main.c        ****       ++wolne_numery;
 199:main.c        ****   }
 200:main.c        ****   utoa(aktywne_numery, ptr, 10);
 201:main.c        ****   ptr += strlen(ptr);
 202:main.c        ****   *ptr++ = '/';
 203:main.c        ****   utoa(wolne_numery, ptr, 10);
 204:main.c        ****   ptr += strlen(ptr);
 205:main.c        ****   *buf_sms = ptr;
 206:main.c        **** }
 207:main.c        **** 
 208:main.c        **** uchar blokada_systemu = FALSE; // Nowa zmienna globalna
 209:main.c        **** uchar tryb_pracy = 1;          // 0=Prywatny, 1=Publiczny (domyślnie Publiczny)
 210:main.c        **** 
 211:main.c        **** void generuj_raport_stanu_urzadzenia(void) {
 212:main.c        ****   uchar *sms = (char *)tekst_wysylanego_smsa;
 213:main.c        ****   *sms++ = '*';
 214:main.c        ****   *sms++ = '\n';
 215:main.c        ****   generuj_raport_sieci(&sms);
 216:main.c        ****   *sms++ = '\n';
 217:main.c        ****   generuj_raport_uzytkownikow_1(&sms);
 218:main.c        ****   *sms++ = '\n';
 219:main.c        **** 
 220:main.c        ****   // Status sterownika (START/STOP)
 221:main.c        ****   if (blokada_systemu) {
 222:main.c        ****     strcpy_P((char *)sms, PSTR("Status: Zablokowany"));
 223:main.c        ****   } else {
 224:main.c        ****     strcpy_P((char *)sms, PSTR("Status: Aktywny"));
 225:main.c        ****   }
 226:main.c        ****   sms += strlen((char *)sms);
 227:main.c        ****   *sms++ = '\n';
 228:main.c        **** 
 229:main.c        ****   // Tryb pracy (OPEN/CLOSE)
 230:main.c        ****   if (tryb_pracy == 0) {
 231:main.c        ****     strcpy_P((char *)sms, PSTR("Tryb: Prywatny"));
 232:main.c        ****   } else {
 233:main.c        ****     strcpy_P((char *)sms, PSTR("Tryb: Publiczny"));
 234:main.c        ****   }
 235:main.c        ****   sms += strlen((char *)sms);
 236:main.c        **** 
 237:main.c        ****   if (tryb_clip) {
 238:main.c        ****     strcpy_P((char *)sms, PSTR(" CLIP"));
 239:main.c        ****   } else {
 240:main.c        ****     strcpy_P((char *)sms, PSTR(" DTMF"));
 241:main.c        ****   }
 242:main.c        ****   sms += strlen((char *)sms);
 243:main.c        ****   *sms++ = '\n';
 244:main.c        **** 
 245:main.c        ****   if (czas_start_h == 0xFF) {
 246:main.c        ****     strcpy_P((char *)sms, PSTR("Harm: Wylaczony"));
 247:main.c        ****   } else {
 248:main.c        ****     sprintf((char *)sms, "Harm: %02d:%02d %02d:%02d", (int)czas_start_h,
 249:main.c        ****             (int)czas_start_m, (int)czas_stop_h, (int)czas_stop_m);
 250:main.c        ****   }
 251:main.c        ****   sms += strlen((char *)sms);
 252:main.c        ****   *sms++ = '\n';
 253:main.c        **** 
 254:main.c        ****   // Skryba status (ON/OFF) - bez wyświetlania limitu
 255:main.c        ****   if (skryba_wlaczona) {
 256:main.c        ****     strcpy_P((char *)sms, PSTR("Skryba: Wlaczona"));
 257:main.c        ****   } else {
 258:main.c        ****     strcpy_P((char *)sms, PSTR("Skryba: Wylaczona"));
 259:main.c        ****   }
 260:main.c        ****   sms += strlen((char *)sms);
 261:main.c        ****   *sms++ = '\n';
 262:main.c        **** 
 263:main.c        ****   // Mój numer (dla auto-sync czasu)
 264:main.c        ****   strcpy_P((char *)sms, PSTR("Moj nr: "));
 265:main.c        ****   sms += strlen((char *)sms);
 266:main.c        ****   if (moj_numer_telefonu[0] != 0xFF && moj_numer_telefonu[0] != 0) {
 267:main.c        ****     strcpy((char *)sms, (char *)moj_numer_telefonu);
 268:main.c        ****   } else {
 269:main.c        ****     strcpy_P((char *)sms, PSTR("----"));
 270:main.c        ****   }
 271:main.c        ****   sms += strlen((char *)sms);
 272:main.c        ****   *sms++ = '\n';
 273:main.c        **** 
 274:main.c        ****   static const char tekst_demo[] PROGMEM = INFORMACJA_W_RAPORCIE;
 275:main.c        ****   strcpy_P((char *)sms, tekst_demo);
 276:main.c        **** }
 277:main.c        **** 
 278:main.c        **** // Helper function: sprawdz czy numer jest Super Userem (pozycje 795-800)
 279:main.c        **** uchar czy_numer_jest_super_userem(const uchar *numer_telefonu) {
 280:main.c        ****   // Konwertuj numer do formatu EEPROM
 281:main.c        ****   uchar temp_buf[LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM];
 282:main.c        ****   konwertuj_telefon_na_blok_eeprom(
 283:main.c        ****       (uchar *)numer_telefonu,
 284:main.c        ****       (uchar *)numer_telefonu + strlen((char *)numer_telefonu), temp_buf);
 285:main.c        **** 
 286:main.c        ****   // Sprawdz pozycje 794-799 (user-facing 795-800)
 287:main.c        ****   for (uint nr_uzyt = 794; nr_uzyt < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 288:main.c        ****        ++nr_uzyt) {
 289:main.c        ****     if (porownaj_numer_telefonu_blok(
 290:main.c        ****             temp_buf, (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt))) {
 291:main.c        ****       return TRUE; // Znaleziono w pozycjach super userow
 292:main.c        ****     }
 293:main.c        ****   }
 294:main.c        ****   return FALSE;
 295:main.c        **** }
 296:main.c        **** 
 297:main.c        **** void ustaw_wyjscie_clip(void) {
 298:main.c        ****   stan_wyjscie[0] = TRUE;
 299:main.c        ****   licznik_przelacznik_wyjscia[0] = 2 * 10ul; // 2 sekundy
 300:main.c        **** }
 301:main.c        **** 
 302:main.c        **** uchar kod_modulu[LICZBA_BAJTOW_KODU_DOSTEPU];
 303:main.c        **** 
 304:main.c        **** uchar nie_wysylaj_echa_z_powodu_nietypowego_smsa;
 305:main.c        **** 
 306:main.c        **** uchar numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama;
 307:main.c        **** uchar numer_telefonu_skryba[20];
 308:main.c        **** 
 309:main.c        **** // Blokada komend REPORT/USER - maksymalnie 8 w ciągu 30 sekund
 310:main.c        **** static uchar licznik_report_user = 0;
 311:main.c        **** static uint timer_report_user_100ms = 0;
 312:main.c        **** #define MAX_LICZBA_KOMEND_REPORT_USER_W_OKNIE 8
 313:main.c        **** #define OKNO_CZASOWE_REPORT_USER_100MS (30 * 10) // 30 sekund
 314:main.c        **** 
 315:main.c        **** // Mechanizm wykrywania zablokowanej kolejki i czyszczenia
 316:main.c        **** static komenda_typ ostatnia_pierwsza_komenda = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 317:main.c        **** static uint licznik_kolejka_stoi_100ms = 0;
 318:main.c        **** #define MAX_CZAS_KOLEJKA_STOI_100MS                                            \
 319:main.c        ****   (15 * 10) // 15 sekund - jesli kolejka stoi tyle czasu, wyczysc
 320:main.c        **** 
 321:main.c        **** static uint licznik_usunietych_sms_przez_limit = 0;
 322:main.c        **** static uint licznik_awaryjnych_resetow_kolejki = 0;
 323:main.c        **** 
 324:main.c        **** #define WATCHDOG_WYSYLANIA_SMS_100MS (30 * 10) // 30 sekund
 325:main.c        **** static uint licznik_watchdog_wysylanie_smsa_100ms = 0;
 326:main.c        **** static uchar liczba_kolejnych_watchdogow_wysylania = 0;
 327:main.c        **** #define WATCHDOG_SMS_TIMEOUT_100MS (10 * 10) // 10 sekund
 328:main.c        **** #define WATCHDOG_SMS_SAFE_MODE_100MS                                           \
 329:main.c        ****   (5 * 10) // 5 sekund po resecie - nie przyjmuj SMS
 330:main.c        **** 
 331:main.c        **** static inline void watchdog_sms_arm(void) {
 332:main.c        ****   watchdog_sms_aktywny = TRUE;
 333:main.c        ****   watchdog_sms_licznik_100ms = 0;
 334:main.c        **** }
 335:main.c        **** 
 336:main.c        **** static inline void watchdog_sms_disarm(void) {
  15               		.loc 1 336 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 337:main.c        ****   watchdog_sms_aktywny = FALSE;
  21               		.loc 1 337 0
  22 0000 1092 0000 		sts watchdog_sms_aktywny,__zero_reg__
 338:main.c        ****   watchdog_sms_licznik_100ms = 0;
  23               		.loc 1 338 0
  24 0004 1092 0000 		sts watchdog_sms_licznik_100ms+1,__zero_reg__
  25 0008 1092 0000 		sts watchdog_sms_licznik_100ms,__zero_reg__
  26               	/* epilogue start */
 339:main.c        **** }
  27               		.loc 1 339 0
  28 000c 0895      		ret
  29               		.cfi_endproc
  30               	.LFE34:
  33               	czy_numer_istnieje:
  34               	.LFB58:
 340:main.c        **** 
 341:main.c        **** static inline void sygnalizuj_pelny_system(void) {
 342:main.c        ****   // 10 szybkich blyskow informuje, ze kolejka/limit SMS jest zapelniony
 343:main.c        ****   zapal_diode_led_blyski(10);
 344:main.c        **** }
 345:main.c        **** 
 346:main.c        **** // Funkcja usuwania zablokowanego SMS z modulu SIM900
 347:main.c        **** static void usun_zablokowany_sms(void) {
 348:main.c        ****   // Usun SMS z modulu SIM900 (numer jest w aktualnie_wysylane_polecenie_SIM900)
 349:main.c        ****   // Sprawdzamy czy to byla komenda odczytu SMS
 350:main.c        ****   if (aktualnie_wysylane_polecenie_SIM900 >= KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 351:main.c        ****       aktualnie_wysylane_polecenie_SIM900 <= KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 352:main.c        ****     const uchar nr_smsa =
 353:main.c        ****         aktualnie_wysylane_polecenie_SIM900 - KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1;
 354:main.c        ****     // Uzywamy filtruj_i_dodaj_komende zamiast dodaj_komende
 355:main.c        ****     filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_USUN_SMSA_1 + nr_smsa);
 356:main.c        ****   } else {
 357:main.c        ****     // Fallback: Usun wszystkie
 358:main.c        ****     filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 359:main.c        ****   }
 360:main.c        **** }
 361:main.c        **** 
 362:main.c        **** static void zareaguj_na_usuniety_sms_z_powodu_limitu(void) {
 363:main.c        ****   if (licznik_usunietych_sms_przez_limit < 0xFFFF)
 364:main.c        ****     ++licznik_usunietych_sms_przez_limit;
 365:main.c        ****   sygnalizuj_pelny_system();
 366:main.c        ****   watchdog_sms_disarm();
 367:main.c        ****   // Uzywamy filtruj_i_dodaj
 368:main.c        ****   filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 369:main.c        **** }
 370:main.c        **** 
 371:main.c        **** // Funkcja zapisu znacznikow debugowania do EEPROM
 372:main.c        **** static void zapisz_debug_do_eeprom(uchar komenda, uchar akcja) {
 373:main.c        ****   if (!czy_wolny_eeprom())
 374:main.c        ****     return;
 375:main.c        **** 
 376:main.c        ****   uchar buf[8];
 377:main.c        ****   buf[0] = licznik_report_user;
 378:main.c        ****   buf[1] = (uchar)(timer_report_user_100ms & 0xFF);
 379:main.c        ****   buf[2] = (uchar)((timer_report_user_100ms >> 8) & 0xFF);
 380:main.c        ****   buf[3] = (uchar)flaga_wysylanie_smsa;
 381:main.c        **** 
 382:main.c        ****   uchar liczba_sms_w_kolejce = 0;
 383:main.c        ****   for (uchar i = 0; i < LICZBA_KOMEND; ++i) {
 384:main.c        ****     if (komendy_kolejka[i] >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
 385:main.c        ****         komendy_kolejka[i] <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
 386:main.c        ****       ++liczba_sms_w_kolejce;
 387:main.c        ****   }
 388:main.c        ****   buf[4] = liczba_sms_w_kolejce;
 389:main.c        ****   buf[5] = komenda;
 390:main.c        ****   buf[6] = akcja;
 391:main.c        **** 
 392:main.c        ****   zapisz_znaki_w_eeprom(buf, EEPROM_DEBUG_START, 7);
 393:main.c        **** }
 394:main.c        **** 
 395:main.c        **** void wykonanie_polecenia_sms(void) {
 396:main.c        ****   tekst_odebranego_smsa[MAX_LICZBA_ZNAKOW_SMS] = 0; // (1) dla pewnoci
 397:main.c        ****   watchdog_sms_arm();
 398:main.c        ****   const uchar komenda = interpretuj_wiadomosc_sms(tekst_odebranego_smsa);
 399:main.c        **** 
 400:main.c        ****   // Aktualizacja czasu z timestampu SMS (PRZED wykonaniem komendy!)
 401:main.c        ****   // KAŻDY SMS (nawet bez kodu ABCD) synchronizuje RTC, z wyłączeniem SET
 402:main.c        ****   extern uchar sms_timestamp_godzina;
 403:main.c        ****   extern uchar sms_timestamp_minuta;
 404:main.c        ****   extern uchar sms_timestamp_sekunda;
 405:main.c        ****   extern uchar sms_pomijaj_aktualizacje_czasu;
 406:main.c        **** 
 407:main.c        ****   if (!sms_pomijaj_aktualizacje_czasu) {
 408:main.c        ****     // Aktualizuj rtc_czas z timestampu SMS (z sekundami z PDU)
 409:main.c        ****     sprintf(rtc_czas, "%02d:%02d:%02d", sms_timestamp_godzina,
 410:main.c        ****             sms_timestamp_minuta, sms_timestamp_sekunda);
 411:main.c        **** 
 412:main.c        ****     // Zaktualizuj RTC w SIM900 (hardware)
 413:main.c        ****     extern char bufor_ustaw_czas[32];
 414:main.c        ****     sprintf(bufor_ustaw_czas, "+CCLK=\"24/01/01,%02d:%02d:%02d+04\"",
 415:main.c        ****             sms_timestamp_godzina, sms_timestamp_minuta, sms_timestamp_sekunda);
 416:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_USTAW_ZEGAR_SIM900);
 417:main.c        **** 
 418:main.c        ****     // Aktualizuj blokadę czasową
 419:main.c        ****     if (czas_start_h != 0xFF) {
 420:main.c        ****       int curr_time = sms_timestamp_godzina * 60 + sms_timestamp_minuta;
 421:main.c        ****       int start_time = czas_start_h * 60 + czas_start_m;
 422:main.c        ****       int stop_time = czas_stop_h * 60 + czas_stop_m;
 423:main.c        **** 
 424:main.c        ****       if (start_time <= stop_time) {
 425:main.c        ****         // Normalny przedział (np. 08:00 - 16:00)
 426:main.c        ****         blokada_sterowania_czasowa =
 427:main.c        ****             !(curr_time >= start_time && curr_time <= stop_time);
 428:main.c        ****       } else {
 429:main.c        ****         // Przejście przez północ (np. 22:00 - 06:00)
 430:main.c        ****         blokada_sterowania_czasowa =
 431:main.c        ****             !(curr_time >= start_time || curr_time <= stop_time);
 432:main.c        ****       }
 433:main.c        ****     } else {
 434:main.c        ****       blokada_sterowania_czasowa = FALSE;
 435:main.c        ****     }
 436:main.c        ****   }
 437:main.c        **** 
 438:main.c        ****   // Resetuj flagę pomijania dla następnego SMS
 439:main.c        ****   sms_pomijaj_aktualizacje_czasu = FALSE;
 440:main.c        **** 
 441:main.c        ****   // Auto-sync: Wyłącz po pierwszej synchronizacji czasu
 442:main.c        ****   if (autosync_czas_aktywny) {
 443:main.c        ****     autosync_czas_aktywny = FALSE;
 444:main.c        ****   }
 445:main.c        **** 
 446:main.c        ****   // --- BLOKADA SYSTEMU (START/STOP) ---
 447:main.c        ****   if (blokada_systemu) {
 448:main.c        ****     // Gdy zablokowany, akceptuj tylko START i REPORT
 449:main.c        ****     if (komenda != INTERPRETACJA_SMS_POPRAWNY && // START/STOP zwracaja POPRAWNY
 450:main.c        ****         komenda != INTERPRETACJA_SMS_RAPORT) {
 451:main.c        ****       // Sprawdz czy to byla komenda START (ktora wlasnie odblokowala system)
 452:main.c        ****       // Jesli system nadal jest zablokowany (czyli to nie byl START), to
 453:main.c        ****       // ignoruj
 454:main.c        ****       if (eeprom_read_byte((const uint8_t *)ADRES_EEPROM_BLOKADA_SYSTEMU) ==
 455:main.c        ****           1) {
 456:main.c        ****         zapisz_debug_do_eeprom(1, 2); // Debug: Odrzucono przez blokade
 457:main.c        ****         usun_zablokowany_sms();
 458:main.c        ****         return;
 459:main.c        ****       }
 460:main.c        ****     }
 461:main.c        ****   }
 462:main.c        **** 
 463:main.c        ****   // --- WARSTWA 1: Limit czasowy (Rate Limiting) - V7 style ---
 464:main.c        ****   if (komenda == INTERPRETACJA_SMS_RAPORT ||
 465:main.c        ****       komenda == INTERPRETACJA_SMS_USER) {
 466:main.c        ****     if (licznik_report_user >= MAX_LICZBA_KOMEND_REPORT_USER_W_OKNIE) {
 467:main.c        ****       zapisz_debug_do_eeprom(1, 1);
 468:main.c        ****       usun_zablokowany_sms();
 469:main.c        ****       zareaguj_na_usuniety_sms_z_powodu_limitu();
 470:main.c        ****       watchdog_sms_disarm();
 471:main.c        ****       return;
 472:main.c        ****     }
 473:main.c        ****   }
 474:main.c        **** 
 475:main.c        ****   // --- WARSTWA 2: Sprawdzenie zajętości modemu (Busy Check) ---
 476:main.c        ****   if (flaga_wysylanie_smsa) {
 477:main.c        ****     // Same number check
 478:main.c        ****     if (strcmp((char *)numer_telefonu_odebranego_smsa,
 479:main.c        ****                (char *)numer_telefonu_wysylanego_smsa) == 0) {
 480:main.c        ****       zapisz_debug_do_eeprom(1, 1);
 481:main.c        ****       usun_zablokowany_sms();
 482:main.c        ****       zareaguj_na_usuniety_sms_z_powodu_limitu();
 483:main.c        ****       watchdog_sms_disarm();
 484:main.c        ****       return;
 485:main.c        ****     }
 486:main.c        ****     // Different number but busy
 487:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 488:main.c        ****     usun_zablokowany_sms();
 489:main.c        ****     zareaguj_na_usuniety_sms_z_powodu_limitu();
 490:main.c        ****     watchdog_sms_disarm();
 491:main.c        ****     return;
 492:main.c        ****   }
 493:main.c        **** 
 494:main.c        ****   // --- WARSTWA 3 i 4: Ochrona kolejki ---
 495:main.c        ****   uchar liczba_sms_w_kolejce = 0;
 496:main.c        ****   uchar liczba_wszystkich_komend = 0;
 497:main.c        ****   for (uchar i = 0; i < LICZBA_KOMEND; ++i) {
 498:main.c        ****     if (komendy_kolejka[i] != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 499:main.c        ****       ++liczba_wszystkich_komend;
 500:main.c        ****       if (komendy_kolejka[i] >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
 501:main.c        ****           komendy_kolejka[i] <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
 502:main.c        ****         ++liczba_sms_w_kolejce;
 503:main.c        ****     }
 504:main.c        ****   }
 505:main.c        **** 
 506:main.c        ****   if (liczba_wszystkich_komend >= 35) {
 507:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 508:main.c        ****     usun_zablokowany_sms();
 509:main.c        ****     zareaguj_na_usuniety_sms_z_powodu_limitu();
 510:main.c        ****     watchdog_sms_disarm();
 511:main.c        ****     return;
 512:main.c        ****   }
 513:main.c        **** 
 514:main.c        ****   if (liczba_sms_w_kolejce >= 6) {
 515:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 516:main.c        ****     usun_zablokowany_sms();
 517:main.c        ****     zareaguj_na_usuniety_sms_z_powodu_limitu();
 518:main.c        ****     watchdog_sms_disarm();
 519:main.c        ****     return;
 520:main.c        ****   }
 521:main.c        **** 
 522:main.c        ****   switch (komenda) {
 523:main.c        ****   case INTERPRETACJA_SMS_POPRAWNY:
 524:main.c        ****     zapal_diode_led_blyski(2); // Odbior poprawnej komendy - 2 blyski
 525:main.c        ****     break;
 526:main.c        ****   case INTERPRETACJA_SMS_BRAK_KODU: {
 527:main.c        ****     zapal_diode_led_blyski(1); // Odbior zwyklego SMS (bez kodu) - 1 blysk
 528:main.c        ****     zapisz_debug_do_eeprom(0, 3);
 529:main.c        ****     break;
 530:main.c        ****   }
 531:main.c        ****   case INTERPRETACJA_SMS_RAPORT: {
 532:main.c        ****     ++licznik_report_user;
 533:main.c        ****     timer_report_user_100ms = OKNO_CZASOWE_REPORT_USER_100MS;
 534:main.c        **** 
 535:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 536:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 537:main.c        ****     generuj_raport_stanu_urzadzenia();
 538:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 539:main.c        ****     zapal_diode_led_blyski(2); // Komenda REPORT - 2 blyski
 540:main.c        ****     zapisz_debug_do_eeprom(1, 0);
 541:main.c        ****     break;
 542:main.c        ****   }
 543:main.c        ****   case INTERPRETACJA_SMS_DEBUG: {
 544:main.c        ****     // DEBUG - wyślij flagi debug dla SKRYBA i USER
 545:main.c        ****     strcpy_P((char *)tekst_wysylanego_smsa, PSTR("DEBUG\n"));
 546:main.c        ****     uchar *sms = tekst_wysylanego_smsa + strlen((char *)tekst_wysylanego_smsa);
 547:main.c        **** 
 548:main.c        ****     // SKRYBA DEBUG
 549:main.c        ****     strcpy_P((char *)sms, PSTR("SKRYBA:"));
 550:main.c        ****     sms += strlen((char *)sms);
 551:main.c        ****     *sms++ =
 552:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_2);
 553:main.c        ****     *sms++ =
 554:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_3);
 555:main.c        ****     *sms++ =
 556:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_4);
 557:main.c        ****     *sms++ =
 558:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_5);
 559:main.c        ****     *sms++ = '\n';
 560:main.c        **** 
 561:main.c        ****     // USER DEBUG - wyświetl jako liczby dziesiętne
 562:main.c        ****     strcpy_P((char *)sms, PSTR("U1="));
 563:main.c        ****     sms += strlen((char *)sms);
 564:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_1), sms, 10);
 565:main.c        ****     sms += strlen((char *)sms);
 566:main.c        **** 
 567:main.c        ****     strcpy_P((char *)sms, PSTR(" U2="));
 568:main.c        ****     sms += strlen((char *)sms);
 569:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_2), sms, 10);
 570:main.c        ****     sms += strlen((char *)sms);
 571:main.c        **** 
 572:main.c        ****     strcpy_P((char *)sms, PSTR(" U3="));
 573:main.c        ****     sms += strlen((char *)sms);
 574:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_3), sms, 10);
 575:main.c        ****     sms += strlen((char *)sms);
 576:main.c        ****     *sms++ = '\n';
 577:main.c        **** 
 578:main.c        ****     strcpy_P((char *)sms, PSTR("U4="));
 579:main.c        ****     sms += strlen((char *)sms);
 580:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_4), sms, 10);
 581:main.c        ****     sms += strlen((char *)sms);
 582:main.c        **** 
 583:main.c        ****     strcpy_P((char *)sms, PSTR(" U5="));
 584:main.c        ****     sms += strlen((char *)sms);
 585:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_5), sms, 10);
 586:main.c        ****     sms += strlen((char *)sms);
 587:main.c        **** 
 588:main.c        ****     strcpy_P((char *)sms, PSTR(" U6="));
 589:main.c        ****     sms += strlen((char *)sms);
 590:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_6), sms, 10);
 591:main.c        ****     sms += strlen((char *)sms);
 592:main.c        **** 
 593:main.c        ****     strcpy_P((char *)sms, PSTR(" U7="));
 594:main.c        ****     sms += strlen((char *)sms);
 595:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_7), sms, 10);
 596:main.c        ****     sms += strlen((char *)sms);
 597:main.c        ****     *sms++ = '\n';
 598:main.c        **** 
 599:main.c        ****     strcpy_P((char *)sms, PSTR("1=RCV 2=BSY 3=CNT 4=QSM 5=QAL 6=FND 7=ADD"));
 600:main.c        **** 
 601:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 602:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 603:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 604:main.c        ****     zapal_diode_led_blyski(2);
 605:main.c        ****     break;
 606:main.c        ****   }
 607:main.c        ****   case INTERPRETACJA_SMS_USER: {
 608:main.c        ****     ++licznik_report_user;
 609:main.c        ****     timer_report_user_100ms = OKNO_CZASOWE_REPORT_USER_100MS;
 610:main.c        **** 
 611:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 612:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 613:main.c        **** 
 614:main.c        ****     // Uzyj lokalnego bufora aby uniknac konfliktow z EEPROM
 615:main.c        ****     uchar temp_buf[LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM];
 616:main.c        **** 
 617:main.c        ****     // Konwertuj numer na format EEPROM
 618:main.c        ****     konwertuj_telefon_na_blok_eeprom(
 619:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
 620:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[strlen(
 621:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
 622:main.c        ****         temp_buf);
 623:main.c        **** 
 624:main.c        ****     // Sprawdz czy numer jest na liscie
 625:main.c        ****     uchar znaleziono = FALSE;
 626:main.c        ****     for (uint nr_uzyt_clip = 0;
 627:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 628:main.c        ****       if (porownaj_numer_telefonu_blok(
 629:main.c        ****               temp_buf, (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
 630:main.c        ****         znaleziono = TRUE;
 631:main.c        ****         break;
 632:main.c        ****       }
 633:main.c        ****     }
 634:main.c        **** 
 635:main.c        ****     // Przygotuj odpowiedz - pokaz FAKTYCZNY numer z EEPROM (max 9 cyfr)
 636:main.c        ****     // zamiast numeru wpisanego w komendzie (ktory moze miec prefiks +48)
 637:main.c        ****     uchar numer_z_eeprom[MAX_LICZBA_ZNAKOW_TELEFON + 1];
 638:main.c        ****     konwertuj_blok_eeprom_na_telefon(temp_buf, numer_z_eeprom,
 639:main.c        ****                                      MAX_LICZBA_ZNAKOW_TELEFON + 1);
 640:main.c        **** 
 641:main.c        ****     strcpy((char *)tekst_wysylanego_smsa, (char *)numer_z_eeprom);
 642:main.c        ****     strcat((char *)tekst_wysylanego_smsa, ": ");
 643:main.c        ****     if (znaleziono) {
 644:main.c        ****       strcat((char *)tekst_wysylanego_smsa, "OK");
 645:main.c        ****     } else {
 646:main.c        ****       strcat((char *)tekst_wysylanego_smsa, "Brak takiego numeru w systemie");
 647:main.c        ****     }
 648:main.c        **** 
 649:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 650:main.c        **** 
 651:main.c        ****     zapal_diode_led_blyski(2); // Komenda USER - 2 blyski
 652:main.c        **** 
 653:main.c        ****     // Zapisz debug tylko na koncu (bezpiecznie)
 654:main.c        ****     // U1=1 (USER), U6=znaleziono
 655:main.c        ****     if (czy_wolny_eeprom()) {
 656:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 657:main.c        ****       // Ale poniewaz zapisz_znak_w_eeprom uzywa przerwan, nie mozemy wolac go
 658:main.c        ****       // od razu drugi raz Mozemy zapisac skondensowana informacje lub uzyc
 659:main.c        ****       // bufora Dla bezpieczenstwa zapiszmy tylko jeden bajt statusu Bit 0:
 660:main.c        ****       // znaleziono, Bit 1: USER wykonany zapisz_znak_w_eeprom(znaleziono |
 661:main.c        ****       // 0x02, ADRES_EEPROM_DEBUG_USER_6);
 662:main.c        ****     }
 663:main.c        ****     zapisz_debug_do_eeprom(2, znaleziono); // 2 = USER
 664:main.c        ****     break;
 665:main.c        ****   }
 666:main.c        ****   case INTERPRETACJA_SMS_USER_BEZ_NUMERU: {
 667:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 668:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 669:main.c        ****     strcpy((char *)tekst_wysylanego_smsa,
 670:main.c        ****            "Wpisz numer jaki sprawdzasz, np: USER 793557357");
 671:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 672:main.c        ****     zapal_diode_led_blyski(2);
 673:main.c        ****     break;
 674:main.c        ****   }
 675:main.c        ****   case INTERPRETACJA_SMS_USER_LIST: {
 676:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 677:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 678:main.c        ****     numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama = 0;
 679:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW);
 680:main.c        ****     zapal_diode_led_blyski(2);
 681:main.c        ****     break;
 682:main.c        ****   }
 683:main.c        ****   case INTERPRETACJA_SMS_RESET_WSZYSTKICH_USTAWIEN: {
 684:main.c        ****     if (not czy_sa_komendy_z_przedzialu(
 685:main.c        ****             KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 686:main.c        ****             KOMENDA_KOLEJKI_RESET_USTAWIEN_INICJALIZACJA)) {
 687:main.c        ****       zapal_diode_led_blyski(25);
 688:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
 689:main.c        ****     }
 690:main.c        ****     break;
 691:main.c        ****   }
 692:main.c        ****   default:
 693:main.c        ****     break;
 694:main.c        ****   }
 695:main.c        **** 
 696:main.c        ****   watchdog_sms_disarm();
 697:main.c        **** }
 698:main.c        **** 
 699:main.c        **** void steruj_wejsciem_reset_100ms(void) {
 700:main.c        ****   static uchar licznik_reset;
 701:main.c        ****   if (CZY_AKTUALNY_STAN_LOGICZNY_ON(0)) {
 702:main.c        ****     if (licznik_reset < 20 * 10)
 703:main.c        ****       ++licznik_reset;
 704:main.c        ****   } else {
 705:main.c        ****     if (licznik_reset >= 20 * 10) {
 706:main.c        ****       if (not czy_sa_komendy_z_przedzialu(
 707:main.c        ****               KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 708:main.c        ****               KOMENDA_KOLEJKI_RESET_USTAWIEN_INICJALIZACJA))
 709:main.c        ****         dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
 710:main.c        ****     } else if (licznik_reset >= 5 * 10) {
 711:main.c        ****       if (not czy_sa_komendy_z_przedzialu(
 712:main.c        ****               KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 713:main.c        ****               KOMENDA_KOLEJKI_RESET_USTAWIEN_INICJALIZACJA))
 714:main.c        ****         dodaj_komende(KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU);
 715:main.c        ****     }
 716:main.c        ****     licznik_reset = 0;
 717:main.c        ****   }
 718:main.c        **** }
 719:main.c        **** 
 720:main.c        **** uchar sprawdz_przychodzaca_rozmowe(void) // wysya TRUE, gdy naley odebra
 721:main.c        **** {
 722:main.c        ****   // Super User: pozycje 795-800 omijaja wszystkie blokady
 723:main.c        ****   uchar jest_super_user =
 724:main.c        ****       czy_numer_jest_super_userem(numer_telefonu_ktory_dzwoni);
 725:main.c        **** 
 726:main.c        ****   if (blokada_systemu && !jest_super_user) {
 727:main.c        ****     return FALSE; // Ignoruj rozmowy gdy system zablokowany (chyba ze super
 728:main.c        ****                   // user)
 729:main.c        ****   }
 730:main.c        **** 
 731:main.c        ****   if (blokada_sterowania_czasowa && !jest_super_user) {
 732:main.c        ****     return FALSE; // Ignoruj rozmowy gdy blokada czasowa (chyba ze super user)
 733:main.c        ****   }
 734:main.c        **** 
 735:main.c        ****   // W trybie DTMF:
 736:main.c        ****   if (!tryb_clip) {
 737:main.c        ****     if (numer_telefonu_ktory_dzwoni[0] != 0)
 738:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA);
 739:main.c        **** 
 740:main.c        ****     // Publiczny: odbierz wszystkie
 741:main.c        ****     if (tryb_pracy == 1)
 742:main.c        ****       return TRUE;
 743:main.c        **** 
 744:main.c        ****     // Prywatny: sprawdź autoryzację SYNCHRONICZNIE
 745:main.c        ****     // Konwertuj numer na format EEPROM
 746:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_ktory_dzwoni[0],
 747:main.c        ****                                      &numer_telefonu_ktory_dzwoni[strlen(
 748:main.c        ****                                          (char *)numer_telefonu_ktory_dzwoni)],
 749:main.c        ****                                      &bufor_eeprom[0]);
 750:main.c        **** 
 751:main.c        ****     // Sprawdź listę autoryzowanych numerów
 752:main.c        ****     for (uint nr_uzyt = 0; nr_uzyt < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 753:main.c        ****          ++nr_uzyt) {
 754:main.c        ****       if (porownaj_numer_telefonu_blok(
 755:main.c        ****               &bufor_eeprom[0], (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt))) {
 756:main.c        ****         return TRUE; // Numer autoryzowany - odbierz
 757:main.c        ****       }
 758:main.c        ****     }
 759:main.c        ****     return FALSE; // Numer nieautoryzowany - odrzuć
 760:main.c        ****   }
 761:main.c        **** 
 762:main.c        ****   // W trybie CLIP:
 763:main.c        ****   if (numer_telefonu_ktory_dzwoni[0] != 0)
 764:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA);
 765:main.c        **** 
 766:main.c        ****   // Publiczny: włącz wyjście dla wszystkich
 767:main.c        ****   if (tryb_pracy == 1)
 768:main.c        ****     return TRUE;
 769:main.c        **** 
 770:main.c        ****   // Prywatny: sprawdź autoryzację
 771:main.c        ****   return FALSE; // Autoryzacja przez SPRAWDZ_UZYTKOWNIKOW_BRAMA
 772:main.c        **** }
 773:main.c        **** 
 774:main.c        **** uchar wysylanie_echa_przez_pdu = FALSE;
 775:main.c        **** 
 776:main.c        **** uchar *ptr_start_pdu_z_wiadomoscia; // pierwszy znak
 777:main.c        **** 
 778:main.c        **** #define WYSYLANIE_SMSA_CLIPA_BRAK 0
 779:main.c        **** #define WYSYLANIE_SMSA_WYSYLANIE 1
 780:main.c        **** #define WYSYLANIE_SMSA_POWTARZANIE 2
 781:main.c        **** #define WYSYLANIE_CLIPA_WYSYLANIE 4
 782:main.c        **** #define WYSYLANIE_CLIPA_KONCZENIE 5
 783:main.c        **** 
 784:main.c        **** uchar wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
 785:main.c        **** 
 786:main.c        **** enum PowodZakonczeniaRozmowyTelefonicznej {
 787:main.c        ****   powod_zakonczenia_rozmowy_odrzucenie,
 788:main.c        ****   powod_zakonczenia_rozmowy_zakonczenie,
 789:main.c        ****   powod_zakonczenia_rozmowy_przekroczony_czas,
 790:main.c        ****   powod_zakonczenia_rozmowy_otrzymana_wiadomosc
 791:main.c        **** };
 792:main.c        **** 
 793:main.c        **** void zakonczono_rozmowe_telefoniczna(
 794:main.c        ****     const enum PowodZakonczeniaRozmowyTelefonicznej powod) {
 795:main.c        ****   POMOC_DODAJ2('#', 'a');
 796:main.c        ****   opoznienie_SIM900_100MS = 60; // byo 60
 797:main.c        ****   licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 798:main.c        ****   ustaw_maksymalny_czas_dzwonienia = 0;
 799:main.c        ****   maksymalny_czas_dzwonienia = 0;
 800:main.c        ****   blokada_clip = FALSE;
 801:main.c        **** }
 802:main.c        **** 
 803:main.c        **** enum PowodZakonczeniaWysylaniaSMS {
 804:main.c        ****   zakonczenie_wysylania_sms_ok,
 805:main.c        ****   zakonczenie_wysylania_sms_blad_powtarzanie,
 806:main.c        ****   zakonczenie_wysylania_sms_blad_zakonczenie,
 807:main.c        ****   zakonczenie_wysylania_sms_blad_powtorz_sms,
 808:main.c        **** };
 809:main.c        **** 
 810:main.c        **** void zakonczono_wysylanie_smsa(const enum PowodZakonczeniaWysylaniaSMS powod) {
 811:main.c        ****   POMOC_DODAJ2('#', 'A');
 812:main.c        ****   opoznienie_SIM900_100MS = 60;
 813:main.c        **** 
 814:main.c        ****   wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
 815:main.c        **** }
 816:main.c        **** 
 817:main.c        **** void problem_z_wyslaniem_powiadomienia(void) {
 818:main.c        ****   wykonywanie_rozmowy_telefonicznej = FALSE;
 819:main.c        ****   licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 820:main.c        ****   wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 821:main.c        ****   czekanie_na_odebranie_zachety = FALSE;
 822:main.c        ****   opoznienie_SIM900_100MS = 60;
 823:main.c        ****   flaga_wysylanie_smsa = 0;
 824:main.c        **** }
 825:main.c        **** 
 826:main.c        **** #define JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ()                             \
 827:main.c        ****   if (!czy_mozna_wysylac_dane_do_SIM900) {                                     \
 828:main.c        ****     dodaj_komende(wykonywana_komenda);                                         \
 829:main.c        ****     break;                                                                     \
 830:main.c        ****   }                                                                            \
 831:main.c        ****   wysylane_polecenie_SIM900 = wykonywana_komenda;
 832:main.c        **** 
 833:main.c        **** #define POWTORZ_JESLI(WAR)                                                     \
 834:main.c        ****   {                                                                            \
 835:main.c        ****     if (WAR) {                                                                 \
 836:main.c        ****       dodaj_komende(wykonywana_komenda);                                       \
 837:main.c        ****       break;                                                                   \
 838:main.c        ****     }                                                                          \
 839:main.c        ****   }
 840:main.c        **** 
 841:main.c        **** #define JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ() POWTORZ_JESLI(!czy_wolny_eeprom())
 842:main.c        **** 
 843:main.c        **** #define JESLI_SIM900_ZAJETY_WYKONAJ_POZNIEJ() POWTORZ_JESLI(czy_gsm_zajety)
 844:main.c        **** 
 845:main.c        **** #include "main_sim900.h"
 846:main.c        **** 
 847:main.c        **** #define aktualnie_wykonywana_komenda wykonywana_komenda
 848:main.c        **** 
 849:main.c        **** void inicjalizuj_parametry_modulu(void);
 850:main.c        **** 
 851:main.c        **** #define MAX_LICZBA_KOMEND_DLA_ALARMOW (LICZBA_KOMEND / 4)
 852:main.c        **** 
 853:main.c        **** // Funkcja pomocnicza: Wyciąga ostatnie N cyfr z numeru telefonu
 854:main.c        **** // max_digits: maksimum cyfr (9)
 855:main.c        **** static void wyciagnij_ostatnie_cyfry(const uchar *numer_pelny,
 856:main.c        ****                                      uchar *numer_skrocony, uchar max_digits) {
 857:main.c        ****   uchar len = strlen((char *)numer_pelny);
 858:main.c        **** 
 859:main.c        ****   if (len > max_digits) {
 860:main.c        ****     // Take last max_digits
 861:main.c        ****     strcpy((char *)numer_skrocony, (char *)numer_pelny + (len - max_digits));
 862:main.c        ****   } else {
 863:main.c        ****     // Take all
 864:main.c        ****     strcpy((char *)numer_skrocony, (char *)numer_pelny);
 865:main.c        ****   }
 866:main.c        **** }
 867:main.c        **** 
 868:main.c        **** // Helper function to check if a number exists in EEPROM
 869:main.c        **** // Uses bufor_eeprom as temporary storage for comparison
 870:main.c        **** static uchar czy_numer_istnieje(const uchar *numer_telefonu) {
  35               		.loc 1 870 0
  36               		.cfi_startproc
  37               	.LVL0:
  38 000e CF93      		push r28
  39               	.LCFI0:
  40               		.cfi_def_cfa_offset 3
  41               		.cfi_offset 28, -2
  42 0010 DF93      		push r29
  43               	.LCFI1:
  44               		.cfi_def_cfa_offset 4
  45               		.cfi_offset 29, -3
  46               	/* prologue: function */
  47               	/* frame size = 0 */
  48               	/* stack size = 2 */
  49               	.L__stack_usage = 2
 871:main.c        ****   // Convert number to EEPROM block format
 872:main.c        ****   // We use a local buffer to avoid corrupting global buffers if possible,
 873:main.c        ****   // but porownaj_numer_telefonu_blok expects a block.
 874:main.c        ****   // Let's use bufor_eeprom as it is standard for this operation in this
 875:main.c        ****   // codebase.
 876:main.c        ****   konwertuj_telefon_na_blok_eeprom(
 877:main.c        ****       numer_telefonu, numer_telefonu + strlen((char *)numer_telefonu),
  50               		.loc 1 877 0
  51 0012 FC01      		movw r30,r24
  52               		0:
  53 0014 0190      		ld __tmp_reg__,Z+
  54 0016 0020      		tst __tmp_reg__
  55 0018 01F4      		brne 0b
  56 001a BF01      		movw r22,r30
 876:main.c        ****       numer_telefonu, numer_telefonu + strlen((char *)numer_telefonu),
  57               		.loc 1 876 0
  58 001c 6150      		subi r22,1
  59 001e 7109      		sbc r23,__zero_reg__
  60 0020 40E0      		ldi r20,lo8(bufor_eeprom)
  61 0022 50E0      		ldi r21,hi8(bufor_eeprom)
  62 0024 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
  63               	.LVL1:
  64 0028 C8E0      		ldi r28,lo8(8)
  65 002a D0E0      		ldi r29,0
  66               	.LVL2:
  67               	.L4:
  68               	.LBB358:
 878:main.c        ****       bufor_eeprom);
 879:main.c        **** 
 880:main.c        ****   for (uint nr_uzyt_clip = 0; nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 881:main.c        ****        ++nr_uzyt_clip) {
 882:main.c        ****     if (porownaj_numer_telefonu_blok(
  69               		.loc 1 882 0
  70 002c BE01      		movw r22,r28
  71 002e 80E0      		ldi r24,lo8(bufor_eeprom)
  72 0030 90E0      		ldi r25,hi8(bufor_eeprom)
  73 0032 0E94 0000 		call porownaj_numer_telefonu_blok
  74               	.LVL3:
  75 0036 8111      		cpse r24,__zero_reg__
  76 0038 00C0      		rjmp .L5
  77 003a 2596      		adiw r28,5
 880:main.c        ****        ++nr_uzyt_clip) {
  78               		.loc 1 880 0
  79 003c C83A      		cpi r28,-88
  80 003e FFE0      		ldi r31,15
  81 0040 DF07      		cpc r29,r31
  82 0042 01F4      		brne .L4
  83               	.L2:
  84               	/* epilogue start */
  85               	.LBE358:
 883:main.c        ****             bufor_eeprom, (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
 884:main.c        ****       return TRUE;
 885:main.c        ****     }
 886:main.c        ****   }
 887:main.c        ****   return FALSE;
 888:main.c        **** }
  86               		.loc 1 888 0
  87 0044 DF91      		pop r29
  88 0046 CF91      		pop r28
  89 0048 0895      		ret
  90               	.L5:
  91               	.LBB359:
 884:main.c        ****     }
  92               		.loc 1 884 0
  93 004a 8FEF      		ldi r24,lo8(-1)
  94 004c 00C0      		rjmp .L2
  95               	.LBE359:
  96               		.cfi_endproc
  97               	.LFE58:
 100               	usun_zablokowany_sms:
 101               	.LFB36:
 347:main.c        ****   // Usun SMS z modulu SIM900 (numer jest w aktualnie_wysylane_polecenie_SIM900)
 102               		.loc 1 347 0
 103               		.cfi_startproc
 104               	/* prologue: function */
 105               	/* frame size = 0 */
 106               	/* stack size = 0 */
 107               	.L__stack_usage = 0
 350:main.c        ****       aktualnie_wysylane_polecenie_SIM900 <= KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 108               		.loc 1 350 0
 109 004e 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 110 0052 96E5      		ldi r25,lo8(86)
 111 0054 980F      		add r25,r24
 112               	.LBB360:
 355:main.c        ****   } else {
 113               		.loc 1 355 0
 114 0056 8C5E      		subi r24,lo8(-(20))
 115               	.LBE360:
 350:main.c        ****       aktualnie_wysylane_polecenie_SIM900 <= KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 116               		.loc 1 350 0
 117 0058 9431      		cpi r25,lo8(20)
 118 005a 00F0      		brlo .L9
 358:main.c        ****   }
 119               		.loc 1 358 0
 120 005c 82E9      		ldi r24,lo8(-110)
 121               	.L9:
 122 005e 0C94 0000 		jmp filtruj_i_dodaj_komende
 123               	.LVL4:
 124               		.cfi_endproc
 125               	.LFE36:
 128               	zareaguj_na_usuniety_sms_z_powodu_limitu:
 129               	.LFB37:
 362:main.c        ****   if (licznik_usunietych_sms_przez_limit < 0xFFFF)
 130               		.loc 1 362 0
 131               		.cfi_startproc
 132               	/* prologue: function */
 133               	/* frame size = 0 */
 134               	/* stack size = 0 */
 135               	.L__stack_usage = 0
 363:main.c        ****     ++licznik_usunietych_sms_przez_limit;
 136               		.loc 1 363 0
 137 0062 8091 0000 		lds r24,licznik_usunietych_sms_przez_limit
 138 0066 9091 0000 		lds r25,licznik_usunietych_sms_przez_limit+1
 139 006a 8F3F      		cpi r24,-1
 140 006c 9807      		cpc r25,r24
 141 006e 01F0      		breq .L11
 364:main.c        ****   sygnalizuj_pelny_system();
 142               		.loc 1 364 0
 143 0070 0196      		adiw r24,1
 144 0072 9093 0000 		sts licznik_usunietych_sms_przez_limit+1,r25
 145 0076 8093 0000 		sts licznik_usunietych_sms_przez_limit,r24
 146               	.L11:
 147               	.LBB363:
 148               	.LBB364:
 343:main.c        **** }
 149               		.loc 1 343 0
 150 007a 8AE0      		ldi r24,lo8(10)
 151 007c 8093 0000 		sts liczba_blyskow_led,r24
 152 0080 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 153               	.LBE364:
 154               	.LBE363:
 366:main.c        ****   // Uzywamy filtruj_i_dodaj
 155               		.loc 1 366 0
 156 0084 0E94 0000 		call watchdog_sms_disarm
 157               	.LVL5:
 368:main.c        **** }
 158               		.loc 1 368 0
 159 0088 82E9      		ldi r24,lo8(-110)
 160 008a 0C94 0000 		jmp filtruj_i_dodaj_komende
 161               	.LVL6:
 162               		.cfi_endproc
 163               	.LFE37:
 166               	polozenie_polecenia_SIM900:
 167               	.LFB48:
 168               		.file 2 "main_sim900.h"
   1:main_sim900.h **** 
   2:main_sim900.h **** #ifdef MAIN_SIM900_H
   3:main_sim900.h **** #error Dwa razy wlaczany plik
   4:main_sim900.h **** #endif
   5:main_sim900.h **** 
   6:main_sim900.h **** void wyzerowanie_danych_SIM900(void) {
   7:main_sim900.h ****   POMOC_DODAJ2('*', 't');
   8:main_sim900.h ****   problem_z_wyslaniem_powiadomienia();
   9:main_sim900.h ****   licznik_wysylane_polecenie_SIM900 = 0;
  10:main_sim900.h ****   aktualnie_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
  11:main_sim900.h ****   liczba_komend_w_kolejce_SIM900 = 0;
  12:main_sim900.h ****   licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow = 0;
  13:main_sim900.h ****   czekanie_na_odebranie_zachety = FALSE;
  14:main_sim900.h ****   flaga_odebrany_znak_zachety = FALSE;
  15:main_sim900.h ****   trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
  16:main_sim900.h ****   wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
  17:main_sim900.h ****   flaga_odczytywanie_smsa = FALSE;
  18:main_sim900.h **** }
  19:main_sim900.h **** 
  20:main_sim900.h **** void reset_modulu_SIM900(void) {
  21:main_sim900.h ****   wyzerowanie_danych_SIM900();
  22:main_sim900.h ****   POMOC_DODAJ2('*', 'm');
  23:main_sim900.h ****   HARDRESET_SIM900();
  24:main_sim900.h ****   podlaczony_modul_gsm_SIM900 = FALSE;
  25:main_sim900.h ****   podlaczona_karta_SIM_SIM900 = FALSE;
  26:main_sim900.h ****   licznik_blad_stanu_karty_SIM = 0;
  27:main_sim900.h ****   licznik_blad_zalogowania_u_operatora = 0;
  28:main_sim900.h ****   nazwa_operatora[0] = '\0';
  29:main_sim900.h ****   licznik_ogolny_blad_zalogowania = 0;
  30:main_sim900.h ****   blokada_clip = FALSE;
  31:main_sim900.h ****   nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
  32:main_sim900.h ****   poziom_sieci_gsm = POZIOM_SIECI_BLAD;
  33:main_sim900.h ****   filtruj_komendy_z_przedzialu(KOMENDA_KOLEJKI_USUN_SMSA_1,
  34:main_sim900.h ****                                KOMENDA_KOLEJKI_USUN_SMSA_20);
  35:main_sim900.h ****   filtruj_komendy_z_przedzialu(
  36:main_sim900.h ****       KOMENDA_KOLEJKI_KOMENDA_SIM900,
  37:main_sim900.h ****       KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE);
  38:main_sim900.h ****   filtruj_komendy_z_przedzialu(
  39:main_sim900.h ****       KOMENDA_KOLEJKI_SPRAWDZ_PIN,
  40:main_sim900.h ****       KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ);
  41:main_sim900.h ****   filtruj_komendy_z_przedzialu(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT,
  42:main_sim900.h ****                                KOMENDA_KOLEJKI_WYSLIJ_PDU);
  43:main_sim900.h ****   modul_zalogowany_w_sieci = FALSE;
  44:main_sim900.h **** }
  45:main_sim900.h **** 
  46:main_sim900.h **** static uchar czy_polecenie_SIM900(PGM_P polecenie, const uchar liczba_znakow) {
  47:main_sim900.h ****   return strncmp_P(odebrany_blok_SIM900 + 2, polecenie, liczba_znakow) == 0;
  48:main_sim900.h **** }
  49:main_sim900.h **** 
  50:main_sim900.h **** static uchar *polozenie_polecenia_SIM900(PGM_P polecenie) {
 169               		.loc 2 50 0
 170               		.cfi_startproc
 171               	.LVL7:
 172               	/* prologue: function */
 173               	/* frame size = 0 */
 174               	/* stack size = 0 */
 175               	.L__stack_usage = 0
  51:main_sim900.h ****   return strstr_P(odebrany_blok_SIM900, polecenie);
 176               		.loc 2 51 0
 177 008e BC01      		movw r22,r24
 178 0090 80E0      		ldi r24,lo8(odebrany_blok_SIM900)
 179 0092 90E0      		ldi r25,hi8(odebrany_blok_SIM900)
 180               	.LVL8:
 181 0094 0C94 0000 		jmp strstr_P
 182               	.LVL9:
 183               		.cfi_endproc
 184               	.LFE48:
 187               	opoznienie_startowe:
 188               	.LFB70:
 889:main.c        **** 
 890:main.c        **** uchar wykonanie_komend_ukladow(void) {
 891:main.c        ****   const komenda_typ aktualnie_wykonywana_komenda = komendy_kolejka[0];
 892:main.c        **** 
 893:main.c        ****   switch (aktualnie_wykonywana_komenda) {
 894:main.c        ****   case KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU: {
 895:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 896:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 897:main.c        ****     kod_modulu[1] = bufor_eeprom[1] = 'B';
 898:main.c        ****     kod_modulu[2] = bufor_eeprom[2] = 'C';
 899:main.c        ****     kod_modulu[3] = bufor_eeprom[3] = 'D';
 900:main.c        ****     zapisz_znaki_w_eeprom_bez_kopiowania(ADRES_EEPROM_KOD_DOSTEPU,
 901:main.c        ****                                          LICZBA_BAJTOW_KODU_DOSTEPU);
 902:main.c        ****     zapal_diode_led(50);
 903:main.c        ****     break;
 904:main.c        ****   }
 905:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_0:
 906:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_1:
 907:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_2:
 908:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_3:
 909:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_4:
 910:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_5:
 911:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_6:
 912:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_7:
 913:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_8:
 914:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_9:
 915:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_10:
 916:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_11:
 917:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_12:
 918:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_13:
 919:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_14:
 920:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_15:
 921:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_16:
 922:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_17:
 923:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_18:
 924:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_19:
 925:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_20:
 926:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_21:
 927:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_22:
 928:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_23:
 929:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_24:
 930:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_25:
 931:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_26:
 932:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_27:
 933:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_28:
 934:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_29:
 935:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_30:
 936:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_31:
 937:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_32:
 938:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_33:
 939:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_34:
 940:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_35:
 941:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_36:
 942:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_37:
 943:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_38:
 944:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_39:
 945:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_40:
 946:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_41:
 947:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_42:
 948:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_43:
 949:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_44:
 950:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_45:
 951:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_46:
 952:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_47:
 953:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_48:
 954:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_49:
 955:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_50:
 956:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_51:
 957:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_52:
 958:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_53:
 959:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_54:
 960:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_55:
 961:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_56:
 962:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_57:
 963:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_58:
 964:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_59:
 965:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_60:
 966:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_61:
 967:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_62:
 968:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_63:
 969:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_64:
 970:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_65:
 971:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_66:
 972:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_67:
 973:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_68:
 974:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_69:
 975:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_70:
 976:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_71:
 977:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_72:
 978:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_73:
 979:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_74:
 980:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_75:
 981:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_76:
 982:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_77:
 983:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_78:
 984:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_79:
 985:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_80:
 986:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_81:
 987:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_82:
 988:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_83:
 989:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_84:
 990:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_85:
 991:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_86:
 992:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_87:
 993:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_88:
 994:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_89:
 995:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_90:
 996:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_91:
 997:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_92:
 998:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_93:
 999:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_94:
1000:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_95:
1001:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_96:
1002:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_97:
1003:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_98:
1004:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_99:
1005:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_100:
1006:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_101:
1007:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_102:
1008:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_103:
1009:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_104:
1010:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_105:
1011:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_106:
1012:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_107:
1013:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_108:
1014:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_109:
1015:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_110:
1016:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_111:
1017:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_112:
1018:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_113:
1019:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_114:
1020:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_115:
1021:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_116:
1022:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_117:
1023:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_118:
1024:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_119:
1025:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_120:
1026:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_121:
1027:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_122:
1028:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_123:
1029:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_124:
1030:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_125:
1031:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_126:
1032:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_127: {
1033:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1034:main.c        ****     const uchar nr_bloku =
1035:main.c        ****         aktualnie_wykonywana_komenda - KOMENDA_KOLEJKI_RESET_USTAWIEN_0;
1036:main.c        **** #define LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE 32
1037:main.c        ****     memset(bufor_eeprom, 0xff, LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE);
1038:main.c        ****     if (nr_bloku == 0) {
1039:main.c        ****       kod_modulu[0] = bufor_eeprom[1] = 'A';
1040:main.c        ****       kod_modulu[1] = bufor_eeprom[2] = 'B';
1041:main.c        ****       kod_modulu[2] = bufor_eeprom[3] = 'C';
1042:main.c        ****       kod_modulu[3] = bufor_eeprom[4] = 'D';
1043:main.c        ****       bufor_eeprom[5] = 0;
1044:main.c        ****       stan_wyjscie[0] = 0;
1045:main.c        ****       licznik_przelacznik_wyjscia[0] = 0;
1046:main.c        ****     }
1047:main.c        ****     zapisz_znaki_w_eeprom_bez_kopiowania(
1048:main.c        ****         nr_bloku * LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE,
1049:main.c        ****         LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE);
1050:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0 + nr_bloku + 1);
1051:main.c        ****     zapal_diode_led(50);
1052:main.c        ****     break;
1053:main.c        ****   }
1054:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_INICJALIZACJA: {
1055:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1056:main.c        ****     uchar bledny_zapis = FALSE;
1057:main.c        ****     static const uchar tab_eeprom_fabryczny[6] PROGMEM = {
1058:main.c        ****         0xff, 'A', 'B', 'C', 'D', 0x00,
1059:main.c        ****     };
1060:main.c        ****     for (uint i = 0; i < 6; ++i) {
1061:main.c        ****       if (eeprom_read_byte((void *)i) !=
1062:main.c        ****           pgm_read_byte(tab_eeprom_fabryczny + i))
1063:main.c        ****         bledny_zapis = TRUE;
1064:main.c        ****     }
1065:main.c        ****     for (uint i = EEPROM_NUMER_TELEFONU_BRAMA_0;
1066:main.c        ****          i < EEPROM_NUMER_TELEFONU_BRAMA_0 +
1067:main.c        ****                  MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA *
1068:main.c        ****                      LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM;
1069:main.c        ****          ++i) {
1070:main.c        ****       if (eeprom_read_byte((void *)i) != 0xff) {
1071:main.c        ****         bledny_zapis = TRUE;
1072:main.c        ****         break;
1073:main.c        ****       }
1074:main.c        ****     }
1075:main.c        ****     if (bledny_zapis) {
1076:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
1077:main.c        ****       break;
1078:main.c        ****     }
1079:main.c        ****     inicjalizuj_parametry_modulu();
1080:main.c        ****     ustaw_stan_led(FALSE); // Wylacz diode po zakonczeniu resetu
1081:main.c        ****     break;
1082:main.c        ****   }
1083:main.c        ****   case KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA: {
1084:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1085:main.c        **** 
1086:main.c        ****     if (blokada_sterowania_czasowa) {
1087:main.c        ****       // Poza dozwolonym czasem - ignoruj
1088:main.c        ****       break;
1089:main.c        ****     }
1090:main.c        **** 
1091:main.c        ****     // Make a local copy of the phone number to prevent corruption
1092:main.c        ****     // if the global buffer changes during processing (e.g. new CLIP)
1093:main.c        ****     uchar numer_lokalny[MAX_LICZBA_ZNAKOW_TELEFON + 1];
1094:main.c        ****     strcpy((char *)numer_lokalny, (char *)numer_telefonu_ktory_dzwoni);
1095:main.c        **** 
1096:main.c        ****     // Konwertuj numer dla późniejszego użycia
1097:main.c        ****     konwertuj_telefon_na_blok_eeprom(
1098:main.c        ****         &numer_lokalny[0], &numer_lokalny[strlen((char *)numer_lokalny)],
1099:main.c        ****         &bufor_eeprom[0]);
1100:main.c        **** 
1101:main.c        ****     // Sprawdź czy numer jest na liście (PEŁNY NUMER)
1102:main.c        ****     uchar znaleziono = FALSE;
1103:main.c        ****     if (tryb_pracy != 1) {
1104:main.c        ****       // Tylko w trybie prywatnym sprawdzamy listę
1105:main.c        ****       for (uint nr_uzyt_clip = 0;
1106:main.c        ****            nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
1107:main.c        ****         if (porownaj_numer_telefonu_blok(
1108:main.c        ****                 &bufor_eeprom[0],
1109:main.c        ****                 (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
1110:main.c        ****           znaleziono = TRUE;
1111:main.c        ****           break;
1112:main.c        ****         }
1113:main.c        ****       }
1114:main.c        ****     }
1115:main.c        **** 
1116:main.c        ****     // SKRYBA: Jeśli nie znaleziono pełnego, sprawdź skrócony (ostatnie 9 cyfr)
1117:main.c        ****     uchar numer_skrocony[20]; // Increased buffer size
1118:main.c        ****     if (skryba_wlaczona && !znaleziono) {
1119:main.c        ****       wyciagnij_ostatnie_cyfry(numer_lokalny, numer_skrocony, 9);
1120:main.c        **** 
1121:main.c        ****       // Konwertuj skrócony numer do bufor_eeprom dla porównania
1122:main.c        ****       konwertuj_telefon_na_blok_eeprom(
1123:main.c        ****           &numer_skrocony[0], &numer_skrocony[strlen((char *)numer_skrocony)],
1124:main.c        ****           &bufor_eeprom[0]);
1125:main.c        **** 
1126:main.c        ****       if (tryb_pracy != 1) {
1127:main.c        ****         for (uint nr_uzyt_clip = 0;
1128:main.c        ****              nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
1129:main.c        ****              ++nr_uzyt_clip) {
1130:main.c        ****           if (porownaj_numer_telefonu_blok(
1131:main.c        ****                   &bufor_eeprom[0],
1132:main.c        ****                   (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
1133:main.c        ****             znaleziono = TRUE;
1134:main.c        ****             break;
1135:main.c        ****           }
1136:main.c        ****         }
1137:main.c        ****       }
1138:main.c        ****     }
1139:main.c        **** 
1140:main.c        ****     // SKRYBA: Auto-save numer jesli wlaczona i nie znaleziono
1141:main.c        ****     zapisz_znak_w_eeprom(skryba_wlaczona ? 1 : 0,
1142:main.c        ****                          ADRES_EEPROM_DEBUG_SKRYBA_2); // DEBUG
1143:main.c        ****     zapisz_znak_w_eeprom(znaleziono ? 0 : 1,
1144:main.c        ****                          ADRES_EEPROM_DEBUG_SKRYBA_3); // DEBUG
1145:main.c        **** 
1146:main.c        ****     if (skryba_wlaczona && !znaleziono) {
1147:main.c        ****       uchar len_full = strlen((char *)numer_lokalny);
1148:main.c        **** 
1149:main.c        ****       // DEBUG: Zapisz dlugosc numeru
1150:main.c        ****       zapisz_znak_w_eeprom(len_full, ADRES_EEPROM_DEBUG_SKRYBA_5);
1151:main.c        **** 
1152:main.c        ****       if (len_full >= 3) {
1153:main.c        ****         // Skopiuj skrócony numer do numer_telefonu_skryba
1154:main.c        ****         strcpy((char *)numer_telefonu_skryba, (char *)numer_skrocony);
1155:main.c        **** 
1156:main.c        ****         // Extra check: ensure extracted number is also >= 3 chars
1157:main.c        ****         if (strlen((char *)numer_telefonu_skryba) >= 3) {
1158:main.c        ****           zapisz_znak_w_eeprom(
1159:main.c        ****               1, ADRES_EEPROM_DEBUG_SKRYBA_4); // DEBUG: komenda dodana
1160:main.c        **** 
1161:main.c        ****           // Dodaj komende dodania uzytkownika Skryba
1162:main.c        ****           dodaj_komende(KOMENDA_KOLEJKI_DODAJ_UZYTKOWNIKA_SKRYBA);
1163:main.c        ****         }
1164:main.c        ****       }
1165:main.c        ****     }
1166:main.c        **** 
1167:main.c        ****     // Teraz sprawdź tryb i otwórz bramę (TYLKO W TRYBIE CLIP!)
1168:main.c        ****     if (tryb_clip) {
1169:main.c        ****       if (tryb_pracy == 1) {
1170:main.c        ****         // Tryb publiczny - otwórz dla każdego
1171:main.c        ****         ustaw_wyjscie_clip();
1172:main.c        ****       } else if (znaleziono) {
1173:main.c        ****         // Tryb prywatny - otwórz tylko dla znalezionych
1174:main.c        ****         ustaw_wyjscie_clip();
1175:main.c        ****       }
1176:main.c        ****     }
1177:main.c        ****     // W trybie DTMF NIE włączamy wyjścia - czekamy na klawisz '1'
1178:main.c        **** 
1179:main.c        ****     break;
1180:main.c        ****   }
1181:main.c        ****   case KOMENDA_KOLEJKI_DODAJ_UZYTKOWNIKA_BRAMA: {
1182:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1183:main.c        **** 
1184:main.c        ****     // Check for duplicates using the helper function
1185:main.c        ****     if (czy_numer_istnieje(numer_telefonu_do_ktorego_dzwonic)) {
1186:main.c        ****       return TRUE; // Duplicate found, abort
1187:main.c        ****     }
1188:main.c        **** 
1189:main.c        ****     // Re-convert because czy_numer_istnieje uses bufor_eeprom which might be
1190:main.c        ****     // modified (though in this implementation it sets it correctly for writing
1191:main.c        ****     // too) But to be safe and consistent with original logic:
1192:main.c        ****     konwertuj_telefon_na_blok_eeprom(
1193:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
1194:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[strlen(
1195:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
1196:main.c        ****         &bufor_eeprom[0]);
1197:main.c        **** 
1198:main.c        ****     uchar dodano = FALSE;
1199:main.c        ****     // Skryba: dodawaj tylko do pozycji 0-794 (user-facing 1-795)
1200:main.c        ****     // Pozycje 795-800 (indeksy 794-799) sa zarezerwowane dla Super Userow
1201:main.c        ****     uint max_pozycja = (skryba_limit < 795) ? skryba_limit : 795;
1202:main.c        ****     for (uint nr_uzyt_clip = 0; nr_uzyt_clip < max_pozycja; ++nr_uzyt_clip) {
1203:main.c        ****       if (not czy_aktywny_numer_telefonu_brama(nr_uzyt_clip)) {
1204:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
1205:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
1206:main.c        ****             LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1207:main.c        ****         dodano = TRUE;
1208:main.c        ****         break;
1209:main.c        ****       }
1210:main.c        ****     }
1211:main.c        **** 
1212:main.c        ****     // Jesli dodano numer i Skryba jest wlaczona, sprawdz czy osiagnieto limit
1213:main.c        ****     if (dodano && skryba_wlaczona) {
1214:main.c        ****       // Policz aktywnych uzytkownikow
1215:main.c        ****       uint aktywne_numery = 0;
1216:main.c        ****       for (uint i = 0; i < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++i) {
1217:main.c        ****         if (czy_aktywny_numer_telefonu_brama(i)) {
1218:main.c        ****           ++aktywne_numery;
1219:main.c        ****         }
1220:main.c        ****       }
1221:main.c        **** 
1222:main.c        ****       // Jesli osiagnieto limit, wylacz Skrybe
1223:main.c        ****       if (aktywne_numery >= skryba_limit) {
1224:main.c        ****         skryba_wlaczona = FALSE;
1225:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_SKRYBA);
1226:main.c        **** 
1227:main.c        ****         tryb_pracy = 0; // Prywatny
1228:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_TRYB_PRACY);
1229:main.c        ****       }
1230:main.c        ****     }
1231:main.c        ****     break;
1232:main.c        ****   }
1233:main.c        ****   case KOMENDA_KOLEJKI_DODAJ_UZYTKOWNIKA_SKRYBA: {
1234:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1235:main.c        **** 
1236:main.c        ****     // Use a LOCAL buffer for Skryba to avoid corruption by czy_numer_istnieje
1237:main.c        ****     uchar bufor_skryba[LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM];
1238:main.c        **** 
1239:main.c        ****     // Convert Skryba number to EEPROM format FIRST, before duplicate check
1240:main.c        ****     konwertuj_telefon_na_blok_eeprom(
1241:main.c        ****         &numer_telefonu_skryba[0],
1242:main.c        ****         &numer_telefonu_skryba[strlen((char *)numer_telefonu_skryba)],
1243:main.c        ****         bufor_skryba);
1244:main.c        **** 
1245:main.c        ****     // Check for duplicates using the helper function
1246:main.c        ****     // (This will use bufor_eeprom internally, but we have our number safe in
1247:main.c        ****     // bufor_skryba)
1248:main.c        ****     if (czy_numer_istnieje(numer_telefonu_skryba)) {
1249:main.c        ****       return TRUE; // Duplicate found, abort
1250:main.c        ****     }
1251:main.c        **** 
1252:main.c        ****     // Copy our safe buffer to bufor_eeprom for writing
1253:main.c        ****     memcpy(bufor_eeprom, bufor_skryba, LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1254:main.c        **** 
1255:main.c        ****     uchar dodano = FALSE;
1256:main.c        ****     for (uint nr_uzyt_clip = 0;
1257:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
1258:main.c        ****       if (not czy_aktywny_numer_telefonu_brama(nr_uzyt_clip)) {
1259:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
1260:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
1261:main.c        ****             LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1262:main.c        **** 
1263:main.c        ****         dodano = TRUE;
1264:main.c        ****         break;
1265:main.c        ****       }
1266:main.c        ****     }
1267:main.c        **** 
1268:main.c        ****     // Jesli dodano numer i Skryba jest wlaczona, sprawdz czy osiagnieto limit
1269:main.c        ****     if (dodano && skryba_wlaczona) {
1270:main.c        ****       // Policz aktywnych uzytkownikow
1271:main.c        ****       uint aktywne_numery = 0;
1272:main.c        ****       for (uint i = 0; i < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++i) {
1273:main.c        ****         if (czy_aktywny_numer_telefonu_brama(i)) {
1274:main.c        ****           ++aktywne_numery;
1275:main.c        ****         }
1276:main.c        ****       }
1277:main.c        **** 
1278:main.c        ****       // Jesli osiagnieto limit, wylacz Skrybe
1279:main.c        ****       if (aktywne_numery >= skryba_limit) {
1280:main.c        ****         skryba_wlaczona = FALSE;
1281:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_SKRYBA);
1282:main.c        **** 
1283:main.c        ****         tryb_pracy = 0; // Prywatny
1284:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_TRYB_PRACY);
1285:main.c        ****       }
1286:main.c        ****     }
1287:main.c        ****     break;
1288:main.c        ****   }
1289:main.c        ****   case KOMENDA_KOLEJKI_DODAJ_SUPER_USERA: {
1290:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1291:main.c        **** 
1292:main.c        ****     // Use a LOCAL buffer to avoid corruption by czy_numer_istnieje
1293:main.c        ****     uchar bufor_super[LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM];
1294:main.c        **** 
1295:main.c        ****     // Convert number to EEPROM format FIRST, before duplicate check
1296:main.c        ****     konwertuj_telefon_na_blok_eeprom(
1297:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
1298:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[strlen(
1299:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
1300:main.c        ****         bufor_super);
1301:main.c        **** 
1302:main.c        ****     // Check for duplicates using the helper function
1303:main.c        ****     // (This will use bufor_eeprom internally, but we have our number safe in
1304:main.c        ****     // bufor_super)
1305:main.c        ****     if (czy_numer_istnieje(numer_telefonu_do_ktorego_dzwonic)) {
1306:main.c        ****       // Numer juz istnieje - wyslij komunikat
1307:main.c        ****       strcpy((char *)numer_telefonu_wysylanego_smsa,
1308:main.c        ****              (char *)numer_telefonu_odebranego_smsa);
1309:main.c        ****       strcpy_P((char *)tekst_wysylanego_smsa,
1310:main.c        ****                PSTR("Numer juz istnieje w systemie"));
1311:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
1312:main.c        ****       return TRUE;
1313:main.c        ****     }
1314:main.c        **** 
1315:main.c        ****     // Copy our safe buffer to bufor_eeprom for writing
1316:main.c        ****     memcpy(bufor_eeprom, bufor_super, LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1317:main.c        **** 
1318:main.c        ****     // Szukaj pierwszej wolnej pozycji w zakresie 794-799 (user-facing 795-800)
1319:main.c        ****     uchar dodano = FALSE;
1320:main.c        ****     uint pozycja_dodana = 0;
1321:main.c        ****     for (uint nr_uzyt = 794; nr_uzyt < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
1322:main.c        ****          ++nr_uzyt) {
1323:main.c        ****       if (not czy_aktywny_numer_telefonu_brama(nr_uzyt)) {
1324:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
1325:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt),
1326:main.c        ****             LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1327:main.c        ****         dodano = TRUE;
1328:main.c        ****         pozycja_dodana = nr_uzyt + 1; // User-facing (1-indexed)
1329:main.c        ****         break;
1330:main.c        ****       }
1331:main.c        ****     }
1332:main.c        **** 
1333:main.c        ****     // Wyslij odpowiedz
1334:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
1335:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
1336:main.c        ****     if (dodano) {
1337:main.c        ****       sprintf((char *)tekst_wysylanego_smsa, "Super User dodany na pozycji %u",
1338:main.c        ****               pozycja_dodana);
1339:main.c        ****     } else {
1340:main.c        ****       strcpy_P((char *)tekst_wysylanego_smsa,
1341:main.c        ****                PSTR("Brak wolnych pozycji Super User (795-800)"));
1342:main.c        ****     }
1343:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
1344:main.c        **** 
1345:main.c        ****     return TRUE;
1346:main.c        ****   }
1347:main.c        ****   case KOMENDA_KOLEJKI_USUN_UZYTKOWNIKA_BRAMA: {
1348:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1349:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
1350:main.c        ****                                      &numer_telefonu_do_ktorego_dzwonic[strlen(
1351:main.c        ****                                          numer_telefonu_do_ktorego_dzwonic)],
1352:main.c        ****                                      &bufor_eeprom[0]);
1353:main.c        ****     // for (uchar nr_uzyt_clip = 0; nr_uzyt_clip <
1354:main.c        ****     // MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip)
1355:main.c        ****     for (uint nr_uzyt_clip = 0;
1356:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
1357:main.c        ****       if (porownaj_numer_telefonu_blok(
1358:main.c        ****               &bufor_eeprom[0], // 1 porwnanie zajmuje ~10us, czyli 170 numerw ~
1359:main.c        ****                                 // 2ms
1360:main.c        ****               (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
1361:main.c        ****         numer_telefonu_do_ktorego_dzwonic[0] = '\0';
1362:main.c        ****         konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
1363:main.c        ****                                          &numer_telefonu_do_ktorego_dzwonic[1],
1364:main.c        ****                                          &bufor_eeprom[0]);
1365:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
1366:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
1367:main.c        ****             LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1368:main.c        ****         break;
1369:main.c        ****       }
1370:main.c        ****     }
1371:main.c        ****     break;
1372:main.c        ****   }
1373:main.c        ****   default:
1374:main.c        ****     return FALSE;
1375:main.c        ****   }
1376:main.c        ****   return TRUE;
1377:main.c        **** }
1378:main.c        **** 
1379:main.c        **** uchar wykonanie_komend_powiadomien(void) {
1380:main.c        ****   const komenda_typ aktualnie_wykonywana_komenda = komendy_kolejka[0];
1381:main.c        **** 
1382:main.c        ****   const uchar czy_gsm_zajety =
1383:main.c        ****       flaga_odczytywanie_smsa || flaga_wysylanie_smsa ||
1384:main.c        ****       wykonywanie_rozmowy_telefonicznej ||
1385:main.c        ****       trwa_rozmowa_przychodzaca_od_uzytkownika ||
1386:main.c        ****       aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
1387:main.c        ****       opoznienie_SIM900_100MS || czekanie_na_odebranie_zachety;
1388:main.c        **** 
1389:main.c        ****   const uchar czy_mozna_wysylac_dane_do_SIM900 =
1390:main.c        ****       !czy_gsm_zajety && CZY_MOZNA_WYSYLAC_DANE_SIM900() &&
1391:main.c        ****       czy_jest_bezczynny_SIM900();
1392:main.c        **** 
1393:main.c        ****   switch (aktualnie_wykonywana_komenda) {
1394:main.c        ****   case KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW: {
1395:main.c        ****     if (not czy_mozna_wysylac_dane_do_SIM900 ||
1396:main.c        ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1397:main.c        ****       dodaj_komende(aktualnie_wykonywana_komenda);
1398:main.c        ****       break;
1399:main.c        ****     }
1400:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1401:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
1402:main.c        ****     *sms++ = '*';
1403:main.c        ****     for (;;) {
1404:main.c        ****       if (czy_aktywny_numer_telefonu_brama(
1405:main.c        ****               numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama)) {
1406:main.c        ****         sms += kopiuj_blok_eeprom_na_telefon(
1407:main.c        ****             (void *)EEPROM_NUMER_TELEFONU_BRAMA(
1408:main.c        ****                 numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama),
1409:main.c        ****             sms, MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER);
1410:main.c        ****         *sms++ = '#';
1411:main.c        ****         *sms++ = '\n';
1412:main.c        ****         ++numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama;
1413:main.c        ****         if ((sms + MAX_LICZBA_ZNAKOW_TELEFON + 1 >=
1414:main.c        ****              &tekst_wysylanego_smsa[MAX_LICZBA_ZNAKOW_SMS]) ||
1415:main.c        ****             (numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama >=
1416:main.c        ****              MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER)) {
1417:main.c        ****           if ((numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama <
1418:main.c        ****                MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER))
1419:main.c        ****             dodaj_komende(aktualnie_wykonywana_komenda);
1420:main.c        ****           *sms = '\0';
1421:main.c        ****           dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
1422:main.c        ****           wysylanie_smsa_clipa = WYSYLANIE_SMSA_WYSYLANIE;
1423:main.c        ****           break;
1424:main.c        ****         }
1425:main.c        ****       } else {
1426:main.c        ****         if (++numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama >=
1427:main.c        ****             MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER) {
1428:main.c        ****           if (sms != &tekst_wysylanego_smsa[0]) {
1429:main.c        ****             *sms = '\0';
1430:main.c        ****             dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
1431:main.c        ****             wysylanie_smsa_clipa = WYSYLANIE_SMSA_WYSYLANIE;
1432:main.c        ****           }
1433:main.c        ****           break;
1434:main.c        ****         }
1435:main.c        ****       }
1436:main.c        ****     }
1437:main.c        ****     break;
1438:main.c        ****   }
1439:main.c        ****   default:
1440:main.c        ****     return FALSE;
1441:main.c        ****   }
1442:main.c        ****   return TRUE;
1443:main.c        **** }
1444:main.c        **** 
1445:main.c        **** void wykonanie_komend(void) {
1446:main.c        ****   if (wykonanie_komend_SIM900())
1447:main.c        ****     ;
1448:main.c        ****   else if (wykonanie_komend_ukladow())
1449:main.c        ****     ;
1450:main.c        ****   else if (wykonanie_komend_powiadomien())
1451:main.c        ****     ;
1452:main.c        ****   else
1453:main.c        ****     ;
1454:main.c        ****   usun_komende();
1455:main.c        **** }
1456:main.c        **** 
1457:main.c        **** void test_sms_clip_100ms(void) {
1458:main.c        ****   // static ulong licznik_sms;
1459:main.c        ****   // if ( ++licznik_sms > 60 * 10 )
1460:main.c        ****   //{
1461:main.c        ****   //	licznik_sms = 0;
1462:main.c        **** 
1463:main.c        ****   // tekst_wysylanego_smsa[0] = 'A';
1464:main.c        ****   // tekst_wysylanego_smsa[1] = 'B';
1465:main.c        ****   // tekst_wysylanego_smsa[2] = 'C';
1466:main.c        ****   // tekst_wysylanego_smsa[3] = 'D';
1467:main.c        ****   // tekst_wysylanego_smsa[4] = 0;
1468:main.c        ****   // static const char tel[] PROGMEM = "731314727";
1469:main.c        ****   ////static const char tel[] PROGMEM = "505691117";
1470:main.c        ****   // memcpy_R(numer_telefonu_wysylanego_smsa, tel);
1471:main.c        ****   // dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
1472:main.c        **** 
1473:main.c        ****   // memcpy_R(numer_telefonu_do_ktorego_dzwonic, tel);
1474:main.c        ****   // dodaj_komende(KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE);
1475:main.c        ****   //}
1476:main.c        **** }
1477:main.c        **** 
1478:main.c        **** void steruj_wejscia_wyjscia_100ms(void) {
1479:main.c        ****   aktualizuj_stan_wyzwolenia_wejsc_100ms();
1480:main.c        ****   steruj_wejsciem_reset_100ms();
1481:main.c        ****   steruj_wyjscia_100ms();
1482:main.c        **** }
1483:main.c        **** 
1484:main.c        **** void zapis_w_eeprom_stanu_wyjsc(void) {
1485:main.c        ****   if (not czy_wolny_eeprom())
1486:main.c        ****     return;
1487:main.c        ****   uchar par = 0;
1488:main.c        ****   if ((stan_wyjscie[0] != 0) ^ (licznik_przelacznik_wyjscia[0] != 0))
1489:main.c        ****     par |= BIT(0);
1490:main.c        ****   if (par != eeprom_read_byte((void *)EEPROM_USTAWIENIE_STANOW_WYJSC))
1491:main.c        ****     zapisz_znaki_w_eeprom(&par, (uint)EEPROM_USTAWIENIE_STANOW_WYJSC, 1);
1492:main.c        **** }
1493:main.c        **** 
1494:main.c        **** // void test_clip_na_101(void)
1495:main.c        **** //{
1496:main.c        **** //	if ( not modul_zalogowany_w_sieci )
1497:main.c        **** //		return;
1498:main.c        **** //	static uint licznik_101;
1499:main.c        **** //	if ( ++licznik_101 < 2 * 60 * 10 )
1500:main.c        **** //		return;
1501:main.c        **** //	licznik_101 = 0;
1502:main.c        **** //	static const char doladowanie[] PROGMEM = "*101#";
1503:main.c        **** //	strcpy_P(numer_telefonu_do_ktorego_dzwonic, doladowanie);
1504:main.c        **** //	dodaj_komende(KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE);
1505:main.c        **** // }
1506:main.c        **** 
1507:main.c        **** void steruj_urzadzeniem_100MS(void) {
1508:main.c        ****   steruj_wejscia_wyjscia_100ms();
1509:main.c        ****   steruj_SIM900_100MS();
1510:main.c        ****   if (licznik_100ms_dioda_led) {
1511:main.c        ****     if (--licznik_100ms_dioda_led == 0)
1512:main.c        ****       ustaw_stan_led(FALSE);
1513:main.c        ****     else
1514:main.c        ****       ustaw_stan_led(TRUE);
1515:main.c        ****   }
1516:main.c        **** 
1517:main.c        ****   // Aktualizacja timera blokady komend REPORT/USER
1518:main.c        ****   if (timer_report_user_100ms > 0) {
1519:main.c        ****     --timer_report_user_100ms;
1520:main.c        ****     if (timer_report_user_100ms == 0) {
1521:main.c        ****       // Okno czasowe minelo - resetuj licznik
1522:main.c        ****       licznik_report_user = 0;
1523:main.c        ****     }
1524:main.c        ****   } else {
1525:main.c        ****     // Timer jest 0 - upewnij sie ze licznik tez jest 0 (ochrona przed
1526:main.c        ****     // bledami)
1527:main.c        ****     licznik_report_user = 0;
1528:main.c        ****   }
1529:main.c        **** 
1530:main.c        ****   // Auto-sync czasu: Wyślij SMS do siebie jeśli aktywny i zalogowany w sieci
1531:main.c        ****   static uchar autosync_sms_wyslany = FALSE;
1532:main.c        ****   static uint autosync_timer_100ms = 0;
1533:main.c        **** 
1534:main.c        ****   if (autosync_czas_aktywny && !autosync_sms_wyslany &&
1535:main.c        ****       modul_zalogowany_w_sieci) {
1536:main.c        ****     // Odczekaj 3 sekundy po zalogowaniu do sieci
1537:main.c        ****     if (autosync_timer_100ms < 30) {
1538:main.c        ****       autosync_timer_100ms++;
1539:main.c        ****     } else {
1540:main.c        ****       // Sprawdź czy mamy zapisany numer i czy nie wysyłamy już SMS-a
1541:main.c        ****       if (moj_numer_telefonu[0] != 0xFF && moj_numer_telefonu[0] != 0 &&
1542:main.c        ****           !flaga_wysylanie_smsa) {
1543:main.c        ****         // Wyślij SMS do siebie z treścią "Synchronizacja Czasu"
1544:main.c        ****         strcpy((char *)numer_telefonu_wysylanego_smsa,
1545:main.c        ****                (char *)moj_numer_telefonu);
1546:main.c        ****         strcpy_P((char *)tekst_wysylanego_smsa, PSTR("Synchronizacja Czasu"));
1547:main.c        ****         dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
1548:main.c        ****         autosync_sms_wyslany = TRUE;
1549:main.c        ****       } else {
1550:main.c        ****         // Brak numeru lub błąd - po prostu czekamy na przychodzący SMS
1551:main.c        ****         // System normalnie pracuje
1552:main.c        ****         autosync_sms_wyslany = TRUE; // Nie próbuj ponownie
1553:main.c        ****       }
1554:main.c        ****     }
1555:main.c        ****   }
1556:main.c        **** 
1557:main.c        ****   // Reset flagi gdy auto-sync zostanie wyłączony
1558:main.c        ****   if (!autosync_czas_aktywny) {
1559:main.c        ****     autosync_sms_wyslany = FALSE;
1560:main.c        ****     autosync_timer_100ms = 0;
1561:main.c        ****   }
1562:main.c        **** 
1563:main.c        ****   // Mechanizm wykrywania zablokowanej kolejki i czyszczenia starych komend
1564:main.c        ****   // SMS
1565:main.c        ****   const komenda_typ pierwsza_komenda = komendy_kolejka[0];
1566:main.c        ****   if (pierwsza_komenda != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
1567:main.c        ****     // Sprawdz czy pierwsza komenda to SMS - jesli tak i stoi zbyt dlugo,
1568:main.c        ****     // wyczysc
1569:main.c        ****     if (pierwsza_komenda >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
1570:main.c        ****         pierwsza_komenda <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU) {
1571:main.c        ****       // To jest komenda SMS - sprawdz czy stoi zbyt dlugo
1572:main.c        ****       if (pierwsza_komenda == ostatnia_pierwsza_komenda) {
1573:main.c        ****         // Ta sama komenda SMS jest na poczatku kolejki - kolejka moze stac
1574:main.c        ****         if (licznik_kolejka_stoi_100ms < MAX_CZAS_KOLEJKA_STOI_100MS)
1575:main.c        ****           ++licznik_kolejka_stoi_100ms;
1576:main.c        ****         else {
1577:main.c        ****           // Komenda SMS stoi juz 30 sekund - wyczysc wszystkie komendy SMS i
1578:main.c        ****           // wznow dzialanie
1579:main.c        ****           filtruj_komendy_z_przedzialu(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT,
1580:main.c        ****                                        KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
1581:main.c        ****           if (licznik_awaryjnych_resetow_kolejki < 0xFFFF)
1582:main.c        ****             ++licznik_awaryjnych_resetow_kolejki;
1583:main.c        **** 
1584:main.c        ****           filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
1585:main.c        **** 
1586:main.c        ****           // Resetuj blokade komend REPORT/USER aby wznowic dzialanie
1587:main.c        ****           licznik_report_user = 0;
1588:main.c        ****           timer_report_user_100ms = 0;
1589:main.c        **** 
1590:main.c        ****           // Resetuj liczniki kolejki
1591:main.c        ****           licznik_kolejka_stoi_100ms = 0;
1592:main.c        ****           ostatnia_pierwsza_komenda = KOMENDA_KOLEJKI_BRAK_KOMENDY;
1593:main.c        **** 
1594:main.c        ****           // Resetuj flage wysylania SMS (na wypadek zablokowania)
1595:main.c        ****           flaga_wysylanie_smsa = 0;
1596:main.c        ****         }
1597:main.c        ****       } else {
1598:main.c        ****         // Pierwsza komenda SMS sie zmienila - kolejka dziala
1599:main.c        ****         ostatnia_pierwsza_komenda = pierwsza_komenda;
1600:main.c        ****         licznik_kolejka_stoi_100ms = 0;
1601:main.c        ****       }
1602:main.c        ****     } else {
1603:main.c        ****       // To nie jest komenda SMS - resetuj licznik (nie interesuje nas)
1604:main.c        ****       ostatnia_pierwsza_komenda = pierwsza_komenda;
1605:main.c        ****       licznik_kolejka_stoi_100ms = 0;
1606:main.c        ****     }
1607:main.c        ****   } else {
1608:main.c        ****     // Kolejka jest pusta
1609:main.c        ****     ostatnia_pierwsza_komenda = KOMENDA_KOLEJKI_BRAK_KOMENDY;
1610:main.c        ****     licznik_kolejka_stoi_100ms = 0;
1611:main.c        ****   }
1612:main.c        **** 
1613:main.c        ****   // Watchdog pilnujacy zakleszczonego wysylania SMS
1614:main.c        ****   if (flaga_wysylanie_smsa) {
1615:main.c        ****     if (licznik_watchdog_wysylanie_smsa_100ms < WATCHDOG_WYSYLANIA_SMS_100MS) {
1616:main.c        ****       ++licznik_watchdog_wysylanie_smsa_100ms;
1617:main.c        ****     } else {
1618:main.c        ****       licznik_watchdog_wysylanie_smsa_100ms = 0;
1619:main.c        ****       // Awaryjne odblokowanie
1620:main.c        ****       watchdog_sms_disarm();
1621:main.c        ****       flaga_wysylanie_smsa = 0;
1622:main.c        ****       liczba_prob_wyslania_smsa = 0;
1623:main.c        ****       czekanie_na_odebranie_zachety = FALSE;
1624:main.c        ****       wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
1625:main.c        **** 
1626:main.c        ****       if (liczba_kolejnych_watchdogow_wysylania < 255)
1627:main.c        ****         ++liczba_kolejnych_watchdogow_wysylania;
1628:main.c        ****       if (liczba_kolejnych_watchdogow_wysylania >= 3) {
1629:main.c        ****         liczba_kolejnych_watchdogow_wysylania = 0;
1630:main.c        ****         reset_modulu_SIM900();
1631:main.c        ****       }
1632:main.c        ****     }
1633:main.c        ****   } else {
1634:main.c        ****     licznik_watchdog_wysylanie_smsa_100ms = 0;
1635:main.c        ****     liczba_kolejnych_watchdogow_wysylania = 0;
1636:main.c        ****   }
1637:main.c        **** 
1638:main.c        ****   if (watchdog_sms_aktywny) {
1639:main.c        ****     if (watchdog_sms_licznik_100ms < WATCHDOG_SMS_TIMEOUT_100MS)
1640:main.c        ****       ++watchdog_sms_licznik_100ms;
1641:main.c        ****     else {
1642:main.c        ****       watchdog_sms_trwa_reset = TRUE;
1643:main.c        ****       cli();
1644:main.c        ****       wdt_enable(WDTO_15MS);
1645:main.c        ****       while (1)
1646:main.c        ****         ;
1647:main.c        ****     }
1648:main.c        ****   } else if (watchdog_sms_safe_mode_100ms) {
1649:main.c        ****     --watchdog_sms_safe_mode_100ms;
1650:main.c        ****   }
1651:main.c        **** 
1652:main.c        ****   // Obsluga szybkich blyskow LED
1653:main.c        ****   if (liczba_blyskow_led > 0) {
1654:main.c        ****     ++stan_cyklu_blysku;
1655:main.c        ****     if (stan_cyklu_blysku >= 6) {
1656:main.c        ****       stan_cyklu_blysku = 0;
1657:main.c        ****       --liczba_blyskow_led;
1658:main.c        ****     }
1659:main.c        ****     ustaw_stan_led(stan_cyklu_blysku < 2);
1660:main.c        ****     return;
1661:main.c        ****   }
1662:main.c        **** 
1663:main.c        ****   // LED: ON gdy nie zalogowany, OFF gdy zalogowany (z mruganiem przy dobrym
1664:main.c        ****   // sygnale)
1665:main.c        ****   if (!modul_zalogowany_w_sieci) {
1666:main.c        ****     // Nie zalogowany - dioda swiecei ciagle
1667:main.c        ****     ustaw_stan_led(TRUE);
1668:main.c        ****   } else {
1669:main.c        ****     // Zalogowany - dioda zgaszona lub mruga w zaleznosci od sygnalu
1670:main.c        ****     if (licznik_100ms_dioda_led) {
1671:main.c        ****       // Mrugniecie (SMS, etc.)
1672:main.c        ****       ustaw_stan_led(TRUE);
1673:main.c        ****     } else {
1674:main.c        ****       // Normalne dzialanie - mrugaj w zaleznosci od poziomu sygnalu
1675:main.c        ****       static uchar licznik_dioda_led_poziom_sieci;
1676:main.c        ****       if (poziom_sieci_gsm < 16) {
1677:main.c        ****         if (++licznik_dioda_led_poziom_sieci >= 50)
1678:main.c        ****           licznik_dioda_led_poziom_sieci = 1;
1679:main.c        ****       } else
1680:main.c        ****         licznik_dioda_led_poziom_sieci = 0;
1681:main.c        **** 
1682:main.c        ****       ustaw_stan_led(licznik_dioda_led_poziom_sieci == 40 ||
1683:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
1684:main.c        ****                      (licznik_dioda_led_poziom_sieci >= 46 &&
1685:main.c        ****                       licznik_dioda_led_poziom_sieci <= 49));
1686:main.c        ****     }
1687:main.c        ****   }
1688:main.c        ****   zapis_w_eeprom_stanu_wyjsc();
1689:main.c        **** }
1690:main.c        **** 
1691:main.c        **** void steruj_urzadzeniem_10MS(void) {
1692:main.c        ****   steruj_wejscia_10ms();
1693:main.c        ****   steruj_SIM900_10MS();
1694:main.c        ****   zapisz_bajt_w_EEPROM();
1695:main.c        ****   // test_dioda_wyjscia();
1696:main.c        ****   // test_wejscie();
1697:main.c        **** }
1698:main.c        **** 
1699:main.c        **** void wolne_zdarzenie_timer(void) {
1700:main.c        ****   WYKONAJ_CLI_SEI(WYLACZ_PRZERWANIE_TIMER());
1701:main.c        ****   if (!CZY_WYKONAC_ZDARZENIE_TIMER()) {
1702:main.c        ****     WYKONAJ_CLI_SEI(WLACZ_PRZERWANIE_TIMER());
1703:main.c        ****     return;
1704:main.c        ****   }
1705:main.c        ****   wykonaj_zdarzenie_timer = FALSE;
1706:main.c        ****   if (wykonac_watki_10MS) {
1707:main.c        ****     wykonac_watki = WYKONAJ_WATKI_10MS;
1708:main.c        ****     wykonac_watki_10MS = FALSE;
1709:main.c        ****   }
1710:main.c        ****   WYKONAJ_CLI_SEI(WLACZ_PRZERWANIE_TIMER());
1711:main.c        ****   if (CZY_WYKONAC_WATKI_10MS()) {
1712:main.c        ****     static uchar licznik_wybuc_watki_100MS = 0;
1713:main.c        **** #define OPOZNIENIE_100_MS 10
1714:main.c        ****     if (++licznik_wybuc_watki_100MS == OPOZNIENIE_100_MS) {
1715:main.c        ****       licznik_wybuc_watki_100MS = 0;
1716:main.c        ****       wykonac_watki = WYKONAJ_WATKI_100MS | WYKONAJ_WATKI_10MS;
1717:main.c        ****     }
1718:main.c        ****     NOP();
1719:main.c        ****     cli();
1720:main.c        ****     if (CZY_ODBIERANIE_DANYCH_SIM900()) {
1721:main.c        ****       WYLACZ_PRZERWANIE_ODBIORU_DANYCH_SIM900();
1722:main.c        ****       sei();
1723:main.c        ****       if (liczba_odebranych_znakow_SIM900 != 0 &&
1724:main.c        ****           ++licznik_opoznienie_oczekiwania_na_bajt_SIM900 >
1725:main.c        ****               MAX_OPOZNIENIE_OCZEKIWANIA_NA_BAJT_SIM900_500_MS) {
1726:main.c        ****         resetuj_odbior_SIM900_po_bledzie();
1727:main.c        ****       } else {
1728:main.c        ****         WYKONAJ_CLI_SEI(WLACZ_PRZERWANIE_ODBIORU_DANYCH_SIM900());
1729:main.c        ****       }
1730:main.c        ****     }
1731:main.c        ****     sei();
1732:main.c        ****   }
1733:main.c        **** }
1734:main.c        **** 
1735:main.c        **** void ustaw_parametry_dla_bezpieczenstwa(void) {
1736:main.c        ****   wdt_reset();
1737:main.c        ****   ustaw_parametry_dla_bezpieczenstwa_rejestry();
1738:main.c        ****   set_sleep_mode(SLEEP_MODE_IDLE);
1739:main.c        **** }
1740:main.c        **** 
1741:main.c        **** void inicjalizuj_parametry_modulu(void) {
1742:main.c        ****   memcpy_E(kod_modulu, ADRES_EEPROM_KOD_DOSTEPU, LICZBA_BAJTOW_KODU_DOSTEPU);
1743:main.c        **** 
1744:main.c        ****   // Auto-naprawa: Jeśli kod jest pusty (FF) lub zerowy, ustaw ABCD
1745:main.c        ****   if (kod_modulu[0] == 0xFF || kod_modulu[0] == 0x00) {
1746:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
1747:main.c        ****     kod_modulu[1] = bufor_eeprom[1] = 'B';
1748:main.c        ****     kod_modulu[2] = bufor_eeprom[2] = 'C';
1749:main.c        ****     kod_modulu[3] = bufor_eeprom[3] = 'D';
1750:main.c        ****     // Zapisz do EEPROM natychmiast (BLOCKING)
1751:main.c        ****     while (!eeprom_is_ready())
1752:main.c        ****       ;
1753:main.c        ****     eeprom_update_block(kod_modulu, (void *)ADRES_EEPROM_KOD_DOSTEPU,
1754:main.c        ****                         LICZBA_BAJTOW_KODU_DOSTEPU);
1755:main.c        ****   }
1756:main.c        **** 
1757:main.c        ****   // Auto-naprawa: Jeśli tryb pracy jest nieokreślony (0xFF), ustaw Publiczny
1758:main.c        ****   // (1)
1759:main.c        ****   tryb_pracy = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_TRYB_PRACY);
1760:main.c        ****   if (tryb_pracy == 0xFF) {
1761:main.c        ****     tryb_pracy = 1; // Domyślnie Publiczny
1762:main.c        ****     while (!eeprom_is_ready())
1763:main.c        ****       ;
1764:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_TRYB_PRACY, 1);
1765:main.c        ****   }
1766:main.c        **** 
1767:main.c        ****   // --- Inicjalizacja trybu CLIP/DTMF ---
1768:main.c        ****   tryb_clip = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_TRYB_CLIP_DTMF);
1769:main.c        ****   if (tryb_clip == 0xFF) {
1770:main.c        ****     tryb_clip = 1; // Domyślnie CLIP (1)
1771:main.c        ****     while (!eeprom_is_ready())
1772:main.c        ****       ;
1773:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_TRYB_CLIP_DTMF, 1);
1774:main.c        ****   }
1775:main.c        **** 
1776:main.c        ****   // Inicjalizacja parametrow czasowych
1777:main.c        ****   czas_start_h = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_START_H);
1778:main.c        ****   czas_start_m = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_START_M);
1779:main.c        ****   czas_stop_h = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_STOP_H);
1780:main.c        ****   czas_stop_m = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_STOP_M);
1781:main.c        **** 
1782:main.c        ****   // Inicjalizacja SKRYBA
1783:main.c        ****   skryba_wlaczona = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA);
1784:main.c        ****   if (skryba_wlaczona == 0xFF)
1785:main.c        ****     skryba_wlaczona = FALSE;
1786:main.c        **** 
1787:main.c        ****   // Odczyt limitu Skryby z EEPROM
1788:main.c        ****   uchar limit_l =
1789:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA_LIMIT_L);
1790:main.c        ****   uchar limit_h =
1791:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA_LIMIT_H);
1792:main.c        ****   if (limit_l == 0xFF && limit_h == 0xFF) {
1793:main.c        ****     // Nie ustawiono - domyslnie 800
1794:main.c        ****     skryba_limit = 800;
1795:main.c        ****   } else {
1796:main.c        ****     skryba_limit = limit_l | (limit_h << 8);
1797:main.c        ****     // Walidacja zakresu
1798:main.c        ****     if (skryba_limit < 1 || skryba_limit > MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA) {
1799:main.c        ****       skryba_limit = 800;
1800:main.c        ****     }
1801:main.c        ****   }
1802:main.c        ****   // Debug initialization
1803:main.c        ****   zapisz_debug_do_eeprom(skryba_wlaczona ? 1 : 0, (uchar)(skryba_limit & 0xFF));
1804:main.c        **** 
1805:main.c        ****   // Auto-naprawa Harmonogramu: Jeśli wartości są nieprawidłowe (ale nie
1806:main.c        ****   // 0xFF), ustaw na OFF
1807:main.c        ****   if ((czas_start_h > 23 && czas_start_h != 0xFF) ||
1808:main.c        ****       (czas_start_m > 59 && czas_start_m != 0xFF) ||
1809:main.c        ****       (czas_stop_h > 23 && czas_stop_h != 0xFF) ||
1810:main.c        ****       (czas_stop_m > 59 && czas_stop_m != 0xFF)) {
1811:main.c        ****     // Zapisz wartosci wylaczajace (0xFF) - BLOCKING
1812:main.c        ****     while (!eeprom_is_ready())
1813:main.c        ****       ;
1814:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_CZAS_START_H, 0xFF);
1815:main.c        ****     while (!eeprom_is_ready())
1816:main.c        ****       ;
1817:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_CZAS_START_M, 0xFF);
1818:main.c        ****     while (!eeprom_is_ready())
1819:main.c        ****       ;
1820:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_CZAS_STOP_H, 0xFF);
1821:main.c        ****     while (!eeprom_is_ready())
1822:main.c        ****       ;
1823:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_CZAS_STOP_M, 0xFF);
1824:main.c        **** 
1825:main.c        ****     czas_start_h = 0xFF;
1826:main.c        ****     czas_start_m = 0xFF;
1827:main.c        ****     czas_stop_h = 0xFF;
1828:main.c        ****     czas_stop_m = 0xFF;
1829:main.c        ****   }
1830:main.c        **** 
1831:main.c        ****   blokada_sterowania_czasowa =
1832:main.c        ****       FALSE; // Domyślnie odblokowane, zaktualizuje sie przy odczycie czasu
1833:main.c        **** 
1834:main.c        ****   // Inicjalizacja blokady systemu (START/STOP)
1835:main.c        ****   blokada_systemu =
1836:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_BLOKADA_SYSTEMU);
1837:main.c        ****   if (blokada_systemu == 0xFF) {
1838:main.c        ****     blokada_systemu = FALSE; // Domyślnie odblokowany
1839:main.c        ****   }
1840:main.c        **** 
1841:main.c        ****   // Inicjalizacja zmiennych debug SKRYBA (jesli 0xFF to wyczysc)
1842:main.c        ****   for (uint16_t addr = ADRES_EEPROM_DEBUG_SKRYBA_1;
1843:main.c        ****        addr <= ADRES_EEPROM_DEBUG_SKRYBA_5; ++addr) {
1844:main.c        ****     if (eeprom_read_byte((const uint8_t *)addr) == 0xFF) {
1845:main.c        ****       while (!eeprom_is_ready())
1846:main.c        ****         ;
1847:main.c        ****       eeprom_update_byte((uint8_t *)addr, 0);
1848:main.c        ****     }
1849:main.c        ****   }
1850:main.c        **** 
1851:main.c        ****   // Inicjalizacja zmiennych debug USER (jesli 0xFF to wyczysc)
1852:main.c        ****   for (uint16_t addr = ADRES_EEPROM_DEBUG_USER_1;
1853:main.c        ****        addr <= ADRES_EEPROM_DEBUG_USER_7; ++addr) {
1854:main.c        ****     if (eeprom_read_byte((const uint8_t *)addr) == 0xFF) {
1855:main.c        ****       while (!eeprom_is_ready())
1856:main.c        ****         ;
1857:main.c        ****       eeprom_update_byte((uint8_t *)addr, 0);
1858:main.c        ****     }
1859:main.c        ****   }
1860:main.c        **** 
1861:main.c        ****   // --- NOWE Z V7 (Ported) ---
1862:main.c        ****   // Reset blokady komend REPORT/USER po inicjalizacji/resecie
1863:main.c        ****   licznik_report_user = 0;
1864:main.c        ****   timer_report_user_100ms = 0;
1865:main.c        **** 
1866:main.c        ****   // Reset flagi wysylania SMS po resecie
1867:main.c        ****   flaga_wysylanie_smsa = 0;
1868:main.c        **** 
1869:main.c        ****   // Zwieksz licznik resetow i zapisz debug
1870:main.c        ****   static uchar licznik_resetow = 0;
1871:main.c        ****   if (licznik_resetow < 255)
1872:main.c        ****     ++licznik_resetow;
1873:main.c        ****   while (!eeprom_is_ready())
1874:main.c        ****     ;
1875:main.c        ****   eeprom_update_byte((void *)EEPROM_DEBUG_LICZNIK_RESETOW, licznik_resetow);
1876:main.c        ****   while (!eeprom_is_ready())
1877:main.c        ****     ;
1878:main.c        ****   zapisz_debug_do_eeprom(0, 2); // Reset (komenda=0 oznacza reset)
1879:main.c        **** 
1880:main.c        ****   // Auto-sync czasu: Odczytaj numer własny z EEPROM
1881:main.c        ****   eeprom_read_block(moj_numer_telefonu,
1882:main.c        ****                     (const void *)ADRES_EEPROM_MOJE_NUMER_START,
1883:main.c        ****                     MAX_LICZBA_ZNAKOW_TELEFON + 1);
1884:main.c        ****   moj_numer_telefonu[MAX_LICZBA_ZNAKOW_TELEFON] = 0; // Ensure null termination
1885:main.c        **** 
1886:main.c        ****   // Sprawdź czy czas jest nieprawidłowy (00:00:xx) i czy mamy zapisany numer
1887:main.c        ****   if (rtc_czas[0] == '0' && rtc_czas[1] == '0' && rtc_czas[3] == '0' &&
1888:main.c        ****       rtc_czas[4] == '0' && moj_numer_telefonu[0] != 0xFF &&
1889:main.c        ****       moj_numer_telefonu[0] != 0) {
1890:main.c        ****     // Czas jest 00:00:xx i mamy zapisany numer - włącz auto-sync
1891:main.c        ****     autosync_czas_aktywny = TRUE;
1892:main.c        ****   }
1893:main.c        **** }
1894:main.c        **** 
1895:main.c        **** static void opoznienie_startowe(void) {
 189               		.loc 1 1895 0
 190               		.cfi_startproc
 191               	/* prologue: function */
 192               	/* frame size = 0 */
 193               	/* stack size = 0 */
 194               	.L__stack_usage = 0
 195               	.LVL10:
 196               	.LBB365:
 197               	.LBB366:
 198               	.LBB367:
 199               		.file 3 "/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h"
   1:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
   6:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
   9:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  12:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      distribution.
  16:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  17:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  21:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  33:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  35:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  38:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #  endif
  42:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  44:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  48:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /** \file */
  49:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \code
  51:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \endcode
  55:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  56:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     used.
  60:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  61:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  70:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  79:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  83:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** */
  84:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  85:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif
  89:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  90:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  97:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 103:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     integer value.
 107:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****  */
 108:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif
 110:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 111:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif
 114:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 115:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif
 120:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 121:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /**
 122:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 124:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 126:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 129:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 131:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 137:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 142:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 147:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    respectively.
 151:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 152:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    \note
 153:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 154:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 164:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****  */
 165:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** void
 166:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** {
 168:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 176:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 179:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 182:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	#else
 183:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	#endif
 186:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 187:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 200               		.loc 3 187 0
 201 0098 8FEF      		ldi r24,lo8(-28673)
 202 009a 9FE8      		ldi r25,hi8(-28673)
 203 009c 0197      	1:	sbiw r24,1
 204 009e 01F4      		brne 1b
 205 00a0 00C0      		rjmp .
 206 00a2 0000      		nop
 207               	.LVL11:
 208 00a4 8FEF      		ldi r24,lo8(-28673)
 209 00a6 9FE8      		ldi r25,hi8(-28673)
 210 00a8 0197      	1:	sbiw r24,1
 211 00aa 01F4      		brne 1b
 212 00ac 00C0      		rjmp .
 213 00ae 0000      		nop
 214               	.LVL12:
 215 00b0 8FEF      		ldi r24,lo8(-28673)
 216 00b2 9FE8      		ldi r25,hi8(-28673)
 217 00b4 0197      	1:	sbiw r24,1
 218 00b6 01F4      		brne 1b
 219 00b8 00C0      		rjmp .
 220 00ba 0000      		nop
 221               	.LVL13:
 222 00bc 8FEF      		ldi r24,lo8(-28673)
 223 00be 9FE8      		ldi r25,hi8(-28673)
 224 00c0 0197      	1:	sbiw r24,1
 225 00c2 01F4      		brne 1b
 226 00c4 00C0      		rjmp .
 227 00c6 0000      		nop
 228               	.LVL14:
 229 00c8 8FEF      		ldi r24,lo8(-28673)
 230 00ca 9FE8      		ldi r25,hi8(-28673)
 231 00cc 0197      	1:	sbiw r24,1
 232 00ce 01F4      		brne 1b
 233 00d0 00C0      		rjmp .
 234 00d2 0000      		nop
 235               	.LVL15:
 236               	.LBE367:
 237               	.LBE366:
 238               	.LBE365:
1896:main.c        ****   for (uchar i = 0; i < 5; ++i)
1897:main.c        ****     _delay_ms(20);
1898:main.c        ****   wdt_reset();
 239               		.loc 1 1898 0
 240               	/* #APP */
 241               	 ;  1898 "main.c" 1
 242 00d4 A895      		wdr
 243               	 ;  0 "" 2
 244               	/* epilogue start */
1899:main.c        **** }
 245               		.loc 1 1899 0
 246               	/* #NOAPP */
 247 00d6 0895      		ret
 248               		.cfi_endproc
 249               	.LFE70:
 252               	zapisz_debug_do_eeprom:
 253               	.LFB38:
 372:main.c        ****   if (!czy_wolny_eeprom())
 254               		.loc 1 372 0
 255               		.cfi_startproc
 256               	.LVL16:
 257 00d8 CF93      		push r28
 258               	.LCFI2:
 259               		.cfi_def_cfa_offset 3
 260               		.cfi_offset 28, -2
 261 00da DF93      		push r29
 262               	.LCFI3:
 263               		.cfi_def_cfa_offset 4
 264               		.cfi_offset 29, -3
 265 00dc CDB7      		in r28,__SP_L__
 266 00de DEB7      		in r29,__SP_H__
 267               	.LCFI4:
 268               		.cfi_def_cfa_register 28
 269 00e0 2897      		sbiw r28,8
 270               	.LCFI5:
 271               		.cfi_def_cfa_offset 12
 272 00e2 0FB6      		in __tmp_reg__,__SREG__
 273 00e4 F894      		cli
 274 00e6 DEBF      		out __SP_H__,r29
 275 00e8 0FBE      		out __SREG__,__tmp_reg__
 276 00ea CDBF      		out __SP_L__,r28
 277               	/* prologue: function */
 278               	/* frame size = 8 */
 279               	/* stack size = 10 */
 280               	.L__stack_usage = 10
 373:main.c        ****     return;
 281               		.loc 1 373 0
 282 00ec 9091 0000 		lds r25,bufor_pomoc_liczba_znakow_do_zapisu
 283 00f0 9111      		cpse r25,__zero_reg__
 284 00f2 00C0      		rjmp .L17
 373:main.c        ****     return;
 285               		.loc 1 373 0 is_stmt 0 discriminator 1
 286 00f4 9091 0000 		lds r25,liczba_znakow_do_zapisu
 287 00f8 9111      		cpse r25,__zero_reg__
 288 00fa 00C0      		rjmp .L17
 373:main.c        ****     return;
 289               		.loc 1 373 0 discriminator 2
 290 00fc 9091 0000 		lds r25,czy_zajety_bufor_eeprom
 291 0100 9111      		cpse r25,__zero_reg__
 292 0102 00C0      		rjmp .L17
 373:main.c        ****     return;
 293               		.loc 1 373 0 discriminator 3
 294 0104 F999      		sbic 0x1f,1
 295 0106 00C0      		rjmp .L17
 296               	.LVL17:
 297               	.LBB371:
 298               	.LBB372:
 377:main.c        ****   buf[1] = (uchar)(timer_report_user_100ms & 0xFF);
 299               		.loc 1 377 0 is_stmt 1
 300 0108 2091 0000 		lds r18,licznik_report_user
 301 010c 2983      		std Y+1,r18
 378:main.c        ****   buf[2] = (uchar)((timer_report_user_100ms >> 8) & 0xFF);
 302               		.loc 1 378 0
 303 010e 3091 0000 		lds r19,timer_report_user_100ms
 304 0112 2091 0000 		lds r18,timer_report_user_100ms+1
 305 0116 3A83      		std Y+2,r19
 379:main.c        ****   buf[3] = (uchar)flaga_wysylanie_smsa;
 306               		.loc 1 379 0
 307 0118 2B83      		std Y+3,r18
 380:main.c        **** 
 308               		.loc 1 380 0
 309 011a 2091 0000 		lds r18,flaga_wysylanie_smsa
 310 011e 2C83      		std Y+4,r18
 311               	.LVL18:
 312 0120 E0E0      		ldi r30,lo8(komendy_kolejka)
 313 0122 F0E0      		ldi r31,hi8(komendy_kolejka)
 314               	.LVL19:
 315               	.L20:
 316               	.LBB373:
 384:main.c        ****         komendy_kolejka[i] <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
 317               		.loc 1 384 0
 318 0124 2191      		ld r18,Z+
 319               	.LVL20:
 320 0126 235D      		subi r18,lo8(-(45))
 321 0128 2230      		cpi r18,lo8(2)
 322 012a 00F4      		brsh .L19
 386:main.c        ****   }
 323               		.loc 1 386 0
 324 012c 9F5F      		subi r25,lo8(-(1))
 325               	.LVL21:
 326               	.L19:
 383:main.c        ****     if (komendy_kolejka[i] >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
 327               		.loc 1 383 0
 328 012e 20E0      		ldi r18,hi8(komendy_kolejka+30)
 329 0130 E030      		cpi r30,lo8(komendy_kolejka+30)
 330 0132 F207      		cpc r31,r18
 331 0134 01F4      		brne .L20
 332               	.LBE373:
 388:main.c        ****   buf[5] = komenda;
 333               		.loc 1 388 0
 334 0136 9D83      		std Y+5,r25
 389:main.c        ****   buf[6] = akcja;
 335               		.loc 1 389 0
 336 0138 8E83      		std Y+6,r24
 390:main.c        **** 
 337               		.loc 1 390 0
 338 013a 6F83      		std Y+7,r22
 392:main.c        **** }
 339               		.loc 1 392 0
 340 013c 47E0      		ldi r20,lo8(7)
 341 013e 62ED      		ldi r22,lo8(-46)
 342 0140 7FE0      		ldi r23,lo8(15)
 343               	.LVL22:
 344 0142 CE01      		movw r24,r28
 345               	.LVL23:
 346 0144 0196      		adiw r24,1
 347 0146 0E94 0000 		call zapisz_znaki_w_eeprom
 348               	.LVL24:
 349               	.L17:
 350               	/* epilogue start */
 351               	.LBE372:
 352               	.LBE371:
 393:main.c        **** 
 353               		.loc 1 393 0
 354 014a 2896      		adiw r28,8
 355 014c 0FB6      		in __tmp_reg__,__SREG__
 356 014e F894      		cli
 357 0150 DEBF      		out __SP_H__,r29
 358 0152 0FBE      		out __SREG__,__tmp_reg__
 359 0154 CDBF      		out __SP_L__,r28
 360 0156 DF91      		pop r29
 361 0158 CF91      		pop r28
 362 015a 0895      		ret
 363               		.cfi_endproc
 364               	.LFE38:
 366               	.global	test_dioda_wyjscia
 368               	test_dioda_wyjscia:
 369               	.LFB24:
 370               		.file 4 "test_pcb.h"
   1:test_pcb.h    **** void test_dioda_wyjscia(void)
   2:test_pcb.h    **** {
 371               		.loc 4 2 0
 372               		.cfi_startproc
 373               	/* prologue: function */
 374               	/* frame size = 0 */
 375               	/* stack size = 0 */
 376               	.L__stack_usage = 0
   3:test_pcb.h    **** 	static uchar opoznienie_1s;
   4:test_pcb.h    **** 	if ( ++opoznienie_1s < 100 )
 377               		.loc 4 4 0
 378 015c 8091 0000 		lds r24,opoznienie_1s.2970
 379 0160 8F5F      		subi r24,lo8(-(1))
 380 0162 8436      		cpi r24,lo8(100)
 381 0164 00F4      		brsh .L23
 382 0166 8093 0000 		sts opoznienie_1s.2970,r24
 383 016a 0895      		ret
 384               	.L23:
   5:test_pcb.h    **** 		return;
   6:test_pcb.h    **** 	opoznienie_1s = 0;
 385               		.loc 4 6 0
 386 016c 1092 0000 		sts opoznienie_1s.2970,__zero_reg__
   7:test_pcb.h    **** 	static uchar stan;
   8:test_pcb.h    **** 	stan = not stan;
 387               		.loc 4 8 0
 388 0170 8091 0000 		lds r24,stan.2971
 389 0174 91E0      		ldi r25,lo8(1)
 390 0176 8111      		cpse r24,__zero_reg__
 391 0178 90E0      		ldi r25,0
 392               	.L25:
 393 017a 9093 0000 		sts stan.2971,r25
   9:test_pcb.h    **** 	if ( stan )
 394               		.loc 4 9 0
 395 017e 8111      		cpse r24,__zero_reg__
 396 0180 00C0      		rjmp .L26
  10:test_pcb.h    **** 	{
  11:test_pcb.h    **** 		ustaw_stan_led(TRUE);
 397               		.loc 4 11 0 discriminator 2
 398 0182 4098      		cbi 0x8,0
 399 0184 0895      		ret
 400               	.L26:
  12:test_pcb.h    **** 	}
  13:test_pcb.h    **** 	else
  14:test_pcb.h    **** 	{
  15:test_pcb.h    **** 		ustaw_stan_led(FALSE);
 401               		.loc 4 15 0 discriminator 1
 402 0186 409A      		sbi 0x8,0
 403               	/* epilogue start */
  16:test_pcb.h    **** 	}
  17:test_pcb.h    **** }
 404               		.loc 4 17 0 discriminator 1
 405 0188 0895      		ret
 406               		.cfi_endproc
 407               	.LFE24:
 409               	.global	test_wejscie
 411               	test_wejscie:
 412               	.LFB25:
  18:test_pcb.h    **** 
  19:test_pcb.h    **** void test_wejscie(void)
  20:test_pcb.h    **** {
 413               		.loc 4 20 0
 414               		.cfi_startproc
 415               	/* prologue: function */
 416               	/* frame size = 0 */
 417               	/* stack size = 0 */
 418               	.L__stack_usage = 0
 419               	.LBB374:
 420               	.LBB375:
 421               		.file 5 "wewy.h"
   1:wewy.h        **** 
   2:wewy.h        **** #include <avr/io.h>
   3:wewy.h        **** #include "narzedzia.h"
   4:wewy.h        **** #include "konfiguracja_eeprom.h"
   5:wewy.h        **** 
   6:wewy.h        **** #define LICZBA_WEJSC	1
   7:wewy.h        **** extern uchar licznik_wejscie[LICZBA_WEJSC];
   8:wewy.h        **** 
   9:wewy.h        **** extern uchar parametry_wejscia[LICZBA_WEJSC];
  10:wewy.h        **** void kopiuj_parametry_we_wy_z_eeprom(void);
  11:wewy.h        **** 
  12:wewy.h        **** extern ulong czas_trwania_impulsu_na_wejsciu[LICZBA_WEJSC];
  13:wewy.h        **** extern ulong czas_trwania_impulsu_off_na_wejsciu[LICZBA_WEJSC];
  14:wewy.h        **** 
  15:wewy.h        **** #define STAN_LOGICZNY_NA_WEJSCIU_WYZWOLENIE	0x02
  16:wewy.h        **** #define STAN_LOGICZNY_NA_WEJSCIU_ON					0x01
  17:wewy.h        **** #define STAN_LOGICZNY_NA_WEJSCIU_OFF				0x00
  18:wewy.h        **** #define CZY_WYZWOLENIE_NA_WEJSCIU(NR_WEJ)	(stan_logiczny_na_wejsciu[NR_WEJ] & STAN_LOGICZNY_NA_WEJS
  19:wewy.h        **** #define CZY_AKTUALNY_STAN_LOGICZNY_ON(NR_WEJ)	(stan_logiczny_na_wejsciu[NR_WEJ] & STAN_LOGICZNY_NA_
  20:wewy.h        **** #define CZY_AKTUALNY_STAN_LOGICZNY_OFF(NR_WEJ)	(!CZY_AKTUALNY_STAN_LOGICZNY_ON(NR_WEJ))
  21:wewy.h        **** 
  22:wewy.h        **** extern uchar stan_logiczny_na_wejsciu[LICZBA_WEJSC];
  23:wewy.h        **** 
  24:wewy.h        **** void steruj_wejscia_10ms(void);
  25:wewy.h        **** void aktualizuj_stan_wyzwolenia_wejsc_100ms(void);
  26:wewy.h        **** void inicjalizuj_parametry_we_wy(void);
  27:wewy.h        **** 
  28:wewy.h        **** static uchar stan_wejscia(const uchar nr_wejscia) __attribute__((unused));
  29:wewy.h        **** 
  30:wewy.h        **** static uchar stan_wejscia(const uchar nr_wejscia)
  31:wewy.h        **** {
  32:wewy.h        **** 	return licznik_wejscie[nr_wejscia] & 0xf0;
 422               		.loc 5 32 0
 423 018a 8091 0000 		lds r24,licznik_wejscie
 424 018e 807F      		andi r24,lo8(-16)
 425               	.LBE375:
 426               	.LBE374:
  21:test_pcb.h    **** 	ustaw_stan_led(stan_wejscia(0));
 427               		.loc 4 21 0
 428 0190 01F4      		brne .L31
 429               		.loc 4 21 0 is_stmt 0 discriminator 1
 430 0192 409A      		sbi 0x8,0
 431 0194 0895      		ret
 432               	.L31:
 433               		.loc 4 21 0 discriminator 2
 434 0196 4098      		cbi 0x8,0
 435               	/* epilogue start */
  22:test_pcb.h    **** }
 436               		.loc 4 22 0 is_stmt 1 discriminator 2
 437 0198 0895      		ret
 438               		.cfi_endproc
 439               	.LFE25:
 441               	.global	__vector_16
 443               	__vector_16:
 444               	.LFB26:
  75:main.c        ****   if (++licznik_wybudz_watki_10MS >= OPOZNIENIE_TIMERA_0) {
 445               		.loc 1 75 0
 446               		.cfi_startproc
 447 019a 7894      		sei
 448 019c 1F92      		push r1
 449               	.LCFI6:
 450               		.cfi_def_cfa_offset 3
 451               		.cfi_offset 1, -2
 452 019e 0F92      		push r0
 453               	.LCFI7:
 454               		.cfi_def_cfa_offset 4
 455               		.cfi_offset 0, -3
 456 01a0 0FB6      		in r0,__SREG__
 457 01a2 0F92      		push r0
 458 01a4 1124      		clr __zero_reg__
 459 01a6 0BB6      		in r0,__RAMPZ__
 460 01a8 0F92      		push r0
 461 01aa 2F93      		push r18
 462               	.LCFI8:
 463               		.cfi_def_cfa_offset 5
 464               		.cfi_offset 18, -4
 465 01ac 8F93      		push r24
 466               	.LCFI9:
 467               		.cfi_def_cfa_offset 6
 468               		.cfi_offset 24, -5
 469 01ae 9F93      		push r25
 470               	.LCFI10:
 471               		.cfi_def_cfa_offset 7
 472               		.cfi_offset 25, -6
 473 01b0 EF93      		push r30
 474               	.LCFI11:
 475               		.cfi_def_cfa_offset 8
 476               		.cfi_offset 30, -7
 477 01b2 FF93      		push r31
 478               	.LCFI12:
 479               		.cfi_def_cfa_offset 9
 480               		.cfi_offset 31, -8
 481               	/* prologue: Interrupt */
 482               	/* frame size = 0 */
 483               	/* stack size = 9 */
 484               	.L__stack_usage = 9
  76:main.c        ****     licznik_wybudz_watki_10MS = 0;
 485               		.loc 1 76 0
 486 01b4 8091 0000 		lds r24,licznik_wybudz_watki_10MS
 487 01b8 8F5F      		subi r24,lo8(-(1))
 488 01ba 8093 0000 		sts licznik_wybudz_watki_10MS,r24
 489 01be 8231      		cpi r24,lo8(18)
 490 01c0 00F0      		brlo .L34
  77:main.c        ****     wykonac_watki_10MS = TRUE;
 491               		.loc 1 77 0
 492 01c2 1092 0000 		sts licznik_wybudz_watki_10MS,__zero_reg__
  78:main.c        ****   }
 493               		.loc 1 78 0
 494 01c6 8FEF      		ldi r24,lo8(-1)
 495 01c8 8093 0000 		sts wykonac_watki_10MS,r24
 496               	.L34:
  81:main.c        ****     if (!CZY_ODBIERANIE_DANYCH_SIM900() && czy_jest_bezczynny_SIM900()) {
 497               		.loc 1 81 0
 498 01cc 4F9B      		sbis 0x9,7
 499 01ce 00C0      		rjmp .L35
  82:main.c        ****       ustaw_odbior_SIM900();
 500               		.loc 1 82 0
 501 01d0 00B6      		in __tmp_reg__,0x30
 502 01d2 01FC      		sbrc __tmp_reg__,1
 503 01d4 00C0      		rjmp .L36
  82:main.c        ****       ustaw_odbior_SIM900();
 504               		.loc 1 82 0 is_stmt 0 discriminator 1
 505 01d6 8091 0000 		lds r24,komenda_SIM900
 506 01da 8111      		cpse r24,__zero_reg__
 507 01dc 00C0      		rjmp .L36
  83:main.c        ****     }
 508               		.loc 1 83 0 is_stmt 1
 509 01de 1092 0000 		sts liczba_odebranych_znakow_SIM900+1,__zero_reg__
 510 01e2 1092 0000 		sts liczba_odebranych_znakow_SIM900,__zero_reg__
 511 01e6 1092 0000 		sts licznik_opoznienie_oczekiwania_na_bajt_SIM900,__zero_reg__
 512 01ea 80B7      		in r24,0x30
 513 01ec 8260      		ori r24,lo8(2)
 514 01ee 80BF      		out 0x30,r24
 515               	/* #APP */
 516               	 ;  83 "main.c" 1
 517 01f0 F894      		cli
 518               	 ;  0 "" 2
 519               	/* #NOAPP */
 520 01f2 8091 C100 		lds r24,193
 521 01f6 8068      		ori r24,lo8(-128)
 522 01f8 8093 C100 		sts 193,r24
 523               	/* #APP */
 524               	 ;  83 "main.c" 1
 525 01fc 7894      		sei
 526               	 ;  0 "" 2
 527               	 ;  83 "main.c" 1
 528 01fe 0000      		nop
 529               	 ;  0 "" 2
 530               	/* #NOAPP */
 531 0200 4598      		cbi 0x8,5
 532               	.L36:
  85:main.c        ****       cli();
 533               		.loc 1 85 0
 534 0202 3499      		sbic 0x6,4
 535 0204 00C0      		rjmp .L37
  86:main.c        ****       if (CZY_WYSYLANIE_DANYCH_SIM900()) {
 536               		.loc 1 86 0
 537               	/* #APP */
 538               	 ;  86 "main.c" 1
 539 0206 F894      		cli
 540               	 ;  0 "" 2
  87:main.c        ****         WYLACZ_PRZERWANIE_WYSYLANIA_DANYCH_SIM900();
 541               		.loc 1 87 0
 542               	/* #NOAPP */
 543 0208 8091 C100 		lds r24,193
 544 020c 86FF      		sbrs r24,6
 545 020e 00C0      		rjmp .L38
 546               	.LBB376:
  88:main.c        ****         sei();
 547               		.loc 1 88 0
 548 0210 8091 C100 		lds r24,193
 549 0214 8F7B      		andi r24,lo8(-65)
 550 0216 8093 C100 		sts 193,r24
  89:main.c        ****         uchar p = sprawdzaj_wejscie_CTS_SIM900;
 551               		.loc 1 89 0
 552               	/* #APP */
 553               	 ;  89 "main.c" 1
 554 021a 7894      		sei
 555               	 ;  0 "" 2
  90:main.c        ****         if (p && (podlaczony_modul_gsm_SIM900 ||
 556               		.loc 1 90 0
 557               	/* #NOAPP */
 558 021c 8091 0000 		lds r24,sprawdzaj_wejscie_CTS_SIM900
 559               	.LVL25:
  91:main.c        ****                   aktualnie_wysylane_polecenie_SIM900 ==
 560               		.loc 1 91 0
 561 0220 8823      		tst r24
 562 0222 01F0      		breq .L39
  91:main.c        ****                   aktualnie_wysylane_polecenie_SIM900 ==
 563               		.loc 1 91 0 is_stmt 0 discriminator 1
 564 0224 8091 0000 		lds r24,podlaczony_modul_gsm_SIM900
 565               	.LVL26:
 566 0228 8111      		cpse r24,__zero_reg__
 567 022a 00C0      		rjmp .L40
  91:main.c        ****                   aktualnie_wysylane_polecenie_SIM900 ==
 568               		.loc 1 91 0 discriminator 2
 569 022c 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 570 0230 8C38      		cpi r24,lo8(-116)
 571 0232 01F4      		brne .L39
 572               	.L40:
 573               	.LVL27:
  95:main.c        ****           WSTAW_ZNAK_DO_BUFORA_SIM900();
 574               		.loc 1 95 0 is_stmt 1
 575 0234 1092 0000 		sts sprawdzaj_wejscie_CTS_SIM900,__zero_reg__
 576               	.LBB377:
  96:main.c        ****         }
 577               		.loc 1 96 0
 578 0238 8091 0000 		lds r24,nr_wyslanego_znaku_SIM900
 579 023c 9091 0000 		lds r25,nr_wyslanego_znaku_SIM900+1
 580               	.LVL28:
 581 0240 FC01      		movw r30,r24
 582 0242 E050      		subi r30,lo8(-(wysylany_blok_SIM900))
 583 0244 F040      		sbci r31,hi8(-(wysylany_blok_SIM900))
 584 0246 2081      		ld r18,Z
 585               	.LVL29:
 586 0248 0196      		adiw r24,1
 587               	.LVL30:
 588 024a 9093 0000 		sts nr_wyslanego_znaku_SIM900+1,r25
 589 024e 8093 0000 		sts nr_wyslanego_znaku_SIM900,r24
 590 0252 2093 C600 		sts 198,r18
 591               	.LVL31:
 592               	.L39:
 593               	.LBE377:
  98:main.c        ****         WLACZ_PRZERWANIE_WYSYLANIA_DANYCH_SIM900();
 594               		.loc 1 98 0
 595               	/* #APP */
 596               	 ;  98 "main.c" 1
 597 0256 F894      		cli
 598               	 ;  0 "" 2
  99:main.c        ****       }
 599               		.loc 1 99 0
 600               	/* #NOAPP */
 601 0258 8091 C100 		lds r24,193
 602 025c 8064      		ori r24,lo8(64)
 603 025e 8093 C100 		sts 193,r24
 604               	.L38:
 605               	.LBE376:
 101:main.c        ****     }
 606               		.loc 1 101 0
 607               	/* #APP */
 608               	 ;  101 "main.c" 1
 609 0262 7894      		sei
 610               	 ;  0 "" 2
 611               	/* #NOAPP */
 612               	.L37:
 107:main.c        ****       TRUE; // uruchamia zdarzenie_timer, ktra korzysta z pozostaych zmiennych
 613               		.loc 1 107 0
 614 0264 8FEF      		ldi r24,lo8(-1)
 615 0266 8093 0000 		sts wykonaj_zdarzenie_timer,r24
 616               	/* epilogue start */
 109:main.c        **** 
 617               		.loc 1 109 0
 618 026a FF91      		pop r31
 619 026c EF91      		pop r30
 620 026e 9F91      		pop r25
 621 0270 8F91      		pop r24
 622 0272 2F91      		pop r18
 623 0274 0F90      		pop r0
 624 0276 0BBE      		out __RAMPZ__,r0
 625 0278 0F90      		pop r0
 626 027a 0FBE      		out __SREG__,r0
 627 027c 0F90      		pop r0
 628 027e 1F90      		pop r1
 629 0280 1895      		reti
 630               	.L35:
 104:main.c        ****   }
 631               		.loc 1 104 0
 632 0282 459A      		sbi 0x8,5
 633               	/* #APP */
 634               	 ;  104 "main.c" 1
 635 0284 F894      		cli
 636               	 ;  0 "" 2
 637               	/* #NOAPP */
 638 0286 8091 C100 		lds r24,193
 639 028a 8F73      		andi r24,lo8(63)
 640 028c 8093 C100 		sts 193,r24
 641 0290 80B7      		in r24,0x30
 642 0292 8D7F      		andi r24,lo8(-3)
 643 0294 80BF      		out 0x30,r24
 644               	/* #APP */
 645               	 ;  104 "main.c" 1
 646 0296 7894      		sei
 647               	 ;  0 "" 2
 648               	 ;  104 "main.c" 1
 649 0298 0000      		nop
 650               	 ;  0 "" 2
 651               	/* #NOAPP */
 652 029a 00C0      		rjmp .L37
 653               		.cfi_endproc
 654               	.LFE26:
 656               	.global	generuj_raport_sieci
 658               	generuj_raport_sieci:
 659               	.LFB27:
 128:main.c        ****   static const char tekst_gsm[] PROGMEM = "AC800-DTM-TS";
 660               		.loc 1 128 0
 661               		.cfi_startproc
 662               	.LVL32:
 663 029c DF92      		push r13
 664               	.LCFI13:
 665               		.cfi_def_cfa_offset 3
 666               		.cfi_offset 13, -2
 667 029e EF92      		push r14
 668               	.LCFI14:
 669               		.cfi_def_cfa_offset 4
 670               		.cfi_offset 14, -3
 671 02a0 FF92      		push r15
 672               	.LCFI15:
 673               		.cfi_def_cfa_offset 5
 674               		.cfi_offset 15, -4
 675 02a2 0F93      		push r16
 676               	.LCFI16:
 677               		.cfi_def_cfa_offset 6
 678               		.cfi_offset 16, -5
 679 02a4 1F93      		push r17
 680               	.LCFI17:
 681               		.cfi_def_cfa_offset 7
 682               		.cfi_offset 17, -6
 683 02a6 CF93      		push r28
 684               	.LCFI18:
 685               		.cfi_def_cfa_offset 8
 686               		.cfi_offset 28, -7
 687 02a8 DF93      		push r29
 688               	.LCFI19:
 689               		.cfi_def_cfa_offset 9
 690               		.cfi_offset 29, -8
 691               	/* prologue: function */
 692               	/* frame size = 0 */
 693               	/* stack size = 7 */
 694               	.L__stack_usage = 7
 695 02aa 8C01      		movw r16,r24
 130:main.c        **** 
 696               		.loc 1 130 0
 697 02ac DC01      		movw r26,r24
 698 02ae ED90      		ld r14,X+
 699 02b0 FC90      		ld r15,X
 700               	.LVL33:
 132:main.c        ****   ptr += sizeof tekst_gsm - 1;
 701               		.loc 1 132 0
 702 02b2 4CE0      		ldi r20,lo8(12)
 703 02b4 50E0      		ldi r21,0
 704 02b6 60E0      		ldi r22,lo8(tekst_gsm.3004)
 705 02b8 70E0      		ldi r23,hi8(tekst_gsm.3004)
 706 02ba C701      		movw r24,r14
 707               	.LVL34:
 708 02bc 0E94 0000 		call memcpy_P
 709               	.LVL35:
 134:main.c        **** 
 710               		.loc 1 134 0
 711 02c0 E701      		movw r28,r14
 712 02c2 2D96      		adiw r28,13
 713               	.LVL36:
 714 02c4 8AE0      		ldi r24,lo8(10)
 715 02c6 D82E      		mov r13,r24
 716 02c8 F701      		movw r30,r14
 717 02ca D486      		std Z+12,r13
 136:main.c        ****   ptr += strlen((char *)ptr);
 718               		.loc 1 136 0
 719 02cc 60E0      		ldi r22,lo8(__c.3006)
 720 02ce 70E0      		ldi r23,hi8(__c.3006)
 721 02d0 CE01      		movw r24,r28
 722 02d2 0E94 0000 		call strcpy_P
 723               	.LVL37:
 137:main.c        ****   strcat((char *)ptr, rtc_czas);
 724               		.loc 1 137 0
 725               		0:
 726 02d6 0990      		ld __tmp_reg__,Y+
 727 02d8 0020      		tst __tmp_reg__
 728 02da 01F4      		brne 0b
 729               	.LVL38:
 730 02dc 2197      		sbiw r28,1
 731               	.LVL39:
 138:main.c        ****   ptr += strlen((char *)ptr);
 732               		.loc 1 138 0
 733 02de 60E0      		ldi r22,lo8(rtc_czas)
 734 02e0 70E0      		ldi r23,hi8(rtc_czas)
 735 02e2 CE01      		movw r24,r28
 736 02e4 0E94 0000 		call strcat
 737               	.LVL40:
 139:main.c        ****   *ptr++ = '\n';
 738               		.loc 1 139 0
 739               		0:
 740 02e8 0990      		ld __tmp_reg__,Y+
 741 02ea 0020      		tst __tmp_reg__
 742 02ec 01F4      		brne 0b
 743               	.LVL41:
 744 02ee 2197      		sbiw r28,1
 745               	.LVL42:
 140:main.c        **** 
 746               		.loc 1 140 0
 747 02f0 DE01      		movw r26,r28
 748 02f2 DD92      		st X+,r13
 749               	.LVL43:
 750 02f4 CD01      		movw r24,r26
 143:main.c        ****   ptr += sizeof text_sygnal - 1;
 751               		.loc 1 143 0
 752 02f6 45E0      		ldi r20,lo8(5)
 753 02f8 50E0      		ldi r21,0
 754 02fa 60E0      		ldi r22,lo8(text_sygnal.3008)
 755 02fc 70E0      		ldi r23,hi8(text_sygnal.3008)
 756 02fe 0E94 0000 		call memcpy_P
 757               	.LVL44:
 146:main.c        ****     utoa(poziom_sieci_gsm * 100 / 31, ptr, 10);
 758               		.loc 1 146 0
 759 0302 8091 0000 		lds r24,poziom_sieci_gsm
 760 0306 8032      		cpi r24,lo8(32)
 761 0308 00F4      		brsh .L48
 146:main.c        ****     utoa(poziom_sieci_gsm * 100 / 31, ptr, 10);
 762               		.loc 1 146 0 is_stmt 0 discriminator 1
 763 030a 9091 0000 		lds r25,modul_zalogowany_w_sieci
 764 030e 9923      		tst r25
 765 0310 01F0      		breq .L48
 144:main.c        **** 
 766               		.loc 1 144 0 is_stmt 1
 767 0312 2696      		adiw r28,6
 768               	.LVL45:
 147:main.c        ****     ptr += strlen(ptr);
 769               		.loc 1 147 0
 770 0314 B4E6      		ldi r27,lo8(100)
 771 0316 8B9F      		mul r24,r27
 772 0318 C001      		movw r24,r0
 773 031a 1124      		clr __zero_reg__
 774               	.LVL46:
 775 031c 6FE1      		ldi r22,lo8(31)
 776 031e 70E0      		ldi r23,0
 777 0320 0E94 0000 		call __divmodhi4
 778 0324 CB01      		movw r24,r22
 779               	.LBB378:
 780               	.LBB379:
 781               		.file 6 "/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h"
   1:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Copyright (c) 2004,2007 Joerg Wunsch
   3:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
   4:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Portions of documentation Copyright (c) 1990, 1991, 1993, 1994
   5:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The Regents of the University of California.
   6:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
   7:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    All rights reserved.
   8:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
   9:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Redistribution and use in source and binary forms, with or without
  10:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    modification, are permitted provided that the following conditions are met:
  11:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  12:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    * Redistributions of source code must retain the above copyright
  13:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer.
  14:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  15:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    * Redistributions in binary form must reproduce the above copyright
  16:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer in
  17:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      the documentation and/or other materials provided with the
  18:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      distribution.
  19:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  20:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    * Neither the name of the copyright holders nor the names of
  21:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      contributors may be used to endorse or promote products derived
  22:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      from this software without specific prior written permission.
  23:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  24:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  28:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  34:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   POSSIBILITY OF SUCH DAMAGE.
  35:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  36:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   $Id$
  37:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
  38:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  39:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef _STDLIB_H_
  40:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define	_STDLIB_H_ 1
  41:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  42:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ASSEMBLER__
  43:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  44:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __DOXYGEN__
  45:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define __need_NULL
  46:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define __need_size_t
  47:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define __need_wchar_t
  48:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #include <stddef.h>
  49:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  50:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ptr_t
  51:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define __ptr_t void *
  52:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  53:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif	/* !__DOXYGEN__ */
  54:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  55:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifdef __cplusplus
  56:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern "C" {
  57:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  58:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  59:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** \file */
  60:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  61:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** \defgroup avr_stdlib <stdlib.h>: General utilities
  62:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \code #include <stdlib.h> \endcode
  63:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  64:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     This file declares some basic C macros and functions as
  65:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     defined by the ISO standard, plus some AVR-specific extensions.
  66:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
  67:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  68:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /*@{*/
  69:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** Result type for function div(). */
  70:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** typedef struct {
  71:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	int quot;                   /**< The Quotient. */
  72:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	int rem;                    /**< The Remainder. */
  73:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** } div_t;
  74:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  75:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** Result type for function ldiv(). */
  76:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** typedef struct {
  77:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	long quot;                  /**< The Quotient. */
  78:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	long rem;                   /**< The Remainder. */
  79:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** } ldiv_t;
  80:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  81:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** Comparision function type for qsort(), just for convenience. */
  82:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** typedef int (*__compar_fn_t)(const void *, const void *);
  83:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  84:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __DOXYGEN__
  85:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  86:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ATTR_CONST__
  87:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # define __ATTR_CONST__ __attribute__((__const__))
  88:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  89:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  90:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ATTR_MALLOC__
  91:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # define __ATTR_MALLOC__ __attribute__((__malloc__))
  92:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  93:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  94:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ATTR_NORETURN__
  95:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # define __ATTR_NORETURN__ __attribute__((__noreturn__))
  96:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  97:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  98:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ATTR_PURE__
  99:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # define __ATTR_PURE__ __attribute__((__pure__))
 100:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 101:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 102:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef	__ATTR_GNU_INLINE__
 103:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # ifdef  __GNUC_STDC_INLINE__
 104:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__   __attribute__((__gnu_inline__))
 105:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # else
 106:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__
 107:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # endif
 108:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 109:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 110:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 111:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 112:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** The abort() function causes abnormal program termination to occur.
 113:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     This realization disables interrupts and jumps to _exit() function
 114:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     with argument equal to 1. In the limited AVR environment, execution is
 115:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     effectively halted by entering an infinite loop. */
 116:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void abort(void) __ATTR_NORETURN__;
 117:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 118:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** The abs() function computes the absolute value of the integer \c i.
 119:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 120:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 121:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern int abs(int __i) __ATTR_CONST__;
 122:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 123:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define	abs(__i) __builtin_abs(__i)
 124:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 125:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 126:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** The labs() function computes the absolute value of the long integer
 127:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c i.
 128:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 129:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 130:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern long labs(long __i) __ATTR_CONST__;
 131:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 132:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define labs(__i) __builtin_labs(__i)
 133:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 134:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 135:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 136:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The bsearch() function searches an array of \c nmemb objects, the
 137:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      initial member of which is pointed to by \c base, for a member
 138:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      that matches the object pointed to by \c key.  The size of each
 139:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      member of the array is specified by \c size.
 140:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 141:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The contents of the array should be in ascending sorted order
 142:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      according to the comparison function referenced by \c compar.
 143:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The \c compar routine is expected to have two arguments which
 144:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      point to the key object and to an array member, in that order,
 145:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      and should return an integer less than, equal to, or greater than
 146:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      zero if the key object is found, respectively, to be less than,
 147:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      to match, or be greater than the array member.
 148:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 149:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The bsearch() function returns a pointer to a matching member of
 150:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      the array, or a null pointer if no match is found.  If two
 151:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      members compare as equal, which member is matched is unspecified.
 152:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 153:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void *bsearch(const void *__key, const void *__base, size_t __nmemb,
 154:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 		     size_t __size, int (*__compar)(const void *, const void *));
 155:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 156:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /* __divmodhi4 and __divmodsi4 from libgcc.a */
 157:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 158:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The div() function computes the value \c num/denom and returns
 159:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c div_t that
 160:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      contains two int members named \c quot and \c rem.
 161:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 162:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern div_t div(int __num, int __denom) __asm__("__divmodhi4") __ATTR_CONST__;
 163:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 164:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The ldiv() function computes the value \c num/denom and returns
 165:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c ldiv_t that
 166:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      contains two long integer members named \c quot and \c rem.
 167:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 168:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern ldiv_t ldiv(long __num, long __denom) __asm__("__divmodsi4") __ATTR_CONST__;
 169:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 170:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 171:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The qsort() function is a modified partition-exchange sort, or
 172:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      quicksort.
 173:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 174:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The qsort() function sorts an array of \c nmemb objects, the
 175:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      initial member of which is pointed to by \c base.  The size of
 176:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      each object is specified by \c size.  The contents of the array
 177:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      base are sorted in ascending order according to a comparison
 178:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      function pointed to by \c compar, which requires two arguments
 179:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      pointing to the objects being compared.
 180:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 181:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The comparison function must return an integer less than, equal
 182:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      to, or greater than zero if the first argument is considered to
 183:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      be respectively less than, equal to, or greater than the second.
 184:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 185:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void qsort(void *__base, size_t __nmemb, size_t __size,
 186:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 		  __compar_fn_t __compar);
 187:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 188:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 189:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The strtol() function converts the string in \c nptr to a long
 190:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     value.  The conversion is done according to the given base, which
 191:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     must be between 2 and 36 inclusive, or be the special value 0.
 192:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 193:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 194:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 195:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 196:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 197:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 198:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 199:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 200:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The remainder of the string is converted to a long value in the
 201:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     obvious manner, stopping at the first character which is not a
 202:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     valid digit in the given base.  (In bases above 10, the letter \c 'A'
 203:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     in either upper or lower case represents 10, \c 'B' represents 11,
 204:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     and so forth, with \c 'Z' representing 35.)
 205:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 206:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     If \c endptr is not NULL, strtol() stores the address of the first
 207:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 208:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     however, strtol() stores the original value of \c nptr in \c
 209:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 210:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     on return, the entire string was valid.)
 211:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 212:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The strtol() function returns the result of the conversion, unless
 213:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     the value would underflow or overflow.  If no conversion could be
 214:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     performed, 0 is returned.  If an overflow or underflow occurs, \c
 215:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE" and the function return value
 216:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     is clamped to \c LONG_MIN or \c LONG_MAX, respectively.
 217:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 218:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern long strtol(const char *__nptr, char **__endptr, int __base);
 219:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 220:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 221:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The strtoul() function converts the string in \c nptr to an
 222:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     unsigned long value.  The conversion is done according to the
 223:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     given base, which must be between 2 and 36 inclusive, or be the
 224:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     special value 0.
 225:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 226:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 227:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 228:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 229:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 230:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 231:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 232:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 233:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The remainder of the string is converted to an unsigned long value
 234:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     in the obvious manner, stopping at the first character which is
 235:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     not a valid digit in the given base.  (In bases above 10, the
 236:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     letter \c 'A' in either upper or lower case represents 10, \c 'B'
 237:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     represents 11, and so forth, with \c 'Z' representing 35.)
 238:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 239:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     If \c endptr is not NULL, strtoul() stores the address of the first
 240:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 241:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     however, strtoul() stores the original value of \c nptr in \c
 242:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 243:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     on return, the entire string was valid.)
 244:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 245:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The strtoul() function return either the result of the conversion
 246:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     or, if there was a leading minus sign, the negation of the result
 247:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     of the conversion, unless the original (non-negated) value would
 248:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     overflow; in the latter case, strtoul() returns ULONG_MAX, and \c
 249:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE".  If no conversion could 
 250:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     be performed, 0 is returned.
 251:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 252:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern unsigned long strtoul(const char *__nptr, char **__endptr, int __base);
 253:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 254:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 255:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The atol() function converts the initial portion of the string
 256:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     pointed to by \p s to long integer representation. In contrast to
 257:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 258:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****         \code strtol(s, (char **)NULL, 10); \endcode
 259:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 260:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 261:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 262:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     stack) and works more quickly.
 263:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 264:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern long atol(const char *__s) __ATTR_PURE__;
 265:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 266:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 267:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The atoi() function converts the initial portion of the string
 268:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     pointed to by \p s to integer representation. In contrast to
 269:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 270:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****         \code (int)strtol(s, (char **)NULL, 10); \endcode
 271:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 272:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 273:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 274:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     stack) and works more quickly.
 275:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 276:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern int atoi(const char *__s) __ATTR_PURE__;
 277:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 278:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 279:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The exit() function terminates the application.  Since there is no
 280:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    environment to return to, \c status is ignored, and code execution
 281:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    will eventually reach an infinite loop, thereby effectively halting
 282:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    all code processing.  Before entering the infinite loop, interrupts
 283:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    are globally disabled.
 284:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 285:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    In a C++ context, global destructors will be called before halting
 286:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    execution.
 287:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 288:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void exit(int __status) __ATTR_NORETURN__;
 289:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 290:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 291:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The malloc() function allocates \c size bytes of memory.
 292:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    If malloc() fails, a NULL pointer is returned.
 293:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 294:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Note that malloc() does \e not initialize the returned memory to
 295:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    zero bytes.
 296:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 297:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    See the chapter about \ref malloc "malloc() usage" for implementation
 298:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    details.
 299:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 300:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void *malloc(size_t __size) __ATTR_MALLOC__;
 301:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 302:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 303:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The free() function causes the allocated memory referenced by \c
 304:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    ptr to be made available for future allocations.  If \c ptr is
 305:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    NULL, no action occurs.
 306:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 307:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void free(void *__ptr);
 308:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 309:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 310:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 311:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 312:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern size_t __malloc_margin;
 313:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 314:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 315:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 316:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 317:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *__malloc_heap_start;
 318:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 319:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 320:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 321:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 322:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *__malloc_heap_end;
 323:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 324:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 325:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Allocate \c nele elements of \c size each.  Identical to calling
 326:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c malloc() using <tt>nele * size</tt> as argument, except the
 327:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    allocated memory will be cleared to zero.
 328:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 329:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void *calloc(size_t __nele, size_t __size) __ATTR_MALLOC__;
 330:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 331:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 332:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The realloc() function tries to change the size of the region
 333:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    allocated at \c ptr to the new \c size value.  It returns a
 334:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    pointer to the new region.  The returned pointer might be the
 335:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    same as the old pointer, or a pointer to a completely different
 336:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    region.
 337:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 338:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The contents of the returned region up to either the old or the new
 339:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    size value (whatever is less) will be identical to the contents of
 340:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    the old region, even in case a new region had to be allocated.
 341:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 342:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    It is acceptable to pass \c ptr as NULL, in which case realloc()
 343:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    will behave identical to malloc().
 344:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 345:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    If the new memory cannot be allocated, realloc() returns NULL, and
 346:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    the region at \c ptr will not be changed.
 347:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 348:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void *realloc(void *__ptr, size_t __size) __ATTR_MALLOC__;
 349:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 350:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern double strtod(const char *__nptr, char **__endptr);
 351:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 352:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** \ingroup avr_stdlib
 353:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \fn  double atof (const char *nptr)
 354:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 355:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The atof() function converts the initial portion of the string pointed
 356:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     to by \a nptr to double representation.
 357:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 358:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     It is equivalent to calling
 359:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	\code strtod(nptr, (char **)0); \endcode
 360:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  */
 361:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern double atof(const char *__nptr);
 362:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 363:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** Highest number that can be generated by rand(). */
 364:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define	RAND_MAX 0x7FFF
 365:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 366:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 367:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The rand() function computes a sequence of pseudo-random integers in the
 368:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      range of 0 to \c RAND_MAX (as defined by the header file <stdlib.h>).
 369:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 370:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The srand() function sets its argument \c seed as the seed for a new
 371:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      sequence of pseudo-random numbers to be returned by rand().  These
 372:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      sequences are repeatable by calling srand() with the same seed value.
 373:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 374:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      If no seed value is provided, the functions are automatically seeded with
 375:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      a value of 1.
 376:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 377:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      In compliance with the C standard, these functions operate on
 378:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      \c int arguments.  Since the underlying algorithm already uses
 379:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      32-bit calculations, this causes a loss of precision.  See
 380:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      \c random() for an alternate set of functions that retains full
 381:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      32-bit precision.
 382:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 383:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern int rand(void);
 384:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 385:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Pseudo-random number generator seeding; see rand().
 386:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 387:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void srand(unsigned int __seed);
 388:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 389:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 390:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Variant of rand() that stores the context in the user-supplied
 391:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    variable located at \c ctx instead of a static library variable
 392:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    so the function becomes re-entrant.
 393:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 394:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern int rand_r(unsigned long *__ctx);
 395:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /*@}*/
 396:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 397:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /*@{*/
 398:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** \name Non-standard (i.e. non-ISO C) functions.
 399:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  \ingroup avr_stdlib
 400:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 401:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 402:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \brief Convert an integer to a string.
 403:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 404:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The function itoa() converts the integer value from \c val into an
 405:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 406:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 407:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 408:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 409:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 410:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (int) + 1 characters, i.e. one
 411:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 412:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 413:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 414:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 415:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 416:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 417:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 418:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 419:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c 'a'.
 420:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     
 421:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     If radix is 10 and val is negative, a minus sign will be prepended.
 422:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 423:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The itoa() function returns the pointer passed as \c s.
 424:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 425:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 426:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *itoa(int val, char *s, int radix);
 427:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #else
 428:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 429:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** char *itoa (int __val, char *__s, int __radix)
 430:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** {
 431:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 432:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__itoa (int, char *, int);
 433:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __itoa (__val, __s, __radix);
 434:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 435:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	*__s = 0;
 436:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __s;
 437:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else {
 438:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__itoa_ncheck (int, char *, unsigned char);
 439:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __itoa_ncheck (__val, __s, __radix);
 440:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     }
 441:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** }
 442:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 443:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 444:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 445:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  \ingroup avr_stdlib
 446:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  
 447:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \brief Convert a long integer to a string.
 448:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 449:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The function ltoa() converts the long integer value from \c val into an
 450:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 451:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 452:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 453:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 454:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 455:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (long int) + 1 characters, i.e. one
 456:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 457:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 458:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 459:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 460:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 461:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 462:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 463:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 464:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c 'a'.
 465:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 466:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    If radix is 10 and val is negative, a minus sign will be prepended.
 467:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 468:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The ltoa() function returns the pointer passed as \c s.
 469:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 470:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 471:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *ltoa(long val, char *s, int radix);
 472:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #else
 473:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 474:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** char *ltoa (long __val, char *__s, int __radix)
 475:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** {
 476:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 477:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__ltoa (long, char *, int);
 478:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __ltoa (__val, __s, __radix);
 479:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 480:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	*__s = 0;
 481:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __s;
 482:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else {
 483:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__ltoa_ncheck (long, char *, unsigned char);
 484:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __ltoa_ncheck (__val, __s, __radix);
 485:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     }
 486:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** }
 487:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 488:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 489:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 490:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  \ingroup avr_stdlib
 491:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 492:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \brief Convert an unsigned integer to a string.
 493:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 494:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The function utoa() converts the unsigned integer value from \c val into an
 495:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 496:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 497:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 498:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 499:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 500:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (unsigned int) + 1 characters, i.e. one
 501:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 502:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 503:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 504:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 505:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 506:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 507:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 508:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 509:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c 'a'.
 510:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 511:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The utoa() function returns the pointer passed as \c s.
 512:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 513:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 514:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *utoa(unsigned int val, char *s, int radix);
 515:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #else
 516:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 517:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** char *utoa (unsigned int __val, char *__s, int __radix)
 518:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** {
 519:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 520:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__utoa (unsigned int, char *, int);
 521:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __utoa (__val, __s, __radix);
 522:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 523:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	*__s = 0;
 524:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __s;
 525:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else {
 526:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__utoa_ncheck (unsigned int, char *, unsigned char);
 527:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __utoa_ncheck (__val, __s, __radix);
 782               		.loc 6 527 0
 783 0326 4AE0      		ldi r20,lo8(10)
 784 0328 BE01      		movw r22,r28
 785 032a 0E94 0000 		call __utoa_ncheck
 786               	.LVL47:
 787               	.LBE379:
 788               	.LBE378:
 148:main.c        ****     *ptr++ = '%';
 789               		.loc 1 148 0
 790               		0:
 791 032e 0990      		ld __tmp_reg__,Y+
 792 0330 0020      		tst __tmp_reg__
 793 0332 01F4      		brne 0b
 794               	.LVL48:
 795 0334 2197      		sbiw r28,1
 796               	.LVL49:
 149:main.c        ****   } else {
 797               		.loc 1 149 0
 798 0336 FE01      		movw r30,r28
 799 0338 3196      		adiw r30,1
 800               	.LVL50:
 801 033a 85E2      		ldi r24,lo8(37)
 802 033c 8883      		st Y,r24
 803               	.L49:
 155:main.c        ****   *buf_sms = ptr;
 804               		.loc 1 155 0
 805 033e 1082      		st Z,__zero_reg__
 156:main.c        **** }
 806               		.loc 1 156 0
 807 0340 D801      		movw r26,r16
 808 0342 ED93      		st X+,r30
 809 0344 FC93      		st X,r31
 810               	/* epilogue start */
 157:main.c        **** 
 811               		.loc 1 157 0
 812 0346 DF91      		pop r29
 813 0348 CF91      		pop r28
 814 034a 1F91      		pop r17
 815 034c 0F91      		pop r16
 816               	.LVL51:
 817 034e FF90      		pop r15
 818 0350 EF90      		pop r14
 819 0352 DF90      		pop r13
 820 0354 0895      		ret
 821               	.LVL52:
 822               	.L48:
 151:main.c        ****     *ptr++ = '-';
 823               		.loc 1 151 0
 824 0356 8DE2      		ldi r24,lo8(45)
 825 0358 8E83      		std Y+6,r24
 826               	.LVL53:
 152:main.c        ****     *ptr++ = '-';
 827               		.loc 1 152 0
 828 035a 8F83      		std Y+7,r24
 153:main.c        ****   }
 829               		.loc 1 153 0
 830 035c FE01      		movw r30,r28
 831 035e 3996      		adiw r30,9
 832               	.LVL54:
 833 0360 8887      		std Y+8,r24
 834 0362 00C0      		rjmp .L49
 835               		.cfi_endproc
 836               	.LFE27:
 838               	.global	generuj_raport_uzytkownikow_1
 840               	generuj_raport_uzytkownikow_1:
 841               	.LFB28:
 159:main.c        ****   static const char tekst_gsm[] PROGMEM = "Uzyt: ";
 842               		.loc 1 159 0
 843               		.cfi_startproc
 844               	.LVL55:
 845 0364 AF92      		push r10
 846               	.LCFI20:
 847               		.cfi_def_cfa_offset 3
 848               		.cfi_offset 10, -2
 849 0366 BF92      		push r11
 850               	.LCFI21:
 851               		.cfi_def_cfa_offset 4
 852               		.cfi_offset 11, -3
 853 0368 CF92      		push r12
 854               	.LCFI22:
 855               		.cfi_def_cfa_offset 5
 856               		.cfi_offset 12, -4
 857 036a DF92      		push r13
 858               	.LCFI23:
 859               		.cfi_def_cfa_offset 6
 860               		.cfi_offset 13, -5
 861 036c EF92      		push r14
 862               	.LCFI24:
 863               		.cfi_def_cfa_offset 7
 864               		.cfi_offset 14, -6
 865 036e FF92      		push r15
 866               	.LCFI25:
 867               		.cfi_def_cfa_offset 8
 868               		.cfi_offset 15, -7
 869 0370 0F93      		push r16
 870               	.LCFI26:
 871               		.cfi_def_cfa_offset 9
 872               		.cfi_offset 16, -8
 873 0372 1F93      		push r17
 874               	.LCFI27:
 875               		.cfi_def_cfa_offset 10
 876               		.cfi_offset 17, -9
 877 0374 CF93      		push r28
 878               	.LCFI28:
 879               		.cfi_def_cfa_offset 11
 880               		.cfi_offset 28, -10
 881 0376 DF93      		push r29
 882               	.LCFI29:
 883               		.cfi_def_cfa_offset 12
 884               		.cfi_offset 29, -11
 885               	/* prologue: function */
 886               	/* frame size = 0 */
 887               	/* stack size = 10 */
 888               	.L__stack_usage = 10
 889 0378 8C01      		movw r16,r24
 161:main.c        **** 
 890               		.loc 1 161 0
 891 037a FC01      		movw r30,r24
 892 037c C081      		ld r28,Z
 893 037e D181      		ldd r29,Z+1
 894               	.LVL56:
 163:main.c        ****   ptr += sizeof tekst_gsm - 1;
 895               		.loc 1 163 0
 896 0380 46E0      		ldi r20,lo8(6)
 897 0382 50E0      		ldi r21,0
 898 0384 60E0      		ldi r22,lo8(tekst_gsm.3012)
 899 0386 70E0      		ldi r23,hi8(tekst_gsm.3012)
 900 0388 CE01      		movw r24,r28
 901               	.LVL57:
 902 038a 0E94 0000 		call memcpy_P
 903               	.LVL58:
 164:main.c        ****   uint aktywne_numery = 0;
 904               		.loc 1 164 0
 905 038e 2696      		adiw r28,6
 906               	.LVL59:
 907 0390 88E0      		ldi r24,lo8(8)
 908 0392 C82E      		mov r12,r24
 909 0394 D12C      		mov r13,__zero_reg__
 166:main.c        ****   // for (uchar nr_uzyt_clip = 0; nr_uzyt_clip <
 910               		.loc 1 166 0
 911 0396 F12C      		mov r15,__zero_reg__
 912 0398 E12C      		mov r14,__zero_reg__
 165:main.c        ****   uint wolne_numery = 0;
 913               		.loc 1 165 0
 914 039a B12C      		mov r11,__zero_reg__
 915 039c A12C      		mov r10,__zero_reg__
 916               	.LVL60:
 917               	.L56:
 918               	.LBB380:
 171:main.c        ****       ++aktywne_numery;
 919               		.loc 1 171 0
 920 039e C601      		movw r24,r12
 921 03a0 0E94 0000 		call eeprom_read_byte
 922               	.LVL61:
 923 03a4 8F3F      		cpi r24,lo8(-1)
 924 03a6 01F0      		breq .L54
 172:main.c        ****     else
 925               		.loc 1 172 0
 926 03a8 FFEF      		ldi r31,-1
 927 03aa AF1A      		sub r10,r31
 928 03ac BF0A      		sbc r11,r31
 929               	.LVL62:
 930               	.L55:
 931 03ae E5E0      		ldi r30,5
 932 03b0 CE0E      		add r12,r30
 933 03b2 D11C      		adc r13,__zero_reg__
 169:main.c        ****        ++nr_uzyt_clip) {
 934               		.loc 1 169 0
 935 03b4 F8EA      		ldi r31,-88
 936 03b6 CF16      		cp r12,r31
 937 03b8 FFE0      		ldi r31,15
 938 03ba DF06      		cpc r13,r31
 939 03bc 01F4      		brne .L56
 940               	.LVL63:
 941               	.LBE380:
 942               	.LBB381:
 943               	.LBB382:
 944               		.loc 6 527 0
 945 03be 4AE0      		ldi r20,lo8(10)
 946 03c0 BE01      		movw r22,r28
 947 03c2 C501      		movw r24,r10
 948 03c4 0E94 0000 		call __utoa_ncheck
 949               	.LVL64:
 950               	.LBE382:
 951               	.LBE381:
 178:main.c        ****   *ptr++ = '/';
 952               		.loc 1 178 0
 953               		0:
 954 03c8 0990      		ld __tmp_reg__,Y+
 955 03ca 0020      		tst __tmp_reg__
 956 03cc 01F4      		brne 0b
 957               	.LVL65:
 958 03ce 2197      		sbiw r28,1
 959               	.LVL66:
 179:main.c        ****   utoa(wolne_numery, ptr, 10);
 960               		.loc 1 179 0
 961 03d0 6E01      		movw r12,r28
 962 03d2 8FEF      		ldi r24,-1
 963 03d4 C81A      		sub r12,r24
 964 03d6 D80A      		sbc r13,r24
 965               	.LVL67:
 966 03d8 8FE2      		ldi r24,lo8(47)
 967 03da 8883      		st Y,r24
 968               	.LVL68:
 969               	.LBB383:
 970               	.LBB384:
 971               		.loc 6 527 0
 972 03dc 4AE0      		ldi r20,lo8(10)
 973 03de B601      		movw r22,r12
 974 03e0 C701      		movw r24,r14
 975 03e2 0E94 0000 		call __utoa_ncheck
 976               	.LVL69:
 977               	.LBE384:
 978               	.LBE383:
 181:main.c        ****   *buf_sms = ptr;
 979               		.loc 1 181 0
 980 03e6 F601      		movw r30,r12
 981               		0:
 982 03e8 0190      		ld __tmp_reg__,Z+
 983 03ea 0020      		tst __tmp_reg__
 984 03ec 01F4      		brne 0b
 985 03ee CF01      		movw r24,r30
 986               	.LVL70:
 987 03f0 0197      		sbiw r24,1
 988               	.LVL71:
 182:main.c        **** }
 989               		.loc 1 182 0
 990 03f2 F801      		movw r30,r16
 991               	.LVL72:
 992 03f4 9183      		std Z+1,r25
 993 03f6 8083      		st Z,r24
 994               	/* epilogue start */
 183:main.c        **** 
 995               		.loc 1 183 0
 996 03f8 DF91      		pop r29
 997 03fa CF91      		pop r28
 998 03fc 1F91      		pop r17
 999 03fe 0F91      		pop r16
 1000               	.LVL73:
 1001 0400 FF90      		pop r15
 1002 0402 EF90      		pop r14
 1003               	.LVL74:
 1004 0404 DF90      		pop r13
 1005 0406 CF90      		pop r12
 1006               	.LVL75:
 1007 0408 BF90      		pop r11
 1008 040a AF90      		pop r10
 1009               	.LVL76:
 1010 040c 0895      		ret
 1011               	.LVL77:
 1012               	.L54:
 1013               	.LBB385:
 174:main.c        ****   }
 1014               		.loc 1 174 0
 1015 040e 8FEF      		ldi r24,-1
 1016 0410 E81A      		sub r14,r24
 1017 0412 F80A      		sbc r15,r24
 1018               	.LVL78:
 1019 0414 00C0      		rjmp .L55
 1020               	.LBE385:
 1021               		.cfi_endproc
 1022               	.LFE28:
 1024               	.global	generuj_raport_uzytkownikow
 1026               	generuj_raport_uzytkownikow:
 1027               	.LFB29:
 185:main.c        ****   static const char tekst_gsm[] PROGMEM = "Uzytkownicy ";
 1028               		.loc 1 185 0
 1029               		.cfi_startproc
 1030               	.LVL79:
 1031 0416 CF92      		push r12
 1032               	.LCFI30:
 1033               		.cfi_def_cfa_offset 3
 1034               		.cfi_offset 12, -2
 1035 0418 DF92      		push r13
 1036               	.LCFI31:
 1037               		.cfi_def_cfa_offset 4
 1038               		.cfi_offset 13, -3
 1039 041a EF92      		push r14
 1040               	.LCFI32:
 1041               		.cfi_def_cfa_offset 5
 1042               		.cfi_offset 14, -4
 1043 041c FF92      		push r15
 1044               	.LCFI33:
 1045               		.cfi_def_cfa_offset 6
 1046               		.cfi_offset 15, -5
 1047 041e 0F93      		push r16
 1048               	.LCFI34:
 1049               		.cfi_def_cfa_offset 7
 1050               		.cfi_offset 16, -6
 1051 0420 1F93      		push r17
 1052               	.LCFI35:
 1053               		.cfi_def_cfa_offset 8
 1054               		.cfi_offset 17, -7
 1055 0422 CF93      		push r28
 1056               	.LCFI36:
 1057               		.cfi_def_cfa_offset 9
 1058               		.cfi_offset 28, -8
 1059 0424 DF93      		push r29
 1060               	.LCFI37:
 1061               		.cfi_def_cfa_offset 10
 1062               		.cfi_offset 29, -9
 1063               	/* prologue: function */
 1064               	/* frame size = 0 */
 1065               	/* stack size = 8 */
 1066               	.L__stack_usage = 8
 1067 0426 8C01      		movw r16,r24
 187:main.c        **** 
 1068               		.loc 1 187 0
 1069 0428 FC01      		movw r30,r24
 1070 042a C081      		ld r28,Z
 1071 042c D181      		ldd r29,Z+1
 1072               	.LVL80:
 189:main.c        ****   ptr += sizeof tekst_gsm - 1;
 1073               		.loc 1 189 0
 1074 042e 4CE0      		ldi r20,lo8(12)
 1075 0430 50E0      		ldi r21,0
 1076 0432 60E0      		ldi r22,lo8(tekst_gsm.3023)
 1077 0434 70E0      		ldi r23,hi8(tekst_gsm.3023)
 1078 0436 CE01      		movw r24,r28
 1079               	.LVL81:
 1080 0438 0E94 0000 		call memcpy_P
 1081               	.LVL82:
 190:main.c        ****   uchar aktywne_numery = 0;
 1082               		.loc 1 190 0
 1083 043c 2C96      		adiw r28,12
 1084               	.LVL83:
 1085 043e 88E0      		ldi r24,lo8(8)
 1086 0440 E82E      		mov r14,r24
 1087 0442 F12C      		mov r15,__zero_reg__
 192:main.c        ****   for (uint nr_uzyt_clip = 0; nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 1088               		.loc 1 192 0
 1089 0444 D12C      		mov r13,__zero_reg__
 191:main.c        ****   uchar wolne_numery = 0;
 1090               		.loc 1 191 0
 1091 0446 C12C      		mov r12,__zero_reg__
 1092               	.LVL84:
 1093               	.L61:
 1094               	.LBB386:
 195:main.c        ****       ++aktywne_numery;
 1095               		.loc 1 195 0
 1096 0448 C701      		movw r24,r14
 1097 044a 0E94 0000 		call eeprom_read_byte
 1098               	.LVL85:
 1099 044e 8F3F      		cpi r24,lo8(-1)
 1100 0450 01F0      		breq .L59
 196:main.c        ****     else
 1101               		.loc 1 196 0
 1102 0452 C394      		inc r12
 1103               	.LVL86:
 1104               	.L60:
 1105 0454 F5E0      		ldi r31,5
 1106 0456 EF0E      		add r14,r31
 1107 0458 F11C      		adc r15,__zero_reg__
 193:main.c        ****        ++nr_uzyt_clip) {
 1108               		.loc 1 193 0
 1109 045a 88EA      		ldi r24,-88
 1110 045c E816      		cp r14,r24
 1111 045e 8FE0      		ldi r24,15
 1112 0460 F806      		cpc r15,r24
 1113 0462 01F4      		brne .L61
 1114               	.LVL87:
 1115               	.LBE386:
 1116               	.LBB387:
 1117               	.LBB388:
 1118               		.loc 6 527 0
 1119 0464 4AE0      		ldi r20,lo8(10)
 1120 0466 BE01      		movw r22,r28
 1121 0468 8C2D      		mov r24,r12
 1122 046a 90E0      		ldi r25,0
 1123 046c 0E94 0000 		call __utoa_ncheck
 1124               	.LVL88:
 1125               	.LBE388:
 1126               	.LBE387:
 201:main.c        ****   *ptr++ = '/';
 1127               		.loc 1 201 0
 1128               		0:
 1129 0470 0990      		ld __tmp_reg__,Y+
 1130 0472 0020      		tst __tmp_reg__
 1131 0474 01F4      		brne 0b
 1132               	.LVL89:
 1133 0476 2197      		sbiw r28,1
 1134               	.LVL90:
 202:main.c        ****   utoa(wolne_numery, ptr, 10);
 1135               		.loc 1 202 0
 1136 0478 7E01      		movw r14,r28
 1137 047a EFEF      		ldi r30,-1
 1138 047c EE1A      		sub r14,r30
 1139 047e FE0A      		sbc r15,r30
 1140               	.LVL91:
 1141 0480 8FE2      		ldi r24,lo8(47)
 1142 0482 8883      		st Y,r24
 1143               	.LVL92:
 1144               	.LBB389:
 1145               	.LBB390:
 1146               		.loc 6 527 0
 1147 0484 4AE0      		ldi r20,lo8(10)
 1148 0486 B701      		movw r22,r14
 1149 0488 8D2D      		mov r24,r13
 1150 048a 90E0      		ldi r25,0
 1151 048c 0E94 0000 		call __utoa_ncheck
 1152               	.LVL93:
 1153               	.LBE390:
 1154               	.LBE389:
 204:main.c        ****   *buf_sms = ptr;
 1155               		.loc 1 204 0
 1156 0490 F701      		movw r30,r14
 1157               		0:
 1158 0492 0190      		ld __tmp_reg__,Z+
 1159 0494 0020      		tst __tmp_reg__
 1160 0496 01F4      		brne 0b
 1161 0498 CF01      		movw r24,r30
 1162               	.LVL94:
 1163 049a 0197      		sbiw r24,1
 1164               	.LVL95:
 205:main.c        **** }
 1165               		.loc 1 205 0
 1166 049c F801      		movw r30,r16
 1167               	.LVL96:
 1168 049e 9183      		std Z+1,r25
 1169 04a0 8083      		st Z,r24
 1170               	/* epilogue start */
 206:main.c        **** 
 1171               		.loc 1 206 0
 1172 04a2 DF91      		pop r29
 1173 04a4 CF91      		pop r28
 1174 04a6 1F91      		pop r17
 1175 04a8 0F91      		pop r16
 1176               	.LVL97:
 1177 04aa FF90      		pop r15
 1178 04ac EF90      		pop r14
 1179               	.LVL98:
 1180 04ae DF90      		pop r13
 1181               	.LVL99:
 1182 04b0 CF90      		pop r12
 1183               	.LVL100:
 1184 04b2 0895      		ret
 1185               	.LVL101:
 1186               	.L59:
 1187               	.LBB391:
 198:main.c        ****   }
 1188               		.loc 1 198 0
 1189 04b4 D394      		inc r13
 1190               	.LVL102:
 1191 04b6 00C0      		rjmp .L60
 1192               	.LBE391:
 1193               		.cfi_endproc
 1194               	.LFE29:
 1196               		.section	.rodata.str1.1,"aMS",@progbits,1
 1197               	.LC0:
 1198 0000 4861 726D 		.string	"Harm: %02d:%02d %02d:%02d"
 1198      3A20 2530 
 1198      3264 3A25 
 1198      3032 6420 
 1198      2530 3264 
 1199               		.text
 1200               	.global	generuj_raport_stanu_urzadzenia
 1202               	generuj_raport_stanu_urzadzenia:
 1203               	.LFB30:
 211:main.c        ****   uchar *sms = (char *)tekst_wysylanego_smsa;
 1204               		.loc 1 211 0
 1205               		.cfi_startproc
 1206 04b8 1F93      		push r17
 1207               	.LCFI38:
 1208               		.cfi_def_cfa_offset 3
 1209               		.cfi_offset 17, -2
 1210 04ba CF93      		push r28
 1211               	.LCFI39:
 1212               		.cfi_def_cfa_offset 4
 1213               		.cfi_offset 28, -3
 1214 04bc DF93      		push r29
 1215               	.LCFI40:
 1216               		.cfi_def_cfa_offset 5
 1217               		.cfi_offset 29, -4
 1218 04be 00D0      		rcall .
 1219               	.LCFI41:
 1220               		.cfi_def_cfa_offset 7
 1221 04c0 CDB7      		in r28,__SP_L__
 1222 04c2 DEB7      		in r29,__SP_H__
 1223               	.LCFI42:
 1224               		.cfi_def_cfa_register 28
 1225               	/* prologue: function */
 1226               	/* frame size = 2 */
 1227               	/* stack size = 5 */
 1228               	.L__stack_usage = 5
 213:main.c        ****   *sms++ = '\n';
 1229               		.loc 1 213 0
 1230 04c4 8AE2      		ldi r24,lo8(42)
 1231 04c6 8093 0000 		sts tekst_wysylanego_smsa,r24
 214:main.c        ****   generuj_raport_sieci(&sms);
 1232               		.loc 1 214 0
 1233 04ca 80E0      		ldi r24,lo8(tekst_wysylanego_smsa+2)
 1234 04cc 90E0      		ldi r25,hi8(tekst_wysylanego_smsa+2)
 1235 04ce 9A83      		std Y+2,r25
 1236 04d0 8983      		std Y+1,r24
 1237 04d2 1AE0      		ldi r17,lo8(10)
 1238 04d4 1093 0000 		sts tekst_wysylanego_smsa+1,r17
 215:main.c        ****   *sms++ = '\n';
 1239               		.loc 1 215 0
 1240 04d8 CE01      		movw r24,r28
 1241 04da 0196      		adiw r24,1
 1242 04dc 0E94 0000 		call generuj_raport_sieci
 1243               	.LVL103:
 216:main.c        ****   generuj_raport_uzytkownikow_1(&sms);
 1244               		.loc 1 216 0
 1245 04e0 E981      		ldd r30,Y+1
 1246 04e2 FA81      		ldd r31,Y+2
 1247 04e4 CF01      		movw r24,r30
 1248 04e6 0196      		adiw r24,1
 1249 04e8 9A83      		std Y+2,r25
 1250 04ea 8983      		std Y+1,r24
 1251 04ec 1083      		st Z,r17
 217:main.c        ****   *sms++ = '\n';
 1252               		.loc 1 217 0
 1253 04ee CE01      		movw r24,r28
 1254 04f0 0196      		adiw r24,1
 1255 04f2 0E94 0000 		call generuj_raport_uzytkownikow_1
 1256               	.LVL104:
 218:main.c        **** 
 1257               		.loc 1 218 0
 1258 04f6 E981      		ldd r30,Y+1
 1259 04f8 FA81      		ldd r31,Y+2
 1260 04fa CF01      		movw r24,r30
 1261 04fc 0196      		adiw r24,1
 1262 04fe 9A83      		std Y+2,r25
 1263 0500 8983      		std Y+1,r24
 1264 0502 1083      		st Z,r17
 221:main.c        ****     strcpy_P((char *)sms, PSTR("Status: Zablokowany"));
 1265               		.loc 1 221 0
 1266 0504 2091 0000 		lds r18,blokada_systemu
 1267 0508 8981      		ldd r24,Y+1
 1268 050a 9A81      		ldd r25,Y+2
 222:main.c        ****   } else {
 1269               		.loc 1 222 0
 1270 050c 60E0      		ldi r22,lo8(__c.3037)
 1271 050e 70E0      		ldi r23,hi8(__c.3037)
 221:main.c        ****     strcpy_P((char *)sms, PSTR("Status: Zablokowany"));
 1272               		.loc 1 221 0
 1273 0510 2111      		cpse r18,__zero_reg__
 1274 0512 00C0      		rjmp .L76
 224:main.c        ****   }
 1275               		.loc 1 224 0
 1276 0514 60E0      		ldi r22,lo8(__c.3039)
 1277 0516 70E0      		ldi r23,hi8(__c.3039)
 1278               	.L76:
 1279 0518 0E94 0000 		call strcpy_P
 1280               	.LVL105:
 226:main.c        ****   *sms++ = '\n';
 1281               		.loc 1 226 0
 1282 051c E981      		ldd r30,Y+1
 1283 051e FA81      		ldd r31,Y+2
 1284               		0:
 1285 0520 0190      		ld __tmp_reg__,Z+
 1286 0522 0020      		tst __tmp_reg__
 1287 0524 01F4      		brne 0b
 227:main.c        **** 
 1288               		.loc 1 227 0
 1289 0526 DF01      		movw r26,r30
 1290 0528 1197      		sbiw r26,1
 1291 052a FA83      		std Y+2,r31
 1292 052c E983      		std Y+1,r30
 1293 052e 8AE0      		ldi r24,lo8(10)
 1294 0530 8C93      		st X,r24
 230:main.c        ****     strcpy_P((char *)sms, PSTR("Tryb: Prywatny"));
 1295               		.loc 1 230 0
 1296 0532 2091 0000 		lds r18,tryb_pracy
 1297 0536 8981      		ldd r24,Y+1
 1298 0538 9A81      		ldd r25,Y+2
 231:main.c        ****   } else {
 1299               		.loc 1 231 0
 1300 053a 60E0      		ldi r22,lo8(__c.3041)
 1301 053c 70E0      		ldi r23,hi8(__c.3041)
 230:main.c        ****     strcpy_P((char *)sms, PSTR("Tryb: Prywatny"));
 1302               		.loc 1 230 0
 1303 053e 2223      		tst r18
 1304 0540 01F0      		breq .L77
 233:main.c        ****   }
 1305               		.loc 1 233 0
 1306 0542 60E0      		ldi r22,lo8(__c.3043)
 1307 0544 70E0      		ldi r23,hi8(__c.3043)
 1308               	.L77:
 1309 0546 0E94 0000 		call strcpy_P
 1310               	.LVL106:
 235:main.c        **** 
 1311               		.loc 1 235 0
 1312 054a 8981      		ldd r24,Y+1
 1313 054c 9A81      		ldd r25,Y+2
 1314 054e FC01      		movw r30,r24
 1315               		0:
 1316 0550 0190      		ld __tmp_reg__,Z+
 1317 0552 0020      		tst __tmp_reg__
 1318 0554 01F4      		brne 0b
 1319 0556 CF01      		movw r24,r30
 1320 0558 0197      		sbiw r24,1
 1321 055a 9A83      		std Y+2,r25
 1322 055c 8983      		std Y+1,r24
 237:main.c        ****     strcpy_P((char *)sms, PSTR(" CLIP"));
 1323               		.loc 1 237 0
 1324 055e 2091 0000 		lds r18,tryb_clip
 238:main.c        ****   } else {
 1325               		.loc 1 238 0
 1326 0562 60E0      		ldi r22,lo8(__c.3045)
 1327 0564 70E0      		ldi r23,hi8(__c.3045)
 237:main.c        ****     strcpy_P((char *)sms, PSTR(" CLIP"));
 1328               		.loc 1 237 0
 1329 0566 2111      		cpse r18,__zero_reg__
 1330 0568 00C0      		rjmp .L78
 240:main.c        ****   }
 1331               		.loc 1 240 0
 1332 056a 60E0      		ldi r22,lo8(__c.3047)
 1333 056c 70E0      		ldi r23,hi8(__c.3047)
 1334               	.L78:
 1335 056e 0E94 0000 		call strcpy_P
 1336               	.LVL107:
 242:main.c        ****   *sms++ = '\n';
 1337               		.loc 1 242 0
 1338 0572 E981      		ldd r30,Y+1
 1339 0574 FA81      		ldd r31,Y+2
 1340               		0:
 1341 0576 0190      		ld __tmp_reg__,Z+
 1342 0578 0020      		tst __tmp_reg__
 1343 057a 01F4      		brne 0b
 243:main.c        **** 
 1344               		.loc 1 243 0
 1345 057c DF01      		movw r26,r30
 1346 057e 1197      		sbiw r26,1
 1347 0580 FA83      		std Y+2,r31
 1348 0582 E983      		std Y+1,r30
 1349 0584 8AE0      		ldi r24,lo8(10)
 1350 0586 8C93      		st X,r24
 245:main.c        ****     strcpy_P((char *)sms, PSTR("Harm: Wylaczony"));
 1351               		.loc 1 245 0
 1352 0588 8091 0000 		lds r24,czas_start_h
 1353 058c 8F3F      		cpi r24,lo8(-1)
 1354 058e 01F0      		breq .+2
 1355 0590 00C0      		rjmp .L70
 246:main.c        ****   } else {
 1356               		.loc 1 246 0
 1357 0592 60E0      		ldi r22,lo8(__c.3049)
 1358 0594 70E0      		ldi r23,hi8(__c.3049)
 1359 0596 8981      		ldd r24,Y+1
 1360 0598 9A81      		ldd r25,Y+2
 1361 059a 0E94 0000 		call strcpy_P
 1362               	.LVL108:
 1363               	.L71:
 251:main.c        ****   *sms++ = '\n';
 1364               		.loc 1 251 0
 1365 059e E981      		ldd r30,Y+1
 1366 05a0 FA81      		ldd r31,Y+2
 1367               		0:
 1368 05a2 0190      		ld __tmp_reg__,Z+
 1369 05a4 0020      		tst __tmp_reg__
 1370 05a6 01F4      		brne 0b
 252:main.c        **** 
 1371               		.loc 1 252 0
 1372 05a8 DF01      		movw r26,r30
 1373 05aa 1197      		sbiw r26,1
 1374 05ac FA83      		std Y+2,r31
 1375 05ae E983      		std Y+1,r30
 1376 05b0 8AE0      		ldi r24,lo8(10)
 1377 05b2 8C93      		st X,r24
 255:main.c        ****     strcpy_P((char *)sms, PSTR("Skryba: Wlaczona"));
 1378               		.loc 1 255 0
 1379 05b4 2091 0000 		lds r18,skryba_wlaczona
 1380 05b8 8981      		ldd r24,Y+1
 1381 05ba 9A81      		ldd r25,Y+2
 256:main.c        ****   } else {
 1382               		.loc 1 256 0
 1383 05bc 60E0      		ldi r22,lo8(__c.3051)
 1384 05be 70E0      		ldi r23,hi8(__c.3051)
 255:main.c        ****     strcpy_P((char *)sms, PSTR("Skryba: Wlaczona"));
 1385               		.loc 1 255 0
 1386 05c0 2111      		cpse r18,__zero_reg__
 1387 05c2 00C0      		rjmp .L79
 258:main.c        ****   }
 1388               		.loc 1 258 0
 1389 05c4 60E0      		ldi r22,lo8(__c.3053)
 1390 05c6 70E0      		ldi r23,hi8(__c.3053)
 1391               	.L79:
 1392 05c8 0E94 0000 		call strcpy_P
 1393               	.LVL109:
 260:main.c        ****   *sms++ = '\n';
 1394               		.loc 1 260 0
 1395 05cc E981      		ldd r30,Y+1
 1396 05ce FA81      		ldd r31,Y+2
 1397               		0:
 1398 05d0 0190      		ld __tmp_reg__,Z+
 1399 05d2 0020      		tst __tmp_reg__
 1400 05d4 01F4      		brne 0b
 261:main.c        **** 
 1401               		.loc 1 261 0
 1402 05d6 DF01      		movw r26,r30
 1403 05d8 1197      		sbiw r26,1
 1404 05da FA83      		std Y+2,r31
 1405 05dc E983      		std Y+1,r30
 1406 05de 8AE0      		ldi r24,lo8(10)
 1407 05e0 8C93      		st X,r24
 264:main.c        ****   sms += strlen((char *)sms);
 1408               		.loc 1 264 0
 1409 05e2 60E0      		ldi r22,lo8(__c.3055)
 1410 05e4 70E0      		ldi r23,hi8(__c.3055)
 1411 05e6 8981      		ldd r24,Y+1
 1412 05e8 9A81      		ldd r25,Y+2
 1413 05ea 0E94 0000 		call strcpy_P
 1414               	.LVL110:
 265:main.c        ****   if (moj_numer_telefonu[0] != 0xFF && moj_numer_telefonu[0] != 0) {
 1415               		.loc 1 265 0
 1416 05ee 8981      		ldd r24,Y+1
 1417 05f0 9A81      		ldd r25,Y+2
 1418 05f2 FC01      		movw r30,r24
 1419               		0:
 1420 05f4 0190      		ld __tmp_reg__,Z+
 1421 05f6 0020      		tst __tmp_reg__
 1422 05f8 01F4      		brne 0b
 1423 05fa CF01      		movw r24,r30
 1424 05fc 0197      		sbiw r24,1
 1425 05fe 9A83      		std Y+2,r25
 1426 0600 8983      		std Y+1,r24
 266:main.c        ****     strcpy((char *)sms, (char *)moj_numer_telefonu);
 1427               		.loc 1 266 0
 1428 0602 2091 0000 		lds r18,moj_numer_telefonu
 1429 0606 2150      		subi r18,lo8(-(-1))
 1430 0608 2E3F      		cpi r18,lo8(-2)
 1431 060a 00F4      		brsh .L74
 267:main.c        ****   } else {
 1432               		.loc 1 267 0
 1433 060c 60E0      		ldi r22,lo8(moj_numer_telefonu)
 1434 060e 70E0      		ldi r23,hi8(moj_numer_telefonu)
 1435 0610 0E94 0000 		call strcpy
 1436               	.LVL111:
 1437               	.L75:
 271:main.c        ****   *sms++ = '\n';
 1438               		.loc 1 271 0
 1439 0614 E981      		ldd r30,Y+1
 1440 0616 FA81      		ldd r31,Y+2
 1441               		0:
 1442 0618 0190      		ld __tmp_reg__,Z+
 1443 061a 0020      		tst __tmp_reg__
 1444 061c 01F4      		brne 0b
 272:main.c        **** 
 1445               		.loc 1 272 0
 1446 061e DF01      		movw r26,r30
 1447 0620 1197      		sbiw r26,1
 1448 0622 FA83      		std Y+2,r31
 1449 0624 E983      		std Y+1,r30
 1450 0626 8AE0      		ldi r24,lo8(10)
 1451 0628 8C93      		st X,r24
 275:main.c        **** }
 1452               		.loc 1 275 0
 1453 062a 60E0      		ldi r22,lo8(tekst_demo.3059)
 1454 062c 70E0      		ldi r23,hi8(tekst_demo.3059)
 1455 062e 8981      		ldd r24,Y+1
 1456 0630 9A81      		ldd r25,Y+2
 1457 0632 0E94 0000 		call strcpy_P
 1458               	.LVL112:
 1459               	/* epilogue start */
 276:main.c        **** 
 1460               		.loc 1 276 0
 1461 0636 0F90      		pop __tmp_reg__
 1462 0638 0F90      		pop __tmp_reg__
 1463 063a DF91      		pop r29
 1464 063c CF91      		pop r28
 1465 063e 1F91      		pop r17
 1466 0640 0895      		ret
 1467               	.L70:
 248:main.c        ****             (int)czas_start_m, (int)czas_stop_h, (int)czas_stop_m);
 1468               		.loc 1 248 0
 1469 0642 9091 0000 		lds r25,czas_stop_m
 1470 0646 1F92      		push __zero_reg__
 1471 0648 9F93      		push r25
 1472 064a 9091 0000 		lds r25,czas_stop_h
 1473 064e 1F92      		push __zero_reg__
 1474 0650 9F93      		push r25
 1475 0652 9091 0000 		lds r25,czas_start_m
 1476 0656 1F92      		push __zero_reg__
 1477 0658 9F93      		push r25
 1478 065a 1F92      		push __zero_reg__
 1479 065c 8F93      		push r24
 1480 065e 80E0      		ldi r24,lo8(.LC0)
 1481 0660 90E0      		ldi r25,hi8(.LC0)
 1482 0662 9F93      		push r25
 1483 0664 8F93      		push r24
 1484 0666 8A81      		ldd r24,Y+2
 1485 0668 8F93      		push r24
 1486 066a 8981      		ldd r24,Y+1
 1487 066c 8F93      		push r24
 1488 066e 0E94 0000 		call sprintf
 1489               	.LVL113:
 1490 0672 0FB6      		in __tmp_reg__,__SREG__
 1491 0674 F894      		cli
 1492 0676 DEBF      		out __SP_H__,r29
 1493 0678 0FBE      		out __SREG__,__tmp_reg__
 1494 067a CDBF      		out __SP_L__,r28
 1495 067c 00C0      		rjmp .L71
 1496               	.L74:
 269:main.c        ****   }
 1497               		.loc 1 269 0
 1498 067e 60E0      		ldi r22,lo8(__c.3057)
 1499 0680 70E0      		ldi r23,hi8(__c.3057)
 1500 0682 0E94 0000 		call strcpy_P
 1501               	.LVL114:
 1502 0686 00C0      		rjmp .L75
 1503               		.cfi_endproc
 1504               	.LFE30:
 1506               	.global	czy_numer_jest_super_userem
 1508               	czy_numer_jest_super_userem:
 1509               	.LFB31:
 279:main.c        ****   // Konwertuj numer do formatu EEPROM
 1510               		.loc 1 279 0
 1511               		.cfi_startproc
 1512               	.LVL115:
 1513 0688 0F93      		push r16
 1514               	.LCFI43:
 1515               		.cfi_def_cfa_offset 3
 1516               		.cfi_offset 16, -2
 1517 068a 1F93      		push r17
 1518               	.LCFI44:
 1519               		.cfi_def_cfa_offset 4
 1520               		.cfi_offset 17, -3
 1521 068c CF93      		push r28
 1522               	.LCFI45:
 1523               		.cfi_def_cfa_offset 5
 1524               		.cfi_offset 28, -4
 1525 068e DF93      		push r29
 1526               	.LCFI46:
 1527               		.cfi_def_cfa_offset 6
 1528               		.cfi_offset 29, -5
 1529 0690 00D0      		rcall .
 1530 0692 00D0      		rcall .
 1531 0694 1F92      		push __zero_reg__
 1532               	.LCFI47:
 1533               		.cfi_def_cfa_offset 11
 1534 0696 CDB7      		in r28,__SP_L__
 1535 0698 DEB7      		in r29,__SP_H__
 1536               	.LCFI48:
 1537               		.cfi_def_cfa_register 28
 1538               	/* prologue: function */
 1539               	/* frame size = 5 */
 1540               	/* stack size = 9 */
 1541               	.L__stack_usage = 9
 284:main.c        **** 
 1542               		.loc 1 284 0
 1543 069a FC01      		movw r30,r24
 1544               		0:
 1545 069c 0190      		ld __tmp_reg__,Z+
 1546 069e 0020      		tst __tmp_reg__
 1547 06a0 01F4      		brne 0b
 1548 06a2 BF01      		movw r22,r30
 282:main.c        ****       (uchar *)numer_telefonu,
 1549               		.loc 1 282 0
 1550 06a4 6150      		subi r22,1
 1551 06a6 7109      		sbc r23,__zero_reg__
 1552 06a8 AE01      		movw r20,r28
 1553 06aa 4F5F      		subi r20,-1
 1554 06ac 5F4F      		sbci r21,-1
 1555 06ae 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 1556               	.LVL116:
 1557 06b2 0AE8      		ldi r16,lo8(-118)
 1558 06b4 1FE0      		ldi r17,lo8(15)
 1559               	.LVL117:
 1560               	.L82:
 1561               	.LBB392:
 289:main.c        ****             temp_buf, (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt))) {
 1562               		.loc 1 289 0
 1563 06b6 B801      		movw r22,r16
 1564 06b8 CE01      		movw r24,r28
 1565 06ba 0196      		adiw r24,1
 1566 06bc 0E94 0000 		call porownaj_numer_telefonu_blok
 1567               	.LVL118:
 1568 06c0 8111      		cpse r24,__zero_reg__
 1569 06c2 00C0      		rjmp .L83
 1570 06c4 0B5F      		subi r16,-5
 1571 06c6 1F4F      		sbci r17,-1
 287:main.c        ****        ++nr_uzyt) {
 1572               		.loc 1 287 0
 1573 06c8 083A      		cpi r16,-88
 1574 06ca FFE0      		ldi r31,15
 1575 06cc 1F07      		cpc r17,r31
 1576 06ce 01F4      		brne .L82
 1577               	.L80:
 1578               	/* epilogue start */
 1579               	.LBE392:
 295:main.c        **** 
 1580               		.loc 1 295 0
 1581 06d0 0F90      		pop __tmp_reg__
 1582 06d2 0F90      		pop __tmp_reg__
 1583 06d4 0F90      		pop __tmp_reg__
 1584 06d6 0F90      		pop __tmp_reg__
 1585 06d8 0F90      		pop __tmp_reg__
 1586 06da DF91      		pop r29
 1587 06dc CF91      		pop r28
 1588 06de 1F91      		pop r17
 1589 06e0 0F91      		pop r16
 1590 06e2 0895      		ret
 1591               	.L83:
 1592               	.LBB393:
 291:main.c        ****     }
 1593               		.loc 1 291 0
 1594 06e4 8FEF      		ldi r24,lo8(-1)
 1595 06e6 00C0      		rjmp .L80
 1596               	.LBE393:
 1597               		.cfi_endproc
 1598               	.LFE31:
 1600               	.global	ustaw_wyjscie_clip
 1602               	ustaw_wyjscie_clip:
 1603               	.LFB32:
 297:main.c        ****   stan_wyjscie[0] = TRUE;
 1604               		.loc 1 297 0
 1605               		.cfi_startproc
 1606               	/* prologue: function */
 1607               	/* frame size = 0 */
 1608               	/* stack size = 0 */
 1609               	.L__stack_usage = 0
 298:main.c        ****   licznik_przelacznik_wyjscia[0] = 2 * 10ul; // 2 sekundy
 1610               		.loc 1 298 0
 1611 06e8 8FEF      		ldi r24,lo8(-1)
 1612 06ea 8093 0000 		sts stan_wyjscie,r24
 299:main.c        **** }
 1613               		.loc 1 299 0
 1614 06ee 84E1      		ldi r24,lo8(20)
 1615 06f0 90E0      		ldi r25,0
 1616 06f2 A0E0      		ldi r26,0
 1617 06f4 B0E0      		ldi r27,0
 1618 06f6 8093 0000 		sts licznik_przelacznik_wyjscia,r24
 1619 06fa 9093 0000 		sts licznik_przelacznik_wyjscia+1,r25
 1620 06fe A093 0000 		sts licznik_przelacznik_wyjscia+2,r26
 1621 0702 B093 0000 		sts licznik_przelacznik_wyjscia+3,r27
 1622               	/* epilogue start */
 300:main.c        **** 
 1623               		.loc 1 300 0
 1624 0706 0895      		ret
 1625               		.cfi_endproc
 1626               	.LFE32:
 1628               		.section	.rodata.str1.1
 1629               	.LC1:
 1630 001a 2530 3264 		.string	"%02d:%02d:%02d"
 1630      3A25 3032 
 1630      643A 2530 
 1630      3264 00
 1631               	.LC2:
 1632 0029 2B43 434C 		.string	"+CCLK=\"24/01/01,%02d:%02d:%02d+04\""
 1632      4B3D 2232 
 1632      342F 3031 
 1632      2F30 312C 
 1632      2530 3264 
 1633               	.LC3:
 1634 004c 3A20 00   		.string	": "
 1635               	.LC4:
 1636 004f 4F4B 00   		.string	"OK"
 1637               	.LC5:
 1638 0052 4272 616B 		.string	"Brak takiego numeru w systemie"
 1638      2074 616B 
 1638      6965 676F 
 1638      206E 756D 
 1638      6572 7520 
 1639               	.LC6:
 1640 0071 5770 6973 		.string	"Wpisz numer jaki sprawdzasz, np: USER 793557357"
 1640      7A20 6E75 
 1640      6D65 7220 
 1640      6A61 6B69 
 1640      2073 7072 
 1641               		.text
 1642               	.global	wykonanie_polecenia_sms
 1644               	wykonanie_polecenia_sms:
 1645               	.LFB39:
 395:main.c        ****   tekst_odebranego_smsa[MAX_LICZBA_ZNAKOW_SMS] = 0; // (1) dla pewnoci
 1646               		.loc 1 395 0
 1647               		.cfi_startproc
 1648 0708 CF92      		push r12
 1649               	.LCFI49:
 1650               		.cfi_def_cfa_offset 3
 1651               		.cfi_offset 12, -2
 1652 070a DF92      		push r13
 1653               	.LCFI50:
 1654               		.cfi_def_cfa_offset 4
 1655               		.cfi_offset 13, -3
 1656 070c FF92      		push r15
 1657               	.LCFI51:
 1658               		.cfi_def_cfa_offset 5
 1659               		.cfi_offset 15, -4
 1660 070e 0F93      		push r16
 1661               	.LCFI52:
 1662               		.cfi_def_cfa_offset 6
 1663               		.cfi_offset 16, -5
 1664 0710 1F93      		push r17
 1665               	.LCFI53:
 1666               		.cfi_def_cfa_offset 7
 1667               		.cfi_offset 17, -6
 1668 0712 CF93      		push r28
 1669               	.LCFI54:
 1670               		.cfi_def_cfa_offset 8
 1671               		.cfi_offset 28, -7
 1672 0714 DF93      		push r29
 1673               	.LCFI55:
 1674               		.cfi_def_cfa_offset 9
 1675               		.cfi_offset 29, -8
 1676 0716 CDB7      		in r28,__SP_L__
 1677 0718 DEB7      		in r29,__SP_H__
 1678               	.LCFI56:
 1679               		.cfi_def_cfa_register 28
 1680 071a 6697      		sbiw r28,22
 1681               	.LCFI57:
 1682               		.cfi_def_cfa_offset 31
 1683 071c 0FB6      		in __tmp_reg__,__SREG__
 1684 071e F894      		cli
 1685 0720 DEBF      		out __SP_H__,r29
 1686 0722 0FBE      		out __SREG__,__tmp_reg__
 1687 0724 CDBF      		out __SP_L__,r28
 1688               	/* prologue: function */
 1689               	/* frame size = 22 */
 1690               	/* stack size = 29 */
 1691               	.L__stack_usage = 29
 396:main.c        ****   watchdog_sms_arm();
 1692               		.loc 1 396 0
 1693 0726 1092 0000 		sts wysylany_blok_SIM900+399,__zero_reg__
 1694               	.LBB433:
 1695               	.LBB434:
 332:main.c        ****   watchdog_sms_licznik_100ms = 0;
 1696               		.loc 1 332 0
 1697 072a 8FEF      		ldi r24,lo8(-1)
 1698 072c 8093 0000 		sts watchdog_sms_aktywny,r24
 333:main.c        **** }
 1699               		.loc 1 333 0
 1700 0730 1092 0000 		sts watchdog_sms_licznik_100ms+1,__zero_reg__
 1701 0734 1092 0000 		sts watchdog_sms_licznik_100ms,__zero_reg__
 1702               	.LBE434:
 1703               	.LBE433:
 398:main.c        **** 
 1704               		.loc 1 398 0
 1705 0738 80E0      		ldi r24,lo8(wysylany_blok_SIM900+239)
 1706 073a 90E0      		ldi r25,hi8(wysylany_blok_SIM900+239)
 1707 073c 0E94 0000 		call interpretuj_wiadomosc_sms
 1708               	.LVL119:
 1709 0740 182F      		mov r17,r24
 1710               	.LVL120:
 407:main.c        ****     // Aktualizuj rtc_czas z timestampu SMS (z sekundami z PDU)
 1711               		.loc 1 407 0
 1712 0742 8091 0000 		lds r24,sms_pomijaj_aktualizacje_czasu
 1713 0746 8111      		cpse r24,__zero_reg__
 1714 0748 00C0      		rjmp .L87
 1715               	.LBB435:
 409:main.c        ****             sms_timestamp_minuta, sms_timestamp_sekunda);
 1716               		.loc 1 409 0
 1717 074a 8091 0000 		lds r24,sms_timestamp_sekunda
 1718 074e 1F92      		push __zero_reg__
 1719 0750 8F93      		push r24
 1720 0752 8091 0000 		lds r24,sms_timestamp_minuta
 1721 0756 1F92      		push __zero_reg__
 1722 0758 8F93      		push r24
 1723 075a 8091 0000 		lds r24,sms_timestamp_godzina
 1724 075e 1F92      		push __zero_reg__
 1725 0760 8F93      		push r24
 1726 0762 80E0      		ldi r24,lo8(.LC1)
 1727 0764 90E0      		ldi r25,hi8(.LC1)
 1728 0766 9F93      		push r25
 1729 0768 8F93      		push r24
 1730 076a 80E0      		ldi r24,lo8(rtc_czas)
 1731 076c 90E0      		ldi r25,hi8(rtc_czas)
 1732 076e 9F93      		push r25
 1733 0770 8F93      		push r24
 1734 0772 0E94 0000 		call sprintf
 1735               	.LVL121:
 414:main.c        ****             sms_timestamp_godzina, sms_timestamp_minuta, sms_timestamp_sekunda);
 1736               		.loc 1 414 0
 1737 0776 8091 0000 		lds r24,sms_timestamp_sekunda
 1738 077a 1F92      		push __zero_reg__
 1739 077c 8F93      		push r24
 1740 077e 8091 0000 		lds r24,sms_timestamp_minuta
 1741 0782 1F92      		push __zero_reg__
 1742 0784 8F93      		push r24
 1743 0786 8091 0000 		lds r24,sms_timestamp_godzina
 1744 078a 1F92      		push __zero_reg__
 1745 078c 8F93      		push r24
 1746 078e 80E0      		ldi r24,lo8(.LC2)
 1747 0790 90E0      		ldi r25,hi8(.LC2)
 1748 0792 9F93      		push r25
 1749 0794 8F93      		push r24
 1750 0796 80E0      		ldi r24,lo8(bufor_ustaw_czas)
 1751 0798 90E0      		ldi r25,hi8(bufor_ustaw_czas)
 1752 079a 9F93      		push r25
 1753 079c 8F93      		push r24
 1754 079e 0E94 0000 		call sprintf
 1755               	.LVL122:
 416:main.c        **** 
 1756               		.loc 1 416 0
 1757 07a2 8EEF      		ldi r24,lo8(-2)
 1758 07a4 0E94 0000 		call dodaj_komende
 1759               	.LVL123:
 419:main.c        ****       int curr_time = sms_timestamp_godzina * 60 + sms_timestamp_minuta;
 1760               		.loc 1 419 0
 1761 07a8 2091 0000 		lds r18,czas_start_h
 1762 07ac 0FB6      		in __tmp_reg__,__SREG__
 1763 07ae F894      		cli
 1764 07b0 DEBF      		out __SP_H__,r29
 1765 07b2 0FBE      		out __SREG__,__tmp_reg__
 1766 07b4 CDBF      		out __SP_L__,r28
 1767 07b6 2F3F      		cpi r18,lo8(-1)
 1768 07b8 01F4      		brne .+2
 1769 07ba 00C0      		rjmp .L88
 1770               	.LBB436:
 420:main.c        ****       int start_time = czas_start_h * 60 + czas_start_m;
 1771               		.loc 1 420 0
 1772 07bc 3091 0000 		lds r19,sms_timestamp_godzina
 1773 07c0 6CE3      		ldi r22,lo8(60)
 1774 07c2 8091 0000 		lds r24,sms_timestamp_minuta
 1775 07c6 90E0      		ldi r25,0
 1776 07c8 369F      		mul r19,r22
 1777 07ca 800D      		add r24,r0
 1778 07cc 911D      		adc r25,r1
 1779 07ce 1124      		clr __zero_reg__
 1780               	.LVL124:
 421:main.c        ****       int stop_time = czas_stop_h * 60 + czas_stop_m;
 1781               		.loc 1 421 0
 1782 07d0 4091 0000 		lds r20,czas_start_m
 1783 07d4 50E0      		ldi r21,0
 1784 07d6 269F      		mul r18,r22
 1785 07d8 400D      		add r20,r0
 1786 07da 511D      		adc r21,r1
 1787 07dc 1124      		clr __zero_reg__
 1788               	.LVL125:
 422:main.c        **** 
 1789               		.loc 1 422 0
 1790 07de 7091 0000 		lds r23,czas_stop_h
 1791 07e2 2091 0000 		lds r18,czas_stop_m
 1792 07e6 30E0      		ldi r19,0
 1793 07e8 769F      		mul r23,r22
 1794 07ea 200D      		add r18,r0
 1795 07ec 311D      		adc r19,r1
 1796 07ee 1124      		clr __zero_reg__
 1797               	.LVL126:
 424:main.c        ****         // Normalny przedział (np. 08:00 - 16:00)
 1798               		.loc 1 424 0
 1799 07f0 2417      		cp r18,r20
 1800 07f2 3507      		cpc r19,r21
 1801 07f4 04F0      		brlt .L89
 427:main.c        ****       } else {
 1802               		.loc 1 427 0
 1803 07f6 8417      		cp r24,r20
 1804 07f8 9507      		cpc r25,r21
 1805 07fa 04F0      		brlt .L116
 427:main.c        ****       } else {
 1806               		.loc 1 427 0 is_stmt 0 discriminator 2
 1807 07fc 41E0      		ldi r20,lo8(1)
 1808               	.LVL127:
 1809 07fe 2817      		cp r18,r24
 1810 0800 3907      		cpc r19,r25
 1811 0802 04F0      		brlt .L90
 1812 0804 40E0      		ldi r20,0
 1813               	.L90:
 426:main.c        ****             !(curr_time >= start_time && curr_time <= stop_time);
 1814               		.loc 1 426 0 is_stmt 1
 1815 0806 4093 0000 		sts blokada_sterowania_czasowa,r20
 1816               	.LVL128:
 1817               	.L87:
 1818               	.LBE436:
 1819               	.LBE435:
 439:main.c        **** 
 1820               		.loc 1 439 0
 1821 080a 1092 0000 		sts sms_pomijaj_aktualizacje_czasu,__zero_reg__
 442:main.c        ****     autosync_czas_aktywny = FALSE;
 1822               		.loc 1 442 0
 1823 080e 8091 0000 		lds r24,autosync_czas_aktywny
 1824 0812 8111      		cpse r24,__zero_reg__
 443:main.c        ****   }
 1825               		.loc 1 443 0
 1826 0814 1092 0000 		sts autosync_czas_aktywny,__zero_reg__
 1827               	.L94:
 447:main.c        ****     // Gdy zablokowany, akceptuj tylko START i REPORT
 1828               		.loc 1 447 0
 1829 0818 8091 0000 		lds r24,blokada_systemu
 1830 081c 8823      		tst r24
 1831 081e 01F0      		breq .L95
 449:main.c        ****         komenda != INTERPRETACJA_SMS_RAPORT) {
 1832               		.loc 1 449 0
 1833 0820 8DEF      		ldi r24,lo8(-3)
 1834 0822 810F      		add r24,r17
 1835 0824 8230      		cpi r24,lo8(2)
 1836 0826 00F0      		brlo .L95
 454:main.c        ****           1) {
 1837               		.loc 1 454 0
 1838 0828 87EF      		ldi r24,lo8(-9)
 1839 082a 9FE0      		ldi r25,lo8(15)
 1840 082c 0E94 0000 		call eeprom_read_byte
 1841               	.LVL129:
 1842 0830 8130      		cpi r24,lo8(1)
 1843 0832 01F4      		brne .L95
 456:main.c        ****         usun_zablokowany_sms();
 1844               		.loc 1 456 0
 1845 0834 62E0      		ldi r22,lo8(2)
 1846 0836 0E94 0000 		call zapisz_debug_do_eeprom
 1847               	.LVL130:
 457:main.c        ****         return;
 1848               		.loc 1 457 0
 1849 083a 0E94 0000 		call usun_zablokowany_sms
 1850               	.LVL131:
 1851               	.L86:
 1852               	/* epilogue start */
 697:main.c        **** 
 1853               		.loc 1 697 0
 1854 083e 6696      		adiw r28,22
 1855 0840 0FB6      		in __tmp_reg__,__SREG__
 1856 0842 F894      		cli
 1857 0844 DEBF      		out __SP_H__,r29
 1858 0846 0FBE      		out __SREG__,__tmp_reg__
 1859 0848 CDBF      		out __SP_L__,r28
 1860 084a DF91      		pop r29
 1861 084c CF91      		pop r28
 1862 084e 1F91      		pop r17
 1863 0850 0F91      		pop r16
 1864 0852 FF90      		pop r15
 1865 0854 DF90      		pop r13
 1866 0856 CF90      		pop r12
 1867 0858 0895      		ret
 1868               	.LVL132:
 1869               	.L116:
 1870               	.LBB438:
 1871               	.LBB437:
 427:main.c        ****       } else {
 1872               		.loc 1 427 0
 1873 085a 41E0      		ldi r20,lo8(1)
 1874               	.LVL133:
 1875 085c 00C0      		rjmp .L90
 1876               	.LVL134:
 1877               	.L89:
 431:main.c        ****       }
 1878               		.loc 1 431 0
 1879 085e 8417      		cp r24,r20
 1880 0860 9507      		cpc r25,r21
 1881 0862 04F4      		brge .L117
 431:main.c        ****       }
 1882               		.loc 1 431 0 is_stmt 0 discriminator 1
 1883 0864 41E0      		ldi r20,lo8(1)
 1884               	.LVL135:
 1885 0866 2817      		cp r18,r24
 1886 0868 3907      		cpc r19,r25
 1887 086a 04F0      		brlt .L93
 1888 086c 40E0      		ldi r20,0
 1889               	.L93:
 1890 086e 842F      		mov r24,r20
 1891               	.LVL136:
 1892               	.L92:
 430:main.c        ****             !(curr_time >= start_time || curr_time <= stop_time);
 1893               		.loc 1 430 0 is_stmt 1
 1894 0870 8093 0000 		sts blokada_sterowania_czasowa,r24
 1895 0874 00C0      		rjmp .L87
 1896               	.LVL137:
 1897               	.L117:
 431:main.c        ****       }
 1898               		.loc 1 431 0
 1899 0876 80E0      		ldi r24,0
 1900               	.LVL138:
 1901 0878 00C0      		rjmp .L92
 1902               	.LVL139:
 1903               	.L88:
 1904               	.LBE437:
 434:main.c        ****     }
 1905               		.loc 1 434 0
 1906 087a 1092 0000 		sts blokada_sterowania_czasowa,__zero_reg__
 1907 087e 00C0      		rjmp .L87
 1908               	.L95:
 1909               	.LBE438:
 464:main.c        ****       komenda == INTERPRETACJA_SMS_USER) {
 1910               		.loc 1 464 0
 1911 0880 8CEF      		ldi r24,lo8(-4)
 1912 0882 810F      		add r24,r17
 1913 0884 8230      		cpi r24,lo8(2)
 1914 0886 00F4      		brsh .L97
 466:main.c        ****       zapisz_debug_do_eeprom(1, 1);
 1915               		.loc 1 466 0
 1916 0888 8091 0000 		lds r24,licznik_report_user
 1917 088c 8830      		cpi r24,lo8(8)
 1918 088e 00F0      		brlo .L97
 1919               	.L98:
 467:main.c        ****       usun_zablokowany_sms();
 1920               		.loc 1 467 0
 1921 0890 61E0      		ldi r22,lo8(1)
 1922 0892 81E0      		ldi r24,lo8(1)
 1923 0894 0E94 0000 		call zapisz_debug_do_eeprom
 1924               	.LVL140:
 468:main.c        ****       zareaguj_na_usuniety_sms_z_powodu_limitu();
 1925               		.loc 1 468 0
 1926 0898 0E94 0000 		call usun_zablokowany_sms
 1927               	.LVL141:
 469:main.c        ****       watchdog_sms_disarm();
 1928               		.loc 1 469 0
 1929 089c 0E94 0000 		call zareaguj_na_usuniety_sms_z_powodu_limitu
 1930               	.LVL142:
 1931               	.L101:
 696:main.c        **** }
 1932               		.loc 1 696 0
 1933 08a0 0E94 0000 		call watchdog_sms_disarm
 1934               	.LVL143:
 1935 08a4 00C0      		rjmp .L86
 1936               	.LVL144:
 1937               	.L97:
 476:main.c        ****     // Same number check
 1938               		.loc 1 476 0
 1939 08a6 8091 0000 		lds r24,flaga_wysylanie_smsa
 1940 08aa 8111      		cpse r24,__zero_reg__
 1941 08ac 00C0      		rjmp .L98
 1942 08ae E0E0      		ldi r30,lo8(komendy_kolejka)
 1943 08b0 F0E0      		ldi r31,hi8(komendy_kolejka)
 496:main.c        ****   for (uchar i = 0; i < LICZBA_KOMEND; ++i) {
 1944               		.loc 1 496 0
 1945 08b2 20E0      		ldi r18,0
 495:main.c        ****   uchar liczba_wszystkich_komend = 0;
 1946               		.loc 1 495 0
 1947 08b4 90E0      		ldi r25,0
 1948               	.L100:
 1949               	.LVL145:
 1950               	.LBB439:
 498:main.c        ****       ++liczba_wszystkich_komend;
 1951               		.loc 1 498 0
 1952 08b6 8191      		ld r24,Z+
 1953               	.LVL146:
 1954 08b8 8823      		tst r24
 1955 08ba 01F0      		breq .L99
 499:main.c        ****       if (komendy_kolejka[i] >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
 1956               		.loc 1 499 0
 1957 08bc 2F5F      		subi r18,lo8(-(1))
 1958               	.LVL147:
 500:main.c        ****           komendy_kolejka[i] <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
 1959               		.loc 1 500 0
 1960 08be 835D      		subi r24,lo8(-(45))
 1961 08c0 8230      		cpi r24,lo8(2)
 1962 08c2 00F4      		brsh .L99
 502:main.c        ****     }
 1963               		.loc 1 502 0
 1964 08c4 9F5F      		subi r25,lo8(-(1))
 1965               	.LVL148:
 1966               	.L99:
 497:main.c        ****     if (komendy_kolejka[i] != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 1967               		.loc 1 497 0 discriminator 2
 1968 08c6 80E0      		ldi r24,hi8(komendy_kolejka+30)
 1969 08c8 E030      		cpi r30,lo8(komendy_kolejka+30)
 1970 08ca F807      		cpc r31,r24
 1971 08cc 01F4      		brne .L100
 1972               	.LBE439:
 506:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 1973               		.loc 1 506 0
 1974 08ce 2332      		cpi r18,lo8(35)
 1975 08d0 00F4      		brsh .L98
 514:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 1976               		.loc 1 514 0
 1977 08d2 9630      		cpi r25,lo8(6)
 1978 08d4 00F4      		brsh .L98
 522:main.c        ****   case INTERPRETACJA_SMS_POPRAWNY:
 1979               		.loc 1 522 0
 1980 08d6 1C30      		cpi r17,lo8(12)
 1981 08d8 00F4      		brsh .L101
 1982 08da E12F      		mov r30,r17
 1983               	.LVL149:
 1984 08dc F0E0      		ldi r31,0
 1985 08de E050      		subi r30,lo8(-(gs(.L103)))
 1986 08e0 F040      		sbci r31,hi8(-(gs(.L103)))
 1987 08e2 0C94 0000 		jmp __tablejump2__
 1988               		.p2align	1
 1989               	.L103:
 1990 08e6 0000      		.word gs(.L102)
 1991 08e8 0000      		.word gs(.L101)
 1992 08ea 0000      		.word gs(.L101)
 1993 08ec 0000      		.word gs(.L131)
 1994 08ee 0000      		.word gs(.L105)
 1995 08f0 0000      		.word gs(.L106)
 1996 08f2 0000      		.word gs(.L107)
 1997 08f4 0000      		.word gs(.L108)
 1998 08f6 0000      		.word gs(.L109)
 1999 08f8 0000      		.word gs(.L101)
 2000 08fa 0000      		.word gs(.L101)
 2001 08fc 0000      		.word gs(.L110)
 2002               	.L102:
 527:main.c        ****     zapisz_debug_do_eeprom(0, 3);
 2003               		.loc 1 527 0
 2004 08fe 81E0      		ldi r24,lo8(1)
 2005 0900 8093 0000 		sts liczba_blyskow_led,r24
 2006 0904 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 528:main.c        ****     break;
 2007               		.loc 1 528 0
 2008 0908 63E0      		ldi r22,lo8(3)
 2009 090a 80E0      		ldi r24,0
 2010               	.LVL150:
 2011               	.L133:
 540:main.c        ****     break;
 2012               		.loc 1 540 0
 2013 090c 0E94 0000 		call zapisz_debug_do_eeprom
 2014               	.LVL151:
 541:main.c        ****   }
 2015               		.loc 1 541 0
 2016 0910 00C0      		rjmp .L101
 2017               	.LVL152:
 2018               	.L105:
 532:main.c        ****     timer_report_user_100ms = OKNO_CZASOWE_REPORT_USER_100MS;
 2019               		.loc 1 532 0
 2020 0912 8091 0000 		lds r24,licznik_report_user
 2021 0916 8F5F      		subi r24,lo8(-(1))
 2022 0918 8093 0000 		sts licznik_report_user,r24
 533:main.c        **** 
 2023               		.loc 1 533 0
 2024 091c 8CE2      		ldi r24,lo8(44)
 2025 091e 91E0      		ldi r25,lo8(1)
 2026 0920 9093 0000 		sts timer_report_user_100ms+1,r25
 2027 0924 8093 0000 		sts timer_report_user_100ms,r24
 535:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 2028               		.loc 1 535 0
 2029 0928 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 2030 092a 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 2031 092c 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 2032 092e 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 2033 0930 0E94 0000 		call strcpy
 2034               	.LVL153:
 537:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 2035               		.loc 1 537 0
 2036 0934 0E94 0000 		call generuj_raport_stanu_urzadzenia
 2037               	.LVL154:
 538:main.c        ****     zapal_diode_led_blyski(2); // Komenda REPORT - 2 blyski
 2038               		.loc 1 538 0
 2039 0938 83ED      		ldi r24,lo8(-45)
 2040 093a 0E94 0000 		call dodaj_komende
 2041               	.LVL155:
 539:main.c        ****     zapisz_debug_do_eeprom(1, 0);
 2042               		.loc 1 539 0
 2043 093e 82E0      		ldi r24,lo8(2)
 2044 0940 8093 0000 		sts liczba_blyskow_led,r24
 2045 0944 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 540:main.c        ****     break;
 2046               		.loc 1 540 0
 2047 0948 60E0      		ldi r22,0
 2048 094a 81E0      		ldi r24,lo8(1)
 2049 094c 00C0      		rjmp .L133
 2050               	.LVL156:
 2051               	.L109:
 2052               	.LBB440:
 545:main.c        ****     uchar *sms = tekst_wysylanego_smsa + strlen((char *)tekst_wysylanego_smsa);
 2053               		.loc 1 545 0
 2054 094e 60E0      		ldi r22,lo8(__c.3133)
 2055 0950 70E0      		ldi r23,hi8(__c.3133)
 2056 0952 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 2057 0954 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 2058 0956 0E94 0000 		call strcpy_P
 2059               	.LVL157:
 546:main.c        **** 
 2060               		.loc 1 546 0
 2061 095a 00E0      		ldi r16,lo8(tekst_wysylanego_smsa)
 2062 095c 10E0      		ldi r17,hi8(tekst_wysylanego_smsa)
 2063 095e F801      		movw r30,r16
 2064               		0:
 2065 0960 0190      		ld __tmp_reg__,Z+
 2066 0962 0020      		tst __tmp_reg__
 2067 0964 01F4      		brne 0b
 2068 0966 8F01      		movw r16,r30
 2069 0968 0150      		subi r16,1
 2070 096a 1109      		sbc r17,__zero_reg__
 2071               	.LVL158:
 549:main.c        ****     sms += strlen((char *)sms);
 2072               		.loc 1 549 0
 2073 096c 60E0      		ldi r22,lo8(__c.3136)
 2074 096e 70E0      		ldi r23,hi8(__c.3136)
 2075 0970 C801      		movw r24,r16
 2076 0972 0E94 0000 		call strcpy_P
 2077               	.LVL159:
 550:main.c        ****     *sms++ =
 2078               		.loc 1 550 0
 2079 0976 F801      		movw r30,r16
 2080               		0:
 2081 0978 0190      		ld __tmp_reg__,Z+
 2082 097a 0020      		tst __tmp_reg__
 2083 097c 01F4      		brne 0b
 2084 097e CF01      		movw r24,r30
 2085 0980 0197      		sbiw r24,1
 2086 0982 6C01      		movw r12,r24
 2087               	.LVL160:
 552:main.c        ****     *sms++ =
 2088               		.loc 1 552 0
 2089 0984 81EF      		ldi r24,lo8(-15)
 2090 0986 9FE0      		ldi r25,lo8(15)
 2091 0988 0E94 0000 		call eeprom_read_byte
 2092               	.LVL161:
 2093 098c 805D      		subi r24,lo8(-(48))
 551:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_2);
 2094               		.loc 1 551 0
 2095 098e F601      		movw r30,r12
 2096 0990 8083      		st Z,r24
 554:main.c        ****     *sms++ =
 2097               		.loc 1 554 0
 2098 0992 82EF      		ldi r24,lo8(-14)
 2099 0994 9FE0      		ldi r25,lo8(15)
 2100 0996 0E94 0000 		call eeprom_read_byte
 2101               	.LVL162:
 2102 099a 805D      		subi r24,lo8(-(48))
 553:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_3);
 2103               		.loc 1 553 0
 2104 099c F601      		movw r30,r12
 2105 099e 8183      		std Z+1,r24
 556:main.c        ****     *sms++ =
 2106               		.loc 1 556 0
 2107 09a0 83EF      		ldi r24,lo8(-13)
 2108 09a2 9FE0      		ldi r25,lo8(15)
 2109 09a4 0E94 0000 		call eeprom_read_byte
 2110               	.LVL163:
 2111 09a8 805D      		subi r24,lo8(-(48))
 555:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_4);
 2112               		.loc 1 555 0
 2113 09aa F601      		movw r30,r12
 2114 09ac 8283      		std Z+2,r24
 558:main.c        ****     *sms++ = '\n';
 2115               		.loc 1 558 0
 2116 09ae 84EF      		ldi r24,lo8(-12)
 2117 09b0 9FE0      		ldi r25,lo8(15)
 2118 09b2 0E94 0000 		call eeprom_read_byte
 2119               	.LVL164:
 2120 09b6 805D      		subi r24,lo8(-(48))
 557:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_5);
 2121               		.loc 1 557 0
 2122 09b8 F601      		movw r30,r12
 2123 09ba 8383      		std Z+3,r24
 559:main.c        **** 
 2124               		.loc 1 559 0
 2125 09bc 8601      		movw r16,r12
 2126 09be 0B5F      		subi r16,-5
 2127 09c0 1F4F      		sbci r17,-1
 2128               	.LVL165:
 2129 09c2 9AE0      		ldi r25,lo8(10)
 2130 09c4 F92E      		mov r15,r25
 2131 09c6 F482      		std Z+4,r15
 562:main.c        ****     sms += strlen((char *)sms);
 2132               		.loc 1 562 0
 2133 09c8 60E0      		ldi r22,lo8(__c.3138)
 2134 09ca 70E0      		ldi r23,hi8(__c.3138)
 2135 09cc C801      		movw r24,r16
 2136 09ce 0E94 0000 		call strcpy_P
 2137               	.LVL166:
 563:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_1), sms, 10);
 2138               		.loc 1 563 0
 2139 09d2 F801      		movw r30,r16
 2140               		0:
 2141 09d4 0190      		ld __tmp_reg__,Z+
 2142 09d6 0020      		tst __tmp_reg__
 2143 09d8 01F4      		brne 0b
 2144 09da 8F01      		movw r16,r30
 2145               	.LVL167:
 2146 09dc 0150      		subi r16,1
 2147 09de 1109      		sbc r17,__zero_reg__
 2148               	.LVL168:
 564:main.c        ****     sms += strlen((char *)sms);
 2149               		.loc 1 564 0
 2150 09e0 86EE      		ldi r24,lo8(-26)
 2151 09e2 9FE0      		ldi r25,lo8(15)
 2152 09e4 0E94 0000 		call eeprom_read_byte
 2153               	.LVL169:
 2154               	.LBB441:
 2155               	.LBB442:
 2156               		.loc 6 527 0
 2157 09e8 4AE0      		ldi r20,lo8(10)
 2158 09ea B801      		movw r22,r16
 2159 09ec 90E0      		ldi r25,0
 2160 09ee 0E94 0000 		call __utoa_ncheck
 2161               	.LVL170:
 2162               	.LBE442:
 2163               	.LBE441:
 565:main.c        **** 
 2164               		.loc 1 565 0
 2165 09f2 F801      		movw r30,r16
 2166               		0:
 2167 09f4 0190      		ld __tmp_reg__,Z+
 2168 09f6 0020      		tst __tmp_reg__
 2169 09f8 01F4      		brne 0b
 2170 09fa 8F01      		movw r16,r30
 2171               	.LVL171:
 2172 09fc 0150      		subi r16,1
 2173 09fe 1109      		sbc r17,__zero_reg__
 2174               	.LVL172:
 567:main.c        ****     sms += strlen((char *)sms);
 2175               		.loc 1 567 0
 2176 0a00 60E0      		ldi r22,lo8(__c.3140)
 2177 0a02 70E0      		ldi r23,hi8(__c.3140)
 2178 0a04 C801      		movw r24,r16
 2179 0a06 0E94 0000 		call strcpy_P
 2180               	.LVL173:
 568:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_2), sms, 10);
 2181               		.loc 1 568 0
 2182 0a0a F801      		movw r30,r16
 2183               		0:
 2184 0a0c 0190      		ld __tmp_reg__,Z+
 2185 0a0e 0020      		tst __tmp_reg__
 2186 0a10 01F4      		brne 0b
 2187 0a12 8F01      		movw r16,r30
 2188               	.LVL174:
 2189 0a14 0150      		subi r16,1
 2190 0a16 1109      		sbc r17,__zero_reg__
 2191               	.LVL175:
 569:main.c        ****     sms += strlen((char *)sms);
 2192               		.loc 1 569 0
 2193 0a18 87EE      		ldi r24,lo8(-25)
 2194 0a1a 9FE0      		ldi r25,lo8(15)
 2195 0a1c 0E94 0000 		call eeprom_read_byte
 2196               	.LVL176:
 2197               	.LBB443:
 2198               	.LBB444:
 2199               		.loc 6 527 0
 2200 0a20 4AE0      		ldi r20,lo8(10)
 2201 0a22 B801      		movw r22,r16
 2202 0a24 90E0      		ldi r25,0
 2203 0a26 0E94 0000 		call __utoa_ncheck
 2204               	.LVL177:
 2205               	.LBE444:
 2206               	.LBE443:
 570:main.c        **** 
 2207               		.loc 1 570 0
 2208 0a2a F801      		movw r30,r16
 2209               		0:
 2210 0a2c 0190      		ld __tmp_reg__,Z+
 2211 0a2e 0020      		tst __tmp_reg__
 2212 0a30 01F4      		brne 0b
 2213 0a32 8F01      		movw r16,r30
 2214               	.LVL178:
 2215 0a34 0150      		subi r16,1
 2216 0a36 1109      		sbc r17,__zero_reg__
 2217               	.LVL179:
 572:main.c        ****     sms += strlen((char *)sms);
 2218               		.loc 1 572 0
 2219 0a38 60E0      		ldi r22,lo8(__c.3142)
 2220 0a3a 70E0      		ldi r23,hi8(__c.3142)
 2221 0a3c C801      		movw r24,r16
 2222 0a3e 0E94 0000 		call strcpy_P
 2223               	.LVL180:
 573:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_3), sms, 10);
 2224               		.loc 1 573 0
 2225 0a42 F801      		movw r30,r16
 2226               		0:
 2227 0a44 0190      		ld __tmp_reg__,Z+
 2228 0a46 0020      		tst __tmp_reg__
 2229 0a48 01F4      		brne 0b
 2230 0a4a 8F01      		movw r16,r30
 2231               	.LVL181:
 2232 0a4c 0150      		subi r16,1
 2233 0a4e 1109      		sbc r17,__zero_reg__
 2234               	.LVL182:
 574:main.c        ****     sms += strlen((char *)sms);
 2235               		.loc 1 574 0
 2236 0a50 88EE      		ldi r24,lo8(-24)
 2237 0a52 9FE0      		ldi r25,lo8(15)
 2238 0a54 0E94 0000 		call eeprom_read_byte
 2239               	.LVL183:
 2240               	.LBB445:
 2241               	.LBB446:
 2242               		.loc 6 527 0
 2243 0a58 4AE0      		ldi r20,lo8(10)
 2244 0a5a B801      		movw r22,r16
 2245 0a5c 90E0      		ldi r25,0
 2246 0a5e 0E94 0000 		call __utoa_ncheck
 2247               	.LVL184:
 2248               	.LBE446:
 2249               	.LBE445:
 575:main.c        ****     *sms++ = '\n';
 2250               		.loc 1 575 0
 2251 0a62 F801      		movw r30,r16
 2252               		0:
 2253 0a64 0190      		ld __tmp_reg__,Z+
 2254 0a66 0020      		tst __tmp_reg__
 2255 0a68 01F4      		brne 0b
 2256 0a6a 3197      		sbiw r30,1
 2257               	.LVL185:
 576:main.c        **** 
 2258               		.loc 1 576 0
 2259 0a6c 8F01      		movw r16,r30
 2260 0a6e 0F5F      		subi r16,-1
 2261 0a70 1F4F      		sbci r17,-1
 2262               	.LVL186:
 2263 0a72 F082      		st Z,r15
 578:main.c        ****     sms += strlen((char *)sms);
 2264               		.loc 1 578 0
 2265 0a74 60E0      		ldi r22,lo8(__c.3144)
 2266 0a76 70E0      		ldi r23,hi8(__c.3144)
 2267 0a78 C801      		movw r24,r16
 2268 0a7a 0E94 0000 		call strcpy_P
 2269               	.LVL187:
 579:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_4), sms, 10);
 2270               		.loc 1 579 0
 2271 0a7e F801      		movw r30,r16
 2272               		0:
 2273 0a80 0190      		ld __tmp_reg__,Z+
 2274 0a82 0020      		tst __tmp_reg__
 2275 0a84 01F4      		brne 0b
 2276 0a86 8F01      		movw r16,r30
 2277               	.LVL188:
 2278 0a88 0150      		subi r16,1
 2279 0a8a 1109      		sbc r17,__zero_reg__
 2280               	.LVL189:
 580:main.c        ****     sms += strlen((char *)sms);
 2281               		.loc 1 580 0
 2282 0a8c 89EE      		ldi r24,lo8(-23)
 2283 0a8e 9FE0      		ldi r25,lo8(15)
 2284 0a90 0E94 0000 		call eeprom_read_byte
 2285               	.LVL190:
 2286               	.LBB447:
 2287               	.LBB448:
 2288               		.loc 6 527 0
 2289 0a94 4AE0      		ldi r20,lo8(10)
 2290 0a96 B801      		movw r22,r16
 2291 0a98 90E0      		ldi r25,0
 2292 0a9a 0E94 0000 		call __utoa_ncheck
 2293               	.LVL191:
 2294               	.LBE448:
 2295               	.LBE447:
 581:main.c        **** 
 2296               		.loc 1 581 0
 2297 0a9e F801      		movw r30,r16
 2298               		0:
 2299 0aa0 0190      		ld __tmp_reg__,Z+
 2300 0aa2 0020      		tst __tmp_reg__
 2301 0aa4 01F4      		brne 0b
 2302 0aa6 8F01      		movw r16,r30
 2303               	.LVL192:
 2304 0aa8 0150      		subi r16,1
 2305 0aaa 1109      		sbc r17,__zero_reg__
 2306               	.LVL193:
 583:main.c        ****     sms += strlen((char *)sms);
 2307               		.loc 1 583 0
 2308 0aac 60E0      		ldi r22,lo8(__c.3146)
 2309 0aae 70E0      		ldi r23,hi8(__c.3146)
 2310 0ab0 C801      		movw r24,r16
 2311 0ab2 0E94 0000 		call strcpy_P
 2312               	.LVL194:
 584:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_5), sms, 10);
 2313               		.loc 1 584 0
 2314 0ab6 F801      		movw r30,r16
 2315               		0:
 2316 0ab8 0190      		ld __tmp_reg__,Z+
 2317 0aba 0020      		tst __tmp_reg__
 2318 0abc 01F4      		brne 0b
 2319 0abe 8F01      		movw r16,r30
 2320               	.LVL195:
 2321 0ac0 0150      		subi r16,1
 2322 0ac2 1109      		sbc r17,__zero_reg__
 2323               	.LVL196:
 585:main.c        ****     sms += strlen((char *)sms);
 2324               		.loc 1 585 0
 2325 0ac4 8AEE      		ldi r24,lo8(-22)
 2326 0ac6 9FE0      		ldi r25,lo8(15)
 2327 0ac8 0E94 0000 		call eeprom_read_byte
 2328               	.LVL197:
 2329               	.LBB449:
 2330               	.LBB450:
 2331               		.loc 6 527 0
 2332 0acc 4AE0      		ldi r20,lo8(10)
 2333 0ace B801      		movw r22,r16
 2334 0ad0 90E0      		ldi r25,0
 2335 0ad2 0E94 0000 		call __utoa_ncheck
 2336               	.LVL198:
 2337               	.LBE450:
 2338               	.LBE449:
 586:main.c        **** 
 2339               		.loc 1 586 0
 2340 0ad6 F801      		movw r30,r16
 2341               		0:
 2342 0ad8 0190      		ld __tmp_reg__,Z+
 2343 0ada 0020      		tst __tmp_reg__
 2344 0adc 01F4      		brne 0b
 2345 0ade 8F01      		movw r16,r30
 2346               	.LVL199:
 2347 0ae0 0150      		subi r16,1
 2348 0ae2 1109      		sbc r17,__zero_reg__
 2349               	.LVL200:
 588:main.c        ****     sms += strlen((char *)sms);
 2350               		.loc 1 588 0
 2351 0ae4 60E0      		ldi r22,lo8(__c.3148)
 2352 0ae6 70E0      		ldi r23,hi8(__c.3148)
 2353 0ae8 C801      		movw r24,r16
 2354 0aea 0E94 0000 		call strcpy_P
 2355               	.LVL201:
 589:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_6), sms, 10);
 2356               		.loc 1 589 0
 2357 0aee F801      		movw r30,r16
 2358               		0:
 2359 0af0 0190      		ld __tmp_reg__,Z+
 2360 0af2 0020      		tst __tmp_reg__
 2361 0af4 01F4      		brne 0b
 2362 0af6 8F01      		movw r16,r30
 2363               	.LVL202:
 2364 0af8 0150      		subi r16,1
 2365 0afa 1109      		sbc r17,__zero_reg__
 2366               	.LVL203:
 590:main.c        ****     sms += strlen((char *)sms);
 2367               		.loc 1 590 0
 2368 0afc 8BEE      		ldi r24,lo8(-21)
 2369 0afe 9FE0      		ldi r25,lo8(15)
 2370 0b00 0E94 0000 		call eeprom_read_byte
 2371               	.LVL204:
 2372               	.LBB451:
 2373               	.LBB452:
 2374               		.loc 6 527 0
 2375 0b04 4AE0      		ldi r20,lo8(10)
 2376 0b06 B801      		movw r22,r16
 2377 0b08 90E0      		ldi r25,0
 2378 0b0a 0E94 0000 		call __utoa_ncheck
 2379               	.LVL205:
 2380               	.LBE452:
 2381               	.LBE451:
 591:main.c        **** 
 2382               		.loc 1 591 0
 2383 0b0e F801      		movw r30,r16
 2384               		0:
 2385 0b10 0190      		ld __tmp_reg__,Z+
 2386 0b12 0020      		tst __tmp_reg__
 2387 0b14 01F4      		brne 0b
 2388 0b16 8F01      		movw r16,r30
 2389               	.LVL206:
 2390 0b18 0150      		subi r16,1
 2391 0b1a 1109      		sbc r17,__zero_reg__
 2392               	.LVL207:
 593:main.c        ****     sms += strlen((char *)sms);
 2393               		.loc 1 593 0
 2394 0b1c 60E0      		ldi r22,lo8(__c.3150)
 2395 0b1e 70E0      		ldi r23,hi8(__c.3150)
 2396 0b20 C801      		movw r24,r16
 2397 0b22 0E94 0000 		call strcpy_P
 2398               	.LVL208:
 594:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_7), sms, 10);
 2399               		.loc 1 594 0
 2400 0b26 F801      		movw r30,r16
 2401               		0:
 2402 0b28 0190      		ld __tmp_reg__,Z+
 2403 0b2a 0020      		tst __tmp_reg__
 2404 0b2c 01F4      		brne 0b
 2405 0b2e 8F01      		movw r16,r30
 2406               	.LVL209:
 2407 0b30 0150      		subi r16,1
 2408 0b32 1109      		sbc r17,__zero_reg__
 2409               	.LVL210:
 595:main.c        ****     sms += strlen((char *)sms);
 2410               		.loc 1 595 0
 2411 0b34 8CEE      		ldi r24,lo8(-20)
 2412 0b36 9FE0      		ldi r25,lo8(15)
 2413 0b38 0E94 0000 		call eeprom_read_byte
 2414               	.LVL211:
 2415               	.LBB453:
 2416               	.LBB454:
 2417               		.loc 6 527 0
 2418 0b3c 4AE0      		ldi r20,lo8(10)
 2419 0b3e B801      		movw r22,r16
 2420 0b40 90E0      		ldi r25,0
 2421 0b42 0E94 0000 		call __utoa_ncheck
 2422               	.LVL212:
 2423               	.LBE454:
 2424               	.LBE453:
 596:main.c        ****     *sms++ = '\n';
 2425               		.loc 1 596 0
 2426 0b46 F801      		movw r30,r16
 2427               		0:
 2428 0b48 0190      		ld __tmp_reg__,Z+
 2429 0b4a 0020      		tst __tmp_reg__
 2430 0b4c 01F4      		brne 0b
 2431 0b4e CF01      		movw r24,r30
 2432               	.LVL213:
 597:main.c        **** 
 2433               		.loc 1 597 0
 2434 0b50 0197      		sbiw r24,1
 2435               	.LVL214:
 2436 0b52 FC01      		movw r30,r24
 2437               	.LVL215:
 2438 0b54 F192      		st Z+,r15
 2439 0b56 CF01      		movw r24,r30
 2440               	.LVL216:
 599:main.c        **** 
 2441               		.loc 1 599 0
 2442 0b58 60E0      		ldi r22,lo8(__c.3152)
 2443 0b5a 70E0      		ldi r23,hi8(__c.3152)
 2444 0b5c 0E94 0000 		call strcpy_P
 2445               	.LVL217:
 601:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 2446               		.loc 1 601 0
 2447 0b60 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 2448 0b62 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 2449 0b64 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 2450 0b66 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 2451               	.L134:
 2452 0b68 0E94 0000 		call strcpy
 2453               	.LVL218:
 603:main.c        ****     zapal_diode_led_blyski(2);
 2454               		.loc 1 603 0
 2455 0b6c 83ED      		ldi r24,lo8(-45)
 2456               	.L132:
 2457 0b6e 0E94 0000 		call dodaj_komende
 2458               	.LVL219:
 2459               	.L131:
 604:main.c        ****     break;
 2460               		.loc 1 604 0
 2461 0b72 82E0      		ldi r24,lo8(2)
 2462 0b74 8093 0000 		sts liczba_blyskow_led,r24
 2463 0b78 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 605:main.c        ****   }
 2464               		.loc 1 605 0
 2465 0b7c 00C0      		rjmp .L101
 2466               	.LVL220:
 2467               	.L106:
 2468               	.LBE440:
 2469               	.LBB455:
 608:main.c        ****     timer_report_user_100ms = OKNO_CZASOWE_REPORT_USER_100MS;
 2470               		.loc 1 608 0
 2471 0b7e 8091 0000 		lds r24,licznik_report_user
 2472 0b82 8F5F      		subi r24,lo8(-(1))
 2473 0b84 8093 0000 		sts licznik_report_user,r24
 609:main.c        **** 
 2474               		.loc 1 609 0
 2475 0b88 8CE2      		ldi r24,lo8(44)
 2476 0b8a 91E0      		ldi r25,lo8(1)
 2477 0b8c 9093 0000 		sts timer_report_user_100ms+1,r25
 2478 0b90 8093 0000 		sts timer_report_user_100ms,r24
 611:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 2479               		.loc 1 611 0
 2480 0b94 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 2481 0b96 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 2482 0b98 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 2483 0b9a 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 2484 0b9c 0E94 0000 		call strcpy
 2485               	.LVL221:
 620:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
 2486               		.loc 1 620 0
 2487 0ba0 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 2488 0ba2 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 2489 0ba4 FB01      		movw r30,r22
 2490               		0:
 2491 0ba6 0190      		ld __tmp_reg__,Z+
 2492 0ba8 0020      		tst __tmp_reg__
 2493 0baa 01F4      		brne 0b
 2494 0bac BF01      		movw r22,r30
 2495 0bae 6150      		subi r22,1
 2496 0bb0 7109      		sbc r23,__zero_reg__
 618:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
 2497               		.loc 1 618 0
 2498 0bb2 AE01      		movw r20,r28
 2499 0bb4 4E5E      		subi r20,-18
 2500 0bb6 5F4F      		sbci r21,-1
 2501 0bb8 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 2502 0bba 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 2503 0bbc 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 2504               	.LVL222:
 2505 0bc0 88E0      		ldi r24,lo8(8)
 2506 0bc2 C82E      		mov r12,r24
 2507 0bc4 D12C      		mov r13,__zero_reg__
 2508               	.LVL223:
 2509               	.L112:
 2510               	.LBB456:
 628:main.c        ****               temp_buf, (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
 2511               		.loc 1 628 0
 2512 0bc6 B601      		movw r22,r12
 2513 0bc8 CE01      		movw r24,r28
 2514 0bca 4296      		adiw r24,18
 2515 0bcc 0E94 0000 		call porownaj_numer_telefonu_blok
 2516               	.LVL224:
 2517 0bd0 182F      		mov r17,r24
 2518 0bd2 8111      		cpse r24,__zero_reg__
 2519 0bd4 00C0      		rjmp .L118
 2520 0bd6 F5E0      		ldi r31,5
 2521 0bd8 CF0E      		add r12,r31
 2522 0bda D11C      		adc r13,__zero_reg__
 626:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 2523               		.loc 1 626 0
 2524 0bdc 88EA      		ldi r24,-88
 2525 0bde C816      		cp r12,r24
 2526 0be0 8FE0      		ldi r24,15
 2527 0be2 D806      		cpc r13,r24
 2528 0be4 01F4      		brne .L112
 2529               	.L111:
 2530               	.LVL225:
 2531               	.LBE456:
 638:main.c        ****                                      MAX_LICZBA_ZNAKOW_TELEFON + 1);
 2532               		.loc 1 638 0
 2533 0be6 41E1      		ldi r20,lo8(17)
 2534 0be8 BE01      		movw r22,r28
 2535 0bea 6F5F      		subi r22,-1
 2536 0bec 7F4F      		sbci r23,-1
 2537 0bee CE01      		movw r24,r28
 2538 0bf0 4296      		adiw r24,18
 2539 0bf2 0E94 0000 		call konwertuj_blok_eeprom_na_telefon
 2540               	.LVL226:
 641:main.c        ****     strcat((char *)tekst_wysylanego_smsa, ": ");
 2541               		.loc 1 641 0
 2542 0bf6 BE01      		movw r22,r28
 2543 0bf8 6F5F      		subi r22,-1
 2544 0bfa 7F4F      		sbci r23,-1
 2545 0bfc 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 2546 0bfe 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 2547 0c00 0E94 0000 		call strcpy
 2548               	.LVL227:
 642:main.c        ****     if (znaleziono) {
 2549               		.loc 1 642 0
 2550 0c04 60E0      		ldi r22,lo8(.LC3)
 2551 0c06 70E0      		ldi r23,hi8(.LC3)
 2552 0c08 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 2553 0c0a 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 2554 0c0c 0E94 0000 		call strcat
 2555               	.LVL228:
 644:main.c        ****     } else {
 2556               		.loc 1 644 0
 2557 0c10 60E0      		ldi r22,lo8(.LC4)
 2558 0c12 70E0      		ldi r23,hi8(.LC4)
 643:main.c        ****       strcat((char *)tekst_wysylanego_smsa, "OK");
 2559               		.loc 1 643 0
 2560 0c14 1111      		cpse r17,__zero_reg__
 2561 0c16 00C0      		rjmp .L130
 2562               	.LVL229:
 646:main.c        ****     }
 2563               		.loc 1 646 0
 2564 0c18 60E0      		ldi r22,lo8(.LC5)
 2565 0c1a 70E0      		ldi r23,hi8(.LC5)
 2566               	.LVL230:
 2567               	.L130:
 2568 0c1c 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 2569 0c1e 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 2570 0c20 0E94 0000 		call strcat
 2571               	.LVL231:
 649:main.c        **** 
 2572               		.loc 1 649 0
 2573 0c24 83ED      		ldi r24,lo8(-45)
 2574 0c26 0E94 0000 		call dodaj_komende
 2575               	.LVL232:
 651:main.c        **** 
 2576               		.loc 1 651 0
 2577 0c2a 82E0      		ldi r24,lo8(2)
 2578 0c2c 8093 0000 		sts liczba_blyskow_led,r24
 2579 0c30 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 655:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 2580               		.loc 1 655 0
 2581 0c34 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 2582 0c38 8111      		cpse r24,__zero_reg__
 2583 0c3a 00C0      		rjmp .L115
 655:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 2584               		.loc 1 655 0 is_stmt 0 discriminator 1
 2585 0c3c 8091 0000 		lds r24,liczba_znakow_do_zapisu
 2586 0c40 8111      		cpse r24,__zero_reg__
 2587 0c42 00C0      		rjmp .L115
 655:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 2588               		.loc 1 655 0 discriminator 2
 2589 0c44 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 2590 0c48 8111      		cpse r24,__zero_reg__
 2591 0c4a 00C0      		rjmp .L115
 655:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 2592               		.loc 1 655 0 discriminator 3
 2593 0c4c 8FB3      		in r24,0x1f
 2594               	.L115:
 663:main.c        ****     break;
 2595               		.loc 1 663 0 is_stmt 1
 2596 0c4e 612F      		mov r22,r17
 2597 0c50 82E0      		ldi r24,lo8(2)
 2598 0c52 00C0      		rjmp .L133
 2599               	.LVL233:
 2600               	.L118:
 2601               	.LBB457:
 630:main.c        ****         break;
 2602               		.loc 1 630 0
 2603 0c54 1FEF      		ldi r17,lo8(-1)
 2604 0c56 00C0      		rjmp .L111
 2605               	.LVL234:
 2606               	.L107:
 2607               	.LBE457:
 2608               	.LBE455:
 667:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 2609               		.loc 1 667 0
 2610 0c58 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 2611 0c5a 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 2612 0c5c 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 2613 0c5e 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 2614 0c60 0E94 0000 		call strcpy
 2615               	.LVL235:
 669:main.c        ****            "Wpisz numer jaki sprawdzasz, np: USER 793557357");
 2616               		.loc 1 669 0
 2617 0c64 60E0      		ldi r22,lo8(.LC6)
 2618 0c66 70E0      		ldi r23,hi8(.LC6)
 2619 0c68 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 2620 0c6a 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 2621 0c6c 00C0      		rjmp .L134
 2622               	.LVL236:
 2623               	.L108:
 676:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 2624               		.loc 1 676 0
 2625 0c6e 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 2626 0c70 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 2627 0c72 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 2628 0c74 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 2629 0c76 0E94 0000 		call strcpy
 2630               	.LVL237:
 678:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW);
 2631               		.loc 1 678 0
 2632 0c7a 1092 0000 		sts numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama,__zero_reg__
 679:main.c        ****     zapal_diode_led_blyski(2);
 2633               		.loc 1 679 0
 2634 0c7e 89E8      		ldi r24,lo8(-119)
 2635 0c80 00C0      		rjmp .L132
 2636               	.LVL238:
 2637               	.L110:
 684:main.c        ****             KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 2638               		.loc 1 684 0
 2639 0c82 63E8      		ldi r22,lo8(-125)
 2640 0c84 82E0      		ldi r24,lo8(2)
 2641 0c86 0E94 0000 		call czy_sa_komendy_z_przedzialu
 2642               	.LVL239:
 2643 0c8a 8111      		cpse r24,__zero_reg__
 2644 0c8c 00C0      		rjmp .L101
 687:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
 2645               		.loc 1 687 0
 2646 0c8e 89E1      		ldi r24,lo8(25)
 2647 0c90 8093 0000 		sts liczba_blyskow_led,r24
 2648 0c94 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 688:main.c        ****     }
 2649               		.loc 1 688 0
 2650 0c98 83E0      		ldi r24,lo8(3)
 2651 0c9a 0E94 0000 		call dodaj_komende
 2652               	.LVL240:
 2653 0c9e 00C0      		rjmp .L101
 2654               		.cfi_endproc
 2655               	.LFE39:
 2657               	.global	steruj_wejsciem_reset_100ms
 2659               	steruj_wejsciem_reset_100ms:
 2660               	.LFB40:
 699:main.c        ****   static uchar licznik_reset;
 2661               		.loc 1 699 0
 2662               		.cfi_startproc
 2663               	/* prologue: function */
 2664               	/* frame size = 0 */
 2665               	/* stack size = 0 */
 2666               	.L__stack_usage = 0
 2667 0ca0 8091 0000 		lds r24,licznik_reset.3173
 701:main.c        ****     if (licznik_reset < 20 * 10)
 2668               		.loc 1 701 0
 2669 0ca4 9091 0000 		lds r25,stan_logiczny_na_wejsciu
 2670 0ca8 90FF      		sbrs r25,0
 2671 0caa 00C0      		rjmp .L136
 702:main.c        ****       ++licznik_reset;
 2672               		.loc 1 702 0
 2673 0cac 883C      		cpi r24,lo8(-56)
 2674 0cae 00F4      		brsh .L135
 703:main.c        ****   } else {
 2675               		.loc 1 703 0
 2676 0cb0 8F5F      		subi r24,lo8(-(1))
 2677 0cb2 8093 0000 		sts licznik_reset.3173,r24
 2678 0cb6 0895      		ret
 2679               	.L136:
 2680               	.LBB460:
 2681               	.LBB461:
 705:main.c        ****       if (not czy_sa_komendy_z_przedzialu(
 2682               		.loc 1 705 0
 2683 0cb8 883C      		cpi r24,lo8(-56)
 2684 0cba 00F0      		brlo .L138
 706:main.c        ****               KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 2685               		.loc 1 706 0
 2686 0cbc 63E8      		ldi r22,lo8(-125)
 2687 0cbe 82E0      		ldi r24,lo8(2)
 2688 0cc0 0E94 0000 		call czy_sa_komendy_z_przedzialu
 2689               	.LVL241:
 2690 0cc4 8111      		cpse r24,__zero_reg__
 2691 0cc6 00C0      		rjmp .L140
 709:main.c        ****     } else if (licznik_reset >= 5 * 10) {
 2692               		.loc 1 709 0
 2693 0cc8 83E0      		ldi r24,lo8(3)
 2694               	.L142:
 714:main.c        ****     }
 2695               		.loc 1 714 0
 2696 0cca 0E94 0000 		call dodaj_komende
 2697               	.LVL242:
 2698               	.L140:
 716:main.c        ****   }
 2699               		.loc 1 716 0
 2700 0cce 1092 0000 		sts licznik_reset.3173,__zero_reg__
 2701               	.L135:
 2702               	/* epilogue start */
 2703               	.LBE461:
 2704               	.LBE460:
 718:main.c        **** 
 2705               		.loc 1 718 0
 2706 0cd2 0895      		ret
 2707               	.L138:
 2708               	.LBB463:
 2709               	.LBB462:
 710:main.c        ****       if (not czy_sa_komendy_z_przedzialu(
 2710               		.loc 1 710 0
 2711 0cd4 8233      		cpi r24,lo8(50)
 2712 0cd6 00F0      		brlo .L140
 711:main.c        ****               KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 2713               		.loc 1 711 0
 2714 0cd8 63E8      		ldi r22,lo8(-125)
 2715 0cda 82E0      		ldi r24,lo8(2)
 2716 0cdc 0E94 0000 		call czy_sa_komendy_z_przedzialu
 2717               	.LVL243:
 2718 0ce0 8111      		cpse r24,__zero_reg__
 2719 0ce2 00C0      		rjmp .L140
 714:main.c        ****     }
 2720               		.loc 1 714 0
 2721 0ce4 82E0      		ldi r24,lo8(2)
 2722 0ce6 00C0      		rjmp .L142
 2723               	.LBE462:
 2724               	.LBE463:
 2725               		.cfi_endproc
 2726               	.LFE40:
 2728               	.global	sprawdz_przychodzaca_rozmowe
 2730               	sprawdz_przychodzaca_rozmowe:
 2731               	.LFB41:
 721:main.c        ****   // Super User: pozycje 795-800 omijaja wszystkie blokady
 2732               		.loc 1 721 0
 2733               		.cfi_startproc
 2734 0ce8 CF93      		push r28
 2735               	.LCFI58:
 2736               		.cfi_def_cfa_offset 3
 2737               		.cfi_offset 28, -2
 2738 0cea DF93      		push r29
 2739               	.LCFI59:
 2740               		.cfi_def_cfa_offset 4
 2741               		.cfi_offset 29, -3
 2742               	/* prologue: function */
 2743               	/* frame size = 0 */
 2744               	/* stack size = 2 */
 2745               	.L__stack_usage = 2
 723:main.c        ****       czy_numer_jest_super_userem(numer_telefonu_ktory_dzwoni);
 2746               		.loc 1 723 0
 2747 0cec 80E0      		ldi r24,lo8(numer_telefonu_ktory_dzwoni)
 2748 0cee 90E0      		ldi r25,hi8(numer_telefonu_ktory_dzwoni)
 2749 0cf0 0E94 0000 		call czy_numer_jest_super_userem
 2750               	.LVL244:
 726:main.c        ****     return FALSE; // Ignoruj rozmowy gdy system zablokowany (chyba ze super
 2751               		.loc 1 726 0
 2752 0cf4 9091 0000 		lds r25,blokada_systemu
 2753 0cf8 9923      		tst r25
 2754 0cfa 01F0      		breq .L144
 726:main.c        ****     return FALSE; // Ignoruj rozmowy gdy system zablokowany (chyba ze super
 2755               		.loc 1 726 0 is_stmt 0 discriminator 1
 2756 0cfc 8111      		cpse r24,__zero_reg__
 2757 0cfe 00C0      		rjmp .L144
 2758               	.LVL245:
 2759               	.L147:
 727:main.c        ****                   // user)
 2760               		.loc 1 727 0 is_stmt 1
 2761 0d00 80E0      		ldi r24,0
 2762               	.L143:
 2763               	/* epilogue start */
 772:main.c        **** 
 2764               		.loc 1 772 0
 2765 0d02 DF91      		pop r29
 2766 0d04 CF91      		pop r28
 2767 0d06 0895      		ret
 2768               	.LVL246:
 2769               	.L144:
 731:main.c        ****     return FALSE; // Ignoruj rozmowy gdy blokada czasowa (chyba ze super user)
 2770               		.loc 1 731 0
 2771 0d08 9091 0000 		lds r25,blokada_sterowania_czasowa
 2772 0d0c 9923      		tst r25
 2773 0d0e 01F0      		breq .L146
 731:main.c        ****     return FALSE; // Ignoruj rozmowy gdy blokada czasowa (chyba ze super user)
 2774               		.loc 1 731 0 is_stmt 0 discriminator 1
 2775 0d10 8823      		tst r24
 2776 0d12 01F0      		breq .L147
 2777               	.L146:
 2778 0d14 8091 0000 		lds r24,numer_telefonu_ktory_dzwoni
 2779               	.LVL247:
 736:main.c        ****     if (numer_telefonu_ktory_dzwoni[0] != 0)
 2780               		.loc 1 736 0 is_stmt 1
 2781 0d18 9091 0000 		lds r25,tryb_clip
 2782 0d1c 9111      		cpse r25,__zero_reg__
 2783 0d1e 00C0      		rjmp .L148
 737:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA);
 2784               		.loc 1 737 0
 2785 0d20 8823      		tst r24
 2786 0d22 01F0      		breq .L149
 738:main.c        **** 
 2787               		.loc 1 738 0
 2788 0d24 84E8      		ldi r24,lo8(-124)
 2789 0d26 0E94 0000 		call dodaj_komende
 2790               	.LVL248:
 2791               	.L149:
 741:main.c        ****       return TRUE;
 2792               		.loc 1 741 0
 2793 0d2a 8091 0000 		lds r24,tryb_pracy
 2794 0d2e 8130      		cpi r24,lo8(1)
 2795 0d30 01F4      		brne .L150
 2796               	.L151:
 742:main.c        **** 
 2797               		.loc 1 742 0
 2798 0d32 8FEF      		ldi r24,lo8(-1)
 2799 0d34 00C0      		rjmp .L143
 2800               	.L150:
 2801               	.LBB467:
 2802               	.LBB468:
 747:main.c        ****                                          (char *)numer_telefonu_ktory_dzwoni)],
 2803               		.loc 1 747 0
 2804 0d36 60E0      		ldi r22,lo8(numer_telefonu_ktory_dzwoni)
 2805 0d38 70E0      		ldi r23,hi8(numer_telefonu_ktory_dzwoni)
 2806 0d3a FB01      		movw r30,r22
 2807               		0:
 2808 0d3c 0190      		ld __tmp_reg__,Z+
 2809 0d3e 0020      		tst __tmp_reg__
 2810 0d40 01F4      		brne 0b
 2811 0d42 BF01      		movw r22,r30
 2812 0d44 6150      		subi r22,1
 2813 0d46 7109      		sbc r23,__zero_reg__
 746:main.c        ****                                      &numer_telefonu_ktory_dzwoni[strlen(
 2814               		.loc 1 746 0
 2815 0d48 40E0      		ldi r20,lo8(bufor_eeprom)
 2816 0d4a 50E0      		ldi r21,hi8(bufor_eeprom)
 2817 0d4c 80E0      		ldi r24,lo8(numer_telefonu_ktory_dzwoni)
 2818 0d4e 90E0      		ldi r25,hi8(numer_telefonu_ktory_dzwoni)
 2819 0d50 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 2820               	.LVL249:
 2821 0d54 C8E0      		ldi r28,lo8(8)
 2822 0d56 D0E0      		ldi r29,0
 2823               	.LVL250:
 2824               	.L152:
 2825               	.LBB469:
 754:main.c        ****               &bufor_eeprom[0], (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt))) {
 2826               		.loc 1 754 0
 2827 0d58 BE01      		movw r22,r28
 2828 0d5a 80E0      		ldi r24,lo8(bufor_eeprom)
 2829 0d5c 90E0      		ldi r25,hi8(bufor_eeprom)
 2830 0d5e 0E94 0000 		call porownaj_numer_telefonu_blok
 2831               	.LVL251:
 2832 0d62 8111      		cpse r24,__zero_reg__
 2833 0d64 00C0      		rjmp .L151
 2834 0d66 2596      		adiw r28,5
 752:main.c        ****          ++nr_uzyt) {
 2835               		.loc 1 752 0
 2836 0d68 C83A      		cpi r28,-88
 2837 0d6a FFE0      		ldi r31,15
 2838 0d6c DF07      		cpc r29,r31
 2839 0d6e 01F4      		brne .L152
 2840 0d70 00C0      		rjmp .L147
 2841               	.L148:
 2842               	.LBE469:
 2843               	.LBE468:
 2844               	.LBE467:
 763:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA);
 2845               		.loc 1 763 0
 2846 0d72 8823      		tst r24
 2847 0d74 01F0      		breq .L153
 764:main.c        **** 
 2848               		.loc 1 764 0
 2849 0d76 84E8      		ldi r24,lo8(-124)
 2850 0d78 0E94 0000 		call dodaj_komende
 2851               	.LVL252:
 2852               	.L153:
 767:main.c        ****     return TRUE;
 2853               		.loc 1 767 0
 2854 0d7c 81E0      		ldi r24,lo8(1)
 2855 0d7e 9091 0000 		lds r25,tryb_pracy
 2856 0d82 9130      		cpi r25,lo8(1)
 2857 0d84 01F0      		breq .L154
 2858 0d86 80E0      		ldi r24,0
 2859               	.L154:
 2860 0d88 8195      		neg r24
 2861 0d8a 00C0      		rjmp .L143
 2862               		.cfi_endproc
 2863               	.LFE41:
 2865               	.global	zakonczono_rozmowe_telefoniczna
 2867               	zakonczono_rozmowe_telefoniczna:
 2868               	.LFB42:
 794:main.c        ****   POMOC_DODAJ2('#', 'a');
 2869               		.loc 1 794 0
 2870               		.cfi_startproc
 2871               	.LVL253:
 2872               	/* prologue: function */
 2873               	/* frame size = 0 */
 2874               	/* stack size = 0 */
 2875               	.L__stack_usage = 0
 796:main.c        ****   licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 2876               		.loc 1 796 0
 2877 0d8c 8CE3      		ldi r24,lo8(60)
 2878               	.LVL254:
 2879 0d8e 8093 0000 		sts opoznienie_SIM900_100MS,r24
 797:main.c        ****   ustaw_maksymalny_czas_dzwonienia = 0;
 2880               		.loc 1 797 0
 2881 0d92 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 2882 0d96 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 798:main.c        ****   maksymalny_czas_dzwonienia = 0;
 2883               		.loc 1 798 0
 2884 0d9a 1092 0000 		sts ustaw_maksymalny_czas_dzwonienia,__zero_reg__
 799:main.c        ****   blokada_clip = FALSE;
 2885               		.loc 1 799 0
 2886 0d9e 1092 0000 		sts maksymalny_czas_dzwonienia,__zero_reg__
 800:main.c        **** }
 2887               		.loc 1 800 0
 2888 0da2 1092 0000 		sts blokada_clip,__zero_reg__
 2889               	/* epilogue start */
 801:main.c        **** 
 2890               		.loc 1 801 0
 2891 0da6 0895      		ret
 2892               		.cfi_endproc
 2893               	.LFE42:
 2895               	.global	zakonczono_wysylanie_smsa
 2897               	zakonczono_wysylanie_smsa:
 2898               	.LFB43:
 810:main.c        ****   POMOC_DODAJ2('#', 'A');
 2899               		.loc 1 810 0
 2900               		.cfi_startproc
 2901               	.LVL255:
 2902               	/* prologue: function */
 2903               	/* frame size = 0 */
 2904               	/* stack size = 0 */
 2905               	.L__stack_usage = 0
 812:main.c        **** 
 2906               		.loc 1 812 0
 2907 0da8 8CE3      		ldi r24,lo8(60)
 2908               	.LVL256:
 2909 0daa 8093 0000 		sts opoznienie_SIM900_100MS,r24
 814:main.c        **** }
 2910               		.loc 1 814 0
 2911 0dae 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 2912               	/* epilogue start */
 815:main.c        **** 
 2913               		.loc 1 815 0
 2914 0db2 0895      		ret
 2915               		.cfi_endproc
 2916               	.LFE43:
 2918               	.global	problem_z_wyslaniem_powiadomienia
 2920               	problem_z_wyslaniem_powiadomienia:
 2921               	.LFB44:
 817:main.c        ****   wykonywanie_rozmowy_telefonicznej = FALSE;
 2922               		.loc 1 817 0
 2923               		.cfi_startproc
 2924               	/* prologue: function */
 2925               	/* frame size = 0 */
 2926               	/* stack size = 0 */
 2927               	.L__stack_usage = 0
 818:main.c        ****   licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 2928               		.loc 1 818 0
 2929 0db4 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 819:main.c        ****   wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 2930               		.loc 1 819 0
 2931 0db8 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 2932 0dbc 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 820:main.c        ****   czekanie_na_odebranie_zachety = FALSE;
 2933               		.loc 1 820 0
 2934 0dc0 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 2935 0dc4 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 2936 0dc8 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
 821:main.c        ****   opoznienie_SIM900_100MS = 60;
 2937               		.loc 1 821 0
 2938 0dcc 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
 822:main.c        ****   flaga_wysylanie_smsa = 0;
 2939               		.loc 1 822 0
 2940 0dd0 8CE3      		ldi r24,lo8(60)
 2941 0dd2 8093 0000 		sts opoznienie_SIM900_100MS,r24
 823:main.c        **** }
 2942               		.loc 1 823 0
 2943 0dd6 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
 2944               	/* epilogue start */
 824:main.c        **** 
 2945               		.loc 1 824 0
 2946 0dda 0895      		ret
 2947               		.cfi_endproc
 2948               	.LFE44:
 2950               	.global	wyzerowanie_danych_SIM900
 2952               	wyzerowanie_danych_SIM900:
 2953               	.LFB45:
   6:main_sim900.h ****   POMOC_DODAJ2('*', 't');
 2954               		.loc 2 6 0
 2955               		.cfi_startproc
 2956               	/* prologue: function */
 2957               	/* frame size = 0 */
 2958               	/* stack size = 0 */
 2959               	.L__stack_usage = 0
 2960               	.LVL257:
   8:main_sim900.h ****   licznik_wysylane_polecenie_SIM900 = 0;
 2961               		.loc 2 8 0
 2962 0ddc 0E94 0000 		call problem_z_wyslaniem_powiadomienia
 2963               	.LVL258:
   9:main_sim900.h ****   aktualnie_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 2964               		.loc 2 9 0
 2965 0de0 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 2966 0de4 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
  10:main_sim900.h ****   liczba_komend_w_kolejce_SIM900 = 0;
 2967               		.loc 2 10 0
 2968 0de8 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
  11:main_sim900.h ****   licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow = 0;
 2969               		.loc 2 11 0
 2970 0dec 1092 0000 		sts liczba_komend_w_kolejce_SIM900,__zero_reg__
  12:main_sim900.h ****   czekanie_na_odebranie_zachety = FALSE;
 2971               		.loc 2 12 0
 2972 0df0 1092 0000 		sts licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow,__zero_reg__
  13:main_sim900.h ****   flaga_odebrany_znak_zachety = FALSE;
 2973               		.loc 2 13 0
 2974 0df4 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
  14:main_sim900.h ****   trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 2975               		.loc 2 14 0
 2976 0df8 1092 0000 		sts flaga_odebrany_znak_zachety,__zero_reg__
  15:main_sim900.h ****   wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
 2977               		.loc 2 15 0
 2978 0dfc 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
  16:main_sim900.h ****   flaga_odczytywanie_smsa = FALSE;
 2979               		.loc 2 16 0
 2980 0e00 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
  17:main_sim900.h **** }
 2981               		.loc 2 17 0
 2982 0e04 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 2983               	/* epilogue start */
  18:main_sim900.h **** 
 2984               		.loc 2 18 0
 2985 0e08 0895      		ret
 2986               		.cfi_endproc
 2987               	.LFE45:
 2989               	.global	reset_modulu_SIM900
 2991               	reset_modulu_SIM900:
 2992               	.LFB46:
  20:main_sim900.h ****   wyzerowanie_danych_SIM900();
 2993               		.loc 2 20 0
 2994               		.cfi_startproc
 2995               	/* prologue: function */
 2996               	/* frame size = 0 */
 2997               	/* stack size = 0 */
 2998               	.L__stack_usage = 0
  21:main_sim900.h ****   POMOC_DODAJ2('*', 'm');
 2999               		.loc 2 21 0
 3000 0e0a 0E94 0000 		call wyzerowanie_danych_SIM900
 3001               	.LVL259:
  23:main_sim900.h ****   podlaczony_modul_gsm_SIM900 = FALSE;
 3002               		.loc 2 23 0
 3003 0e0e 86E9      		ldi r24,lo8(-106)
 3004 0e10 8093 0000 		sts licznik_100ms_procedura_inicjalizacyjna_SIM900,r24
  24:main_sim900.h ****   podlaczona_karta_SIM_SIM900 = FALSE;
 3005               		.loc 2 24 0
 3006 0e14 1092 0000 		sts podlaczony_modul_gsm_SIM900,__zero_reg__
  25:main_sim900.h ****   licznik_blad_stanu_karty_SIM = 0;
 3007               		.loc 2 25 0
 3008 0e18 1092 0000 		sts podlaczona_karta_SIM_SIM900,__zero_reg__
  26:main_sim900.h ****   licznik_blad_zalogowania_u_operatora = 0;
 3009               		.loc 2 26 0
 3010 0e1c 1092 0000 		sts licznik_blad_stanu_karty_SIM,__zero_reg__
  27:main_sim900.h ****   nazwa_operatora[0] = '\0';
 3011               		.loc 2 27 0
 3012 0e20 1092 0000 		sts licznik_blad_zalogowania_u_operatora,__zero_reg__
  28:main_sim900.h ****   licznik_ogolny_blad_zalogowania = 0;
 3013               		.loc 2 28 0
 3014 0e24 1092 0000 		sts nazwa_operatora,__zero_reg__
  29:main_sim900.h ****   blokada_clip = FALSE;
 3015               		.loc 2 29 0
 3016 0e28 1092 0000 		sts licznik_ogolny_blad_zalogowania+1,__zero_reg__
 3017 0e2c 1092 0000 		sts licznik_ogolny_blad_zalogowania,__zero_reg__
  30:main_sim900.h ****   nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 3018               		.loc 2 30 0
 3019 0e30 1092 0000 		sts blokada_clip,__zero_reg__
  31:main_sim900.h ****   poziom_sieci_gsm = POZIOM_SIECI_BLAD;
 3020               		.loc 2 31 0
 3021 0e34 1092 0000 		sts nastepne_wysylane_polecenie_SIM900,__zero_reg__
  32:main_sim900.h ****   filtruj_komendy_z_przedzialu(KOMENDA_KOLEJKI_USUN_SMSA_1,
 3022               		.loc 2 32 0
 3023 0e38 83E6      		ldi r24,lo8(99)
 3024 0e3a 8093 0000 		sts poziom_sieci_gsm,r24
  33:main_sim900.h ****                                KOMENDA_KOLEJKI_USUN_SMSA_20);
 3025               		.loc 2 33 0
 3026 0e3e 61ED      		ldi r22,lo8(-47)
 3027 0e40 8EEB      		ldi r24,lo8(-66)
 3028 0e42 0E94 0000 		call filtruj_komendy_z_przedzialu
 3029               	.LVL260:
  35:main_sim900.h ****       KOMENDA_KOLEJKI_KOMENDA_SIM900,
 3030               		.loc 2 35 0
 3031 0e46 6EE9      		ldi r22,lo8(-98)
 3032 0e48 8AE8      		ldi r24,lo8(-118)
 3033 0e4a 0E94 0000 		call filtruj_komendy_z_przedzialu
 3034               	.LVL261:
  38:main_sim900.h ****       KOMENDA_KOLEJKI_SPRAWDZ_PIN,
 3035               		.loc 2 38 0
 3036 0e4e 68EA      		ldi r22,lo8(-88)
 3037 0e50 8FE9      		ldi r24,lo8(-97)
 3038 0e52 0E94 0000 		call filtruj_komendy_z_przedzialu
 3039               	.LVL262:
  41:main_sim900.h ****                                KOMENDA_KOLEJKI_WYSLIJ_PDU);
 3040               		.loc 2 41 0
 3041 0e56 65ED      		ldi r22,lo8(-43)
 3042 0e58 83ED      		ldi r24,lo8(-45)
 3043 0e5a 0E94 0000 		call filtruj_komendy_z_przedzialu
 3044               	.LVL263:
  43:main_sim900.h **** }
 3045               		.loc 2 43 0
 3046 0e5e 1092 0000 		sts modul_zalogowany_w_sieci,__zero_reg__
 3047               	/* epilogue start */
  44:main_sim900.h **** 
 3048               		.loc 2 44 0
 3049 0e62 0895      		ret
 3050               		.cfi_endproc
 3051               	.LFE46:
 3053               	.global	obsluga_wysylania_sms
 3055               	obsluga_wysylania_sms:
 3056               	.LFB49:
  52:main_sim900.h **** }
  53:main_sim900.h **** 
  54:main_sim900.h **** void obsluga_wysylania_sms(void) {
 3057               		.loc 2 54 0
 3058               		.cfi_startproc
 3059               	/* prologue: function */
 3060               	/* frame size = 0 */
 3061               	/* stack size = 0 */
 3062               	.L__stack_usage = 0
 3063               	.LVL264:
  55:main_sim900.h ****   POMOC_DODAJ2('#', 'M');
  56:main_sim900.h ****   if (czy_jest_komenda_wyslano_sms()) {
 3064               		.loc 2 56 0
 3065 0e64 8091 0000 		lds r24,komenda_SIM900
 3066 0e68 8D30      		cpi r24,lo8(13)
 3067 0e6a 01F4      		brne .L180
 3068               	.LVL265:
  57:main_sim900.h ****     POMOC_DODAJ2('#', 'T');
  58:main_sim900.h ****     liczba_prob_wyslania_smsa = 0;
 3069               		.loc 2 58 0
 3070 0e6c 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
 3071               	.LVL266:
 3072               	.LBB490:
 3073               	.LBB491:
 814:main.c        **** }
 3074               		.loc 1 814 0
 3075 0e70 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 3076               	.LBE491:
 3077               	.LBE490:
  59:main_sim900.h ****     zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_ok);
  60:main_sim900.h ****     flaga_wysylanie_smsa = 0;
 3078               		.loc 2 60 0
 3079 0e74 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
  61:main_sim900.h ****     opoznienie_SIM900_100MS = 70;
 3080               		.loc 2 61 0
 3081 0e78 86E4      		ldi r24,lo8(70)
 3082 0e7a 8093 0000 		sts opoznienie_SIM900_100MS,r24
  62:main_sim900.h ****     return;
 3083               		.loc 2 62 0
 3084 0e7e 0895      		ret
 3085               	.LVL267:
 3086               	.L180:
  63:main_sim900.h ****   } else if (
  64:main_sim900.h ****       czy_jest_komenda_blad_CMS()) // spawdzi
 3087               		.loc 2 64 0
 3088 0e80 8091 0000 		lds r24,komenda_SIM900
  63:main_sim900.h ****   } else if (
 3089               		.loc 2 63 0
 3090 0e84 8630      		cpi r24,lo8(6)
 3091 0e86 01F4      		brne .L182
  65:main_sim900.h ****                                    // czy_modul_byl_polaczony_z_internetem
  66:main_sim900.h ****   {
  67:main_sim900.h ****     ++liczba_prob_wyslania_smsa;
 3092               		.loc 2 67 0
 3093 0e88 2091 0000 		lds r18,liczba_prob_wyslania_smsa
 3094 0e8c 2F5F      		subi r18,lo8(-(1))
 3095 0e8e 2093 0000 		sts liczba_prob_wyslania_smsa,r18
  68:main_sim900.h ****     if (numer_bledu_cms == CMS_SM_BL_NOT_READY ||
 3096               		.loc 2 68 0
 3097 0e92 8091 0000 		lds r24,numer_bledu_cms
 3098 0e96 9091 0000 		lds r25,numer_bledu_cms+1
 3099 0e9a 8530      		cpi r24,5
 3100 0e9c 32E0      		ldi r19,2
 3101 0e9e 9307      		cpc r25,r19
 3102 0ea0 01F0      		breq .L183
 3103               		.loc 2 68 0 is_stmt 0 discriminator 1
 3104 0ea2 8A33      		cpi r24,58
 3105 0ea4 31E0      		ldi r19,1
 3106 0ea6 9307      		cpc r25,r19
 3107 0ea8 01F0      		breq .L183
  69:main_sim900.h ****         numer_bledu_cms == CMS_SIM_BUSY ||
 3108               		.loc 2 69 0 is_stmt 1
 3109 0eaa 8330      		cpi r24,3
 3110 0eac 32E0      		ldi r19,2
 3111 0eae 9307      		cpc r25,r19
 3112 0eb0 01F0      		breq .L183
  70:main_sim900.h ****         numer_bledu_cms == CMS_PC_BUSY // powinien by reset
  71:main_sim900.h ****         || numer_bledu_cms == CMS_INVALID_CHARS_IN_PDU ||
 3113               		.loc 2 71 0
 3114 0eb2 8051      		subi r24,16
 3115 0eb4 9240      		sbci r25,2
 3116 0eb6 0297      		sbiw r24,2
 3117 0eb8 00F4      		brsh .L184
 3118               	.L183:
  72:main_sim900.h ****         numer_bledu_cms == CMS_INCORECT_PDU_LENGTH) {
  73:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 3119               		.loc 2 73 0
 3120 0eba 8CE3      		ldi r24,lo8(60)
 3121 0ebc 8093 0000 		sts opoznienie_SIM900_100MS,r24
  74:main_sim900.h ****       if (liczba_prob_wyslania_smsa < max_liczba_prob_wyslania_smsa) {
  75:main_sim900.h ****         POMOC_DODAJ2('#', 'C');
  76:main_sim900.h ****         POMOC_DODAJ_HEX(numer_bledu_cms >> 8);
  77:main_sim900.h ****         POMOC_DODAJ_HEX(numer_bledu_cms & 0xff);
  78:main_sim900.h ****         dodaj_komende(flaga_wysylanie_smsa);
 3122               		.loc 2 78 0
 3123 0ec0 8091 0000 		lds r24,flaga_wysylanie_smsa
  74:main_sim900.h ****       if (liczba_prob_wyslania_smsa < max_liczba_prob_wyslania_smsa) {
 3124               		.loc 2 74 0
 3125 0ec4 2230      		cpi r18,lo8(2)
 3126 0ec6 00F0      		brlo .L208
 3127               	.LVL268:
 3128               	.L209:
  79:main_sim900.h ****       } else {
  80:main_sim900.h ****         POMOC_DODAJ2('#', 'D');
  81:main_sim900.h ****         POMOC_DODAJ_HEX(numer_bledu_cms >> 8);
  82:main_sim900.h ****         POMOC_DODAJ_HEX(numer_bledu_cms & 0xff);
  83:main_sim900.h ****         liczba_prob_wyslania_smsa = 0;
  84:main_sim900.h ****         zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
  85:main_sim900.h ****       }
  86:main_sim900.h ****     } else {
  87:main_sim900.h ****       POMOC_DODAJ2('#', 'F');
  88:main_sim900.h ****       POMOC_DODAJ_HEX(numer_bledu_cms >> 8);
  89:main_sim900.h ****       POMOC_DODAJ_HEX(numer_bledu_cms & 0xff);
  90:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
  91:main_sim900.h ****       liczba_prob_wyslania_smsa = 0;
 3129               		.loc 2 91 0
 3130 0ec8 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
 3131               	.LVL269:
 3132               	.LBB492:
 3133               	.LBB493:
 814:main.c        **** }
 3134               		.loc 1 814 0
 3135 0ecc 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 3136               	.LVL270:
 3137               	.L186:
 3138               	.LBE493:
 3139               	.LBE492:
  92:main_sim900.h ****       zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
  93:main_sim900.h ****     }
  94:main_sim900.h ****     flaga_wysylanie_smsa = 0;
 3140               		.loc 2 94 0
 3141 0ed0 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
 3142 0ed4 0895      		ret
 3143               	.LVL271:
 3144               	.L184:
  90:main_sim900.h ****       liczba_prob_wyslania_smsa = 0;
 3145               		.loc 2 90 0
 3146 0ed6 8CE3      		ldi r24,lo8(60)
 3147 0ed8 8093 0000 		sts opoznienie_SIM900_100MS,r24
 3148 0edc 00C0      		rjmp .L209
 3149               	.LVL272:
 3150               	.L182:
 3151               	.LBB494:
 3152               	.LBB495:
  95:main_sim900.h ****   } else if (czy_jest_komenda_ERROR()) {
 3153               		.loc 2 95 0
 3154 0ede 8091 0000 		lds r24,komenda_SIM900
 3155 0ee2 8430      		cpi r24,lo8(4)
 3156 0ee4 01F4      		brne .L187
 3157               	.LVL273:
  96:main_sim900.h ****     POMOC_DODAJ2('#', 'G');
  97:main_sim900.h ****     opoznienie_SIM900_100MS = 60;
 3158               		.loc 2 97 0
 3159 0ee6 8CE3      		ldi r24,lo8(60)
 3160 0ee8 8093 0000 		sts opoznienie_SIM900_100MS,r24
  98:main_sim900.h ****     czekanie_na_odebranie_zachety = FALSE;
 3161               		.loc 2 98 0
 3162 0eec 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
  99:main_sim900.h ****     if ((odebrany_blok_SIM900[2] == '>' &&
 3163               		.loc 2 99 0
 3164 0ef0 8091 0000 		lds r24,odebrany_blok_SIM900+2
 3165 0ef4 8E33      		cpi r24,lo8(62)
 3166 0ef6 01F4      		brne .L188
 100:main_sim900.h ****          liczba_odebranych_znakow_SIM900 < 10) ||
 3167               		.loc 2 100 0
 3168 0ef8 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 3169 0efc 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
  99:main_sim900.h ****     if ((odebrany_blok_SIM900[2] == '>' &&
 3170               		.loc 2 99 0
 3171 0f00 0A97      		sbiw r24,10
 3172 0f02 00F0      		brlo .L189
 3173               	.L188:
 101:main_sim900.h ****         flaga_wysylanie_smsa == 0) // SIM900 nie odpowiada
 3174               		.loc 2 101 0
 3175 0f04 8091 0000 		lds r24,flaga_wysylanie_smsa
 100:main_sim900.h ****          liczba_odebranych_znakow_SIM900 < 10) ||
 3176               		.loc 2 100 0
 3177 0f08 8111      		cpse r24,__zero_reg__
 3178 0f0a 00C0      		rjmp .L190
 3179               	.L189:
 3180               	.LVL274:
 102:main_sim900.h ****     {
 103:main_sim900.h ****       POMOC_DODAJ2('#', 'H');
 104:main_sim900.h ****       liczba_prob_wyslania_smsa = 0;
 3181               		.loc 2 104 0
 3182 0f0c 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
 3183               	.LVL275:
 3184               	.LBB496:
 3185               	.LBB497:
 814:main.c        **** }
 3186               		.loc 1 814 0
 3187 0f10 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 3188               	.LBE497:
 3189               	.LBE496:
 105:main_sim900.h ****       zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
 106:main_sim900.h ****       reset_modulu_SIM900();
 3190               		.loc 2 106 0
 3191 0f14 0E94 0000 		call reset_modulu_SIM900
 3192               	.LVL276:
 3193 0f18 00C0      		rjmp .L186
 3194               	.LVL277:
 3195               	.L190:
 107:main_sim900.h ****     } else {
 108:main_sim900.h ****       POMOC_DODAJ2('#', 'I');
 109:main_sim900.h ****       if (++liczba_prob_wyslania_smsa <
 3196               		.loc 2 109 0
 3197 0f1a 9091 0000 		lds r25,liczba_prob_wyslania_smsa
 3198 0f1e 9F5F      		subi r25,lo8(-(1))
 3199 0f20 9093 0000 		sts liczba_prob_wyslania_smsa,r25
 3200 0f24 9230      		cpi r25,lo8(2)
 3201 0f26 00F4      		brsh .L209
 3202               	.LVL278:
 3203               	.L208:
 110:main_sim900.h ****           max_liczba_prob_wyslania_smsa) // musi by sta wartoci
 111:main_sim900.h ****         dodaj_komende(flaga_wysylanie_smsa);
 3204               		.loc 2 111 0
 3205 0f28 0E94 0000 		call dodaj_komende
 3206               	.LVL279:
 3207 0f2c 00C0      		rjmp .L186
 3208               	.LVL280:
 3209               	.L187:
 112:main_sim900.h ****       else {
 113:main_sim900.h ****         liczba_prob_wyslania_smsa = 0;
 114:main_sim900.h ****         zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
 115:main_sim900.h ****       }
 116:main_sim900.h ****     }
 117:main_sim900.h ****     flaga_wysylanie_smsa = 0;
 118:main_sim900.h ****   } else if (czy_jest_komenda_blad_CME()) {
 3210               		.loc 2 118 0
 3211 0f2e 8091 0000 		lds r24,komenda_SIM900
 3212 0f32 8530      		cpi r24,lo8(5)
 3213 0f34 01F4      		brne .L191
 3214               	.LVL281:
 119:main_sim900.h ****     POMOC_DODAJ2('#', 'J');
 120:main_sim900.h ****     POMOC_DODAJ_HEX(numer_bledu_cme >> 8);
 3215               		.loc 2 120 0
 3216 0f36 8091 0000 		lds r24,numer_bledu_cme
 3217 0f3a 9091 0000 		lds r25,numer_bledu_cme+1
 3218               	.LVL282:
 121:main_sim900.h ****     POMOC_DODAJ_HEX(numer_bledu_cme & 0xff);
 122:main_sim900.h ****     if (numer_bledu_cme == CME_SIM_NOT_INSERTED ||
 3219               		.loc 2 122 0
 3220 0f3e 8A30      		cpi r24,10
 3221 0f40 9105      		cpc r25,__zero_reg__
 3222 0f42 01F0      		breq .L192
 3223 0f44 9C01      		movw r18,r24
 3224 0f46 2D7F      		andi r18,253
 3225 0f48 2D30      		cpi r18,13
 3226 0f4a 3105      		cpc r19,__zero_reg__
 3227 0f4c 01F0      		breq .L192
 123:main_sim900.h ****         numer_bledu_cme == CME_SIM_FAILURE ||
 124:main_sim900.h ****         numer_bledu_cme == CME_SIM_WRONG ||
 3228               		.loc 2 124 0
 3229 0f4e 4E97      		sbiw r24,30
 3230 0f50 01F4      		brne .L179
 3231               	.L192:
 3232               	.LVL283:
 125:main_sim900.h ****         numer_bledu_cme == CME_NO_NETWORK_SERVICE) {
 126:main_sim900.h ****       POMOC_DODAJ2('#', 'K');
 127:main_sim900.h ****       liczba_prob_wyslania_smsa = 0;
 3233               		.loc 2 127 0
 3234 0f52 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
 3235               	.LVL284:
 3236               	.LBB498:
 3237               	.LBB499:
 812:main.c        **** 
 3238               		.loc 1 812 0
 3239 0f56 8CE3      		ldi r24,lo8(60)
 3240               	.LVL285:
 3241 0f58 8093 0000 		sts opoznienie_SIM900_100MS,r24
 814:main.c        **** }
 3242               		.loc 1 814 0
 3243 0f5c 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 3244               	.LBE499:
 3245               	.LBE498:
 128:main_sim900.h ****       zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
 129:main_sim900.h ****       reset_modulu_SIM900();
 3246               		.loc 2 129 0
 3247 0f60 0C94 0000 		jmp reset_modulu_SIM900
 3248               	.LVL286:
 3249               	.L191:
 130:main_sim900.h ****     }
 131:main_sim900.h ****   } else {
 132:main_sim900.h ****     POMOC_DODAJ2('#', 'L');
 133:main_sim900.h ****     POMOC_DODAJ_HEX(komenda_SIM900 >> 8);
 3250               		.loc 2 133 0
 3251 0f64 8091 0000 		lds r24,komenda_SIM900
 3252               	.LVL287:
 134:main_sim900.h ****     POMOC_DODAJ_HEX(komenda_SIM900 & 0xff);
 3253               		.loc 2 134 0
 3254 0f68 8091 0000 		lds r24,komenda_SIM900
 3255               	.LVL288:
 3256               	.L179:
 3257               	/* epilogue start */
 3258               	.LBE495:
 3259               	.LBE494:
 135:main_sim900.h ****   }
 136:main_sim900.h **** }
 3260               		.loc 2 136 0
 3261 0f6c 0895      		ret
 3262               		.cfi_endproc
 3263               	.LFE49:
 3265               	.global	odpowiedz_na_polecenie
 3267               	odpowiedz_na_polecenie:
 3268               	.LFB50:
 137:main_sim900.h **** 
 138:main_sim900.h **** void odpowiedz_na_polecenie(void) {
 3269               		.loc 2 138 0
 3270               		.cfi_startproc
 3271 0f6e 0F93      		push r16
 3272               	.LCFI60:
 3273               		.cfi_def_cfa_offset 3
 3274               		.cfi_offset 16, -2
 3275 0f70 1F93      		push r17
 3276               	.LCFI61:
 3277               		.cfi_def_cfa_offset 4
 3278               		.cfi_offset 17, -3
 3279 0f72 CF93      		push r28
 3280               	.LCFI62:
 3281               		.cfi_def_cfa_offset 5
 3282               		.cfi_offset 28, -4
 3283 0f74 DF93      		push r29
 3284               	.LCFI63:
 3285               		.cfi_def_cfa_offset 6
 3286               		.cfi_offset 29, -5
 3287               	/* prologue: function */
 3288               	/* frame size = 0 */
 3289               	/* stack size = 4 */
 3290               	.L__stack_usage = 4
 139:main_sim900.h **** #define czy_polecenie_sim(POL) czy_polecenie_SIM900(POL, sizeof POL - 1)
 140:main_sim900.h ****   const uchar kom = komenda_SIM900;
 3291               		.loc 2 140 0
 3292 0f76 D091 0000 		lds r29,komenda_SIM900
 3293               	.LVL289:
 141:main_sim900.h **** 
 142:main_sim900.h ****   switch (aktualnie_wysylane_polecenie_SIM900) {
 3294               		.loc 2 142 0
 3295 0f7a C091 0000 		lds r28,aktualnie_wysylane_polecenie_SIM900
 3296 0f7e CE39      		cpi r28,lo8(-98)
 3297 0f80 01F4      		brne .+2
 3298 0f82 00C0      		rjmp .L212
 3299 0f84 00F0      		brlo .+2
 3300 0f86 00C0      		rjmp .L213
 3301 0f88 C539      		cpi r28,lo8(-107)
 3302 0f8a 01F4      		brne .+2
 3303 0f8c 00C0      		rjmp .L214
 3304 0f8e 00F4      		brsh .L215
 3305 0f90 CF38      		cpi r28,lo8(-113)
 3306 0f92 01F4      		brne .+2
 3307 0f94 00C0      		rjmp .L216
 3308 0f96 00F4      		brsh .L217
 3309 0f98 CC38      		cpi r28,lo8(-116)
 3310 0f9a 01F4      		brne .+2
 3311 0f9c 00C0      		rjmp .L218
 3312 0f9e CE38      		cpi r28,lo8(-114)
 3313 0fa0 01F4      		brne .+2
 3314 0fa2 00C0      		rjmp .L219
 3315               	.L211:
 143:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 144:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_ODEBRANO_POLECENIE_ROZPOCZYNAJACE);
 145:main_sim900.h ****     max_oczekiwanie_na_odpowiedz_at = 0;
 146:main_sim900.h ****     break;
 147:main_sim900.h ****   }
 148:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE: {
 149:main_sim900.h ****     static const char polecenie_zegar[] PROGMEM = "+CCLK:";
 150:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 &&
 151:main_sim900.h ****         polozenie_polecenia_SIM900(polecenie_zegar) != NULL) {
 152:main_sim900.h ****       const uchar *p1 =
 153:main_sim900.h ****           strchr(polozenie_polecenia_SIM900(polecenie_zegar), '\"');
 154:main_sim900.h ****       if (p1++ != NULL) {
 155:main_sim900.h ****         const uchar *p2 = strchr(p1, '\"');
 156:main_sim900.h ****         const uchar *p3 = strchr(p1, ',');
 157:main_sim900.h ****         if (p2 != NULL && p3++ != NULL && p2 > p3) {
 158:main_sim900.h ****           // const uchar g = atoi(p3);
 159:main_sim900.h ****           if ((p3 = strchr(p3, ':')) != NULL && p2 > p3++) {
 160:main_sim900.h ****             // Pobierz czas z odpowiedzi +CCLK: "yy/MM/dd,hh:mm:ss+zz"
 161:main_sim900.h ****             // p3 wskazuje na minuty po pierwszym ':'
 162:main_sim900.h ****             // cofnijmy si do pocztku godziny (p3 wskazuje na mm, wic -3 to hh)
 163:main_sim900.h ****             // ale w kodzie powyej p3 byo przesuwane.
 164:main_sim900.h **** 
 165:main_sim900.h ****             // Restart parsowania dla pewnoci:
 166:main_sim900.h ****             // "24/01/01,12:34:56+00"
 167:main_sim900.h ****             const char *ptr_time = strchr(p1, ',');
 168:main_sim900.h ****             if (ptr_time) {
 169:main_sim900.h ****               ptr_time++; // skip comma
 170:main_sim900.h ****               if (strlen(ptr_time) >= 8) {
 171:main_sim900.h ****                 memcpy(rtc_czas, ptr_time, 8);
 172:main_sim900.h ****                 rtc_czas[8] = '\0';
 173:main_sim900.h **** 
 174:main_sim900.h ****                 // Aktualizacja blokady czasowej
 175:main_sim900.h ****                 if (czas_start_h == 0xFF) {
 176:main_sim900.h ****                   blokada_sterowania_czasowa = FALSE;
 177:main_sim900.h ****                 } else {
 178:main_sim900.h ****                   // Parsowanie aktualnego czasu
 179:main_sim900.h ****                   int curr_h = (rtc_czas[0] - '0') * 10 + (rtc_czas[1] - '0');
 180:main_sim900.h ****                   int curr_m = (rtc_czas[3] - '0') * 10 + (rtc_czas[4] - '0');
 181:main_sim900.h ****                   int curr_time = curr_h * 60 + curr_m;
 182:main_sim900.h **** 
 183:main_sim900.h ****                   int start_time = czas_start_h * 60 + czas_start_m;
 184:main_sim900.h ****                   int stop_time = czas_stop_h * 60 + czas_stop_m;
 185:main_sim900.h **** 
 186:main_sim900.h ****                   if (start_time <= stop_time) {
 187:main_sim900.h ****                     // Normalny przedzial (np. 08:00 - 16:00)
 188:main_sim900.h ****                     if (curr_time >= start_time && curr_time <= stop_time)
 189:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 190:main_sim900.h ****                     else
 191:main_sim900.h ****                       blokada_sterowania_czasowa = TRUE;
 192:main_sim900.h ****                   } else {
 193:main_sim900.h ****                     // Przejscie przez polnoc (np. 22:00 - 06:00)
 194:main_sim900.h ****                     if (curr_time >= start_time || curr_time <= stop_time)
 195:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 196:main_sim900.h ****                     else
 197:main_sim900.h ****                       blokada_sterowania_czasowa = TRUE;
 198:main_sim900.h ****                   }
 199:main_sim900.h ****                 }
 200:main_sim900.h ****               }
 201:main_sim900.h ****             }
 202:main_sim900.h ****           }
 203:main_sim900.h ****         }
 204:main_sim900.h ****       }
 205:main_sim900.h ****     }
 206:main_sim900.h ****     break;
 207:main_sim900.h ****   }
 208:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_PIN: {
 209:main_sim900.h ****     static const char polecenie_pin_ready[] PROGMEM = "+CPIN: READY";
 210:main_sim900.h ****     static uchar nr_zapytania_o_pin;
 211:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 212:main_sim900.h ****       if (polozenie_polecenia_SIM900(polecenie_pin_ready) != NULL) {
 213:main_sim900.h ****         podlaczona_karta_SIM_SIM900 = TRUE;
 214:main_sim900.h ****         bledny_PIN = FALSE;
 215:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 216:main_sim900.h ****       } else
 217:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_PODAJ_PIN);
 218:main_sim900.h ****       nr_zapytania_o_pin = 0;
 219:main_sim900.h ****     } else if (kom == CME_ERROR_KOMENDA_SIM900 &&
 220:main_sim900.h ****                numer_bledu_cme == CME_SIM_BUSY)
 221:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 222:main_sim900.h ****     else if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900()) {
 223:main_sim900.h ****       if (++nr_zapytania_o_pin >= 20) {
 224:main_sim900.h ****         reset_modulu_SIM900();
 225:main_sim900.h ****         nr_zapytania_o_pin = 0;
 226:main_sim900.h ****       } else {
 227:main_sim900.h ****         opoznienie_SIM900_100MS = 20;
 228:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 229:main_sim900.h ****       }
 230:main_sim900.h ****     } else
 231:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 232:main_sim900.h ****     break;
 233:main_sim900.h ****   }
 234:main_sim900.h ****   case KOMENDA_KOLEJKI_PODAJ_PIN: {
 235:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 236:main_sim900.h ****       podlaczona_karta_SIM_SIM900 = TRUE;
 237:main_sim900.h ****       bledny_PIN = FALSE;
 238:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 239:main_sim900.h ****       opoznienie_SIM900_100MS = 50;
 240:main_sim900.h ****     } else if (kom == CME_ERROR_KOMENDA_SIM900 &&
 241:main_sim900.h ****                numer_bledu_cme == CME_SIM_INCORECT_PASWORD)
 242:main_sim900.h ****       bledny_PIN = TRUE;
 243:main_sim900.h ****     else if (kom == CME_ERROR_KOMENDA_SIM900 && numer_bledu_cme == CME_SIM_BUSY)
 244:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 245:main_sim900.h ****     else if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900())
 246:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 247:main_sim900.h ****     else
 248:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 249:main_sim900.h ****     break;
 250:main_sim900.h ****   }
 251:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY: {
 252:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900)
 253:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW);
 254:main_sim900.h ****     else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 255:main_sim900.h ****       if (numer_bledu_cms == CMS_SIM_BUSY ||
 256:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 257:main_sim900.h ****         opoznienie_SIM900_100MS = 60;
 258:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 259:main_sim900.h ****       }
 260:main_sim900.h ****     } else if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900())
 261:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 262:main_sim900.h ****     break;
 263:main_sim900.h ****   }
 264:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW: {
 265:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900)
 266:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW);
 267:main_sim900.h ****     else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 268:main_sim900.h ****       if (numer_bledu_cms == CMS_SIM_BUSY ||
 269:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 270:main_sim900.h ****         opoznienie_SIM900_100MS = 20;
 271:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 272:main_sim900.h ****       }
 273:main_sim900.h ****     } else {
 274:main_sim900.h ****       opoznienie_SIM900_100MS = 10;
 275:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 276:main_sim900.h ****     }
 277:main_sim900.h ****     break;
 278:main_sim900.h ****   }
 279:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_WYSYLANIE_INFO_O_DZWONIACYM: {
 280:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 ||
 281:main_sim900.h ****         (kom == CME_ERROR_KOMENDA_SIM900 &&
 282:main_sim900.h ****          (numer_bledu_cme == CME_OPERATION_NOT_ALLOWED ||
 283:main_sim900.h ****           numer_bledu_cme == CME_OPERATION_NOT_SUPPORTED))) {
 284:main_sim900.h ****       dodaj_komende(nastepne_wysylane_polecenie_SIM900);
 285:main_sim900.h ****       nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 286:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 287:main_sim900.h ****     } else if (kom != OK_KOMENDA_SIM900 &&
 288:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 289:main_sim900.h ****                    MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 290:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 291:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 292:main_sim900.h ****     break;
 293:main_sim900.h ****   }
 294:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_POZIOM_SIECI: {
 295:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 296:main_sim900.h ****       static const uchar urc[] PROGMEM = "+CSQ:";
 297:main_sim900.h ****       const uchar *p1 = polozenie_polecenia_SIM900(urc);
 298:main_sim900.h ****       if (p1 != NULL) {
 299:main_sim900.h ****         p1 += strlen_R(urc) + 1;
 300:main_sim900.h ****         poziom_sieci_gsm = strtol(p1, NULL, 10);
 301:main_sim900.h ****         // if ( poziom_sieci_gsm != POZIOM_SIECI_BLAD )
 302:main_sim900.h ****         //	POMOC_DODAJ2('*', '0' + poziom_sieci_gsm / 4);
 303:main_sim900.h ****         // else
 304:main_sim900.h ****         //{
 305:main_sim900.h ****         //	POMOC_DODAJ2('*', 'c');
 306:main_sim900.h ****         // }
 307:main_sim900.h ****       }
 308:main_sim900.h ****     } else
 309:main_sim900.h ****       poziom_sieci_gsm = POZIOM_SIECI_BLAD;
 310:main_sim900.h ****     break;
 311:main_sim900.h ****   }
 312:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_ZAREJESTROWANIE: {
 313:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 314:main_sim900.h ****       static const uchar urc[] PROGMEM = "+CREG:";
 315:main_sim900.h ****       const uchar *p1 = polozenie_polecenia_SIM900(urc);
 316:main_sim900.h ****       if (p1 != NULL) {
 317:main_sim900.h ****         p1 += strlen_R(urc) + 1;
 318:main_sim900.h ****         if (*p1 != ',')
 319:main_sim900.h ****           ++p1;
 320:main_sim900.h ****         if (*p1 != ',')
 321:main_sim900.h ****           ++p1;
 322:main_sim900.h ****         if (*p1 != ',')
 323:main_sim900.h ****           ++p1;
 324:main_sim900.h ****         ++p1;
 325:main_sim900.h ****         uchar stan_zarejestrowania = (uchar)strtol(p1, NULL, 10);
 326:main_sim900.h ****         if (stan_zarejestrowania == 0 || stan_zarejestrowania == 3 ||
 327:main_sim900.h ****             stan_zarejestrowania == 4) {
 328:main_sim900.h ****           reset_modulu_SIM900();
 329:main_sim900.h ****         } else if (stan_zarejestrowania == 1 || stan_zarejestrowania == 5) {
 330:main_sim900.h ****           modul_zalogowany_w_sieci = TRUE;
 331:main_sim900.h ****         }
 332:main_sim900.h ****       }
 333:main_sim900.h ****     }
 334:main_sim900.h ****     break;
 335:main_sim900.h ****   }
 336:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_STAN_KARTY_SIM: {
 337:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 || (kom == CME_ERROR_KOMENDA_SIM900 &&
 338:main_sim900.h ****                                      (numer_bledu_cme == CME_INVALID_INDEX ||
 339:main_sim900.h ****                                       numer_bledu_cme == CME_NOT_FOUND))) {
 340:main_sim900.h ****       licznik_blad_stanu_karty_SIM = 0;
 341:main_sim900.h ****     } else {
 342:main_sim900.h ****       ++licznik_blad_stanu_karty_SIM;
 343:main_sim900.h ****     }
 344:main_sim900.h ****     break;
 345:main_sim900.h ****   }
 346:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_ZALOGOWANIE_U_OPERATORA: {
 347:main_sim900.h ****     static const char polecenie_operator[] PROGMEM = "+COPS:";
 348:main_sim900.h ****     uchar w = FALSE;
 349:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 && czy_polecenie_sim(polecenie_operator)) {
 350:main_sim900.h ****       const uchar *p1 =
 351:main_sim900.h ****           strchr(polozenie_polecenia_SIM900(polecenie_operator), ',');
 352:main_sim900.h ****       if (p1 != NULL) {
 353:main_sim900.h ****         p1 = strchr(p1, ',');
 354:main_sim900.h ****         if (p1 != NULL) {
 355:main_sim900.h ****           p1 = strchr(p1, '\"');
 356:main_sim900.h ****           if (p1++ != NULL) {
 357:main_sim900.h ****             const uchar *p2 = strchr(p1, '\"');
 358:main_sim900.h ****             if (p2 != NULL && p1 != p2) {
 359:main_sim900.h ****               const uchar m = min(p2 - p1, ROZMIAR_NAZWA_OPERATORA);
 360:main_sim900.h ****               memcpy(nazwa_operatora, p1, m);
 361:main_sim900.h ****               nazwa_operatora[m] = '\0';
 362:main_sim900.h ****               w = TRUE;
 363:main_sim900.h ****             }
 364:main_sim900.h ****           }
 365:main_sim900.h ****         }
 366:main_sim900.h ****       }
 367:main_sim900.h ****     }
 368:main_sim900.h ****     if (w)
 369:main_sim900.h ****       licznik_blad_zalogowania_u_operatora = 0;
 370:main_sim900.h ****     else {
 371:main_sim900.h ****       ++licznik_blad_zalogowania_u_operatora;
 372:main_sim900.h ****     }
 373:main_sim900.h ****     // POMOC_DODAJ2('*', w ? '+' : '-');
 374:main_sim900.h ****     break;
 375:main_sim900.h ****   }
 376:main_sim900.h ****   case KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS: {
 377:main_sim900.h ****     if (kom ==
 378:main_sim900.h ****         CMS_ERROR_KOMENDA_SIM900 /*&& numer_bledu_cms == CMS_SMS_ME_RESERVED*/) // co le interpretu
 379:main_sim900.h ****       ; // nic nie robi
 380:main_sim900.h ****     else if (kom != OK_KOMENDA_SIM900)
 381:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 382:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 383:main_sim900.h ****     break;
 384:main_sim900.h ****   }
 385:main_sim900.h ****   case KOMENDA_KOLEJKI_ODBIERZ_ROZMOWE: {
 386:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 ||
 387:main_sim900.h ****         czy_jest_komenda_uzytkownik_odebral_rozmowe()) {
 388:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = TRUE;
 389:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 390:main_sim900.h **** 
 391:main_sim900.h ****       // DTMF START
 392:main_sim900.h ****       if (!tryb_clip) {
 393:main_sim900.h ****         licznik_timeout_rozmowy_100ms = MAX_LICZNIK_TIMEOUT_ROZMOWY_100MS;
 394:main_sim900.h ****         opoznienie_SIM900_100MS =
 395:main_sim900.h ****             20; // 2 sekundy opoznienia przed wyslaniem tonu
 396:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_TON_DTMF); // Beep potwierdzenia
 397:main_sim900.h ****       }
 398:main_sim900.h ****     } else if ((kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900()) &&
 399:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 400:main_sim900.h ****                    MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 401:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 402:main_sim900.h ****     else if (kom == NO_CARRIER_KOMENDA_SIM900) {
 403:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 404:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 405:main_sim900.h ****     } else
 406:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 407:main_sim900.h ****     break;
 408:main_sim900.h ****   }
 409:main_sim900.h ****   case KOMENDA_KOLEJKI_ODRZUC_ROZMOWE: {
 410:main_sim900.h ****     if (kom != OK_KOMENDA_SIM900)
 411:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 412:main_sim900.h ****     else {
 413:main_sim900.h ****       zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_zakonczenie);
 414:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 415:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 416:main_sim900.h ****     }
 417:main_sim900.h ****     break;
 418:main_sim900.h ****   }
 419:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1:
 420:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_2:
 421:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_3:
 422:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_4:
 423:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_5:
 424:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_6:
 425:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_7:
 426:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_8:
 427:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_9:
 428:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_10:
 429:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_11:
 430:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_12:
 431:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_13:
 432:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_14:
 433:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_15:
 434:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_16:
 435:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_17:
 436:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_18:
 437:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_19:
 438:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20: {
 439:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 440:main_sim900.h ****       // odczytany sms
 441:main_sim900.h ****       const uchar *ptr = polozenie_polecenia_SIM900(PSTR("+CMGR:")); // (1)
 442:main_sim900.h ****       ptr = strchr(ptr, ZNAK_KONCA_ODBIERANIA_ZNAKOW_LF);            // (1)
 443:main_sim900.h ****       // const uchar* ptr = strchr(&odebrany_blok_SIM900[7],
 444:main_sim900.h ****       // ZNAK_KONCA_ODBIERANIA_ZNAKOW_LF);
 445:main_sim900.h ****       if (ptr != NULL) {
 446:main_sim900.h ****         ++ptr;
 447:main_sim900.h ****         const uchar *ptr2 = strchr(ptr, ZNAK_KONCA_WYSYLANIA_ZNAKOW_CR);
 448:main_sim900.h ****         if (ptr2 != NULL) {
 449:main_sim900.h ****           dlugosc_pdu = (ptr2 - ptr) / 2;
 450:main_sim900.h ****           if (dlugosc_pdu > MAX_DLUGOSC_PDU)
 451:main_sim900.h ****             dlugosc_pdu = MAX_DLUGOSC_PDU;
 452:main_sim900.h ****           konwertuj_blok_dwa_znaki_na_znak_pdu(ptr, dlugosc_pdu, bufor_pdu);
 453:main_sim900.h ****           dodaj_komende(KOMENDA_KOLEJKI_INTERPRETUJ_PDU);
 454:main_sim900.h ****           const uchar nr_smsa = aktualnie_wysylane_polecenie_SIM900 -
 455:main_sim900.h ****                                 KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1;
 456:main_sim900.h ****           dodaj_komende(KOMENDA_KOLEJKI_USUN_SMSA_1 + nr_smsa);
 457:main_sim900.h ****           flaga_odczytywanie_smsa = TRUE;
 458:main_sim900.h ****           POMOC_DODAJ2('#', 'O');
 459:main_sim900.h ****         } else
 460:main_sim900.h ****           flaga_odczytywanie_smsa = FALSE;
 461:main_sim900.h ****       } else
 462:main_sim900.h ****         flaga_odczytywanie_smsa = FALSE;
 463:main_sim900.h ****     } else if (kom == CME_ERROR_KOMENDA_SIM900) {
 464:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 465:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 466:main_sim900.h ****     } else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 467:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 468:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 469:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 470:main_sim900.h ****       POMOC_DODAJ2('#', 'P');
 471:main_sim900.h ****       POMOC_DODAJ_HEX(numer_bledu_cms >> 8);
 472:main_sim900.h ****       POMOC_DODAJ_HEX(numer_bledu_cms & 0xff);
 473:main_sim900.h ****     } else {
 474:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 475:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 476:main_sim900.h ****     }
 477:main_sim900.h ****     break;
 478:main_sim900.h ****   }
 479:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_1:
 480:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_2:
 481:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_3:
 482:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_4:
 483:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_5:
 484:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_6:
 485:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_7:
 486:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_8:
 487:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_9:
 488:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_10:
 489:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_11:
 490:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_12:
 491:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_13:
 492:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_14:
 493:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_15:
 494:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_16:
 495:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_17:
 496:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_18:
 497:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_19:
 498:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_20: {
 499:main_sim900.h ****     if (kom == CMS_ERROR_KOMENDA_SIM900 &&
 500:main_sim900.h ****         numer_bledu_cms != CMS_INVALID_MEMORY_INDEX) {
 501:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 502:main_sim900.h ****     } else if (kom == ERROR_KOMENDA_SIM900)
 503:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 504:main_sim900.h ****     else if (czy_jest_blad_SIM900())
 505:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 506:main_sim900.h ****     POMOC_DODAJ2('#', 'Q');
 507:main_sim900.h ****     opoznienie_SIM900_100MS = 25;
 508:main_sim900.h ****     break;
 509:main_sim900.h ****   }
 510:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT: {
 511:main_sim900.h ****     // czekanie_na_odebranie_zachety = FALSE; byo
 512:main_sim900.h ****     break;
 513:main_sim900.h ****   }
 514:main_sim900.h ****   case KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE: {
 515:main_sim900.h ****     if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900()) {
 516:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 517:main_sim900.h ****       if (++liczba_wykonanych_komend_identycznego_polecenia <
 518:main_sim900.h ****           MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 519:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 520:main_sim900.h ****       else {
 521:main_sim900.h ****         liczba_wykonanych_komend_identycznego_polecenia = 0;
 522:main_sim900.h ****         zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 523:main_sim900.h ****         trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 524:main_sim900.h ****         wykonywanie_rozmowy_telefonicznej = FALSE;
 525:main_sim900.h ****         licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 526:main_sim900.h ****       }
 527:main_sim900.h ****     } else
 528:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 529:main_sim900.h ****     break;
 530:main_sim900.h ****   }
 531:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW:
 532:main_sim900.h ****     if (kom != OK_KOMENDA_SIM900) {
 533:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 534:main_sim900.h ****       opoznienie_SIM900_100MS = 20;
 535:main_sim900.h ****       break;
 536:main_sim900.h ****     } // bez break
 537:main_sim900.h ****     goto obsluga_standardowej_instrukcji_at;
 538:main_sim900.h ****   case KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1: {
 539:main_sim900.h ****     if (polozenie_polecenia_SIM900(PSTR(">")) != 0) {
 540:main_sim900.h ****       reset_modulu_SIM900();
 541:main_sim900.h ****       break;
 542:main_sim900.h ****     }
 543:main_sim900.h ****   }
 544:main_sim900.h ****   case KOMENDA_KOLEJKI_WSTAWIENIE_MORING_GDY_DZWONI:
 545:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_WZMOCNIENIE_MIKROFONU:
 546:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_CICHY_TRYB:
 547:main_sim900.h ****   case KOMENDA_KOLEJKI_WYCISZ_DZWONKI:
 548:main_sim900.h ****   case KOMENDA_KOLEJKI_ODBIERAJ_SMS_FLASH:
 549:main_sim900.h ****   case KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ:
 550:main_sim900.h ****   case KOMENDA_KOLEJKI_WLACZ_CZAS_Z_SIECI: {
 551:main_sim900.h ****   obsluga_standardowej_instrukcji_at:
 552:main_sim900.h ****     if (kom != OK_KOMENDA_SIM900 &&
 553:main_sim900.h ****         ++liczba_wykonanych_komend_identycznego_polecenia <
 554:main_sim900.h ****             MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 555:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 556:main_sim900.h ****     else {
 557:main_sim900.h ****       dodaj_komende(nastepne_wysylane_polecenie_SIM900);
 558:main_sim900.h ****       if (nastepne_wysylane_polecenie_SIM900 >=
 559:main_sim900.h ****               KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 560:main_sim900.h ****           nastepne_wysylane_polecenie_SIM900 <=
 561:main_sim900.h ****               KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 562:main_sim900.h ****         flaga_odczytywanie_smsa = FALSE;
 563:main_sim900.h ****       }
 564:main_sim900.h ****       nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 565:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 566:main_sim900.h ****     }
 567:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 568:main_sim900.h ****     break;
 569:main_sim900.h ****   }
 570:main_sim900.h ****   }
 571:main_sim900.h **** #undef czy_polecenie_sim
 572:main_sim900.h ****   wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 3316               		.loc 2 572 0
 3317 0fa4 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 3318 0fa8 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 3319 0fac 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
 3320               	/* epilogue start */
 573:main_sim900.h **** }
 3321               		.loc 2 573 0
 3322 0fb0 DF91      		pop r29
 3323               	.LVL290:
 3324 0fb2 CF91      		pop r28
 3325 0fb4 1F91      		pop r17
 3326 0fb6 0F91      		pop r16
 3327 0fb8 0895      		ret
 3328               	.LVL291:
 3329               	.L217:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3330               		.loc 2 142 0
 3331 0fba C239      		cpi r28,lo8(-110)
 3332 0fbc 01F4      		brne .+2
 3333 0fbe 00C0      		rjmp .L220
 3334 0fc0 C439      		cpi r28,lo8(-108)
 3335 0fc2 01F4      		brne .L211
 3336               	.L221:
 552:main_sim900.h ****         ++liczba_wykonanych_komend_identycznego_polecenia <
 3337               		.loc 2 552 0
 3338 0fc4 D130      		cpi r29,lo8(1)
 3339 0fc6 01F4      		brne .+2
 3340 0fc8 00C0      		rjmp .L298
 553:main_sim900.h ****             MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 3341               		.loc 2 553 0 discriminator 1
 3342 0fca 8091 0000 		lds r24,liczba_wykonanych_komend_identycznego_polecenia
 3343 0fce 8F5F      		subi r24,lo8(-(1))
 552:main_sim900.h ****         ++liczba_wykonanych_komend_identycznego_polecenia <
 3344               		.loc 2 552 0 discriminator 1
 3345 0fd0 8093 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,r24
 3346 0fd4 8330      		cpi r24,lo8(3)
 3347 0fd6 00F0      		brlo .+2
 3348 0fd8 00C0      		rjmp .L298
 555:main_sim900.h ****     else {
 3349               		.loc 2 555 0
 3350 0fda 8C2F      		mov r24,r28
 3351 0fdc 00C0      		rjmp .L405
 3352               	.L215:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3353               		.loc 2 142 0
 3354 0fde C939      		cpi r28,lo8(-103)
 3355 0fe0 01F4      		brne .+2
 3356 0fe2 00C0      		rjmp .L222
 3357 0fe4 00F4      		brsh .L223
 3358 0fe6 C639      		cpi r28,lo8(-106)
 3359 0fe8 01F4      		brne .+2
 3360 0fea 00C0      		rjmp .L224
 3361 0fec C739      		cpi r28,lo8(-105)
 3362 0fee 01F4      		brne .L211
 411:main_sim900.h ****     else {
 3363               		.loc 2 411 0
 3364 0ff0 87E9      		ldi r24,lo8(-105)
 410:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3365               		.loc 2 410 0
 3366 0ff2 D130      		cpi r29,lo8(1)
 3367 0ff4 01F0      		breq .+2
 3368 0ff6 00C0      		rjmp .L410
 413:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 3369               		.loc 2 413 0
 3370 0ff8 81E0      		ldi r24,lo8(1)
 3371 0ffa 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 3372               	.LVL292:
 414:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 3373               		.loc 2 414 0
 3374 0ffe 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 415:main_sim900.h ****     }
 3375               		.loc 2 415 0
 3376 1002 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 3377 1006 00C0      		rjmp .L211
 3378               	.L223:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3379               		.loc 2 142 0
 3380 1008 CB39      		cpi r28,lo8(-101)
 3381 100a 01F4      		brne .+2
 3382 100c 00C0      		rjmp .L226
 3383 100e 00F4      		brsh .+2
 3384 1010 00C0      		rjmp .L227
 3385 1012 CD39      		cpi r28,lo8(-99)
 3386 1014 01F4      		brne .L211
 313:main_sim900.h ****       static const uchar urc[] PROGMEM = "+CREG:";
 3387               		.loc 2 313 0
 3388 1016 D130      		cpi r29,lo8(1)
 3389 1018 01F4      		brne .L211
 3390               	.LBB520:
 315:main_sim900.h ****       if (p1 != NULL) {
 3391               		.loc 2 315 0
 3392 101a 80E0      		ldi r24,lo8(urc.3248)
 3393 101c 90E0      		ldi r25,hi8(urc.3248)
 3394 101e 0E94 0000 		call polozenie_polecenia_SIM900
 3395               	.LVL293:
 3396 1022 FC01      		movw r30,r24
 3397               	.LVL294:
 316:main_sim900.h ****         p1 += strlen_R(urc) + 1;
 3398               		.loc 2 316 0
 3399 1024 892B      		or r24,r25
 3400 1026 01F4      		brne .+2
 3401 1028 00C0      		rjmp .L211
 3402               	.LVL295:
 3403               	.LBB521:
 318:main_sim900.h ****           ++p1;
 3404               		.loc 2 318 0
 3405 102a 2781      		ldd r18,Z+7
 3406 102c 2C32      		cpi r18,lo8(44)
 3407 102e 01F0      		breq .+2
 3408 1030 00C0      		rjmp .L270
 317:main_sim900.h ****         if (*p1 != ',')
 3409               		.loc 2 317 0
 3410 1032 3796      		adiw r30,7
 3411               	.LVL296:
 3412               	.L271:
 320:main_sim900.h ****           ++p1;
 3413               		.loc 2 320 0
 3414 1034 8081      		ld r24,Z
 3415 1036 8C32      		cpi r24,lo8(44)
 3416 1038 01F0      		breq .L272
 3417 103a 3196      		adiw r30,1
 3418               	.LVL297:
 3419               	.L272:
 322:main_sim900.h ****           ++p1;
 3420               		.loc 2 322 0
 3421 103c 8081      		ld r24,Z
 3422 103e 8C32      		cpi r24,lo8(44)
 3423 1040 01F0      		breq .L273
 3424 1042 3196      		adiw r30,1
 3425               	.LVL298:
 3426               	.L273:
 325:main_sim900.h ****         if (stan_zarejestrowania == 0 || stan_zarejestrowania == 3 ||
 3427               		.loc 2 325 0
 3428 1044 4AE0      		ldi r20,lo8(10)
 3429 1046 50E0      		ldi r21,0
 3430 1048 70E0      		ldi r23,0
 3431 104a 60E0      		ldi r22,0
 3432 104c CF01      		movw r24,r30
 3433 104e 0196      		adiw r24,1
 3434               	.LVL299:
 3435 1050 0E94 0000 		call strtol
 3436               	.LVL300:
 326:main_sim900.h ****             stan_zarejestrowania == 4) {
 3437               		.loc 2 326 0
 3438 1054 6623      		tst r22
 3439 1056 01F0      		breq .L274
 326:main_sim900.h ****             stan_zarejestrowania == 4) {
 3440               		.loc 2 326 0 is_stmt 0 discriminator 1
 3441 1058 8DEF      		ldi r24,lo8(-3)
 3442 105a 860F      		add r24,r22
 3443 105c 8230      		cpi r24,lo8(2)
 3444 105e 00F0      		brlo .+2
 3445 1060 00C0      		rjmp .L275
 3446               	.LVL301:
 3447               	.L274:
 328:main_sim900.h ****         } else if (stan_zarejestrowania == 1 || stan_zarejestrowania == 5) {
 3448               		.loc 2 328 0 is_stmt 1
 3449 1062 0E94 0000 		call reset_modulu_SIM900
 3450               	.LVL302:
 3451 1066 00C0      		rjmp .L211
 3452               	.L213:
 3453               	.LBE521:
 3454               	.LBE520:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3455               		.loc 2 142 0
 3456 1068 CA3A      		cpi r28,lo8(-86)
 3457 106a 00F4      		brsh .L229
 3458 106c C63A      		cpi r28,lo8(-90)
 3459 106e 00F0      		brlo .+2
 3460 1070 00C0      		rjmp .L221
 3461 1072 C13A      		cpi r28,lo8(-95)
 3462 1074 01F4      		brne .+2
 3463 1076 00C0      		rjmp .L221
 3464 1078 00F4      		brsh .L230
 3465 107a CF39      		cpi r28,lo8(-97)
 3466 107c 01F4      		brne .+2
 3467 107e 00C0      		rjmp .L231
 3468 1080 C03A      		cpi r28,lo8(-96)
 3469 1082 01F0      		breq .+2
 3470 1084 00C0      		rjmp .L211
 265:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW);
 3471               		.loc 2 265 0
 3472 1086 D130      		cpi r29,lo8(1)
 3473 1088 01F0      		breq .+2
 3474 108a 00C0      		rjmp .L262
 266:main_sim900.h ****     else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 3475               		.loc 2 266 0
 3476 108c 8FE8      		ldi r24,lo8(-113)
 3477 108e 00C0      		rjmp .L410
 3478               	.L230:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3479               		.loc 2 142 0
 3480 1090 C23A      		cpi r28,lo8(-94)
 3481 1092 01F4      		brne .+2
 3482 1094 00C0      		rjmp .L233
 3483 1096 C43A      		cpi r28,lo8(-92)
 3484 1098 01F4      		brne .+2
 3485 109a 00C0      		rjmp .L221
 3486 109c 00C0      		rjmp .L211
 3487               	.L229:
 3488 109e C23D      		cpi r28,lo8(-46)
 3489 10a0 00F4      		brsh .L234
 3490 10a2 CE3B      		cpi r28,lo8(-66)
 3491 10a4 00F4      		brsh .+2
 3492 10a6 00C0      		rjmp .L402
 499:main_sim900.h ****         numer_bledu_cms != CMS_INVALID_MEMORY_INDEX) {
 3493               		.loc 2 499 0
 3494 10a8 D630      		cpi r29,lo8(6)
 3495 10aa 01F0      		breq .+2
 3496 10ac 00C0      		rjmp .L293
 499:main_sim900.h ****         numer_bledu_cms != CMS_INVALID_MEMORY_INDEX) {
 3497               		.loc 2 499 0 is_stmt 0 discriminator 1
 3498 10ae 8091 0000 		lds r24,numer_bledu_cms
 3499 10b2 9091 0000 		lds r25,numer_bledu_cms+1
 3500 10b6 8134      		cpi r24,65
 3501 10b8 9140      		sbci r25,1
 3502 10ba 01F4      		brne .+2
 3503 10bc 00C0      		rjmp .L294
 3504               	.L407:
 505:main_sim900.h ****     POMOC_DODAJ2('#', 'Q');
 3505               		.loc 2 505 0 is_stmt 1
 3506 10be 8C2F      		mov r24,r28
 3507 10c0 0E94 0000 		call dodaj_komende
 3508               	.LVL303:
 3509 10c4 00C0      		rjmp .L295
 3510               	.L234:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3511               		.loc 2 142 0
 3512 10c6 C63D      		cpi r28,lo8(-42)
 3513 10c8 01F4      		brne .+2
 3514 10ca 00C0      		rjmp .L237
 3515 10cc CD3F      		cpi r28,lo8(-3)
 3516 10ce 01F0      		breq .+2
 3517 10d0 00C0      		rjmp .L211
 539:main_sim900.h ****       reset_modulu_SIM900();
 3518               		.loc 2 539 0
 3519 10d2 80E0      		ldi r24,lo8(__c.3311)
 3520 10d4 90E0      		ldi r25,hi8(__c.3311)
 3521 10d6 0E94 0000 		call polozenie_polecenia_SIM900
 3522               	.LVL304:
 3523 10da 892B      		or r24,r25
 3524 10dc 01F4      		brne .+2
 3525 10de 00C0      		rjmp .L221
 3526 10e0 00C0      		rjmp .L274
 3527               	.L218:
 144:main_sim900.h ****     max_oczekiwanie_na_odpowiedz_at = 0;
 3528               		.loc 2 144 0
 3529 10e2 8DE8      		ldi r24,lo8(-115)
 3530 10e4 0E94 0000 		call dodaj_komende
 3531               	.LVL305:
 145:main_sim900.h ****     break;
 3532               		.loc 2 145 0
 3533 10e8 1092 0000 		sts max_oczekiwanie_na_odpowiedz_at,__zero_reg__
 146:main_sim900.h ****   }
 3534               		.loc 2 146 0
 3535 10ec 00C0      		rjmp .L211
 3536               	.L212:
 3537               	.LBB523:
 150:main_sim900.h ****         polozenie_polecenia_SIM900(polecenie_zegar) != NULL) {
 3538               		.loc 2 150 0
 3539 10ee D130      		cpi r29,lo8(1)
 3540 10f0 01F0      		breq .+2
 3541 10f2 00C0      		rjmp .L211
 151:main_sim900.h ****       const uchar *p1 =
 3542               		.loc 2 151 0 discriminator 1
 3543 10f4 80E0      		ldi r24,lo8(polecenie_zegar.3227)
 3544 10f6 90E0      		ldi r25,hi8(polecenie_zegar.3227)
 3545 10f8 0E94 0000 		call polozenie_polecenia_SIM900
 3546               	.LVL306:
 150:main_sim900.h ****         polozenie_polecenia_SIM900(polecenie_zegar) != NULL) {
 3547               		.loc 2 150 0 discriminator 1
 3548 10fc 0097      		sbiw r24,0
 3549 10fe 01F4      		brne .+2
 3550 1100 00C0      		rjmp .L211
 3551               	.LBB524:
 152:main_sim900.h ****           strchr(polozenie_polecenia_SIM900(polecenie_zegar), '\"');
 3552               		.loc 2 152 0
 3553 1102 62E2      		ldi r22,lo8(34)
 3554 1104 70E0      		ldi r23,0
 3555 1106 0E94 0000 		call strchr
 3556               	.LVL307:
 154:main_sim900.h ****         const uchar *p2 = strchr(p1, '\"');
 3557               		.loc 2 154 0
 3558 110a 0097      		sbiw r24,0
 3559 110c 01F4      		brne .+2
 3560 110e 00C0      		rjmp .L211
 3561 1110 EC01      		movw r28,r24
 3562 1112 2196      		adiw r28,1
 3563               	.LVL308:
 3564               	.LBB525:
 155:main_sim900.h ****         const uchar *p3 = strchr(p1, ',');
 3565               		.loc 2 155 0
 3566 1114 62E2      		ldi r22,lo8(34)
 3567 1116 70E0      		ldi r23,0
 3568 1118 CE01      		movw r24,r28
 3569 111a 0E94 0000 		call strchr
 3570               	.LVL309:
 3571 111e 8C01      		movw r16,r24
 3572               	.LVL310:
 156:main_sim900.h ****         if (p2 != NULL && p3++ != NULL && p2 > p3) {
 3573               		.loc 2 156 0
 3574 1120 6CE2      		ldi r22,lo8(44)
 3575 1122 70E0      		ldi r23,0
 3576 1124 CE01      		movw r24,r28
 3577 1126 0E94 0000 		call strchr
 3578               	.LVL311:
 157:main_sim900.h ****           // const uchar g = atoi(p3);
 3579               		.loc 2 157 0
 3580 112a 0115      		cp r16,__zero_reg__
 3581 112c 1105      		cpc r17,__zero_reg__
 3582 112e 01F4      		brne .+2
 3583 1130 00C0      		rjmp .L211
 3584               	.LVL312:
 157:main_sim900.h ****           // const uchar g = atoi(p3);
 3585               		.loc 2 157 0 is_stmt 0 discriminator 1
 3586 1132 0097      		sbiw r24,0
 3587 1134 01F4      		brne .+2
 3588 1136 00C0      		rjmp .L211
 157:main_sim900.h ****           // const uchar g = atoi(p3);
 3589               		.loc 2 157 0 discriminator 2
 3590 1138 EC01      		movw r28,r24
 3591               	.LVL313:
 3592 113a 2196      		adiw r28,1
 3593               	.LVL314:
 3594 113c C017      		cp r28,r16
 3595 113e D107      		cpc r29,r17
 3596 1140 00F0      		brlo .+2
 3597 1142 00C0      		rjmp .L211
 159:main_sim900.h ****             // Pobierz czas z odpowiedzi +CCLK: "yy/MM/dd,hh:mm:ss+zz"
 3598               		.loc 2 159 0 is_stmt 1
 3599 1144 6AE3      		ldi r22,lo8(58)
 3600 1146 70E0      		ldi r23,0
 3601 1148 CE01      		movw r24,r28
 3602 114a 0E94 0000 		call strchr
 3603               	.LVL315:
 3604 114e 0097      		sbiw r24,0
 3605 1150 01F4      		brne .+2
 3606 1152 00C0      		rjmp .L211
 3607               	.LVL316:
 159:main_sim900.h ****             // Pobierz czas z odpowiedzi +CCLK: "yy/MM/dd,hh:mm:ss+zz"
 3608               		.loc 2 159 0 is_stmt 0 discriminator 1
 3609 1154 8017      		cp r24,r16
 3610 1156 9107      		cpc r25,r17
 3611 1158 00F0      		brlo .+2
 3612 115a 00C0      		rjmp .L211
 3613               	.LVL317:
 3614               	.LBB526:
 170:main_sim900.h ****                 memcpy(rtc_czas, ptr_time, 8);
 3615               		.loc 2 170 0 is_stmt 1
 3616 115c FE01      		movw r30,r28
 3617               		0:
 3618 115e 0190      		ld __tmp_reg__,Z+
 3619 1160 0020      		tst __tmp_reg__
 3620 1162 01F4      		brne 0b
 3621 1164 3197      		sbiw r30,1
 3622 1166 EC1B      		sub r30,r28
 3623 1168 FD0B      		sbc r31,r29
 3624 116a 3897      		sbiw r30,8
 3625 116c 00F4      		brsh .+2
 3626 116e 00C0      		rjmp .L211
 171:main_sim900.h ****                 rtc_czas[8] = '\0';
 3627               		.loc 2 171 0
 3628 1170 88E0      		ldi r24,lo8(8)
 3629               	.LVL318:
 3630 1172 FE01      		movw r30,r28
 3631 1174 A0E0      		ldi r26,lo8(rtc_czas)
 3632 1176 B0E0      		ldi r27,hi8(rtc_czas)
 3633               		0:
 3634 1178 0190      		ld r0,Z+
 3635 117a 0D92      		st X+,r0
 3636 117c 8A95      		dec r24
 3637 117e 01F4      		brne 0b
 172:main_sim900.h **** 
 3638               		.loc 2 172 0
 3639 1180 1092 0000 		sts rtc_czas+8,__zero_reg__
 175:main_sim900.h ****                   blokada_sterowania_czasowa = FALSE;
 3640               		.loc 2 175 0
 3641 1184 7091 0000 		lds r23,czas_start_h
 3642 1188 7F3F      		cpi r23,lo8(-1)
 3643 118a 01F4      		brne .L241
 3644               	.L244:
 176:main_sim900.h ****                 } else {
 3645               		.loc 2 176 0
 3646 118c 1092 0000 		sts blokada_sterowania_czasowa,__zero_reg__
 3647 1190 00C0      		rjmp .L211
 3648               	.L241:
 3649               	.LVL319:
 3650               	.LBB527:
 179:main_sim900.h ****                   int curr_m = (rtc_czas[3] - '0') * 10 + (rtc_czas[4] - '0');
 3651               		.loc 2 179 0
 3652 1192 2091 0000 		lds r18,rtc_czas
 3653 1196 2053      		subi r18,48
 3654 1198 330B      		sbc r19,r19
 3655 119a EAE0      		ldi r30,lo8(10)
 3656 119c E29F      		mul r30,r18
 3657 119e C001      		movw r24,r0
 3658 11a0 E39F      		mul r30,r19
 3659 11a2 900D      		add r25,r0
 3660 11a4 1124      		clr __zero_reg__
 3661 11a6 2091 0000 		lds r18,rtc_czas+1
 3662 11aa 2053      		subi r18,48
 3663 11ac 330B      		sbc r19,r19
 3664 11ae 820F      		add r24,r18
 3665 11b0 931F      		adc r25,r19
 181:main_sim900.h **** 
 3666               		.loc 2 181 0
 3667 11b2 6CE3      		ldi r22,lo8(60)
 3668 11b4 689F      		mul r22,r24
 3669 11b6 A001      		movw r20,r0
 3670 11b8 699F      		mul r22,r25
 3671 11ba 500D      		add r21,r0
 3672 11bc 1124      		clr __zero_reg__
 180:main_sim900.h ****                   int curr_time = curr_h * 60 + curr_m;
 3673               		.loc 2 180 0
 3674 11be 2091 0000 		lds r18,rtc_czas+3
 3675 11c2 2053      		subi r18,48
 3676 11c4 330B      		sbc r19,r19
 3677 11c6 E29F      		mul r30,r18
 3678 11c8 C001      		movw r24,r0
 3679 11ca E39F      		mul r30,r19
 3680 11cc 900D      		add r25,r0
 3681 11ce 1124      		clr __zero_reg__
 3682 11d0 2091 0000 		lds r18,rtc_czas+4
 3683 11d4 2053      		subi r18,48
 3684 11d6 330B      		sbc r19,r19
 3685 11d8 820F      		add r24,r18
 3686 11da 931F      		adc r25,r19
 181:main_sim900.h **** 
 3687               		.loc 2 181 0
 3688 11dc 480F      		add r20,r24
 3689 11de 591F      		adc r21,r25
 3690               	.LVL320:
 183:main_sim900.h ****                   int stop_time = czas_stop_h * 60 + czas_stop_m;
 3691               		.loc 2 183 0
 3692 11e0 2091 0000 		lds r18,czas_start_m
 3693 11e4 30E0      		ldi r19,0
 3694 11e6 769F      		mul r23,r22
 3695 11e8 200D      		add r18,r0
 3696 11ea 311D      		adc r19,r1
 3697 11ec 1124      		clr __zero_reg__
 3698               	.LVL321:
 184:main_sim900.h **** 
 3699               		.loc 2 184 0
 3700 11ee 7091 0000 		lds r23,czas_stop_h
 3701 11f2 8091 0000 		lds r24,czas_stop_m
 3702 11f6 90E0      		ldi r25,0
 3703 11f8 769F      		mul r23,r22
 3704 11fa 800D      		add r24,r0
 3705 11fc 911D      		adc r25,r1
 3706 11fe 1124      		clr __zero_reg__
 3707               	.LVL322:
 186:main_sim900.h ****                     // Normalny przedzial (np. 08:00 - 16:00)
 3708               		.loc 2 186 0
 3709 1200 8217      		cp r24,r18
 3710 1202 9307      		cpc r25,r19
 3711 1204 04F0      		brlt .L242
 188:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 3712               		.loc 2 188 0
 3713 1206 4217      		cp r20,r18
 3714 1208 5307      		cpc r21,r19
 3715 120a 04F0      		brlt .L243
 3716               	.L403:
 194:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 3717               		.loc 2 194 0 discriminator 1
 3718 120c 8417      		cp r24,r20
 3719 120e 9507      		cpc r25,r21
 3720 1210 04F0      		brlt .+2
 3721 1212 00C0      		rjmp .L244
 3722               	.L243:
 191:main_sim900.h ****                   } else {
 3723               		.loc 2 191 0
 3724 1214 8FEF      		ldi r24,lo8(-1)
 3725               	.LVL323:
 3726 1216 8093 0000 		sts blokada_sterowania_czasowa,r24
 3727 121a 00C0      		rjmp .L211
 3728               	.LVL324:
 3729               	.L242:
 194:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 3730               		.loc 2 194 0
 3731 121c 4217      		cp r20,r18
 3732 121e 5307      		cpc r21,r19
 3733 1220 04F0      		brlt .L403
 3734 1222 00C0      		rjmp .L244
 3735               	.LVL325:
 3736               	.L231:
 3737               	.LBE527:
 3738               	.LBE526:
 3739               	.LBE525:
 3740               	.LBE524:
 3741               	.LBE523:
 3742               	.LBB528:
 211:main_sim900.h ****       if (polozenie_polecenia_SIM900(polecenie_pin_ready) != NULL) {
 3743               		.loc 2 211 0
 3744 1224 D130      		cpi r29,lo8(1)
 3745 1226 01F4      		brne .L245
 212:main_sim900.h ****         podlaczona_karta_SIM_SIM900 = TRUE;
 3746               		.loc 2 212 0
 3747 1228 80E0      		ldi r24,lo8(polecenie_pin_ready.3238)
 3748 122a 90E0      		ldi r25,hi8(polecenie_pin_ready.3238)
 3749 122c 0E94 0000 		call polozenie_polecenia_SIM900
 3750               	.LVL326:
 3751 1230 892B      		or r24,r25
 3752 1232 01F0      		breq .L246
 213:main_sim900.h ****         bledny_PIN = FALSE;
 3753               		.loc 2 213 0
 3754 1234 8FEF      		ldi r24,lo8(-1)
 3755 1236 8093 0000 		sts podlaczona_karta_SIM_SIM900,r24
 214:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 3756               		.loc 2 214 0
 3757 123a 1092 0000 		sts bledny_PIN,__zero_reg__
 215:main_sim900.h ****       } else
 3758               		.loc 2 215 0
 3759 123e 82E9      		ldi r24,lo8(-110)
 3760               	.L404:
 217:main_sim900.h ****       nr_zapytania_o_pin = 0;
 3761               		.loc 2 217 0
 3762 1240 0E94 0000 		call dodaj_komende
 3763               	.LVL327:
 3764               	.L408:
 225:main_sim900.h ****       } else {
 3765               		.loc 2 225 0
 3766 1244 1092 0000 		sts nr_zapytania_o_pin.3239,__zero_reg__
 3767 1248 00C0      		rjmp .L211
 3768               	.L246:
 217:main_sim900.h ****       nr_zapytania_o_pin = 0;
 3769               		.loc 2 217 0
 3770 124a 8EE8      		ldi r24,lo8(-114)
 3771 124c 00C0      		rjmp .L404
 3772               	.L245:
 219:main_sim900.h ****                numer_bledu_cme == CME_SIM_BUSY)
 3773               		.loc 2 219 0
 3774 124e D530      		cpi r29,lo8(5)
 3775 1250 01F4      		brne .L248
 219:main_sim900.h ****                numer_bledu_cme == CME_SIM_BUSY)
 3776               		.loc 2 219 0 is_stmt 0 discriminator 1
 3777 1252 8091 0000 		lds r24,numer_bledu_cme
 3778 1256 9091 0000 		lds r25,numer_bledu_cme+1
 3779 125a 0E97      		sbiw r24,14
 3780 125c 01F4      		brne .L249
 3781               	.L412:
 228:main_sim900.h ****       }
 3782               		.loc 2 228 0 is_stmt 1
 3783 125e 8FE9      		ldi r24,lo8(-97)
 3784               	.L410:
 3785               	.LBE528:
 266:main_sim900.h ****     else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 3786               		.loc 2 266 0
 3787 1260 0E94 0000 		call dodaj_komende
 3788               	.LVL328:
 3789 1264 00C0      		rjmp .L211
 3790               	.L248:
 3791               	.LBB529:
 222:main_sim900.h ****       if (++nr_zapytania_o_pin >= 20) {
 3792               		.loc 2 222 0
 3793 1266 D430      		cpi r29,lo8(4)
 3794 1268 01F0      		breq .L250
 3795               	.L249:
 222:main_sim900.h ****       if (++nr_zapytania_o_pin >= 20) {
 3796               		.loc 2 222 0 is_stmt 0 discriminator 1
 3797 126a 8091 0000 		lds r24,komenda_SIM900
 3798 126e 8038      		cpi r24,lo8(-128)
 3799 1270 01F4      		brne .L412
 3800               	.L250:
 223:main_sim900.h ****         reset_modulu_SIM900();
 3801               		.loc 2 223 0 is_stmt 1
 3802 1272 8091 0000 		lds r24,nr_zapytania_o_pin.3239
 3803 1276 8F5F      		subi r24,lo8(-(1))
 3804 1278 8093 0000 		sts nr_zapytania_o_pin.3239,r24
 3805 127c 8431      		cpi r24,lo8(20)
 3806 127e 00F0      		brlo .L252
 224:main_sim900.h ****         nr_zapytania_o_pin = 0;
 3807               		.loc 2 224 0
 3808 1280 0E94 0000 		call reset_modulu_SIM900
 3809               	.LVL329:
 3810 1284 00C0      		rjmp .L408
 3811               	.L252:
 227:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3812               		.loc 2 227 0
 3813 1286 84E1      		ldi r24,lo8(20)
 3814 1288 8093 0000 		sts opoznienie_SIM900_100MS,r24
 3815 128c 00C0      		rjmp .L412
 3816               	.L219:
 3817               	.LBE529:
 235:main_sim900.h ****       podlaczona_karta_SIM_SIM900 = TRUE;
 3818               		.loc 2 235 0
 3819 128e D130      		cpi r29,lo8(1)
 3820 1290 01F4      		brne .L253
 236:main_sim900.h ****       bledny_PIN = FALSE;
 3821               		.loc 2 236 0
 3822 1292 8FEF      		ldi r24,lo8(-1)
 3823 1294 8093 0000 		sts podlaczona_karta_SIM_SIM900,r24
 237:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 3824               		.loc 2 237 0
 3825 1298 1092 0000 		sts bledny_PIN,__zero_reg__
 238:main_sim900.h ****       opoznienie_SIM900_100MS = 50;
 3826               		.loc 2 238 0
 3827 129c 82E9      		ldi r24,lo8(-110)
 3828 129e 0E94 0000 		call dodaj_komende
 3829               	.LVL330:
 239:main_sim900.h ****     } else if (kom == CME_ERROR_KOMENDA_SIM900 &&
 3830               		.loc 2 239 0
 3831 12a2 82E3      		ldi r24,lo8(50)
 3832               	.L409:
 534:main_sim900.h ****       break;
 3833               		.loc 2 534 0
 3834 12a4 8093 0000 		sts opoznienie_SIM900_100MS,r24
 535:main_sim900.h ****     } // bez break
 3835               		.loc 2 535 0
 3836 12a8 00C0      		rjmp .L211
 3837               	.L253:
 240:main_sim900.h ****                numer_bledu_cme == CME_SIM_INCORECT_PASWORD)
 3838               		.loc 2 240 0
 3839 12aa D530      		cpi r29,lo8(5)
 3840 12ac 01F4      		brne .L254
 241:main_sim900.h ****       bledny_PIN = TRUE;
 3841               		.loc 2 241 0 discriminator 1
 3842 12ae 8091 0000 		lds r24,numer_bledu_cme
 3843 12b2 9091 0000 		lds r25,numer_bledu_cme+1
 240:main_sim900.h ****                numer_bledu_cme == CME_SIM_INCORECT_PASWORD)
 3844               		.loc 2 240 0 discriminator 1
 3845 12b6 8031      		cpi r24,16
 3846 12b8 9105      		cpc r25,__zero_reg__
 3847 12ba 01F4      		brne .L255
 242:main_sim900.h ****     else if (kom == CME_ERROR_KOMENDA_SIM900 && numer_bledu_cme == CME_SIM_BUSY)
 3848               		.loc 2 242 0
 3849 12bc 8FEF      		ldi r24,lo8(-1)
 3850 12be 8093 0000 		sts bledny_PIN,r24
 3851 12c2 00C0      		rjmp .L211
 3852               	.L255:
 243:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3853               		.loc 2 243 0 discriminator 1
 3854 12c4 0E97      		sbiw r24,14
 3855 12c6 01F4      		brne .L256
 3856               	.L257:
 244:main_sim900.h ****     else if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900())
 3857               		.loc 2 244 0
 3858 12c8 8EE8      		ldi r24,lo8(-114)
 3859 12ca 00C0      		rjmp .L410
 3860               	.L254:
 245:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3861               		.loc 2 245 0
 3862 12cc D430      		cpi r29,lo8(4)
 3863 12ce 01F0      		breq .L257
 3864               	.L256:
 245:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3865               		.loc 2 245 0 is_stmt 0 discriminator 1
 3866 12d0 8091 0000 		lds r24,komenda_SIM900
 3867 12d4 00C0      		rjmp .L257
 3868               	.L220:
 252:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW);
 3869               		.loc 2 252 0 is_stmt 1
 3870 12d6 D130      		cpi r29,lo8(1)
 3871 12d8 01F4      		brne .L258
 3872               	.L411:
 275:main_sim900.h ****     }
 3873               		.loc 2 275 0
 3874 12da 80EA      		ldi r24,lo8(-96)
 3875 12dc 00C0      		rjmp .L410
 3876               	.L258:
 254:main_sim900.h ****       if (numer_bledu_cms == CMS_SIM_BUSY ||
 3877               		.loc 2 254 0
 3878 12de D630      		cpi r29,lo8(6)
 3879 12e0 01F4      		brne .L259
 255:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 3880               		.loc 2 255 0
 3881 12e2 8091 0000 		lds r24,numer_bledu_cms
 3882 12e6 9091 0000 		lds r25,numer_bledu_cms+1
 3883 12ea 8A33      		cpi r24,58
 3884 12ec 21E0      		ldi r18,1
 3885 12ee 9207      		cpc r25,r18
 3886 12f0 01F0      		breq .L260
 255:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 3887               		.loc 2 255 0 is_stmt 0 discriminator 1
 3888 12f2 8530      		cpi r24,5
 3889 12f4 9240      		sbci r25,2
 3890 12f6 01F0      		breq .+2
 3891 12f8 00C0      		rjmp .L211
 3892               	.L260:
 257:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3893               		.loc 2 257 0 is_stmt 1
 3894 12fa 8CE3      		ldi r24,lo8(60)
 3895 12fc 8093 0000 		sts opoznienie_SIM900_100MS,r24
 3896               	.L261:
 261:main_sim900.h ****     break;
 3897               		.loc 2 261 0
 3898 1300 82E9      		ldi r24,lo8(-110)
 3899 1302 00C0      		rjmp .L410
 3900               	.L259:
 260:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3901               		.loc 2 260 0
 3902 1304 D430      		cpi r29,lo8(4)
 3903 1306 01F0      		breq .L261
 260:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3904               		.loc 2 260 0 is_stmt 0 discriminator 1
 3905 1308 8091 0000 		lds r24,komenda_SIM900
 3906 130c 8038      		cpi r24,lo8(-128)
 3907 130e 01F0      		breq .+2
 3908 1310 00C0      		rjmp .L211
 3909 1312 00C0      		rjmp .L261
 3910               	.L262:
 267:main_sim900.h ****       if (numer_bledu_cms == CMS_SIM_BUSY ||
 3911               		.loc 2 267 0 is_stmt 1
 3912 1314 D630      		cpi r29,lo8(6)
 3913 1316 01F4      		brne .L263
 268:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 3914               		.loc 2 268 0
 3915 1318 8091 0000 		lds r24,numer_bledu_cms
 3916 131c 9091 0000 		lds r25,numer_bledu_cms+1
 3917 1320 8A33      		cpi r24,58
 3918 1322 21E0      		ldi r18,1
 3919 1324 9207      		cpc r25,r18
 3920 1326 01F0      		breq .L264
 268:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 3921               		.loc 2 268 0 is_stmt 0 discriminator 1
 3922 1328 8530      		cpi r24,5
 3923 132a 9240      		sbci r25,2
 3924 132c 01F0      		breq .+2
 3925 132e 00C0      		rjmp .L211
 3926               	.L264:
 270:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3927               		.loc 2 270 0 is_stmt 1
 3928 1330 84E1      		ldi r24,lo8(20)
 3929               	.L413:
 274:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3930               		.loc 2 274 0
 3931 1332 8093 0000 		sts opoznienie_SIM900_100MS,r24
 3932 1336 00C0      		rjmp .L411
 3933               	.L263:
 3934 1338 8AE0      		ldi r24,lo8(10)
 3935 133a 00C0      		rjmp .L413
 3936               	.L233:
 280:main_sim900.h ****         (kom == CME_ERROR_KOMENDA_SIM900 &&
 3937               		.loc 2 280 0
 3938 133c D130      		cpi r29,lo8(1)
 3939 133e 01F0      		breq .L265
 280:main_sim900.h ****         (kom == CME_ERROR_KOMENDA_SIM900 &&
 3940               		.loc 2 280 0 is_stmt 0 discriminator 1
 3941 1340 D530      		cpi r29,lo8(5)
 3942 1342 01F4      		brne .L266
 282:main_sim900.h ****           numer_bledu_cme == CME_OPERATION_NOT_SUPPORTED))) {
 3943               		.loc 2 282 0 is_stmt 1
 3944 1344 8091 0000 		lds r24,numer_bledu_cme
 3945 1348 9091 0000 		lds r25,numer_bledu_cme+1
 3946 134c 0397      		sbiw r24,3
 281:main_sim900.h ****          (numer_bledu_cme == CME_OPERATION_NOT_ALLOWED ||
 3947               		.loc 2 281 0
 3948 134e 0297      		sbiw r24,2
 3949 1350 00F4      		brsh .L266
 3950               	.L265:
 284:main_sim900.h ****       nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 3951               		.loc 2 284 0
 3952 1352 8091 0000 		lds r24,nastepne_wysylane_polecenie_SIM900
 3953 1356 0E94 0000 		call dodaj_komende
 3954               	.LVL331:
 3955               	.L299:
 564:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 3956               		.loc 2 564 0
 3957 135a 1092 0000 		sts nastepne_wysylane_polecenie_SIM900,__zero_reg__
 565:main_sim900.h ****     }
 3958               		.loc 2 565 0
 3959 135e 1092 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,__zero_reg__
 3960 1362 00C0      		rjmp .L267
 3961               	.L266:
 288:main_sim900.h ****                    MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 3962               		.loc 2 288 0 discriminator 1
 3963 1364 8091 0000 		lds r24,liczba_wykonanych_komend_identycznego_polecenia
 3964 1368 8F5F      		subi r24,lo8(-(1))
 287:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 3965               		.loc 2 287 0 discriminator 1
 3966 136a 8093 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,r24
 3967 136e 8330      		cpi r24,lo8(3)
 3968 1370 00F4      		brsh .L267
 290:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 3969               		.loc 2 290 0
 3970 1372 82EA      		ldi r24,lo8(-94)
 3971               	.L405:
 3972 1374 0E94 0000 		call dodaj_komende
 3973               	.LVL332:
 3974               	.L267:
 291:main_sim900.h ****     break;
 3975               		.loc 2 291 0
 3976 1378 82E0      		ldi r24,lo8(2)
 3977 137a 00C0      		rjmp .L409
 3978               	.L226:
 295:main_sim900.h ****       static const uchar urc[] PROGMEM = "+CSQ:";
 3979               		.loc 2 295 0
 3980 137c D130      		cpi r29,lo8(1)
 3981 137e 01F4      		brne .L269
 3982               	.LBB530:
 297:main_sim900.h ****       if (p1 != NULL) {
 3983               		.loc 2 297 0
 3984 1380 80E0      		ldi r24,lo8(urc.3245)
 3985 1382 90E0      		ldi r25,hi8(urc.3245)
 3986 1384 0E94 0000 		call polozenie_polecenia_SIM900
 3987               	.LVL333:
 298:main_sim900.h ****         p1 += strlen_R(urc) + 1;
 3988               		.loc 2 298 0
 3989 1388 0097      		sbiw r24,0
 3990 138a 01F4      		brne .+2
 3991 138c 00C0      		rjmp .L211
 3992               	.LVL334:
 300:main_sim900.h ****         // if ( poziom_sieci_gsm != POZIOM_SIECI_BLAD )
 3993               		.loc 2 300 0
 3994 138e 4AE0      		ldi r20,lo8(10)
 3995 1390 50E0      		ldi r21,0
 3996 1392 70E0      		ldi r23,0
 3997 1394 60E0      		ldi r22,0
 3998 1396 0696      		adiw r24,6
 3999               	.LVL335:
 4000 1398 0E94 0000 		call strtol
 4001               	.LVL336:
 4002 139c 6093 0000 		sts poziom_sieci_gsm,r22
 4003 13a0 00C0      		rjmp .L211
 4004               	.L269:
 4005               	.LBE530:
 309:main_sim900.h ****     break;
 4006               		.loc 2 309 0
 4007 13a2 83E6      		ldi r24,lo8(99)
 4008 13a4 8093 0000 		sts poziom_sieci_gsm,r24
 4009 13a8 00C0      		rjmp .L211
 4010               	.LVL337:
 4011               	.L270:
 4012               	.LBB531:
 4013               	.LBB522:
 319:main_sim900.h ****         if (*p1 != ',')
 4014               		.loc 2 319 0
 4015 13aa 3896      		adiw r30,8
 4016               	.LVL338:
 4017 13ac 00C0      		rjmp .L271
 4018               	.LVL339:
 4019               	.L275:
 329:main_sim900.h ****           modul_zalogowany_w_sieci = TRUE;
 4020               		.loc 2 329 0
 4021 13ae 6B7F      		andi r22,lo8(-5)
 4022               	.LVL340:
 4023 13b0 6130      		cpi r22,lo8(1)
 4024 13b2 01F0      		breq .+2
 4025 13b4 00C0      		rjmp .L211
 330:main_sim900.h ****         }
 4026               		.loc 2 330 0
 4027 13b6 8FEF      		ldi r24,lo8(-1)
 4028 13b8 8093 0000 		sts modul_zalogowany_w_sieci,r24
 4029 13bc 00C0      		rjmp .L211
 4030               	.L222:
 4031               	.LBE522:
 4032               	.LBE531:
 337:main_sim900.h ****                                      (numer_bledu_cme == CME_INVALID_INDEX ||
 4033               		.loc 2 337 0
 4034 13be D130      		cpi r29,lo8(1)
 4035 13c0 01F0      		breq .L276
 337:main_sim900.h ****                                      (numer_bledu_cme == CME_INVALID_INDEX ||
 4036               		.loc 2 337 0 is_stmt 0 discriminator 1
 4037 13c2 D530      		cpi r29,lo8(5)
 4038 13c4 01F4      		brne .L277
 338:main_sim900.h ****                                       numer_bledu_cme == CME_NOT_FOUND))) {
 4039               		.loc 2 338 0 is_stmt 1 discriminator 2
 4040 13c6 8091 0000 		lds r24,numer_bledu_cme
 4041 13ca 9091 0000 		lds r25,numer_bledu_cme+1
 4042 13ce 4597      		sbiw r24,21
 337:main_sim900.h ****                                      (numer_bledu_cme == CME_INVALID_INDEX ||
 4043               		.loc 2 337 0 discriminator 2
 4044 13d0 0297      		sbiw r24,2
 4045 13d2 00F4      		brsh .L277
 4046               	.L276:
 340:main_sim900.h ****     } else {
 4047               		.loc 2 340 0
 4048 13d4 1092 0000 		sts licznik_blad_stanu_karty_SIM,__zero_reg__
 4049 13d8 00C0      		rjmp .L211
 4050               	.L277:
 342:main_sim900.h ****     }
 4051               		.loc 2 342 0
 4052 13da 8091 0000 		lds r24,licznik_blad_stanu_karty_SIM
 4053 13de 8F5F      		subi r24,lo8(-(1))
 4054 13e0 8093 0000 		sts licznik_blad_stanu_karty_SIM,r24
 4055 13e4 00C0      		rjmp .L211
 4056               	.L227:
 4057               	.LVL341:
 4058               	.LBB532:
 349:main_sim900.h ****       const uchar *p1 =
 4059               		.loc 2 349 0
 4060 13e6 D130      		cpi r29,lo8(1)
 4061 13e8 01F0      		breq .+2
 4062 13ea 00C0      		rjmp .L278
 4063               	.LVL342:
 4064               	.LBB533:
 4065               	.LBB534:
  47:main_sim900.h **** }
 4066               		.loc 2 47 0
 4067 13ec 46E0      		ldi r20,lo8(6)
 4068 13ee 50E0      		ldi r21,0
 4069 13f0 60E0      		ldi r22,lo8(polecenie_operator.3253)
 4070 13f2 70E0      		ldi r23,hi8(polecenie_operator.3253)
 4071 13f4 80E0      		ldi r24,lo8(odebrany_blok_SIM900+2)
 4072 13f6 90E0      		ldi r25,hi8(odebrany_blok_SIM900+2)
 4073 13f8 0E94 0000 		call strncmp_P
 4074               	.LVL343:
 4075               	.LBE534:
 4076               	.LBE533:
 349:main_sim900.h ****       const uchar *p1 =
 4077               		.loc 2 349 0
 4078 13fc 892B      		or r24,r25
 4079 13fe 01F4      		brne .L278
 4080               	.LBB535:
 351:main_sim900.h ****       if (p1 != NULL) {
 4081               		.loc 2 351 0
 4082 1400 80E0      		ldi r24,lo8(polecenie_operator.3253)
 4083 1402 90E0      		ldi r25,hi8(polecenie_operator.3253)
 4084 1404 0E94 0000 		call polozenie_polecenia_SIM900
 4085               	.LVL344:
 350:main_sim900.h ****           strchr(polozenie_polecenia_SIM900(polecenie_operator), ',');
 4086               		.loc 2 350 0
 4087 1408 6CE2      		ldi r22,lo8(44)
 4088 140a 70E0      		ldi r23,0
 4089 140c 0E94 0000 		call strchr
 4090               	.LVL345:
 352:main_sim900.h ****         p1 = strchr(p1, ',');
 4091               		.loc 2 352 0
 4092 1410 0097      		sbiw r24,0
 4093 1412 01F0      		breq .L278
 353:main_sim900.h ****         if (p1 != NULL) {
 4094               		.loc 2 353 0
 4095 1414 6CE2      		ldi r22,lo8(44)
 4096 1416 70E0      		ldi r23,0
 4097 1418 0E94 0000 		call strchr
 4098               	.LVL346:
 354:main_sim900.h ****           p1 = strchr(p1, '\"');
 4099               		.loc 2 354 0
 4100 141c 0097      		sbiw r24,0
 4101 141e 01F0      		breq .L278
 355:main_sim900.h ****           if (p1++ != NULL) {
 4102               		.loc 2 355 0
 4103 1420 62E2      		ldi r22,lo8(34)
 4104 1422 70E0      		ldi r23,0
 4105 1424 0E94 0000 		call strchr
 4106               	.LVL347:
 356:main_sim900.h ****             const uchar *p2 = strchr(p1, '\"');
 4107               		.loc 2 356 0
 4108 1428 0097      		sbiw r24,0
 4109 142a 01F0      		breq .L278
 4110 142c 8C01      		movw r16,r24
 4111 142e 0F5F      		subi r16,-1
 4112 1430 1F4F      		sbci r17,-1
 4113               	.LVL348:
 4114               	.LBB536:
 357:main_sim900.h ****             if (p2 != NULL && p1 != p2) {
 4115               		.loc 2 357 0
 4116 1432 62E2      		ldi r22,lo8(34)
 4117 1434 70E0      		ldi r23,0
 4118 1436 C801      		movw r24,r16
 4119 1438 0E94 0000 		call strchr
 4120               	.LVL349:
 358:main_sim900.h ****               const uchar m = min(p2 - p1, ROZMIAR_NAZWA_OPERATORA);
 4121               		.loc 2 358 0
 4122 143c 0097      		sbiw r24,0
 4123 143e 01F0      		breq .L278
 358:main_sim900.h ****               const uchar m = min(p2 - p1, ROZMIAR_NAZWA_OPERATORA);
 4124               		.loc 2 358 0 is_stmt 0 discriminator 1
 4125 1440 0817      		cp r16,r24
 4126 1442 1907      		cpc r17,r25
 4127 1444 01F0      		breq .L278
 4128               	.LVL350:
 4129               	.LBB537:
 359:main_sim900.h ****               memcpy(nazwa_operatora, p1, m);
 4130               		.loc 2 359 0 is_stmt 1
 4131 1446 801B      		sub r24,r16
 4132 1448 910B      		sbc r25,r17
 4133               	.LVL351:
 4134 144a 8C30      		cpi r24,12
 4135 144c 9105      		cpc r25,__zero_reg__
 4136 144e 04F0      		brlt .L279
 4137 1450 8BE0      		ldi r24,lo8(11)
 4138 1452 90E0      		ldi r25,0
 4139               	.L279:
 4140 1454 EC01      		movw r28,r24
 4141 1456 DD27      		clr r29
 360:main_sim900.h ****               nazwa_operatora[m] = '\0';
 4142               		.loc 2 360 0
 4143 1458 AE01      		movw r20,r28
 4144 145a B801      		movw r22,r16
 4145 145c 80E0      		ldi r24,lo8(nazwa_operatora)
 4146 145e 90E0      		ldi r25,hi8(nazwa_operatora)
 4147 1460 0E94 0000 		call memcpy
 4148               	.LVL352:
 361:main_sim900.h ****               w = TRUE;
 4149               		.loc 2 361 0
 4150 1464 C050      		subi r28,lo8(-(nazwa_operatora))
 4151 1466 D040      		sbci r29,hi8(-(nazwa_operatora))
 4152 1468 1882      		st Y,__zero_reg__
 4153               	.LVL353:
 4154               	.LBE537:
 4155               	.LBE536:
 4156               	.LBE535:
 369:main_sim900.h ****     else {
 4157               		.loc 2 369 0
 4158 146a 1092 0000 		sts licznik_blad_zalogowania_u_operatora,__zero_reg__
 4159 146e 00C0      		rjmp .L211
 4160               	.LVL354:
 4161               	.L278:
 371:main_sim900.h ****     }
 4162               		.loc 2 371 0
 4163 1470 8091 0000 		lds r24,licznik_blad_zalogowania_u_operatora
 4164 1474 8F5F      		subi r24,lo8(-(1))
 4165 1476 8093 0000 		sts licznik_blad_zalogowania_u_operatora,r24
 4166 147a 00C0      		rjmp .L211
 4167               	.LVL355:
 4168               	.L214:
 4169               	.LBE532:
 377:main_sim900.h ****         CMS_ERROR_KOMENDA_SIM900 /*&& numer_bledu_cms == CMS_SMS_ME_RESERVED*/) // co le interpretu
 4170               		.loc 2 377 0
 4171 147c D630      		cpi r29,lo8(6)
 4172 147e 01F4      		brne .+2
 4173 1480 00C0      		rjmp .L267
 381:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 4174               		.loc 2 381 0
 4175 1482 85E9      		ldi r24,lo8(-107)
 380:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 4176               		.loc 2 380 0
 4177 1484 D130      		cpi r29,lo8(1)
 4178 1486 01F0      		breq .+2
 4179 1488 00C0      		rjmp .L405
 4180 148a 00C0      		rjmp .L267
 4181               	.L224:
 386:main_sim900.h ****         czy_jest_komenda_uzytkownik_odebral_rozmowe()) {
 4182               		.loc 2 386 0
 4183 148c D130      		cpi r29,lo8(1)
 4184 148e 01F0      		breq .L281
 387:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = TRUE;
 4185               		.loc 2 387 0 discriminator 1
 4186 1490 8091 0000 		lds r24,komenda_SIM900
 386:main_sim900.h ****         czy_jest_komenda_uzytkownik_odebral_rozmowe()) {
 4187               		.loc 2 386 0 discriminator 1
 4188 1494 8C30      		cpi r24,lo8(12)
 4189 1496 01F4      		brne .L282
 4190               	.L281:
 388:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 4191               		.loc 2 388 0
 4192 1498 8FEF      		ldi r24,lo8(-1)
 4193 149a 8093 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,r24
 389:main_sim900.h **** 
 4194               		.loc 2 389 0
 4195 149e 1092 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,__zero_reg__
 392:main_sim900.h ****         licznik_timeout_rozmowy_100ms = MAX_LICZNIK_TIMEOUT_ROZMOWY_100MS;
 4196               		.loc 2 392 0
 4197 14a2 8091 0000 		lds r24,tryb_clip
 4198 14a6 8111      		cpse r24,__zero_reg__
 4199 14a8 00C0      		rjmp .L211
 393:main_sim900.h ****         opoznienie_SIM900_100MS =
 4200               		.loc 2 393 0
 4201 14aa 8CE2      		ldi r24,lo8(44)
 4202 14ac 91E0      		ldi r25,lo8(1)
 4203 14ae 9093 0000 		sts licznik_timeout_rozmowy_100ms+1,r25
 4204 14b2 8093 0000 		sts licznik_timeout_rozmowy_100ms,r24
 394:main_sim900.h ****             20; // 2 sekundy opoznienia przed wyslaniem tonu
 4205               		.loc 2 394 0
 4206 14b6 84E1      		ldi r24,lo8(20)
 4207 14b8 8093 0000 		sts opoznienie_SIM900_100MS,r24
 396:main_sim900.h ****       }
 4208               		.loc 2 396 0
 4209 14bc 85EA      		ldi r24,lo8(-91)
 4210 14be 00C0      		rjmp .L410
 4211               	.L282:
 398:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 4212               		.loc 2 398 0
 4213 14c0 D430      		cpi r29,lo8(4)
 4214 14c2 01F0      		breq .L283
 398:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 4215               		.loc 2 398 0 is_stmt 0 discriminator 2
 4216 14c4 8091 0000 		lds r24,komenda_SIM900
 4217 14c8 8038      		cpi r24,lo8(-128)
 4218 14ca 01F4      		brne .L284
 4219               	.L283:
 399:main_sim900.h ****                    MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 4220               		.loc 2 399 0 is_stmt 1 discriminator 3
 4221 14cc 8091 0000 		lds r24,liczba_wykonanych_komend_identycznego_polecenia
 4222 14d0 8F5F      		subi r24,lo8(-(1))
 398:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 4223               		.loc 2 398 0 discriminator 3
 4224 14d2 8093 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,r24
 4225 14d6 8330      		cpi r24,lo8(3)
 4226 14d8 00F4      		brsh .L284
 401:main_sim900.h ****     else if (kom == NO_CARRIER_KOMENDA_SIM900) {
 4227               		.loc 2 401 0
 4228 14da 86E9      		ldi r24,lo8(-106)
 4229 14dc 00C0      		rjmp .L410
 4230               	.L284:
 402:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 4231               		.loc 2 402 0
 4232 14de D330      		cpi r29,lo8(3)
 4233 14e0 01F4      		brne .L285
 403:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 4234               		.loc 2 403 0
 4235 14e2 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 4236               	.L285:
 406:main_sim900.h ****     break;
 4237               		.loc 2 406 0
 4238 14e6 1092 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,__zero_reg__
 4239 14ea 00C0      		rjmp .L211
 4240               	.L402:
 439:main_sim900.h ****       // odczytany sms
 4241               		.loc 2 439 0
 4242 14ec D130      		cpi r29,lo8(1)
 4243 14ee 01F4      		brne .L287
 4244               	.LBB538:
 441:main_sim900.h ****       ptr = strchr(ptr, ZNAK_KONCA_ODBIERANIA_ZNAKOW_LF);            // (1)
 4245               		.loc 2 441 0
 4246 14f0 80E0      		ldi r24,lo8(__c.3282)
 4247 14f2 90E0      		ldi r25,hi8(__c.3282)
 4248 14f4 0E94 0000 		call polozenie_polecenia_SIM900
 4249               	.LVL356:
 442:main_sim900.h ****       // const uchar* ptr = strchr(&odebrany_blok_SIM900[7],
 4250               		.loc 2 442 0
 4251 14f8 6AE0      		ldi r22,lo8(10)
 4252 14fa 70E0      		ldi r23,0
 4253 14fc 0E94 0000 		call strchr
 4254               	.LVL357:
 445:main_sim900.h ****         ++ptr;
 4255               		.loc 2 445 0
 4256 1500 0097      		sbiw r24,0
 4257 1502 01F0      		breq .L288
 4258               	.LBB539:
 446:main_sim900.h ****         const uchar *ptr2 = strchr(ptr, ZNAK_KONCA_WYSYLANIA_ZNAKOW_CR);
 4259               		.loc 2 446 0
 4260 1504 EC01      		movw r28,r24
 4261 1506 2196      		adiw r28,1
 4262               	.LVL358:
 447:main_sim900.h ****         if (ptr2 != NULL) {
 4263               		.loc 2 447 0
 4264 1508 6DE0      		ldi r22,lo8(13)
 4265 150a 70E0      		ldi r23,0
 4266 150c CE01      		movw r24,r28
 4267 150e 0E94 0000 		call strchr
 4268               	.LVL359:
 448:main_sim900.h ****           dlugosc_pdu = (ptr2 - ptr) / 2;
 4269               		.loc 2 448 0
 4270 1512 0097      		sbiw r24,0
 4271 1514 01F0      		breq .L288
 4272               	.LBB540:
 449:main_sim900.h ****           if (dlugosc_pdu > MAX_DLUGOSC_PDU)
 4273               		.loc 2 449 0
 4274 1516 8C1B      		sub r24,r28
 4275 1518 9D0B      		sbc r25,r29
 4276               	.LVL360:
 4277 151a 97FD      		sbrc r25,7
 4278 151c 0196      		adiw r24,1
 4279               	.L289:
 4280 151e 9595      		asr r25
 4281 1520 8795      		ror r24
 450:main_sim900.h ****             dlugosc_pdu = MAX_DLUGOSC_PDU;
 4282               		.loc 2 450 0
 4283 1522 893C      		cpi r24,lo8(-55)
 4284 1524 00F4      		brsh .L290
 4285               	.L406:
 451:main_sim900.h ****           konwertuj_blok_dwa_znaki_na_znak_pdu(ptr, dlugosc_pdu, bufor_pdu);
 4286               		.loc 2 451 0
 4287 1526 8093 0000 		sts dlugosc_pdu,r24
 452:main_sim900.h ****           dodaj_komende(KOMENDA_KOLEJKI_INTERPRETUJ_PDU);
 4288               		.loc 2 452 0
 4289 152a 40E0      		ldi r20,lo8(bufor_pdu)
 4290 152c 50E0      		ldi r21,hi8(bufor_pdu)
 4291 152e 6091 0000 		lds r22,dlugosc_pdu
 4292 1532 CE01      		movw r24,r28
 4293 1534 0E94 0000 		call konwertuj_blok_dwa_znaki_na_znak_pdu
 4294               	.LVL361:
 453:main_sim900.h ****           const uchar nr_smsa = aktualnie_wysylane_polecenie_SIM900 -
 4295               		.loc 2 453 0
 4296 1538 82ED      		ldi r24,lo8(-46)
 4297 153a 0E94 0000 		call dodaj_komende
 4298               	.LVL362:
 456:main_sim900.h ****           flaga_odczytywanie_smsa = TRUE;
 4299               		.loc 2 456 0
 4300 153e 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4301 1542 8C5E      		subi r24,lo8(-(20))
 4302 1544 0E94 0000 		call dodaj_komende
 4303               	.LVL363:
 457:main_sim900.h ****           POMOC_DODAJ2('#', 'O');
 4304               		.loc 2 457 0
 4305 1548 8FEF      		ldi r24,lo8(-1)
 4306 154a 8093 0000 		sts flaga_odczytywanie_smsa,r24
 4307               	.LVL364:
 4308 154e 00C0      		rjmp .L211
 4309               	.LVL365:
 4310               	.L290:
 451:main_sim900.h ****           konwertuj_blok_dwa_znaki_na_znak_pdu(ptr, dlugosc_pdu, bufor_pdu);
 4311               		.loc 2 451 0
 4312 1550 88EC      		ldi r24,lo8(-56)
 4313 1552 00C0      		rjmp .L406
 4314               	.LVL366:
 4315               	.L288:
 4316               	.LBE540:
 460:main_sim900.h ****       } else
 4317               		.loc 2 460 0
 4318 1554 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 4319 1558 00C0      		rjmp .L211
 4320               	.L287:
 4321               	.LBE539:
 4322               	.LBE538:
 463:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 4323               		.loc 2 463 0
 4324 155a D630      		cpi r29,lo8(6)
 4325 155c 01F0      		breq .L292
 4326               	.L414:
 468:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 4327               		.loc 2 468 0
 4328 155e 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 469:main_sim900.h ****       POMOC_DODAJ2('#', 'P');
 4329               		.loc 2 469 0
 4330 1562 8CE3      		ldi r24,lo8(60)
 4331 1564 00C0      		rjmp .L409
 4332               	.L292:
 467:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 4333               		.loc 2 467 0
 4334 1566 8C2F      		mov r24,r28
 4335 1568 0E94 0000 		call dodaj_komende
 4336               	.LVL367:
 4337 156c 00C0      		rjmp .L414
 4338               	.L293:
 502:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 4339               		.loc 2 502 0
 4340 156e D430      		cpi r29,lo8(4)
 4341 1570 01F4      		brne .+2
 4342 1572 00C0      		rjmp .L407
 4343               	.L294:
 504:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 4344               		.loc 2 504 0
 4345 1574 8091 0000 		lds r24,komenda_SIM900
 4346 1578 8038      		cpi r24,lo8(-128)
 4347 157a 01F4      		brne .+2
 4348 157c 00C0      		rjmp .L407
 4349               	.L295:
 4350               	.LVL368:
 507:main_sim900.h ****     break;
 4351               		.loc 2 507 0
 4352 157e 89E1      		ldi r24,lo8(25)
 4353 1580 00C0      		rjmp .L409
 4354               	.LVL369:
 4355               	.L237:
 515:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 4356               		.loc 2 515 0
 4357 1582 D430      		cpi r29,lo8(4)
 4358 1584 01F0      		breq .L296
 515:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 4359               		.loc 2 515 0 is_stmt 0 discriminator 1
 4360 1586 8091 0000 		lds r24,komenda_SIM900
 4361 158a 8038      		cpi r24,lo8(-128)
 4362 158c 01F0      		breq .+2
 4363 158e 00C0      		rjmp .L285
 4364               	.L296:
 516:main_sim900.h ****       if (++liczba_wykonanych_komend_identycznego_polecenia <
 4365               		.loc 2 516 0 is_stmt 1
 4366 1590 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 517:main_sim900.h ****           MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 4367               		.loc 2 517 0
 4368 1594 8091 0000 		lds r24,liczba_wykonanych_komend_identycznego_polecenia
 4369 1598 8F5F      		subi r24,lo8(-(1))
 4370 159a 8093 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,r24
 4371 159e 8330      		cpi r24,lo8(3)
 4372 15a0 00F4      		brsh .L297
 519:main_sim900.h ****       else {
 4373               		.loc 2 519 0
 4374 15a2 86ED      		ldi r24,lo8(-42)
 4375 15a4 00C0      		rjmp .L410
 4376               	.L297:
 521:main_sim900.h ****         zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 4377               		.loc 2 521 0
 4378 15a6 1092 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,__zero_reg__
 522:main_sim900.h ****         trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 4379               		.loc 2 522 0
 4380 15aa 80E0      		ldi r24,0
 4381 15ac 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 4382               	.LVL370:
 523:main_sim900.h ****         wykonywanie_rozmowy_telefonicznej = FALSE;
 4383               		.loc 2 523 0
 4384 15b0 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 524:main_sim900.h ****         licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 4385               		.loc 2 524 0
 4386 15b4 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 525:main_sim900.h ****       }
 4387               		.loc 2 525 0
 4388 15b8 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 4389 15bc 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 4390 15c0 00C0      		rjmp .L211
 4391               	.L216:
 532:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 4392               		.loc 2 532 0
 4393 15c2 D130      		cpi r29,lo8(1)
 4394 15c4 01F0      		breq .L298
 533:main_sim900.h ****       opoznienie_SIM900_100MS = 20;
 4395               		.loc 2 533 0
 4396 15c6 8FE8      		ldi r24,lo8(-113)
 4397 15c8 0E94 0000 		call dodaj_komende
 4398               	.LVL371:
 534:main_sim900.h ****       break;
 4399               		.loc 2 534 0
 4400 15cc 84E1      		ldi r24,lo8(20)
 4401 15ce 00C0      		rjmp .L409
 4402               	.L298:
 557:main_sim900.h ****       if (nastepne_wysylane_polecenie_SIM900 >=
 4403               		.loc 2 557 0
 4404 15d0 8091 0000 		lds r24,nastepne_wysylane_polecenie_SIM900
 4405 15d4 0E94 0000 		call dodaj_komende
 4406               	.LVL372:
 559:main_sim900.h ****           nastepne_wysylane_polecenie_SIM900 <=
 4407               		.loc 2 559 0
 4408 15d8 8091 0000 		lds r24,nastepne_wysylane_polecenie_SIM900
 4409 15dc 8A5A      		subi r24,lo8(-(86))
 558:main_sim900.h ****               KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 4410               		.loc 2 558 0
 4411 15de 8431      		cpi r24,lo8(20)
 4412 15e0 00F0      		brlo .+2
 4413 15e2 00C0      		rjmp .L299
 562:main_sim900.h ****       }
 4414               		.loc 2 562 0
 4415 15e4 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 4416 15e8 00C0      		rjmp .L299
 4417               		.cfi_endproc
 4418               	.LFE50:
 4420               	.global	obsluga_komendy_SIM900
 4422               	obsluga_komendy_SIM900:
 4423               	.LFB51:
 574:main_sim900.h **** 
 575:main_sim900.h **** void obsluga_komendy_SIM900(void) {
 4424               		.loc 2 575 0
 4425               		.cfi_startproc
 4426 15ea 0F93      		push r16
 4427               	.LCFI64:
 4428               		.cfi_def_cfa_offset 3
 4429               		.cfi_offset 16, -2
 4430 15ec 1F93      		push r17
 4431               	.LCFI65:
 4432               		.cfi_def_cfa_offset 4
 4433               		.cfi_offset 17, -3
 4434 15ee CF93      		push r28
 4435               	.LCFI66:
 4436               		.cfi_def_cfa_offset 5
 4437               		.cfi_offset 28, -4
 4438 15f0 DF93      		push r29
 4439               	.LCFI67:
 4440               		.cfi_def_cfa_offset 6
 4441               		.cfi_offset 29, -5
 4442               	/* prologue: function */
 4443               	/* frame size = 0 */
 4444               	/* stack size = 4 */
 4445               	.L__stack_usage = 4
 576:main_sim900.h ****   if (!czy_jest_bezczynny_SIM900())
 4446               		.loc 2 576 0
 4447 15f2 8091 0000 		lds r24,komenda_SIM900
 577:main_sim900.h ****     POMOC_SIM900_DODAJ(odebrany_blok_SIM900);
 578:main_sim900.h **** 
 579:main_sim900.h ****   if (czy_jest_blad_SIM900() || oproznij_bufor_SIM900_po_bledzie) {
 4448               		.loc 2 579 0
 4449 15f6 8091 0000 		lds r24,komenda_SIM900
 4450 15fa 8038      		cpi r24,lo8(-128)
 4451 15fc 01F0      		breq .L416
 4452               		.loc 2 579 0 is_stmt 0 discriminator 1
 4453 15fe 8091 0000 		lds r24,oproznij_bufor_SIM900_po_bledzie
 4454 1602 8823      		tst r24
 4455 1604 01F0      		breq .L417
 4456               	.L416:
 580:main_sim900.h ****     komenda_SIM900 = BLAD_SIM900;
 4457               		.loc 2 580 0 is_stmt 1
 4458 1606 80E8      		ldi r24,lo8(-128)
 4459 1608 8093 0000 		sts komenda_SIM900,r24
 581:main_sim900.h ****     odpowiedz_na_polecenie();
 4460               		.loc 2 581 0
 4461 160c 0E94 0000 		call odpowiedz_na_polecenie
 4462               	.LVL373:
 582:main_sim900.h ****     opoznienie_SIM900_100MS = 50;
 4463               		.loc 2 582 0
 4464 1610 82E3      		ldi r24,lo8(50)
 4465 1612 8093 0000 		sts opoznienie_SIM900_100MS,r24
 583:main_sim900.h ****     oproznij_bufor_SIM900_po_bledzie = TRUE;
 4466               		.loc 2 583 0
 4467 1616 8FEF      		ldi r24,lo8(-1)
 4468 1618 8093 0000 		sts oproznij_bufor_SIM900_po_bledzie,r24
 4469               	.LVL374:
 4470               	.L415:
 4471               	/* epilogue start */
 584:main_sim900.h ****     POMOC_DODAJ2('*', 'd');
 585:main_sim900.h ****     return;
 586:main_sim900.h ****   }
 587:main_sim900.h **** 
 588:main_sim900.h ****   if (czy_jest_komenda_wyslane_polecenie_SIM900()) {
 589:main_sim900.h ****     if ((liczba_wysylanych_znakow_SIM900 != liczba_odebranych_znakow_SIM900 ||
 590:main_sim900.h ****          memcmp(odebrany_blok_SIM900, wysylany_blok_SIM900,
 591:main_sim900.h ****                 liczba_wysylanych_znakow_SIM900) != 0) &&
 592:main_sim900.h ****         !czekanie_na_odebranie_zachety) {
 593:main_sim900.h ****       komenda_SIM900 = BLAD_SIM900;
 594:main_sim900.h ****       oproznij_bufor_SIM900_po_bledzie = TRUE;
 595:main_sim900.h ****       opoznienie_SIM900_100MS = 50;
 596:main_sim900.h ****       POMOC_DODAJ2('*', 'e');
 597:main_sim900.h ****     }
 598:main_sim900.h ****     return;
 599:main_sim900.h ****   }
 600:main_sim900.h **** 
 601:main_sim900.h ****   if (czy_jest_komenda_rozmowa_telefoniczna()) {
 602:main_sim900.h ****     POMOC_DODAJ2('#', 'b');
 603:main_sim900.h ****     // numer_telefonu_ktory_dzwoni[0] = '\0';  // REMOVED: Niepotrzebne
 604:main_sim900.h ****     // czyszczenie - numer jest zaraz nadpisywany
 605:main_sim900.h ****     const uchar *p1 = strchr(polozenie_polecenia_SIM900(PSTR("+CLIP:")), '\"');
 606:main_sim900.h ****     if (p1++ != NULL) {
 607:main_sim900.h ****       const uchar *p2 = strchr(p1, '\"');
 608:main_sim900.h ****       if (p2 != NULL) {
 609:main_sim900.h ****         const uchar l = p2 - p1;
 610:main_sim900.h ****         if (l < MAX_LICZBA_ZNAKOW_TELEFON) {
 611:main_sim900.h ****           memcpy(numer_telefonu_ktory_dzwoni, p1, l);
 612:main_sim900.h ****           numer_telefonu_ktory_dzwoni[l] = '\0';
 613:main_sim900.h ****           POMOC_DODAJ_HEX(l);
 614:main_sim900.h ****           if (licznik_blad_zalogowania_u_operatora != 0)
 615:main_sim900.h ****             licznik_blad_zalogowania_u_operatora = 0;
 616:main_sim900.h ****           if (poziom_sieci_gsm == 0 || poziom_sieci_gsm == POZIOM_SIECI_BLAD)
 617:main_sim900.h ****             poziom_sieci_gsm = 16;
 618:main_sim900.h ****         }
 619:main_sim900.h ****       }
 620:main_sim900.h ****     }
 621:main_sim900.h ****     filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_PRZYCHODZACA_ROZMOWE);
 622:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 623:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 624:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 625:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 626:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 627:main_sim900.h ****     }
 628:main_sim900.h ****     wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 629:main_sim900.h ****     return;
 630:main_sim900.h ****   }
 631:main_sim900.h **** 
 632:main_sim900.h ****   if (czy_jest_komenda_zakonczenie_rozmowy_telefonicznej()) {
 633:main_sim900.h ****     POMOC_DODAJ2('#', 'c');
 634:main_sim900.h ****     zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 635:main_sim900.h ****     trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 636:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 637:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 638:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 ==
 639:main_sim900.h ****         KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE) {
 640:main_sim900.h ****       wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 641:main_sim900.h ****     }
 642:main_sim900.h ****     return;
 643:main_sim900.h ****   }
 644:main_sim900.h **** 
 645:main_sim900.h ****   if (czy_jest_komenda_uzytkownik_odebral_dzwonek()) {
 646:main_sim900.h ****     POMOC_DODAJ2('#', 'd');
 647:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 == KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE)
 648:main_sim900.h ****       odpowiedz_na_polecenie();
 649:main_sim900.h ****     if (ustaw_maksymalny_czas_dzwonienia == 0)
 650:main_sim900.h ****       maksymalny_czas_dzwonienia = 90; // standardowy czas czekania 9 sekund
 651:main_sim900.h ****     else {
 652:main_sim900.h ****       maksymalny_czas_dzwonienia = ustaw_maksymalny_czas_dzwonienia;
 653:main_sim900.h ****       ustaw_maksymalny_czas_dzwonienia = 0;
 654:main_sim900.h ****     }
 655:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = TRUE;
 656:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 657:main_sim900.h ****     return;
 658:main_sim900.h ****   }
 659:main_sim900.h **** 
 660:main_sim900.h ****   // Obsluga +DTMF:
 661:main_sim900.h ****   const uchar *ptr_dtmf = polozenie_polecenia_SIM900(PSTR("+DTMF:"));
 662:main_sim900.h ****   if (ptr_dtmf != NULL) {
 663:main_sim900.h ****     POMOC_DODAJ2('#', 'D');
 664:main_sim900.h ****     ptr_dtmf += 7; // Skip "+DTMF: "
 665:main_sim900.h ****     while (*ptr_dtmf == ' ')
 666:main_sim900.h ****       ++ptr_dtmf;
 667:main_sim900.h ****     const uchar dtmf_key = *ptr_dtmf;
 668:main_sim900.h ****     POMOC_DODAJ(dtmf_key);
 669:main_sim900.h **** 
 670:main_sim900.h ****     if (!tryb_clip) // Tylko w trybie DTMF
 671:main_sim900.h ****     {
 672:main_sim900.h ****       if (dtmf_key == '1') {
 673:main_sim900.h ****         stan_wyjscie[0] = TRUE;
 674:main_sim900.h ****         licznik_przelacznik_wyjscia[0] = 2 * 10ul; // 2 sekundy retrigger
 675:main_sim900.h ****         zapal_diode_led(10);
 676:main_sim900.h ****       }
 677:main_sim900.h ****     }
 678:main_sim900.h ****     resetuj_komende_SIM900(); // Krytyczne dla kolejnych znakow
 679:main_sim900.h ****     return;
 680:main_sim900.h ****   }
 681:main_sim900.h **** 
 682:main_sim900.h ****   if (czy_jest_komenda_uzytkownik_odebral_rozmowe()) {
 683:main_sim900.h ****     POMOC_DODAJ2('#', 'e');
 684:main_sim900.h ****     if (tryb_clip) {
 685:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 686:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
 687:main_sim900.h ****     }
 688:main_sim900.h ****     return;
 689:main_sim900.h ****   }
 690:main_sim900.h ****   if (czy_jest_komenda_brak_sygnalu_tonowego()) {
 691:main_sim900.h ****     POMOC_DODAJ2('#', 'f');
 692:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 == KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE)
 693:main_sim900.h ****       odpowiedz_na_polecenie();
 694:main_sim900.h ****     zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 695:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 696:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 697:main_sim900.h ****     return;
 698:main_sim900.h ****   }
 699:main_sim900.h **** 
 700:main_sim900.h ****   if (czy_jest_komenda_telefon_zajety()) {
 701:main_sim900.h ****     POMOC_DODAJ2('#', 'g');
 702:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 == KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE)
 703:main_sim900.h ****       odpowiedz_na_polecenie();
 704:main_sim900.h ****     zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 705:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 706:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 707:main_sim900.h ****     return;
 708:main_sim900.h ****   }
 709:main_sim900.h **** 
 710:main_sim900.h ****   if (czy_jest_komenda_nowy_SMS()) {
 711:main_sim900.h ****     const uchar *ptr = strchr(polozenie_polecenia_SIM900(PSTR("+CMTI:")), ',');
 712:main_sim900.h ****     if (ptr != NULL) {
 713:main_sim900.h ****       uint numer_smsa = (uint)strtoul(ptr + 1, NULL, 10);
 714:main_sim900.h ****       if (numer_smsa > 0 && numer_smsa <= 20) // Hardcoded 20
 715:main_sim900.h ****       {
 716:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 + numer_smsa - 1);
 717:main_sim900.h ****         opoznienie_SIM900_100MS = 1; // 20 (1)
 718:main_sim900.h ****       }
 719:main_sim900.h ****     }
 720:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 721:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 722:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 723:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 724:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 725:main_sim900.h ****       wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 726:main_sim900.h ****     }
 727:main_sim900.h ****     return;
 728:main_sim900.h ****   }
 729:main_sim900.h **** 
 730:main_sim900.h ****   if (czy_jest_komenda_otrzymano_sms_flash()) {
 731:main_sim900.h ****     opoznienie_SIM900_100MS = 20;
 732:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 733:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 734:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 735:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 736:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 737:main_sim900.h ****       wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 738:main_sim900.h ****     }
 739:main_sim900.h ****     const uchar *p1 = strchr(polozenie_polecenia_SIM900(PSTR("+CUSD:")), '\"');
 740:main_sim900.h ****     if (p1++ != NULL) {
 741:main_sim900.h ****       uchar *p2 = strchr(p1, '\"');
 742:main_sim900.h ****       if (p2 != NULL) {
 743:main_sim900.h ****         //*p2 = '\0';
 744:main_sim900.h ****         // tekst_wysylanego_smsa[0] = '*';
 745:main_sim900.h ****         // strncpy(&tekst_wysylanego_smsa[1], p1, MAX_LICZBA_ZNAKOW_SMS - 1);
 746:main_sim900.h ****         // tekst_wysylanego_smsa[MAX_LICZBA_ZNAKOW_SMS] = 0;
 747:main_sim900.h ****       }
 748:main_sim900.h ****     }
 749:main_sim900.h ****     return;
 750:main_sim900.h ****   }
 751:main_sim900.h **** 
 752:main_sim900.h ****   if (flaga_wysylanie_smsa)
 753:main_sim900.h ****     obsluga_wysylania_sms();
 754:main_sim900.h **** 
 755:main_sim900.h ****   if (liczba_odebranych_znakow_SIM900 != 0 &&
 756:main_sim900.h ****       komenda_SIM900 != BRAK_KOMENDY_SIM900)
 757:main_sim900.h ****     odpowiedz_na_polecenie();
 758:main_sim900.h **** }
 4472               		.loc 2 758 0
 4473 161c DF91      		pop r29
 4474 161e CF91      		pop r28
 4475 1620 1F91      		pop r17
 4476 1622 0F91      		pop r16
 4477 1624 0895      		ret
 4478               	.L417:
 588:main_sim900.h ****     if ((liczba_wysylanych_znakow_SIM900 != liczba_odebranych_znakow_SIM900 ||
 4479               		.loc 2 588 0
 4480 1626 8091 0000 		lds r24,komenda_SIM900
 4481 162a 8138      		cpi r24,lo8(-127)
 4482 162c 01F4      		brne .L419
 589:main_sim900.h ****          memcmp(odebrany_blok_SIM900, wysylany_blok_SIM900,
 4483               		.loc 2 589 0
 4484 162e 2091 0000 		lds r18,liczba_wysylanych_znakow_SIM900
 4485 1632 3091 0000 		lds r19,liczba_wysylanych_znakow_SIM900+1
 4486 1636 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 4487 163a 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
 4488 163e 2817      		cp r18,r24
 4489 1640 3907      		cpc r19,r25
 4490 1642 01F4      		brne .L420
 590:main_sim900.h ****                 liczba_wysylanych_znakow_SIM900) != 0) &&
 4491               		.loc 2 590 0 discriminator 1
 4492 1644 4091 0000 		lds r20,liczba_wysylanych_znakow_SIM900
 4493 1648 5091 0000 		lds r21,liczba_wysylanych_znakow_SIM900+1
 4494 164c 60E0      		ldi r22,lo8(wysylany_blok_SIM900)
 4495 164e 70E0      		ldi r23,hi8(wysylany_blok_SIM900)
 4496 1650 80E0      		ldi r24,lo8(odebrany_blok_SIM900)
 4497 1652 90E0      		ldi r25,hi8(odebrany_blok_SIM900)
 4498 1654 0E94 0000 		call memcmp
 4499               	.LVL375:
 589:main_sim900.h ****          memcmp(odebrany_blok_SIM900, wysylany_blok_SIM900,
 4500               		.loc 2 589 0 discriminator 1
 4501 1658 892B      		or r24,r25
 4502 165a 01F0      		breq .L415
 4503               	.L420:
 592:main_sim900.h ****       komenda_SIM900 = BLAD_SIM900;
 4504               		.loc 2 592 0
 4505 165c 8091 0000 		lds r24,czekanie_na_odebranie_zachety
 591:main_sim900.h ****         !czekanie_na_odebranie_zachety) {
 4506               		.loc 2 591 0
 4507 1660 8111      		cpse r24,__zero_reg__
 4508 1662 00C0      		rjmp .L415
 593:main_sim900.h ****       oproznij_bufor_SIM900_po_bledzie = TRUE;
 4509               		.loc 2 593 0
 4510 1664 80E8      		ldi r24,lo8(-128)
 4511 1666 8093 0000 		sts komenda_SIM900,r24
 594:main_sim900.h ****       opoznienie_SIM900_100MS = 50;
 4512               		.loc 2 594 0
 4513 166a 8FEF      		ldi r24,lo8(-1)
 4514 166c 8093 0000 		sts oproznij_bufor_SIM900_po_bledzie,r24
 595:main_sim900.h ****       POMOC_DODAJ2('*', 'e');
 4515               		.loc 2 595 0
 4516 1670 82E3      		ldi r24,lo8(50)
 4517 1672 8093 0000 		sts opoznienie_SIM900_100MS,r24
 4518               	.LVL376:
 4519 1676 00C0      		rjmp .L415
 4520               	.LVL377:
 4521               	.L419:
 4522               	.LBB555:
 4523               	.LBB556:
 601:main_sim900.h ****     POMOC_DODAJ2('#', 'b');
 4524               		.loc 2 601 0
 4525 1678 8091 0000 		lds r24,komenda_SIM900
 4526 167c 8A30      		cpi r24,lo8(10)
 4527 167e 01F0      		breq .+2
 4528 1680 00C0      		rjmp .L422
 4529               	.LVL378:
 4530               	.LBB557:
 605:main_sim900.h ****     if (p1++ != NULL) {
 4531               		.loc 2 605 0
 4532 1682 80E0      		ldi r24,lo8(__c.3324)
 4533 1684 90E0      		ldi r25,hi8(__c.3324)
 4534 1686 0E94 0000 		call polozenie_polecenia_SIM900
 4535               	.LVL379:
 4536 168a 62E2      		ldi r22,lo8(34)
 4537 168c 70E0      		ldi r23,0
 4538 168e 0E94 0000 		call strchr
 4539               	.LVL380:
 606:main_sim900.h ****       const uchar *p2 = strchr(p1, '\"');
 4540               		.loc 2 606 0
 4541 1692 0097      		sbiw r24,0
 4542 1694 01F0      		breq .L424
 4543 1696 8C01      		movw r16,r24
 4544 1698 0F5F      		subi r16,-1
 4545 169a 1F4F      		sbci r17,-1
 4546               	.LVL381:
 4547               	.LBB558:
 607:main_sim900.h ****       if (p2 != NULL) {
 4548               		.loc 2 607 0
 4549 169c 62E2      		ldi r22,lo8(34)
 4550 169e 70E0      		ldi r23,0
 4551 16a0 C801      		movw r24,r16
 4552 16a2 0E94 0000 		call strchr
 4553               	.LVL382:
 608:main_sim900.h ****         const uchar l = p2 - p1;
 4554               		.loc 2 608 0
 4555 16a6 0097      		sbiw r24,0
 4556 16a8 01F0      		breq .L424
 4557               	.LBB559:
 609:main_sim900.h ****         if (l < MAX_LICZBA_ZNAKOW_TELEFON) {
 4558               		.loc 2 609 0
 4559 16aa EC01      		movw r28,r24
 4560 16ac C01B      		sub r28,r16
 4561 16ae D10B      		sbc r29,r17
 4562               	.LVL383:
 610:main_sim900.h ****           memcpy(numer_telefonu_ktory_dzwoni, p1, l);
 4563               		.loc 2 610 0
 4564 16b0 C031      		cpi r28,lo8(16)
 4565 16b2 00F4      		brsh .L424
 4566 16b4 DD27      		clr r29
 4567               	.LVL384:
 611:main_sim900.h ****           numer_telefonu_ktory_dzwoni[l] = '\0';
 4568               		.loc 2 611 0
 4569 16b6 AE01      		movw r20,r28
 4570 16b8 B801      		movw r22,r16
 4571 16ba 80E0      		ldi r24,lo8(numer_telefonu_ktory_dzwoni)
 4572 16bc 90E0      		ldi r25,hi8(numer_telefonu_ktory_dzwoni)
 4573               	.LVL385:
 4574 16be 0E94 0000 		call memcpy
 4575               	.LVL386:
 612:main_sim900.h ****           POMOC_DODAJ_HEX(l);
 4576               		.loc 2 612 0
 4577 16c2 C050      		subi r28,lo8(-(numer_telefonu_ktory_dzwoni))
 4578 16c4 D040      		sbci r29,hi8(-(numer_telefonu_ktory_dzwoni))
 4579 16c6 1882      		st Y,__zero_reg__
 4580               	.LVL387:
 614:main_sim900.h ****             licznik_blad_zalogowania_u_operatora = 0;
 4581               		.loc 2 614 0
 4582 16c8 8091 0000 		lds r24,licznik_blad_zalogowania_u_operatora
 4583 16cc 8111      		cpse r24,__zero_reg__
 615:main_sim900.h ****           if (poziom_sieci_gsm == 0 || poziom_sieci_gsm == POZIOM_SIECI_BLAD)
 4584               		.loc 2 615 0
 4585 16ce 1092 0000 		sts licznik_blad_zalogowania_u_operatora,__zero_reg__
 4586               	.L426:
 616:main_sim900.h ****             poziom_sieci_gsm = 16;
 4587               		.loc 2 616 0
 4588 16d2 8091 0000 		lds r24,poziom_sieci_gsm
 4589 16d6 8823      		tst r24
 4590 16d8 01F0      		breq .L427
 4591 16da 8336      		cpi r24,lo8(99)
 4592 16dc 01F4      		brne .L424
 4593               	.L427:
 617:main_sim900.h ****         }
 4594               		.loc 2 617 0
 4595 16de 80E1      		ldi r24,lo8(16)
 4596 16e0 8093 0000 		sts poziom_sieci_gsm,r24
 4597               	.LVL388:
 4598               	.L424:
 4599               	.LBE559:
 4600               	.LBE558:
 621:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 4601               		.loc 2 621 0
 4602 16e4 88E9      		ldi r24,lo8(-104)
 4603 16e6 0E94 0000 		call filtruj_i_dodaj_komende
 4604               	.LVL389:
 623:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 4605               		.loc 2 623 0
 4606 16ea 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4607 16ee 8A5A      		subi r24,lo8(-(86))
 622:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 4608               		.loc 2 622 0
 4609 16f0 8431      		cpi r24,lo8(20)
 4610 16f2 00F4      		brsh .L428
 4611               	.LVL390:
 4612               	.L484:
 626:main_sim900.h ****     }
 4613               		.loc 2 626 0
 4614 16f4 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 4615               	.L428:
 628:main_sim900.h ****     return;
 4616               		.loc 2 628 0
 4617 16f8 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 4618 16fc 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 4619 1700 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
 4620 1704 00C0      		rjmp .L415
 4621               	.L422:
 4622               	.LBE557:
 632:main_sim900.h ****     POMOC_DODAJ2('#', 'c');
 4623               		.loc 2 632 0
 4624 1706 8091 0000 		lds r24,komenda_SIM900
 4625 170a 8330      		cpi r24,lo8(3)
 4626 170c 01F4      		brne .L429
 4627               	.LVL391:
 634:main_sim900.h ****     trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 4628               		.loc 2 634 0
 4629 170e 80E0      		ldi r24,0
 4630 1710 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 4631               	.LVL392:
 635:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 4632               		.loc 2 635 0
 4633 1714 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 636:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 4634               		.loc 2 636 0
 4635 1718 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 637:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 ==
 4636               		.loc 2 637 0
 4637 171c 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 4638 1720 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 638:main_sim900.h ****         KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE) {
 4639               		.loc 2 638 0
 4640 1724 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4641 1728 863D      		cpi r24,lo8(-42)
 4642 172a 01F0      		breq .+2
 4643 172c 00C0      		rjmp .L415
 4644 172e 00C0      		rjmp .L428
 4645               	.LVL393:
 4646               	.L429:
 645:main_sim900.h ****     POMOC_DODAJ2('#', 'd');
 4647               		.loc 2 645 0
 4648 1730 8091 0000 		lds r24,komenda_SIM900
 4649 1734 8230      		cpi r24,lo8(2)
 4650 1736 01F4      		brne .L430
 4651               	.LVL394:
 647:main_sim900.h ****       odpowiedz_na_polecenie();
 4652               		.loc 2 647 0
 4653 1738 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4654 173c 863D      		cpi r24,lo8(-42)
 4655 173e 01F4      		brne .L431
 648:main_sim900.h ****     if (ustaw_maksymalny_czas_dzwonienia == 0)
 4656               		.loc 2 648 0
 4657 1740 0E94 0000 		call odpowiedz_na_polecenie
 4658               	.LVL395:
 4659               	.L431:
 649:main_sim900.h ****       maksymalny_czas_dzwonienia = 90; // standardowy czas czekania 9 sekund
 4660               		.loc 2 649 0
 4661 1744 8091 0000 		lds r24,ustaw_maksymalny_czas_dzwonienia
 4662 1748 8111      		cpse r24,__zero_reg__
 4663 174a 00C0      		rjmp .L432
 650:main_sim900.h ****     else {
 4664               		.loc 2 650 0
 4665 174c 8AE5      		ldi r24,lo8(90)
 4666 174e 8093 0000 		sts maksymalny_czas_dzwonienia,r24
 4667               	.L433:
 655:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 4668               		.loc 2 655 0
 4669 1752 8FEF      		ldi r24,lo8(-1)
 4670 1754 8093 0000 		sts wykonywanie_rozmowy_telefonicznej,r24
 4671               	.LVL396:
 4672               	.L485:
 696:main_sim900.h ****     return;
 4673               		.loc 2 696 0
 4674 1758 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 4675 175c 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 4676 1760 00C0      		rjmp .L415
 4677               	.LVL397:
 4678               	.L432:
 652:main_sim900.h ****       ustaw_maksymalny_czas_dzwonienia = 0;
 4679               		.loc 2 652 0
 4680 1762 8093 0000 		sts maksymalny_czas_dzwonienia,r24
 653:main_sim900.h ****     }
 4681               		.loc 2 653 0
 4682 1766 1092 0000 		sts ustaw_maksymalny_czas_dzwonienia,__zero_reg__
 4683 176a 00C0      		rjmp .L433
 4684               	.LVL398:
 4685               	.L430:
 661:main_sim900.h ****   if (ptr_dtmf != NULL) {
 4686               		.loc 2 661 0
 4687 176c 80E0      		ldi r24,lo8(__c.3329)
 4688 176e 90E0      		ldi r25,hi8(__c.3329)
 4689 1770 0E94 0000 		call polozenie_polecenia_SIM900
 4690               	.LVL399:
 662:main_sim900.h ****     POMOC_DODAJ2('#', 'D');
 4691               		.loc 2 662 0
 4692 1774 0097      		sbiw r24,0
 4693 1776 01F0      		breq .L434
 4694               	.LVL400:
 4695               	.LBB560:
 664:main_sim900.h ****     while (*ptr_dtmf == ' ')
 4696               		.loc 2 664 0
 4697 1778 FC01      		movw r30,r24
 4698 177a 3796      		adiw r30,7
 4699               	.LVL401:
 4700               	.L435:
 665:main_sim900.h ****       ++ptr_dtmf;
 4701               		.loc 2 665 0
 4702 177c 8191      		ld r24,Z+
 4703               	.LVL402:
 4704 177e 8032      		cpi r24,lo8(32)
 4705 1780 01F0      		breq .L435
 4706               	.LVL403:
 670:main_sim900.h ****     {
 4707               		.loc 2 670 0
 4708 1782 9091 0000 		lds r25,tryb_clip
 4709 1786 9111      		cpse r25,__zero_reg__
 4710 1788 00C0      		rjmp .L436
 672:main_sim900.h ****         stan_wyjscie[0] = TRUE;
 4711               		.loc 2 672 0
 4712 178a 8133      		cpi r24,lo8(49)
 4713 178c 01F4      		brne .L436
 673:main_sim900.h ****         licznik_przelacznik_wyjscia[0] = 2 * 10ul; // 2 sekundy retrigger
 4714               		.loc 2 673 0
 4715 178e 8FEF      		ldi r24,lo8(-1)
 4716               	.LVL404:
 4717 1790 8093 0000 		sts stan_wyjscie,r24
 4718               	.LVL405:
 674:main_sim900.h ****         zapal_diode_led(10);
 4719               		.loc 2 674 0
 4720 1794 84E1      		ldi r24,lo8(20)
 4721 1796 90E0      		ldi r25,0
 4722 1798 A0E0      		ldi r26,0
 4723 179a B0E0      		ldi r27,0
 4724 179c 8093 0000 		sts licznik_przelacznik_wyjscia,r24
 4725 17a0 9093 0000 		sts licznik_przelacznik_wyjscia+1,r25
 4726 17a4 A093 0000 		sts licznik_przelacznik_wyjscia+2,r26
 4727 17a8 B093 0000 		sts licznik_przelacznik_wyjscia+3,r27
 675:main_sim900.h ****       }
 4728               		.loc 2 675 0
 4729 17ac 8BE0      		ldi r24,lo8(11)
 4730 17ae 8093 0000 		sts licznik_100ms_dioda_led,r24
 4731               	.L436:
 678:main_sim900.h ****     return;
 4732               		.loc 2 678 0
 4733 17b2 1092 0000 		sts komenda_SIM900,__zero_reg__
 4734 17b6 00C0      		rjmp .L415
 4735               	.LVL406:
 4736               	.L434:
 4737               	.LBE560:
 682:main_sim900.h ****     POMOC_DODAJ2('#', 'e');
 4738               		.loc 2 682 0
 4739 17b8 8091 0000 		lds r24,komenda_SIM900
 4740               	.LVL407:
 4741 17bc 8C30      		cpi r24,lo8(12)
 4742 17be 01F4      		brne .L437
 4743               	.LVL408:
 684:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 4744               		.loc 2 684 0
 4745 17c0 8091 0000 		lds r24,tryb_clip
 4746 17c4 8823      		tst r24
 4747 17c6 01F4      		brne .+2
 4748 17c8 00C0      		rjmp .L415
 685:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
 4749               		.loc 2 685 0
 4750 17ca 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 686:main_sim900.h ****     }
 4751               		.loc 2 686 0
 4752 17ce 87E9      		ldi r24,lo8(-105)
 4753               	/* epilogue start */
 4754               	.LBE556:
 4755               	.LBE555:
 4756               		.loc 2 758 0
 4757 17d0 DF91      		pop r29
 4758 17d2 CF91      		pop r28
 4759 17d4 1F91      		pop r17
 4760 17d6 0F91      		pop r16
 4761               	.LBB566:
 4762               	.LBB564:
 686:main_sim900.h ****     }
 4763               		.loc 2 686 0
 4764 17d8 0C94 0000 		jmp dodaj_komende
 4765               	.LVL409:
 4766               	.L437:
 690:main_sim900.h ****     POMOC_DODAJ2('#', 'f');
 4767               		.loc 2 690 0
 4768 17dc 8091 0000 		lds r24,komenda_SIM900
 4769 17e0 8930      		cpi r24,lo8(9)
 4770 17e2 01F4      		brne .L438
 4771               	.L482:
 4772               	.LVL410:
 692:main_sim900.h ****       odpowiedz_na_polecenie();
 4773               		.loc 2 692 0
 4774 17e4 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4775 17e8 863D      		cpi r24,lo8(-42)
 4776 17ea 01F4      		brne .L439
 693:main_sim900.h ****     zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 4777               		.loc 2 693 0
 4778 17ec 0E94 0000 		call odpowiedz_na_polecenie
 4779               	.LVL411:
 4780               	.L439:
 694:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 4781               		.loc 2 694 0
 4782 17f0 80E0      		ldi r24,0
 4783 17f2 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 4784               	.LVL412:
 695:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 4785               		.loc 2 695 0
 4786 17f6 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 4787 17fa 00C0      		rjmp .L485
 4788               	.LVL413:
 4789               	.L438:
 700:main_sim900.h ****     POMOC_DODAJ2('#', 'g');
 4790               		.loc 2 700 0
 4791 17fc 8091 0000 		lds r24,komenda_SIM900
 4792 1800 8730      		cpi r24,lo8(7)
 4793 1802 01F0      		breq .L482
 710:main_sim900.h ****     const uchar *ptr = strchr(polozenie_polecenia_SIM900(PSTR("+CMTI:")), ',');
 4794               		.loc 2 710 0
 4795 1804 8091 0000 		lds r24,komenda_SIM900
 4796 1808 8830      		cpi r24,lo8(8)
 4797 180a 01F4      		brne .L442
 4798               	.LBB561:
 711:main_sim900.h ****     if (ptr != NULL) {
 4799               		.loc 2 711 0
 4800 180c 80E0      		ldi r24,lo8(__c.3336)
 4801 180e 90E0      		ldi r25,hi8(__c.3336)
 4802 1810 0E94 0000 		call polozenie_polecenia_SIM900
 4803               	.LVL414:
 4804 1814 6CE2      		ldi r22,lo8(44)
 4805 1816 70E0      		ldi r23,0
 4806 1818 0E94 0000 		call strchr
 4807               	.LVL415:
 712:main_sim900.h ****       uint numer_smsa = (uint)strtoul(ptr + 1, NULL, 10);
 4808               		.loc 2 712 0
 4809 181c 0097      		sbiw r24,0
 4810 181e 01F0      		breq .L444
 4811               	.LBB562:
 713:main_sim900.h ****       if (numer_smsa > 0 && numer_smsa <= 20) // Hardcoded 20
 4812               		.loc 2 713 0
 4813 1820 4AE0      		ldi r20,lo8(10)
 4814 1822 50E0      		ldi r21,0
 4815 1824 70E0      		ldi r23,0
 4816 1826 60E0      		ldi r22,0
 4817 1828 0196      		adiw r24,1
 4818               	.LVL416:
 4819 182a 0E94 0000 		call strtoul
 4820               	.LVL417:
 714:main_sim900.h ****       {
 4821               		.loc 2 714 0
 4822 182e 9B01      		movw r18,r22
 4823 1830 2150      		subi r18,1
 4824 1832 3109      		sbc r19,__zero_reg__
 4825 1834 2431      		cpi r18,20
 4826 1836 3105      		cpc r19,__zero_reg__
 4827 1838 00F4      		brsh .L444
 716:main_sim900.h ****         opoznienie_SIM900_100MS = 1; // 20 (1)
 4828               		.loc 2 716 0
 4829 183a 89EA      		ldi r24,lo8(-87)
 4830 183c 860F      		add r24,r22
 4831 183e 0E94 0000 		call dodaj_komende
 4832               	.LVL418:
 717:main_sim900.h ****       }
 4833               		.loc 2 717 0
 4834 1842 81E0      		ldi r24,lo8(1)
 4835               	.L483:
 4836 1844 8093 0000 		sts opoznienie_SIM900_100MS,r24
 4837               	.L444:
 4838               	.LBE562:
 721:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 4839               		.loc 2 721 0
 4840 1848 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4841 184c 8A5A      		subi r24,lo8(-(86))
 720:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 4842               		.loc 2 720 0
 4843 184e 8431      		cpi r24,lo8(20)
 4844 1850 00F4      		brsh .+2
 4845 1852 00C0      		rjmp .L484
 4846 1854 00C0      		rjmp .L415
 4847               	.L442:
 4848               	.LBE561:
 730:main_sim900.h ****     opoznienie_SIM900_100MS = 20;
 4849               		.loc 2 730 0
 4850 1856 8091 0000 		lds r24,komenda_SIM900
 4851 185a 8E30      		cpi r24,lo8(14)
 4852 185c 01F4      		brne .L446
 4853               	.LBB563:
 731:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 4854               		.loc 2 731 0
 4855 185e 84E1      		ldi r24,lo8(20)
 4856 1860 00C0      		rjmp .L483
 4857               	.L446:
 4858               	.LBE563:
 752:main_sim900.h ****     obsluga_wysylania_sms();
 4859               		.loc 2 752 0
 4860 1862 8091 0000 		lds r24,flaga_wysylanie_smsa
 4861 1866 8111      		cpse r24,__zero_reg__
 753:main_sim900.h **** 
 4862               		.loc 2 753 0
 4863 1868 0E94 0000 		call obsluga_wysylania_sms
 4864               	.LVL419:
 4865               	.L448:
 755:main_sim900.h ****       komenda_SIM900 != BRAK_KOMENDY_SIM900)
 4866               		.loc 2 755 0
 4867 186c 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 4868 1870 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
 4869 1874 892B      		or r24,r25
 4870 1876 01F4      		brne .+2
 4871 1878 00C0      		rjmp .L415
 756:main_sim900.h ****     odpowiedz_na_polecenie();
 4872               		.loc 2 756 0
 4873 187a 8091 0000 		lds r24,komenda_SIM900
 755:main_sim900.h ****       komenda_SIM900 != BRAK_KOMENDY_SIM900)
 4874               		.loc 2 755 0
 4875 187e 8823      		tst r24
 4876 1880 01F4      		brne .+2
 4877 1882 00C0      		rjmp .L415
 4878               	/* epilogue start */
 4879               	.LBE564:
 4880               	.LBE566:
 4881               		.loc 2 758 0
 4882 1884 DF91      		pop r29
 4883 1886 CF91      		pop r28
 4884 1888 1F91      		pop r17
 4885 188a 0F91      		pop r16
 4886               	.LBB567:
 4887               	.LBB565:
 757:main_sim900.h **** }
 4888               		.loc 2 757 0
 4889 188c 0C94 0000 		jmp odpowiedz_na_polecenie
 4890               	.LVL420:
 4891               	.LBE565:
 4892               	.LBE567:
 4893               		.cfi_endproc
 4894               	.LFE51:
 4896               	.global	wyslanie_polecenia_ROM
 4898               	wyslanie_polecenia_ROM:
 4899               	.LFB52:
 759:main_sim900.h **** 
 760:main_sim900.h **** uchar wyslanie_polecenia_ROM(const uchar czy_mozna_wysylac_dane_do_SIM900,
 761:main_sim900.h ****                              const komenda_typ wykonywana_komenda,
 762:main_sim900.h ****                              const komenda_typ nastepne_wysylane_polecenie,
 763:main_sim900.h ****                              PGM_P instrukcja) {
 4900               		.loc 2 763 0
 4901               		.cfi_startproc
 4902               	.LVL421:
 4903               	/* prologue: function */
 4904               	/* frame size = 0 */
 4905               	/* stack size = 0 */
 4906               	.L__stack_usage = 0
 764:main_sim900.h ****   if (!czy_mozna_wysylac_dane_do_SIM900) {
 4907               		.loc 2 764 0
 4908 1890 8111      		cpse r24,__zero_reg__
 4909 1892 00C0      		rjmp .L487
 765:main_sim900.h ****     dodaj_komende(wykonywana_komenda);
 4910               		.loc 2 765 0
 4911 1894 862F      		mov r24,r22
 4912               	.LVL422:
 4913 1896 0E94 0000 		call dodaj_komende
 4914               	.LVL423:
 766:main_sim900.h ****     return FALSE;
 4915               		.loc 2 766 0
 4916 189a 80E0      		ldi r24,0
 4917 189c 0895      		ret
 4918               	.LVL424:
 4919               	.L487:
 767:main_sim900.h ****   }
 768:main_sim900.h ****   wysylane_polecenie_SIM900 = wykonywana_komenda;
 4920               		.loc 2 768 0
 4921 189e 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 4922 18a2 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 4923 18a6 6093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r22
 769:main_sim900.h ****   nastepne_wysylane_polecenie_SIM900 = nastepne_wysylane_polecenie;
 4924               		.loc 2 769 0
 4925 18aa 4093 0000 		sts nastepne_wysylane_polecenie_SIM900,r20
 770:main_sim900.h ****   wyslij_polecenie_ROM_SIM900(instrukcja);
 4926               		.loc 2 770 0
 4927 18ae C901      		movw r24,r18
 4928               	.LVL425:
 4929 18b0 0E94 0000 		call wyslij_polecenie_ROM_SIM900
 4930               	.LVL426:
 771:main_sim900.h ****   return TRUE;
 4931               		.loc 2 771 0
 4932 18b4 8FEF      		ldi r24,lo8(-1)
 4933               	/* epilogue start */
 772:main_sim900.h **** }
 4934               		.loc 2 772 0
 4935 18b6 0895      		ret
 4936               		.cfi_endproc
 4937               	.LFE52:
 4939               	.global	wyslij_sms
 4941               	wyslij_sms:
 4942               	.LFB53:
 773:main_sim900.h **** 
 774:main_sim900.h **** #ifndef memcpy_E
 775:main_sim900.h **** #define memcpy_E(sink, source, l)                                              \
 776:main_sim900.h ****   eeprom_read_block((sink), (void *)(source), (l))
 777:main_sim900.h **** #endif
 778:main_sim900.h **** 
 779:main_sim900.h **** void wyslij_sms(const uchar wyslij_pdu) {
 4943               		.loc 2 779 0
 4944               		.cfi_startproc
 4945               	.LVL427:
 4946 18b8 0F93      		push r16
 4947               	.LCFI68:
 4948               		.cfi_def_cfa_offset 3
 4949               		.cfi_offset 16, -2
 4950 18ba CF93      		push r28
 4951               	.LCFI69:
 4952               		.cfi_def_cfa_offset 4
 4953               		.cfi_offset 28, -3
 4954 18bc DF93      		push r29
 4955               	.LCFI70:
 4956               		.cfi_def_cfa_offset 5
 4957               		.cfi_offset 29, -4
 4958               	/* prologue: function */
 4959               	/* frame size = 0 */
 4960               	/* stack size = 3 */
 4961               	.L__stack_usage = 3
 780:main_sim900.h ****   czekanie_na_odebranie_zachety = TRUE;
 4962               		.loc 2 780 0
 4963 18be 9FEF      		ldi r25,lo8(-1)
 4964 18c0 9093 0000 		sts czekanie_na_odebranie_zachety,r25
 781:main_sim900.h ****   flaga_odebrany_znak_zachety = FALSE;
 4965               		.loc 2 781 0
 4966 18c4 1092 0000 		sts flaga_odebrany_znak_zachety,__zero_reg__
 782:main_sim900.h ****   if (!wyslij_pdu) {
 4967               		.loc 2 782 0
 4968 18c8 8111      		cpse r24,__zero_reg__
 4969 18ca 00C0      		rjmp .L490
 4970               	.LBB568:
 783:main_sim900.h ****     // Zmiana: 5 blyskow LED przy wysylaniu SMS
 784:main_sim900.h ****     zapal_diode_led_blyski(5);
 4971               		.loc 2 784 0
 4972 18cc 85E0      		ldi r24,lo8(5)
 4973               	.LVL428:
 4974 18ce 8093 0000 		sts liczba_blyskow_led,r24
 4975 18d2 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 785:main_sim900.h ****     flaga_wysylanie_smsa = KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT;
 4976               		.loc 2 785 0
 4977 18d6 83ED      		ldi r24,lo8(-45)
 4978 18d8 8093 0000 		sts flaga_wysylanie_smsa,r24
 786:main_sim900.h ****     bufor_pdu[0] = 0xff; // memcpy_E(bufor_pdu, (void*)EEPROM_ADRES_CENTRUM_SMS,
 4979               		.loc 2 786 0
 4980 18dc 9093 0000 		sts bufor_pdu,r25
 787:main_sim900.h ****                          // LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 788:main_sim900.h ****     konwertuj_blok_eeprom_na_telefon(
 4981               		.loc 2 788 0
 4982 18e0 4AE0      		ldi r20,lo8(10)
 4983 18e2 60E0      		ldi r22,lo8(bufor_eeprom)
 4984 18e4 70E0      		ldi r23,hi8(bufor_eeprom)
 4985 18e6 80E0      		ldi r24,lo8(bufor_pdu)
 4986 18e8 90E0      		ldi r25,hi8(bufor_pdu)
 4987 18ea 0E94 0000 		call konwertuj_blok_eeprom_na_telefon
 4988               	.LVL429:
 789:main_sim900.h ****         bufor_pdu, bufor_eeprom, 2 * LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 790:main_sim900.h ****     uchar *ptr = zapisz_naglowek_pdu(bufor_pdu, numer_telefonu_wysylanego_smsa,
 4989               		.loc 2 790 0
 4990 18ee 00E0      		ldi r16,0
 4991 18f0 20E0      		ldi r18,0
 4992 18f2 40E0      		ldi r20,lo8(bufor_eeprom)
 4993 18f4 50E0      		ldi r21,hi8(bufor_eeprom)
 4994 18f6 60E0      		ldi r22,lo8(numer_telefonu_wysylanego_smsa)
 4995 18f8 70E0      		ldi r23,hi8(numer_telefonu_wysylanego_smsa)
 4996 18fa 80E0      		ldi r24,lo8(bufor_pdu)
 4997 18fc 90E0      		ldi r25,hi8(bufor_pdu)
 4998 18fe 0E94 0000 		call zapisz_naglowek_pdu
 4999               	.LVL430:
 791:main_sim900.h ****                                      bufor_eeprom, 0x00, 0x00);
 792:main_sim900.h ****     dlugosc_pdu = ascii_to_pdu(ptr, tekst_wysylanego_smsa) - bufor_pdu;
 5000               		.loc 2 792 0
 5001 1902 40E0      		ldi r20,lo8(tekst_wysylanego_smsa)
 5002 1904 50E0      		ldi r21,hi8(tekst_wysylanego_smsa)
 5003 1906 FA01      		movw r30,r20
 5004               		0:
 5005 1908 0190      		ld __tmp_reg__,Z+
 5006 190a 0020      		tst __tmp_reg__
 5007 190c 01F4      		brne 0b
 5008 190e AF01      		movw r20,r30
 5009 1910 4150      		subi r20,1
 5010 1912 5109      		sbc r21,__zero_reg__
 5011 1914 60E0      		ldi r22,lo8(tekst_wysylanego_smsa)
 5012 1916 70E0      		ldi r23,hi8(tekst_wysylanego_smsa)
 5013 1918 0E94 0000 		call ascii_to_pdu_blok
 5014               	.LVL431:
 5015               	.L492:
 5016               	.LBE568:
 5017               	.LBB569:
 793:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 794:main_sim900.h ****     uchar l = strlen(numer_telefonu_wysylanego_smsa);
 795:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
 796:main_sim900.h ****       POMOC_DODAJ(numer_telefonu_wysylanego_smsa[i]);
 797:main_sim900.h ****     POMOC_DODAJ(' ');
 798:main_sim900.h ****     l = strlen(tekst_wysylanego_smsa);
 799:main_sim900.h ****     if (l > 20)
 800:main_sim900.h ****       l = 20;
 801:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
 802:main_sim900.h ****       POMOC_DODAJ(tekst_wysylanego_smsa[i]);
 803:main_sim900.h **** #endif
 804:main_sim900.h ****   } else {
 805:main_sim900.h ****     // Zmiana: 5 blyskow LED przy wysylaniu PDU
 806:main_sim900.h ****     zapal_diode_led_blyski(5);
 807:main_sim900.h ****     flaga_wysylanie_smsa = KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU;
 808:main_sim900.h ****     const uchar TP_DCS = tekst_wysylanego_smsa[0]; // message class
 809:main_sim900.h ****     bufor_pdu[0] = 0xff; // memcpy_E(bufor_pdu, (void*)EEPROM_ADRES_CENTRUM_SMS,
 810:main_sim900.h ****                          // LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 811:main_sim900.h ****     konwertuj_blok_eeprom_na_telefon(
 812:main_sim900.h ****         bufor_pdu, bufor_eeprom, 2 * LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 813:main_sim900.h ****     uchar *ptr = zapisz_naglowek_pdu(bufor_pdu, numer_telefonu_wysylanego_smsa,
 814:main_sim900.h ****                                      bufor_eeprom, 0x00, TP_DCS);
 815:main_sim900.h ****     memcpy(ptr, &tekst_wysylanego_smsa[2], tekst_wysylanego_smsa[1]);
 816:main_sim900.h ****     dlugosc_pdu = (ptr + tekst_wysylanego_smsa[1]) - bufor_pdu;
 5018               		.loc 2 816 0
 5019 191c 8050      		subi r24,lo8(bufor_pdu)
 5020 191e 9040      		sbci r25,hi8(bufor_pdu)
 5021 1920 8093 0000 		sts dlugosc_pdu,r24
 5022               	.LBE569:
 817:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 818:main_sim900.h ****     uchar l = strlen(numer_telefonu_wysylanego_smsa);
 819:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
 820:main_sim900.h ****       POMOC_DODAJ(numer_telefonu_wysylanego_smsa[i]);
 821:main_sim900.h ****     POMOC_DODAJ(' ');
 822:main_sim900.h ****     POMOC_DODAJ('P');
 823:main_sim900.h ****     POMOC_DODAJ('D');
 824:main_sim900.h ****     POMOC_DODAJ('U');
 825:main_sim900.h **** #endif
 826:main_sim900.h ****   }
 827:main_sim900.h ****   const uchar oktety = dlugosc_pdu - 1 - bufor_pdu[0];
 5023               		.loc 2 827 0
 5024 1924 C091 0000 		lds r28,dlugosc_pdu
 5025 1928 C150      		subi r28,lo8(-(-1))
 5026 192a 8091 0000 		lds r24,bufor_pdu
 5027 192e C81B      		sub r28,r24
 5028               	.LVL432:
 828:main_sim900.h ****   static const char instrukcja_wyslij_smsa[] PROGMEM = "+cmgs=";
 829:main_sim900.h ****   memcpy_R(wysylane_dane_RAM_SIM900, instrukcja_wyslij_smsa);
 5029               		.loc 2 829 0
 5030 1930 46E0      		ldi r20,lo8(6)
 5031 1932 50E0      		ldi r21,0
 5032 1934 60E0      		ldi r22,lo8(instrukcja_wyslij_smsa.3356)
 5033 1936 70E0      		ldi r23,hi8(instrukcja_wyslij_smsa.3356)
 5034 1938 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 5035 193a 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 5036 193c 0E94 0000 		call memcpy_P
 5037               	.LVL433:
 5038               	.LBB570:
 5039               	.LBB571:
 5040               		.loc 6 527 0
 5041 1940 4AE0      		ldi r20,lo8(10)
 5042 1942 60E0      		ldi r22,lo8(wysylany_blok_SIM900+8)
 5043 1944 70E0      		ldi r23,hi8(wysylany_blok_SIM900+8)
 5044               	.LVL434:
 5045 1946 8C2F      		mov r24,r28
 5046 1948 90E0      		ldi r25,0
 5047 194a 0E94 0000 		call __utoa_ncheck
 5048               	.LVL435:
 5049               	.LBE571:
 5050               	.LBE570:
 830:main_sim900.h ****   utoa(oktety, wysylane_dane_RAM_SIM900 + strlen_R(instrukcja_wyslij_smsa), 10);
 831:main_sim900.h ****   max_oczekiwanie_na_odpowiedz = 250;
 5051               		.loc 2 831 0
 5052 194e 8AEF      		ldi r24,lo8(-6)
 5053 1950 8093 0000 		sts max_oczekiwanie_na_odpowiedz,r24
 5054               	/* epilogue start */
 832:main_sim900.h ****   wyslij_polecenie_RAM_SIM900();
 833:main_sim900.h ****   POMOC_DODAJ2('#', 'S');
 834:main_sim900.h **** }
 5055               		.loc 2 834 0
 5056 1954 DF91      		pop r29
 5057 1956 CF91      		pop r28
 5058               	.LVL436:
 5059 1958 0F91      		pop r16
 832:main_sim900.h ****   wyslij_polecenie_RAM_SIM900();
 5060               		.loc 2 832 0
 5061 195a 0C94 0000 		jmp wyslij_polecenie_RAM_SIM900
 5062               	.LVL437:
 5063               	.L490:
 5064               	.LBB572:
 806:main_sim900.h ****     flaga_wysylanie_smsa = KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU;
 5065               		.loc 2 806 0
 5066 195e 85E0      		ldi r24,lo8(5)
 5067               	.LVL438:
 5068 1960 8093 0000 		sts liczba_blyskow_led,r24
 5069 1964 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 807:main_sim900.h ****     const uchar TP_DCS = tekst_wysylanego_smsa[0]; // message class
 5070               		.loc 2 807 0
 5071 1968 84ED      		ldi r24,lo8(-44)
 5072 196a 8093 0000 		sts flaga_wysylanie_smsa,r24
 808:main_sim900.h ****     bufor_pdu[0] = 0xff; // memcpy_E(bufor_pdu, (void*)EEPROM_ADRES_CENTRUM_SMS,
 5073               		.loc 2 808 0
 5074 196e 0091 0000 		lds r16,tekst_wysylanego_smsa
 5075               	.LVL439:
 809:main_sim900.h ****                          // LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 5076               		.loc 2 809 0
 5077 1972 9093 0000 		sts bufor_pdu,r25
 811:main_sim900.h ****         bufor_pdu, bufor_eeprom, 2 * LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 5078               		.loc 2 811 0
 5079 1976 4AE0      		ldi r20,lo8(10)
 5080 1978 60E0      		ldi r22,lo8(bufor_eeprom)
 5081 197a 70E0      		ldi r23,hi8(bufor_eeprom)
 5082 197c 80E0      		ldi r24,lo8(bufor_pdu)
 5083 197e 90E0      		ldi r25,hi8(bufor_pdu)
 5084 1980 0E94 0000 		call konwertuj_blok_eeprom_na_telefon
 5085               	.LVL440:
 813:main_sim900.h ****                                      bufor_eeprom, 0x00, TP_DCS);
 5086               		.loc 2 813 0
 5087 1984 20E0      		ldi r18,0
 5088 1986 40E0      		ldi r20,lo8(bufor_eeprom)
 5089 1988 50E0      		ldi r21,hi8(bufor_eeprom)
 5090 198a 60E0      		ldi r22,lo8(numer_telefonu_wysylanego_smsa)
 5091 198c 70E0      		ldi r23,hi8(numer_telefonu_wysylanego_smsa)
 5092 198e 80E0      		ldi r24,lo8(bufor_pdu)
 5093 1990 90E0      		ldi r25,hi8(bufor_pdu)
 5094 1992 0E94 0000 		call zapisz_naglowek_pdu
 5095               	.LVL441:
 5096 1996 EC01      		movw r28,r24
 5097               	.LVL442:
 815:main_sim900.h ****     dlugosc_pdu = (ptr + tekst_wysylanego_smsa[1]) - bufor_pdu;
 5098               		.loc 2 815 0
 5099 1998 4091 0000 		lds r20,tekst_wysylanego_smsa+1
 5100 199c 50E0      		ldi r21,0
 5101 199e 60E0      		ldi r22,lo8(tekst_wysylanego_smsa+2)
 5102 19a0 70E0      		ldi r23,hi8(tekst_wysylanego_smsa+2)
 5103 19a2 0E94 0000 		call memcpy
 5104               	.LVL443:
 816:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 5105               		.loc 2 816 0
 5106 19a6 8091 0000 		lds r24,tekst_wysylanego_smsa+1
 5107 19aa 8C0F      		add r24,r28
 5108 19ac 9D2F      		mov r25,r29
 5109 19ae 911D      		adc r25,__zero_reg__
 5110 19b0 00C0      		rjmp .L492
 5111               	.LBE572:
 5112               		.cfi_endproc
 5113               	.LFE53:
 5115               	.global	wykonanie_komend_SIM900
 5117               	wykonanie_komend_SIM900:
 5118               	.LFB54:
 835:main_sim900.h **** 
 836:main_sim900.h **** uchar wykonanie_komend_SIM900(void) {
 5119               		.loc 2 836 0
 5120               		.cfi_startproc
 5121 19b2 EF92      		push r14
 5122               	.LCFI71:
 5123               		.cfi_def_cfa_offset 3
 5124               		.cfi_offset 14, -2
 5125 19b4 FF92      		push r15
 5126               	.LCFI72:
 5127               		.cfi_def_cfa_offset 4
 5128               		.cfi_offset 15, -3
 5129 19b6 0F93      		push r16
 5130               	.LCFI73:
 5131               		.cfi_def_cfa_offset 5
 5132               		.cfi_offset 16, -4
 5133 19b8 1F93      		push r17
 5134               	.LCFI74:
 5135               		.cfi_def_cfa_offset 6
 5136               		.cfi_offset 17, -5
 5137 19ba CF93      		push r28
 5138               	.LCFI75:
 5139               		.cfi_def_cfa_offset 7
 5140               		.cfi_offset 28, -6
 5141 19bc DF93      		push r29
 5142               	.LCFI76:
 5143               		.cfi_def_cfa_offset 8
 5144               		.cfi_offset 29, -7
 5145 19be 00D0      		rcall .
 5146 19c0 1F92      		push __zero_reg__
 5147               	.LCFI77:
 5148               		.cfi_def_cfa_offset 11
 5149 19c2 CDB7      		in r28,__SP_L__
 5150 19c4 DEB7      		in r29,__SP_H__
 5151               	.LCFI78:
 5152               		.cfi_def_cfa_register 28
 5153               	/* prologue: function */
 5154               	/* frame size = 3 */
 5155               	/* stack size = 9 */
 5156               	.L__stack_usage = 9
 837:main_sim900.h ****   const uchar czy_gsm_zajety =
 838:main_sim900.h ****       flaga_odczytywanie_smsa || flaga_wysylanie_smsa ||
 5157               		.loc 2 838 0
 5158 19c6 9091 0000 		lds r25,flaga_odczytywanie_smsa
 839:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej ||
 840:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika ||
 841:main_sim900.h ****       aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
 842:main_sim900.h ****       opoznienie_SIM900_100MS || czekanie_na_odebranie_zachety;
 5159               		.loc 2 842 0
 5160 19ca 9111      		cpse r25,__zero_reg__
 5161 19cc 00C0      		rjmp .L595
 838:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej ||
 5162               		.loc 2 838 0
 5163 19ce 8091 0000 		lds r24,flaga_wysylanie_smsa
 5164 19d2 8111      		cpse r24,__zero_reg__
 5165 19d4 00C0      		rjmp .L595
 838:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej ||
 5166               		.loc 2 838 0 is_stmt 0 discriminator 1
 5167 19d6 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5168 19da 8111      		cpse r24,__zero_reg__
 5169 19dc 00C0      		rjmp .L595
 839:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej ||
 5170               		.loc 2 839 0 is_stmt 1
 5171 19de 8091 0000 		lds r24,trwa_rozmowa_przychodzaca_od_uzytkownika
 5172 19e2 8111      		cpse r24,__zero_reg__
 5173 19e4 00C0      		rjmp .L595
 840:main_sim900.h ****       aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
 5174               		.loc 2 840 0
 5175 19e6 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 5176 19ea 8111      		cpse r24,__zero_reg__
 5177 19ec 00C0      		rjmp .L595
 841:main_sim900.h ****       opoznienie_SIM900_100MS || czekanie_na_odebranie_zachety;
 5178               		.loc 2 841 0
 5179 19ee 8091 0000 		lds r24,opoznienie_SIM900_100MS
 5180 19f2 8111      		cpse r24,__zero_reg__
 5181 19f4 00C0      		rjmp .L595
 5182               		.loc 2 842 0 discriminator 2
 5183 19f6 2091 0000 		lds r18,czekanie_na_odebranie_zachety
 5184 19fa 81E0      		ldi r24,lo8(1)
 5185 19fc 2111      		cpse r18,__zero_reg__
 5186 19fe 00C0      		rjmp .L495
 5187 1a00 80E0      		ldi r24,0
 5188               	.L495:
 5189               	.LVL444:
 843:main_sim900.h **** 
 844:main_sim900.h ****   const uchar czy_mozna_wysylac_dane_do_SIM900 =
 845:main_sim900.h ****       !czy_gsm_zajety && CZY_MOZNA_WYSYLAC_DANE_SIM900() &&
 5190               		.loc 2 845 0 discriminator 2
 5191 1a02 8111      		cpse r24,__zero_reg__
 5192 1a04 00C0      		rjmp .L598
 5193               	.LVL445:
 5194               		.loc 2 845 0 is_stmt 0 discriminator 1
 5195 1a06 2091 C100 		lds r18,193
 5196 1a0a 26FD      		sbrc r18,6
 5197 1a0c 00C0      		rjmp .L598
 5198               		.loc 2 845 0 discriminator 3
 5199 1a0e 2091 0000 		lds r18,podlaczony_modul_gsm_SIM900
 5200 1a12 2223      		tst r18
 5201 1a14 01F0      		breq .L598
 846:main_sim900.h ****       czy_jest_bezczynny_SIM900();
 5202               		.loc 2 846 0 is_stmt 1 discriminator 5
 5203 1a16 2091 0000 		lds r18,komenda_SIM900
 845:main_sim900.h ****       czy_jest_bezczynny_SIM900();
 5204               		.loc 2 845 0 discriminator 5
 5205 1a1a 01E0      		ldi r16,lo8(1)
 5206 1a1c 2111      		cpse r18,__zero_reg__
 5207 1a1e 00C0      		rjmp .L598
 5208               	.LVL446:
 5209               	.L496:
 847:main_sim900.h **** 
 848:main_sim900.h ****   const komenda_typ wykonywana_komenda = komendy_kolejka[0];
 5210               		.loc 2 848 0
 5211 1a20 1091 0000 		lds r17,komendy_kolejka
 5212               	.LVL447:
 849:main_sim900.h ****   switch (wykonywana_komenda) {
 5213               		.loc 2 849 0
 5214 1a24 E12E      		mov r14,r17
 5215 1a26 F12C      		mov r15,__zero_reg__
 5216 1a28 1D39      		cpi r17,lo8(-99)
 5217 1a2a 01F4      		brne .+2
 5218 1a2c 00C0      		rjmp .L499
 5219 1a2e 00F0      		brlo .+2
 5220 1a30 00C0      		rjmp .L500
 5221 1a32 1239      		cpi r17,lo8(-110)
 5222 1a34 01F4      		brne .+2
 5223 1a36 00C0      		rjmp .L501
 5224 1a38 00F4      		brsh .L502
 5225 1a3a 1D38      		cpi r17,lo8(-115)
 5226 1a3c 01F4      		brne .+2
 5227 1a3e 00C0      		rjmp .L503
 5228 1a40 00F4      		brsh .L504
 5229 1a42 1B38      		cpi r17,lo8(-117)
 5230 1a44 01F4      		brne .+2
 5231 1a46 00C0      		rjmp .L505
 5232 1a48 00F0      		brlo .+2
 5233 1a4a 00C0      		rjmp .L506
 5234 1a4c 1A38      		cpi r17,lo8(-118)
 5235 1a4e 01F4      		brne .+2
 5236 1a50 00C0      		rjmp .L507
 5237               	.L498:
 850:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 851:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU: {
 852:main_sim900.h ****     POWTORZ_JESLI(flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS);
 853:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 854:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 855:main_sim900.h ****     wyslij_sms(wykonywana_komenda == KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
 856:main_sim900.h ****     break;
 857:main_sim900.h ****   }
 858:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_PDU: {
 859:main_sim900.h ****     czekanie_na_odebranie_zachety = FALSE;
 860:main_sim900.h ****     konwertuj_pdu_na_blok_wysylany(wysylany_blok_SIM900, bufor_pdu,
 861:main_sim900.h ****                                    dlugosc_pdu);
 862:main_sim900.h ****     const uint liczba_znakow = 2 * dlugosc_pdu + 1;
 863:main_sim900.h ****     wysylany_blok_SIM900[liczba_znakow - 1] = ZNAK_CTRL_Z;
 864:main_sim900.h ****     wyslij_znaki_SIM900(liczba_znakow);
 865:main_sim900.h ****     break;
 866:main_sim900.h ****   }
 867:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1:
 868:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_2:
 869:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_3:
 870:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_4:
 871:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_5:
 872:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_6:
 873:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_7:
 874:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_8:
 875:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_9:
 876:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_10:
 877:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_11:
 878:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_12:
 879:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_13:
 880:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_14:
 881:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_15:
 882:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_16:
 883:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_17:
 884:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_18:
 885:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_19:
 886:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20: {
 887:main_sim900.h ****     POWTORZ_JESLI(flaga_odczytywanie_smsa || !modul_zalogowany_w_sieci ||
 888:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 889:main_sim900.h ****                   wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK ||
 890:main_sim900.h ****                   flaga_wysylanie_smsa ||
 891:main_sim900.h ****                   aktualnie_wysylane_polecenie_SIM900 ==
 892:main_sim900.h ****                       KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 893:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 894:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 895:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW,
 896:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW) ||
 897:main_sim900.h ****                   czy_sa_komendy_z_przedzialu(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT,
 898:main_sim900.h ****                                               KOMENDA_KOLEJKI_WYSLIJ_PDU) ||
 899:main_sim900.h ****                   czy_sa_komendy_z_przedzialu(
 900:main_sim900.h ****                       KOMENDA_KOLEJKI_ODBIERZ_ROZMOWE,
 901:main_sim900.h ****                       KOMENDA_KOLEJKI_SPRAWDZ_PRZYCHODZACA_ROZMOWE));
 902:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 903:main_sim900.h ****     flaga_odczytywanie_smsa = TRUE;
 904:main_sim900.h ****     static const char instrukcja_odczytaj_smsa[] PROGMEM = "+cmgr=";
 905:main_sim900.h ****     memcpy_R(wysylane_dane_RAM_SIM900, instrukcja_odczytaj_smsa);
 906:main_sim900.h ****     const uint nr_smsa =
 907:main_sim900.h ****         wykonywana_komenda - KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 + 1;
 908:main_sim900.h ****     utoa(nr_smsa, wysylane_dane_RAM_SIM900 + strlen_R(instrukcja_odczytaj_smsa),
 909:main_sim900.h ****          10);
 910:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 911:main_sim900.h ****     POMOC_DODAJ2('#', 'X');
 912:main_sim900.h ****     break;
 913:main_sim900.h ****   }
 914:main_sim900.h ****   case KOMENDA_KOLEJKI_INTERPRETUJ_PDU: {
 915:main_sim900.h ****     const uchar *ptr = pobierz_numer_telefonu_nadawcy_z_PDU(
 916:main_sim900.h ****         bufor_pdu, numer_telefonu_odebranego_smsa,
 917:main_sim900.h ****         &nie_wysylaj_echa_z_powodu_nietypowego_smsa);
 918:main_sim900.h ****     if (ptr == 0) // (1)
 919:main_sim900.h ****     {
 920:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 921:main_sim900.h ****       break;
 922:main_sim900.h ****     }
 923:main_sim900.h ****     {
 924:main_sim900.h ****       uchar rok, miesiac, dzien;
 925:main_sim900.h ****       ptr = pobierz_date_z_PDU(ptr, &rok, &miesiac, &dzien);
 926:main_sim900.h ****     }
 927:main_sim900.h ****     {
 928:main_sim900.h ****       uchar godzina, minuta, sekunda;
 929:main_sim900.h ****       ptr = pobierz_czas_z_PDU(ptr, &godzina, &minuta, &sekunda);
 930:main_sim900.h **** 
 931:main_sim900.h ****       // Zapisz timestamp z SMS do późniejszego użycia
 932:main_sim900.h ****       // (zostanie użyty w wykonanie_polecenia_sms jeśli kod ABCD jest poprawny)
 933:main_sim900.h ****       sms_timestamp_godzina = godzina;
 934:main_sim900.h ****       sms_timestamp_minuta = minuta;
 935:main_sim900.h ****       extern uchar sms_timestamp_sekunda;
 936:main_sim900.h ****       sms_timestamp_sekunda = sekunda;
 937:main_sim900.h ****     }
 938:main_sim900.h ****     ptr_start_pdu_z_wiadomoscia = (uchar *)ptr;
 939:main_sim900.h ****     pdu_to_ascii(ptr, tekst_odebranego_smsa, MAX_LICZBA_ZNAKOW_SMS + 1);
 940:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 941:main_sim900.h ****     const uchar l = min(strlen(tekst_odebranego_smsa), 20);
 942:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
 943:main_sim900.h ****       POMOC_DODAJ(tekst_odebranego_smsa[i]);
 944:main_sim900.h **** #endif
 945:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_INTERPRETUJ_ODEBRANEGO_SMSA);
 946:main_sim900.h ****     break;
 947:main_sim900.h ****   }
 948:main_sim900.h ****   case KOMENDA_KOLEJKI_INTERPRETUJ_ODEBRANEGO_SMSA: {
 949:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 950:main_sim900.h ****     zapal_diode_led(10);
 951:main_sim900.h ****     wykonanie_polecenia_sms();
 952:main_sim900.h ****     flaga_odczytywanie_smsa = FALSE;
 953:main_sim900.h ****     break;
 954:main_sim900.h ****   }
 955:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_1:
 956:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_2:
 957:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_3:
 958:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_4:
 959:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_5:
 960:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_6:
 961:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_7:
 962:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_8:
 963:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_9:
 964:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_10:
 965:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_11:
 966:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_12:
 967:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_13:
 968:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_14:
 969:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_15:
 970:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_16:
 971:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_17:
 972:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_18:
 973:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_19:
 974:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_20: {
 975:main_sim900.h ****     POWTORZ_JESLI(flaga_odczytywanie_smsa || flaga_trwa_rozmowa_wychodzaca ||
 976:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 977:main_sim900.h ****                   czekanie_na_odebranie_zachety)
 978:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 979:main_sim900.h ****     static const char instrukcja_usun_smsa[] PROGMEM = "+cmgd=";
 980:main_sim900.h ****     memcpy_R(wysylane_dane_RAM_SIM900, instrukcja_usun_smsa);
 981:main_sim900.h ****     const uint nr_smsa = wykonywana_komenda - KOMENDA_KOLEJKI_USUN_SMSA_1 + 1;
 982:main_sim900.h ****     utoa(nr_smsa, wysylane_dane_RAM_SIM900 + strlen_R(instrukcja_usun_smsa),
 983:main_sim900.h ****          10);
 984:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 985:main_sim900.h ****     POMOC_DODAJ2('#', 'Y');
 986:main_sim900.h ****     break;
 987:main_sim900.h ****   }
 988:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_PRZYCHODZACA_ROZMOWE: {
 989:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 990:main_sim900.h ****     zapal_diode_led(10);
 991:main_sim900.h **** 
 992:main_sim900.h ****     uchar status_ok =
 993:main_sim900.h ****         sprawdz_przychodzaca_rozmowe(); // Returns TRUE if number authorized
 994:main_sim900.h **** 
 995:main_sim900.h ****     if (status_ok) {
 996:main_sim900.h ****       if (tryb_clip) {
 997:main_sim900.h ****         // Tryb CLIP: wlacz wyjscie i ODRZUC polaczenie
 998:main_sim900.h ****         if (polozenie_polecenia_SIM900(PSTR("+CMTI:")) == NULL) {
 999:main_sim900.h ****           ustaw_wyjscie_clip();
1000:main_sim900.h ****         }
1001:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
1002:main_sim900.h ****       } else {
1003:main_sim900.h ****         // Tryb DTMF: ODBIERZ polaczenie
1004:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_ODBIERZ_ROZMOWE);
1005:main_sim900.h ****       }
1006:main_sim900.h ****     } else {
1007:main_sim900.h ****       // Status NIE OK - odrzuc
1008:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
1009:main_sim900.h ****     }
1010:main_sim900.h ****     blokada_clip = TRUE;
1011:main_sim900.h ****     break;
1012:main_sim900.h ****   }
1013:main_sim900.h ****   case KOMENDA_KOLEJKI_ODRZUC_ROZMOWE: {
1014:main_sim900.h ****     POWTORZ_JESLI(
1015:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
1016:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
1017:main_sim900.h ****         czekanie_na_odebranie_zachety || wykonywanie_rozmowy_telefonicznej ||
1018:main_sim900.h ****         !CZY_MOZNA_WYSYLAC_DANE_SIM900() || !czy_jest_bezczynny_SIM900());
1019:main_sim900.h ****     wysylane_polecenie_SIM900 = wykonywana_komenda;
1020:main_sim900.h ****     static const char instrukcja_odrzuc_rozmowe[] PROGMEM = "h";
1021:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_odrzuc_rozmowe);
1022:main_sim900.h ****     break;
1023:main_sim900.h ****   }
1024:main_sim900.h ****   case KOMENDA_KOLEJKI_ODBIERZ_ROZMOWE: {
1025:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1026:main_sim900.h ****     static const char instrukcja_odbierz_rozmowe[] PROGMEM = "a";
1027:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_odbierz_rozmowe);
1028:main_sim900.h ****     POMOC_DODAJ2('#', 'p');
1029:main_sim900.h ****     break;
1030:main_sim900.h ****   }
1031:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_TON_DTMF: {
1032:main_sim900.h ****     // Czekaj na koncowke inicjalizacji polaczenia/opoznienia?
1033:main_sim900.h ****     POWTORZ_JESLI(opoznienie_SIM900_100MS);
1034:main_sim900.h ****     if (!CZY_MOZNA_WYSYLAC_DANE_SIM900() || !czy_jest_bezczynny_SIM900() ||
1035:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
1036:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
1037:main_sim900.h ****       break;
1038:main_sim900.h ****     }
1039:main_sim900.h ****     wysylane_polecenie_SIM900 = wykonywana_komenda;
1040:main_sim900.h ****     static const char instrukcja_vts[] PROGMEM = "+vts=1";
1041:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_vts);
1042:main_sim900.h ****     POMOC_DODAJ2('#', 'V');
1043:main_sim900.h ****     break;
1044:main_sim900.h ****   }
1045:main_sim900.h ****   case KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE: {
1046:main_sim900.h ****     POWTORZ_JESLI(!modul_zalogowany_w_sieci || opoznienie_SIM900_100MS);
1047:main_sim900.h ****     if (wykonywanie_rozmowy_telefonicznej)
1048:main_sim900.h ****       break;
1049:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1050:main_sim900.h ****     zapal_diode_led(20);
1051:main_sim900.h ****     wysylane_dane_RAM_SIM900[0] = 'd';
1052:main_sim900.h ****     // static const char doladowanie[] PROGMEM = "*100*59484869838559#";
1053:main_sim900.h ****     // strcpy_P(numer_telefonu_do_ktorego_dzwonic, doladowanie);
1054:main_sim900.h ****     strcpy(wysylane_dane_RAM_SIM900 + 1, numer_telefonu_do_ktorego_dzwonic);
1055:main_sim900.h ****     uchar l = strlen(numer_telefonu_do_ktorego_dzwonic) + 1;
1056:main_sim900.h ****     wysylane_dane_RAM_SIM900[l] = ';';
1057:main_sim900.h ****     wysylane_dane_RAM_SIM900[l + 1] = '\0';
1058:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
1059:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 300;
1060:main_sim900.h ****     POMOC_DODAJ2('#', 'h');
1061:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
1062:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
1063:main_sim900.h ****       POMOC_DODAJ(numer_telefonu_do_ktorego_dzwonic[i]);
1064:main_sim900.h **** #endif
1065:main_sim900.h ****     break;
1066:main_sim900.h ****   }
1067:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_POZIOM_SIECI: {
1068:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1069:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1070:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1071:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1072:main_sim900.h ****       if (poziom_sieci_gsm == POZIOM_SIECI_BLAD ||
1073:main_sim900.h ****           poziom_sieci_gsm == 0) // poziom sieci bez zmian
1074:main_sim900.h ****         poziom_sieci_gsm = 16;
1075:main_sim900.h ****       break;
1076:main_sim900.h ****     }
1077:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1078:main_sim900.h ****     static const char instrukcja_poziom_sieci[] PROGMEM = "+csq";
1079:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_poziom_sieci);
1080:main_sim900.h ****     break;
1081:main_sim900.h ****   }
1082:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_ZAREJESTROWANIE: {
1083:main_sim900.h ****     // Usunięto warunek !modul_zalogowany_w_sieci - musimy sprawdzać ZAWSZE!
1084:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1085:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1086:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1087:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1088:main_sim900.h ****       break;
1089:main_sim900.h ****     }
1090:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1091:main_sim900.h ****     static const char instrukcja_creg[] PROGMEM = "+creg?";
1092:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_creg);
1093:main_sim900.h ****     break;
1094:main_sim900.h ****   }
1095:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_STAN_KARTY_SIM: {
1096:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1097:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1098:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1099:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1100:main_sim900.h ****       licznik_blad_stanu_karty_SIM = 0;
1101:main_sim900.h ****       break;
1102:main_sim900.h ****     }
1103:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1104:main_sim900.h ****     static const char instrukcja_odczyt_ksiazki[] PROGMEM = "+cpbr=26";
1105:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_odczyt_ksiazki);
1106:main_sim900.h ****     break;
1107:main_sim900.h ****   }
1108:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_ZALOGOWANIE_U_OPERATORA: {
1109:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1110:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1111:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1112:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1113:main_sim900.h ****       licznik_blad_zalogowania_u_operatora = 0;
1114:main_sim900.h ****       break;
1115:main_sim900.h ****     }
1116:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1117:main_sim900.h ****     static const char instrukcja_sprawdz_operatora[] PROGMEM = "+cops?";
1118:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_sprawdz_operatora);
1119:main_sim900.h ****     break;
1120:main_sim900.h ****   }
1121:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE: {
1122:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1123:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1124:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1125:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK)
1126:main_sim900.h ****       break;
1127:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1128:main_sim900.h ****     static const char instrukcja_cclk[] PROGMEM = "+cclk?";
1129:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_cclk);
1130:main_sim900.h ****     break;
1131:main_sim900.h ****   }
1132:main_sim900.h ****   case KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS: {
1133:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1134:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM = "+cdscb";
1135:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_ustawienie_pamieci);
1136:main_sim900.h ****     break;
1137:main_sim900.h ****   }
1138:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW: {
1139:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1140:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM =
1141:main_sim900.h ****         "+cpms=\"SM\",\"SM\",\"SM\"";
1142:main_sim900.h ****     nastepne_wysylane_polecenie_SIM900 =
1143:main_sim900.h ****         KOMENDA_KOLEJKI_WSTAWIENIE_MORING_GDY_DZWONI;
1144:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_ustawienie_pamieci);
1145:main_sim900.h ****     break;
1146:main_sim900.h ****   }
1147:main_sim900.h ****   case KOMENDA_KOLEJKI_PODLACZONY_MODUL_GSM: {
1148:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT);
1149:main_sim900.h ****     opoznienie_zatrzymaj_odpytywanie_urzadzenia = 20;
1150:main_sim900.h ****     ustaw_odbior_SIM900();
1151:main_sim900.h ****     break;
1152:main_sim900.h ****   }
1153:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: { // po wczeniu zasilania wysya 2
1154:main_sim900.h ****                                               // razy, bo za pierwszym razem nie
1155:main_sim900.h ****                                               // dziaa kontrola RTS / CTS w
1156:main_sim900.h ****                                               // SIM800
1157:main_sim900.h ****     if (max_oczekiwanie_na_odpowiedz_at)
1158:main_sim900.h ****       break;
1159:main_sim900.h ****     if (opoznienie_zatrzymaj_odpytywanie_urzadzenia) {
1160:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
1161:main_sim900.h ****       break;
1162:main_sim900.h ****     }
1163:main_sim900.h ****     if (CZY_WYSYLANIE_DANYCH_SIM900()) {
1164:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
1165:main_sim900.h ****       break;
1166:main_sim900.h ****     }
1167:main_sim900.h ****     ustaw_odbior_SIM900();
1168:main_sim900.h ****     wysylane_polecenie_SIM900 = wykonywana_komenda;
1169:main_sim900.h ****     max_oczekiwanie_na_odpowiedz_at = 20;
1170:main_sim900.h ****     static const char instrukcja_at[] PROGMEM = "+ifc=2,2";
1171:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_at);
1172:main_sim900.h ****     break;
1173:main_sim900.h ****   }
1174:main_sim900.h ****   case KOMENDA_KOLEJKI_ODEBRANO_POLECENIE_ROZPOCZYNAJACE: {
1175:main_sim900.h ****     podlaczony_modul_gsm_SIM900 = TRUE;
1176:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_PIN);
1177:main_sim900.h ****     opoznienie_SIM900_100MS = 40;
1178:main_sim900.h ****     break;
1179:main_sim900.h ****   }
1180:main_sim900.h ****   case KOMENDA_KOLEJKI_PODAJ_PIN: {
1181:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1182:main_sim900.h ****     static const char instrukcja_podaj_pin[] PROGMEM = "+cpin=\"1976\"";
1183:main_sim900.h ****     strcpy_P(wysylane_dane_RAM_SIM900, instrukcja_podaj_pin);
1184:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
1185:main_sim900.h ****     break;
1186:main_sim900.h ****   }
1187:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY: {
1188:main_sim900.h ****     static uchar drugi_raz = FALSE;
1189:main_sim900.h ****     if (drugi_raz) {
1190:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW);
1191:main_sim900.h ****       break;
1192:main_sim900.h ****     }
1193:main_sim900.h ****     drugi_raz = TRUE;
1194:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1195:main_sim900.h ****     static const char instrukcja_usun_wszystkie_smsy[] PROGMEM = "+cmgda=6";
1196:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_usun_wszystkie_smsy);
1197:main_sim900.h ****     break;
1198:main_sim900.h ****   }
1199:main_sim900.h ****   case KOMENDA_KOLEJKI_KOMENDA_SIM900: {
1200:main_sim900.h ****     obsluga_komendy_SIM900();
1201:main_sim900.h ****     if (komenda_SIM900 != KOMENDA_SIM900_WYSLANE_POLECENIE)
1202:main_sim900.h ****       max_oczekiwanie_na_odpowiedz = 20;
1203:main_sim900.h ****     resetuj_komende_SIM900();
1204:main_sim900.h ****     break;
1205:main_sim900.h ****   }
1206:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_WZMOCNIENIE_MIKROFONU: {
1207:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1208:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1209:main_sim900.h ****     static const char instrukcja[] PROGMEM =
1210:main_sim900.h ****         "+cmic=0,15"; // ustawienie od 0 ... 15
1211:main_sim900.h ****     strcpy_P(wysylane_dane_RAM_SIM900, instrukcja);
1212:main_sim900.h ****     nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_ROZPOCZNIJ_PRACE;
1213:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
1214:main_sim900.h ****     break;
1215:main_sim900.h ****   }
1216:main_sim900.h ****   case KOMENDA_KOLEJKI_ROZPOCZNIJ_PRACE: {
1217:main_sim900.h ****     POMOC_DODAJ2('*', 'h');
1218:main_sim900.h ****     if (podlaczona_karta_SIM_SIM900) {
1219:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS);
1220:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_MODUL_ZALOGOWANY);
1221:main_sim900.h ****     }
1222:main_sim900.h ****     break;
1223:main_sim900.h ****   }
1224:main_sim900.h ****   case KOMENDA_KOLEJKI_MODUL_ZALOGOWANY: {
1225:main_sim900.h ****     // Nie ustawiamy modul_zalogowany_w_sieci tutaj!
1226:main_sim900.h ****     // Flaga jest ustawiana tylko przez +CREG gdy faktycznie zalogowany
1227:main_sim900.h ****     break;
1228:main_sim900.h ****   }
1229:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_ZEGAR_SIM900: {
1230:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1231:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1232:main_sim900.h ****     strcpy(wysylane_dane_RAM_SIM900, bufor_ustaw_czas);
1233:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
1234:main_sim900.h ****     break;
1235:main_sim900.h ****   }
1236:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_PIN:
1237:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW:
1238:main_sim900.h ****   case KOMENDA_KOLEJKI_WSTAWIENIE_MORING_GDY_DZWONI:
1239:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_WYSYLANIE_INFO_O_DZWONIACYM:
1240:main_sim900.h ****   case KOMENDA_KOLEJKI_WLACZ_DETEKCJE_DTMF:
1241:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_CICHY_TRYB:
1242:main_sim900.h ****   case KOMENDA_KOLEJKI_WYCISZ_DZWONKI:
1243:main_sim900.h ****   case KOMENDA_KOLEJKI_ODBIERAJ_SMS_FLASH:
1244:main_sim900.h ****   case KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ:
1245:main_sim900.h ****   case KOMENDA_KOLEJKI_WLACZ_CZAS_Z_SIECI: {
1246:main_sim900.h **** 
1247:main_sim900.h **** #define MAX_ROZMIAR_POLECENIA_GSM 14
1248:main_sim900.h **** 
1249:main_sim900.h ****     static const char instrukcje[10][MAX_ROZMIAR_POLECENIA_GSM] PROGMEM = {
1250:main_sim900.h ****         "+cpin?",         "+cnmi=2,1,2,1", "+moring=1", "+clip=1",
1251:main_sim900.h ****         "+ddet=1,10,1",   "+calm=1",       "+crsl=1",   "+cusd=1",
1252:main_sim900.h ****         "+cpbw=26,\"1\"", "+clts=0",
1253:main_sim900.h ****     };
1254:main_sim900.h ****     static const komenda_typ nastepna_komenda[10] PROGMEM = {
1255:main_sim900.h ****         KOMENDA_KOLEJKI_BRAK_KOMENDY,
1256:main_sim900.h ****         KOMENDA_KOLEJKI_BRAK_KOMENDY,
1257:main_sim900.h ****         KOMENDA_KOLEJKI_USTAW_WYSYLANIE_INFO_O_DZWONIACYM,
1258:main_sim900.h ****         KOMENDA_KOLEJKI_WLACZ_DETEKCJE_DTMF,
1259:main_sim900.h ****         KOMENDA_KOLEJKI_USTAW_CICHY_TRYB,
1260:main_sim900.h ****         KOMENDA_KOLEJKI_WYCISZ_DZWONKI,
1261:main_sim900.h ****         KOMENDA_KOLEJKI_ODBIERAJ_SMS_FLASH,
1262:main_sim900.h ****         KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ,
1263:main_sim900.h ****         KOMENDA_KOLEJKI_WLACZ_CZAS_Z_SIECI,
1264:main_sim900.h ****         KOMENDA_KOLEJKI_USTAW_WZMOCNIENIE_MIKROFONU,
1265:main_sim900.h ****     };
1266:main_sim900.h ****     // RE-DOING THIS CHUNK TO BE SAFE AND CORRECT
1267:main_sim900.h **** 
1268:main_sim900.h ****     const uchar nr = wykonywana_komenda - KOMENDA_KOLEJKI_SPRAWDZ_PIN;
1269:main_sim900.h ****     if (!wyslanie_polecenia_ROM(
1270:main_sim900.h ****             czy_mozna_wysylac_dane_do_SIM900, wykonywana_komenda,
1271:main_sim900.h ****             pgm_read_word(&nastepna_komenda[nr]), &instrukcje[nr][0]))
1272:main_sim900.h ****       break;
1273:main_sim900.h ****     POMOC_DODAJ2('*', 's');
1274:main_sim900.h ****     POMOC_DODAJ_HEX(nr);
1275:main_sim900.h ****     break;
1276:main_sim900.h ****   }
1277:main_sim900.h ****   default:
1278:main_sim900.h ****     return FALSE;
 5238               		.loc 2 1278 0
 5239 1a52 80E0      		ldi r24,0
 5240               	.LVL448:
 5241               	.L493:
 5242               	/* epilogue start */
1279:main_sim900.h ****   }
1280:main_sim900.h ****   return TRUE;
1281:main_sim900.h **** }
 5243               		.loc 2 1281 0
 5244 1a54 0F90      		pop __tmp_reg__
 5245 1a56 0F90      		pop __tmp_reg__
 5246 1a58 0F90      		pop __tmp_reg__
 5247 1a5a DF91      		pop r29
 5248 1a5c CF91      		pop r28
 5249 1a5e 1F91      		pop r17
 5250 1a60 0F91      		pop r16
 5251               	.LVL449:
 5252 1a62 FF90      		pop r15
 5253 1a64 EF90      		pop r14
 5254               	.LVL450:
 5255 1a66 0895      		ret
 5256               	.L595:
 842:main_sim900.h **** 
 5257               		.loc 2 842 0
 5258 1a68 81E0      		ldi r24,lo8(1)
 5259               	.L598:
 845:main_sim900.h ****       czy_jest_bezczynny_SIM900();
 5260               		.loc 2 845 0
 5261 1a6a 00E0      		ldi r16,0
 5262 1a6c 00C0      		rjmp .L496
 5263               	.LVL451:
 5264               	.L504:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5265               		.loc 2 849 0
 5266 1a6e 1F38      		cpi r17,lo8(-113)
 5267 1a70 01F4      		brne .+2
 5268 1a72 00C0      		rjmp .L508
 5269 1a74 00F4      		brsh .+2
 5270 1a76 00C0      		rjmp .L509
 5271 1a78 1039      		cpi r17,lo8(-112)
 5272 1a7a 01F4      		brne .+2
 5273 1a7c 00C0      		rjmp .L510
 5274 1a7e 1139      		cpi r17,lo8(-111)
 5275 1a80 01F4      		brne .L498
 5276               	.L615:
1280:main_sim900.h **** }
 5277               		.loc 2 1280 0
 5278 1a82 8FEF      		ldi r24,lo8(-1)
 5279 1a84 00C0      		rjmp .L493
 5280               	.L502:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5281               		.loc 2 849 0
 5282 1a86 1739      		cpi r17,lo8(-105)
 5283 1a88 01F4      		brne .+2
 5284 1a8a 00C0      		rjmp .L512
 5285 1a8c 00F4      		brsh .L513
 5286 1a8e 1539      		cpi r17,lo8(-107)
 5287 1a90 01F4      		brne .+2
 5288 1a92 00C0      		rjmp .L514
 5289 1a94 00F0      		brlo .+2
 5290 1a96 00C0      		rjmp .L515
 5291 1a98 1439      		cpi r17,lo8(-108)
 5292 1a9a 01F4      		brne .L498
 5293               	.LBB573:
1207:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5294               		.loc 2 1207 0
 5295 1a9c 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5296 1aa0 8111      		cpse r24,__zero_reg__
 5297 1aa2 00C0      		rjmp .L586
1207:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5298               		.loc 2 1207 0 is_stmt 0 discriminator 2
 5299 1aa4 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5300 1aa8 8111      		cpse r24,__zero_reg__
 5301 1aaa 00C0      		rjmp .L586
1207:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5302               		.loc 2 1207 0 discriminator 4
 5303 1aac 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5304 1ab0 8111      		cpse r24,__zero_reg__
 5305 1ab2 00C0      		rjmp .L586
1207:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5306               		.loc 2 1207 0 discriminator 6
 5307 1ab4 F99B      		sbis 0x1f,1
 5308 1ab6 00C0      		rjmp .L587
 5309               	.L586:
1207:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5310               		.loc 2 1207 0 discriminator 7
 5311 1ab8 84E9      		ldi r24,lo8(-108)
 5312 1aba 00C0      		rjmp .L656
 5313               	.L513:
 5314               	.LBE573:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5315               		.loc 2 849 0 is_stmt 1
 5316 1abc 1939      		cpi r17,lo8(-103)
 5317 1abe 01F4      		brne .+2
 5318 1ac0 00C0      		rjmp .L517
 5319 1ac2 00F4      		brsh .+2
 5320 1ac4 00C0      		rjmp .L518
 5321 1ac6 1A39      		cpi r17,lo8(-102)
 5322 1ac8 01F4      		brne .+2
 5323 1aca 00C0      		rjmp .L519
 5324 1acc 1B39      		cpi r17,lo8(-101)
 5325 1ace 01F4      		brne .L498
 5326               	.LBB574:
1068:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5327               		.loc 2 1068 0
 5328 1ad0 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 5329 1ad4 9111      		cpse r25,__zero_reg__
 5330 1ad6 00C0      		rjmp .L566
1068:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5331               		.loc 2 1068 0 is_stmt 0 discriminator 1
 5332 1ad8 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 5333 1adc 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5334 1ae0 232B      		or r18,r19
 5335 1ae2 01F4      		brne .L566
1068:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5336               		.loc 2 1068 0 discriminator 2
 5337 1ae4 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 5338 1ae8 9111      		cpse r25,__zero_reg__
 5339 1aea 00C0      		rjmp .L566
1069:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 5340               		.loc 2 1069 0 is_stmt 1
 5341 1aec 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 5342 1af0 9111      		cpse r25,__zero_reg__
 5343 1af2 00C0      		rjmp .L566
1070:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 5344               		.loc 2 1070 0
 5345 1af4 8111      		cpse r24,__zero_reg__
 5346 1af6 00C0      		rjmp .L566
1070:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 5347               		.loc 2 1070 0 is_stmt 0 discriminator 1
 5348 1af8 8091 0000 		lds r24,wysylanie_smsa_clipa
 5349 1afc 8823      		tst r24
 5350 1afe 01F4      		brne .+2
 5351 1b00 00C0      		rjmp .L567
 5352               	.L566:
1072:main_sim900.h ****           poziom_sieci_gsm == 0) // poziom sieci bez zmian
 5353               		.loc 2 1072 0 is_stmt 1
 5354 1b02 8091 0000 		lds r24,poziom_sieci_gsm
 5355 1b06 8336      		cpi r24,lo8(99)
 5356 1b08 01F0      		breq .L568
1072:main_sim900.h ****           poziom_sieci_gsm == 0) // poziom sieci bez zmian
 5357               		.loc 2 1072 0 is_stmt 0 discriminator 1
 5358 1b0a 8111      		cpse r24,__zero_reg__
 5359 1b0c 00C0      		rjmp .L615
 5360               	.L568:
1074:main_sim900.h ****       break;
 5361               		.loc 2 1074 0 is_stmt 1
 5362 1b0e 80E1      		ldi r24,lo8(16)
 5363 1b10 8093 0000 		sts poziom_sieci_gsm,r24
 5364 1b14 00C0      		rjmp .L615
 5365               	.L500:
 5366               	.LBE574:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5367               		.loc 2 849 0
 5368 1b16 123D      		cpi r17,lo8(-46)
 5369 1b18 00F0      		brlo .+2
 5370 1b1a 00C0      		rjmp .L521
 5371 1b1c 1E3B      		cpi r17,lo8(-66)
 5372 1b1e 00F0      		brlo .+2
 5373 1b20 00C0      		rjmp .L522
 5374 1b22 153A      		cpi r17,lo8(-91)
 5375 1b24 01F4      		brne .+2
 5376 1b26 00C0      		rjmp .L523
 5377 1b28 00F4      		brsh .L524
 5378 1b2a 1E39      		cpi r17,lo8(-98)
 5379 1b2c 01F4      		brne .+2
 5380 1b2e 00C0      		rjmp .L525
 5381               	.L526:
 5382               	.LBB575:
1268:main_sim900.h ****     if (!wyslanie_polecenia_ROM(
 5383               		.loc 2 1268 0
 5384 1b30 21E6      		ldi r18,lo8(97)
 5385 1b32 210F      		add r18,r17
 5386               	.LVL452:
 5387               	.LBB576:
1271:main_sim900.h ****       break;
 5388               		.loc 2 1271 0
 5389 1b34 E22F      		mov r30,r18
 5390 1b36 F0E0      		ldi r31,0
 5391 1b38 E050      		subi r30,lo8(-(nastepna_komenda.3475))
 5392 1b3a F040      		sbci r31,hi8(-(nastepna_komenda.3475))
 5393               	.LVL453:
 5394               	/* #APP */
 5395               	 ;  1271 "main_sim900.h" 1
 5396 1b3c 4591      		lpm r20, Z+
 5397 1b3e 5491      		lpm r21, Z
 5398               		
 5399               	 ;  0 "" 2
 5400               	.LVL454:
 5401               	/* #NOAPP */
 5402               	.LBE576:
1269:main_sim900.h ****             czy_mozna_wysylac_dane_do_SIM900, wykonywana_komenda,
 5403               		.loc 2 1269 0
 5404 1b40 FEE0      		ldi r31,lo8(14)
 5405 1b42 2F9F      		mul r18,r31
 5406 1b44 9001      		movw r18,r0
 5407 1b46 1124      		clr __zero_reg__
 5408               	.LVL455:
 5409 1b48 2050      		subi r18,lo8(-(instrukcje.3474))
 5410 1b4a 3040      		sbci r19,hi8(-(instrukcje.3474))
 5411 1b4c 612F      		mov r22,r17
 5412 1b4e 802F      		mov r24,r16
 5413 1b50 0E94 0000 		call wyslanie_polecenia_ROM
 5414               	.LVL456:
 5415 1b54 00C0      		rjmp .L615
 5416               	.LVL457:
 5417               	.L524:
 5418               	.LBE575:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5419               		.loc 2 849 0
 5420 1b56 1A3A      		cpi r17,lo8(-86)
 5421 1b58 00F0      		brlo .L526
 5422               	.LBB577:
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5423               		.loc 2 887 0
 5424 1b5a 9111      		cpse r25,__zero_reg__
 5425 1b5c 00C0      		rjmp .L662
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5426               		.loc 2 887 0 is_stmt 0 discriminator 2
 5427 1b5e 8091 0000 		lds r24,modul_zalogowany_w_sieci
 5428 1b62 8823      		tst r24
 5429 1b64 01F4      		brne .+2
 5430 1b66 00C0      		rjmp .L662
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5431               		.loc 2 887 0 discriminator 4
 5432 1b68 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5433 1b6c 8111      		cpse r24,__zero_reg__
 5434 1b6e 00C0      		rjmp .L662
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5435               		.loc 2 887 0 discriminator 6
 5436 1b70 8091 0000 		lds r24,licznik_bezpieczenstwa_wykonywana_rozmowa
 5437 1b74 9091 0000 		lds r25,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5438 1b78 892B      		or r24,r25
 5439 1b7a 01F0      		breq .+2
 5440 1b7c 00C0      		rjmp .L662
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5441               		.loc 2 887 0 discriminator 8
 5442 1b7e 8091 0000 		lds r24,opoznienie_SIM900_100MS
 5443 1b82 8111      		cpse r24,__zero_reg__
 5444 1b84 00C0      		rjmp .L662
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5445               		.loc 2 887 0 discriminator 10
 5446 1b86 8091 0000 		lds r24,wysylanie_smsa_clipa
 5447 1b8a 8111      		cpse r24,__zero_reg__
 5448 1b8c 00C0      		rjmp .L662
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5449               		.loc 2 887 0 discriminator 12
 5450 1b8e 8091 0000 		lds r24,flaga_wysylanie_smsa
 5451 1b92 8111      		cpse r24,__zero_reg__
 5452 1b94 00C0      		rjmp .L662
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5453               		.loc 2 887 0 discriminator 14
 5454 1b96 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 5455 1b9a 8239      		cpi r24,lo8(-110)
 5456 1b9c 01F4      		brne .+2
 5457 1b9e 00C0      		rjmp .L662
 893:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 5458               		.loc 2 893 0 is_stmt 1
 5459 1ba0 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5460 1ba4 8111      		cpse r24,__zero_reg__
 5461 1ba6 00C0      		rjmp .L662
 893:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 5462               		.loc 2 893 0 is_stmt 0 discriminator 2
 5463 1ba8 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5464 1bac 8111      		cpse r24,__zero_reg__
 5465 1bae 00C0      		rjmp .L662
 893:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 5466               		.loc 2 893 0 discriminator 4
 5467 1bb0 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5468 1bb4 8111      		cpse r24,__zero_reg__
 5469 1bb6 00C0      		rjmp .L662
 893:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 5470               		.loc 2 893 0 discriminator 6
 5471 1bb8 F999      		sbic 0x1f,1
 5472 1bba 00C0      		rjmp .L662
 894:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW,
 5473               		.loc 2 894 0 is_stmt 1
 5474 1bbc 61E0      		ldi r22,lo8(1)
 5475 1bbe 81E0      		ldi r24,lo8(1)
 5476 1bc0 0E94 0000 		call czy_sa_komendy_z_przedzialu
 5477               	.LVL458:
 5478 1bc4 8111      		cpse r24,__zero_reg__
 5479 1bc6 00C0      		rjmp .L662
 894:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW,
 5480               		.loc 2 894 0 is_stmt 0 discriminator 2
 5481 1bc8 65ED      		ldi r22,lo8(-43)
 5482 1bca 83ED      		ldi r24,lo8(-45)
 5483 1bcc 0E94 0000 		call czy_sa_komendy_z_przedzialu
 5484               	.LVL459:
 5485 1bd0 8111      		cpse r24,__zero_reg__
 5486 1bd2 00C0      		rjmp .L662
 894:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW,
 5487               		.loc 2 894 0 discriminator 4
 5488 1bd4 68E9      		ldi r22,lo8(-104)
 5489 1bd6 86E9      		ldi r24,lo8(-106)
 5490 1bd8 0E94 0000 		call czy_sa_komendy_z_przedzialu
 5491               	.LVL460:
 5492 1bdc 8111      		cpse r24,__zero_reg__
 5493 1bde 00C0      		rjmp .L662
 902:main_sim900.h ****     flaga_odczytywanie_smsa = TRUE;
 5494               		.loc 2 902 0 is_stmt 1
 5495 1be0 0023      		tst r16
 5496 1be2 01F4      		brne .+2
 5497 1be4 00C0      		rjmp .L662
 902:main_sim900.h ****     flaga_odczytywanie_smsa = TRUE;
 5498               		.loc 2 902 0 is_stmt 0 discriminator 2
 5499 1be6 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5500 1bea 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5501 1bee 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
 903:main_sim900.h ****     static const char instrukcja_odczytaj_smsa[] PROGMEM = "+cmgr=";
 5502               		.loc 2 903 0 is_stmt 1 discriminator 2
 5503 1bf2 8FEF      		ldi r24,lo8(-1)
 5504 1bf4 8093 0000 		sts flaga_odczytywanie_smsa,r24
 905:main_sim900.h ****     const uint nr_smsa =
 5505               		.loc 2 905 0 discriminator 2
 5506 1bf8 46E0      		ldi r20,lo8(6)
 5507 1bfa 50E0      		ldi r21,0
 5508 1bfc 60E0      		ldi r22,lo8(instrukcja_odczytaj_smsa.3388)
 5509 1bfe 70E0      		ldi r23,hi8(instrukcja_odczytaj_smsa.3388)
 5510 1c00 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 5511 1c02 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 5512 1c04 0E94 0000 		call memcpy_P
 5513               	.LVL461:
 5514               	.LBB578:
 5515               	.LBB579:
 5516               		.loc 6 527 0 discriminator 2
 5517 1c08 4AE0      		ldi r20,lo8(10)
 5518 1c0a 60E0      		ldi r22,lo8(wysylany_blok_SIM900+8)
 5519 1c0c 70E0      		ldi r23,hi8(wysylany_blok_SIM900+8)
 5520               	.LVL462:
 5521 1c0e C701      		movw r24,r14
 5522 1c10 895A      		subi r24,-87
 5523 1c12 9109      		sbc r25,__zero_reg__
 5524               	.LVL463:
 5525               	.L663:
 5526               	.LBE579:
 5527               	.LBE578:
 5528               	.LBE577:
 5529               	.LBB580:
 5530               	.LBB581:
 5531               	.LBB582:
 5532 1c14 0E94 0000 		call __utoa_ncheck
 5533               	.LVL464:
 5534               	.L657:
 5535               	.LBE582:
 5536               	.LBE581:
 5537               	.LBE580:
1233:main_sim900.h ****     break;
 5538               		.loc 2 1233 0 discriminator 2
 5539 1c18 0E94 0000 		call wyslij_polecenie_RAM_SIM900
 5540               	.LVL465:
 5541 1c1c 00C0      		rjmp .L615
 5542               	.L521:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5543               		.loc 2 849 0
 5544 1c1e 153D      		cpi r17,lo8(-43)
 5545 1c20 01F4      		brne .+2
 5546 1c22 00C0      		rjmp .L528
 5547 1c24 00F4      		brsh .L529
 5548 1c26 123D      		cpi r17,lo8(-46)
 5549 1c28 01F4      		brne .L654
 5550               	.LBB585:
 915:main_sim900.h ****         bufor_pdu, numer_telefonu_odebranego_smsa,
 5551               		.loc 2 915 0
 5552 1c2a 40E0      		ldi r20,lo8(nie_wysylaj_echa_z_powodu_nietypowego_smsa)
 5553 1c2c 50E0      		ldi r21,hi8(nie_wysylaj_echa_z_powodu_nietypowego_smsa)
 5554 1c2e 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 5555 1c30 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 5556 1c32 80E0      		ldi r24,lo8(bufor_pdu)
 5557 1c34 90E0      		ldi r25,hi8(bufor_pdu)
 5558 1c36 0E94 0000 		call pobierz_numer_telefonu_nadawcy_z_PDU
 5559               	.LVL466:
 918:main_sim900.h ****     {
 5560               		.loc 2 918 0
 5561 1c3a 0097      		sbiw r24,0
 5562 1c3c 01F0      		breq .+2
 5563 1c3e 00C0      		rjmp .L548
 5564               	.LVL467:
 5565               	.L658:
 5566               	.LBE585:
 952:main_sim900.h ****     break;
 5567               		.loc 2 952 0
 5568 1c40 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 5569 1c44 00C0      		rjmp .L615
 5570               	.L529:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5571               		.loc 2 849 0
 5572 1c46 183D      		cpi r17,lo8(-40)
 5573 1c48 01F4      		brne .+2
 5574 1c4a 00C0      		rjmp .L532
 5575 1c4c 1E3F      		cpi r17,lo8(-2)
 5576 1c4e 01F4      		brne .+2
 5577 1c50 00C0      		rjmp .L533
 5578 1c52 163D      		cpi r17,lo8(-42)
 5579 1c54 01F0      		breq .+2
 5580 1c56 00C0      		rjmp .L498
 5581               	.LBB588:
1046:main_sim900.h ****     if (wykonywanie_rozmowy_telefonicznej)
 5582               		.loc 2 1046 0
 5583 1c58 8091 0000 		lds r24,modul_zalogowany_w_sieci
 5584 1c5c 8823      		tst r24
 5585 1c5e 01F0      		breq .L564
1046:main_sim900.h ****     if (wykonywanie_rozmowy_telefonicznej)
 5586               		.loc 2 1046 0 is_stmt 0 discriminator 2
 5587 1c60 8091 0000 		lds r24,opoznienie_SIM900_100MS
 5588 1c64 8823      		tst r24
 5589 1c66 01F4      		brne .+2
 5590 1c68 00C0      		rjmp .L565
 5591               	.L564:
1046:main_sim900.h ****     if (wykonywanie_rozmowy_telefonicznej)
 5592               		.loc 2 1046 0 discriminator 3
 5593 1c6a 86ED      		ldi r24,lo8(-42)
 5594 1c6c 00C0      		rjmp .L656
 5595               	.L654:
 5596               	.LBE588:
 852:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 5597               		.loc 2 852 0 is_stmt 1
 5598 1c6e 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5599 1c72 8111      		cpse r24,__zero_reg__
 5600 1c74 00C0      		rjmp .L662
 852:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 5601               		.loc 2 852 0 is_stmt 0 discriminator 2
 5602 1c76 8091 0000 		lds r24,licznik_bezpieczenstwa_wykonywana_rozmowa
 5603 1c7a 9091 0000 		lds r25,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5604 1c7e 892B      		or r24,r25
 5605 1c80 01F4      		brne .L662
 852:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 5606               		.loc 2 852 0 discriminator 4
 5607 1c82 8091 0000 		lds r24,opoznienie_SIM900_100MS
 5608 1c86 8823      		tst r24
 5609 1c88 01F0      		breq .L536
 5610               	.L662:
 5611               	.LBB589:
 978:main_sim900.h ****     static const char instrukcja_usun_smsa[] PROGMEM = "+cmgd=";
 5612               		.loc 2 978 0 is_stmt 1 discriminator 1
 5613 1c8a 812F      		mov r24,r17
 5614 1c8c 00C0      		rjmp .L656
 5615               	.L536:
 5616               	.LBE589:
 853:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5617               		.loc 2 853 0
 5618 1c8e 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5619 1c92 8111      		cpse r24,__zero_reg__
 5620 1c94 00C0      		rjmp .L662
 853:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5621               		.loc 2 853 0 is_stmt 0 discriminator 2
 5622 1c96 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5623 1c9a 8111      		cpse r24,__zero_reg__
 5624 1c9c 00C0      		rjmp .L662
 853:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5625               		.loc 2 853 0 discriminator 4
 5626 1c9e 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5627 1ca2 8111      		cpse r24,__zero_reg__
 5628 1ca4 00C0      		rjmp .L662
 853:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5629               		.loc 2 853 0 discriminator 6
 5630 1ca6 F999      		sbic 0x1f,1
 5631 1ca8 00C0      		rjmp .L662
 854:main_sim900.h ****     wyslij_sms(wykonywana_komenda == KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
 5632               		.loc 2 854 0 is_stmt 1
 5633 1caa 0023      		tst r16
 5634 1cac 01F0      		breq .L662
 854:main_sim900.h ****     wyslij_sms(wykonywana_komenda == KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
 5635               		.loc 2 854 0 is_stmt 0 discriminator 2
 5636 1cae 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5637 1cb2 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5638 1cb6 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
 855:main_sim900.h ****     break;
 5639               		.loc 2 855 0 is_stmt 1 discriminator 2
 5640 1cba 81E0      		ldi r24,lo8(1)
 5641 1cbc 143D      		cpi r17,lo8(-44)
 5642 1cbe 01F0      		breq .L540
 5643 1cc0 80E0      		ldi r24,0
 5644               	.L540:
 5645 1cc2 0E94 0000 		call wyslij_sms
 5646               	.LVL468:
 5647 1cc6 00C0      		rjmp .L615
 5648               	.L528:
 5649               	.LBB590:
 859:main_sim900.h ****     konwertuj_pdu_na_blok_wysylany(wysylany_blok_SIM900, bufor_pdu,
 5650               		.loc 2 859 0
 5651 1cc8 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
 860:main_sim900.h ****                                    dlugosc_pdu);
 5652               		.loc 2 860 0
 5653 1ccc 4091 0000 		lds r20,dlugosc_pdu
 5654 1cd0 60E0      		ldi r22,lo8(bufor_pdu)
 5655 1cd2 70E0      		ldi r23,hi8(bufor_pdu)
 5656 1cd4 80E0      		ldi r24,lo8(wysylany_blok_SIM900)
 5657 1cd6 90E0      		ldi r25,hi8(wysylany_blok_SIM900)
 5658 1cd8 0E94 0000 		call konwertuj_pdu_na_blok_wysylany
 5659               	.LVL469:
 862:main_sim900.h ****     wysylany_blok_SIM900[liczba_znakow - 1] = ZNAK_CTRL_Z;
 5660               		.loc 2 862 0
 5661 1cdc 8091 0000 		lds r24,dlugosc_pdu
 5662 1ce0 90E0      		ldi r25,0
 5663 1ce2 880F      		lsl r24
 5664 1ce4 991F      		rol r25
 5665 1ce6 0196      		adiw r24,1
 5666               	.LVL470:
 863:main_sim900.h ****     wyslij_znaki_SIM900(liczba_znakow);
 5667               		.loc 2 863 0
 5668 1ce8 FC01      		movw r30,r24
 5669 1cea E050      		subi r30,lo8(-(wysylany_blok_SIM900-1))
 5670 1cec F040      		sbci r31,hi8(-(wysylany_blok_SIM900-1))
 5671 1cee 2AE1      		ldi r18,lo8(26)
 5672 1cf0 2083      		st Z,r18
 864:main_sim900.h ****     break;
 5673               		.loc 2 864 0
 5674 1cf2 0E94 0000 		call wyslij_znaki_SIM900
 5675               	.LVL471:
 5676 1cf6 00C0      		rjmp .L615
 5677               	.LVL472:
 5678               	.L548:
 5679               	.LBE590:
 5680               	.LBB591:
 5681               	.LBB586:
 925:main_sim900.h ****     }
 5682               		.loc 2 925 0
 5683 1cf8 9E01      		movw r18,r28
 5684 1cfa 2F5F      		subi r18,-1
 5685 1cfc 3F4F      		sbci r19,-1
 5686 1cfe AE01      		movw r20,r28
 5687 1d00 4E5F      		subi r20,-2
 5688 1d02 5F4F      		sbci r21,-1
 5689 1d04 BE01      		movw r22,r28
 5690 1d06 6D5F      		subi r22,-3
 5691 1d08 7F4F      		sbci r23,-1
 5692 1d0a 0E94 0000 		call pobierz_date_z_PDU
 5693               	.LVL473:
 5694               	.LBE586:
 5695               	.LBB587:
 929:main_sim900.h **** 
 5696               		.loc 2 929 0
 5697 1d0e 9E01      		movw r18,r28
 5698 1d10 2F5F      		subi r18,-1
 5699 1d12 3F4F      		sbci r19,-1
 5700 1d14 AE01      		movw r20,r28
 5701 1d16 4E5F      		subi r20,-2
 5702 1d18 5F4F      		sbci r21,-1
 5703 1d1a BE01      		movw r22,r28
 5704 1d1c 6D5F      		subi r22,-3
 5705 1d1e 7F4F      		sbci r23,-1
 5706 1d20 0E94 0000 		call pobierz_czas_z_PDU
 5707               	.LVL474:
 933:main_sim900.h ****       sms_timestamp_minuta = minuta;
 5708               		.loc 2 933 0
 5709 1d24 2B81      		ldd r18,Y+3
 5710 1d26 2093 0000 		sts sms_timestamp_godzina,r18
 934:main_sim900.h ****       extern uchar sms_timestamp_sekunda;
 5711               		.loc 2 934 0
 5712 1d2a 2A81      		ldd r18,Y+2
 5713 1d2c 2093 0000 		sts sms_timestamp_minuta,r18
 936:main_sim900.h ****     }
 5714               		.loc 2 936 0
 5715 1d30 2981      		ldd r18,Y+1
 5716 1d32 2093 0000 		sts sms_timestamp_sekunda,r18
 5717               	.LBE587:
 938:main_sim900.h ****     pdu_to_ascii(ptr, tekst_odebranego_smsa, MAX_LICZBA_ZNAKOW_SMS + 1);
 5718               		.loc 2 938 0
 5719 1d36 9093 0000 		sts ptr_start_pdu_z_wiadomoscia+1,r25
 5720 1d3a 8093 0000 		sts ptr_start_pdu_z_wiadomoscia,r24
 939:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 5721               		.loc 2 939 0
 5722 1d3e 41EA      		ldi r20,lo8(-95)
 5723 1d40 60E0      		ldi r22,lo8(wysylany_blok_SIM900+239)
 5724 1d42 70E0      		ldi r23,hi8(wysylany_blok_SIM900+239)
 5725 1d44 0E94 0000 		call pdu_to_ascii
 5726               	.LVL475:
 5727               	.L549:
 5728               	.LBE591:
 949:main_sim900.h ****     zapal_diode_led(10);
 5729               		.loc 2 949 0 discriminator 7
 5730 1d48 88ED      		ldi r24,lo8(-40)
 5731               	.L656:
1230:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5732               		.loc 2 1230 0 discriminator 7
 5733 1d4a 0E94 0000 		call dodaj_komende
 5734               	.LVL476:
 5735 1d4e 00C0      		rjmp .L615
 5736               	.L532:
 949:main_sim900.h ****     zapal_diode_led(10);
 5737               		.loc 2 949 0
 5738 1d50 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5739 1d54 8111      		cpse r24,__zero_reg__
 5740 1d56 00C0      		rjmp .L549
 949:main_sim900.h ****     zapal_diode_led(10);
 5741               		.loc 2 949 0 is_stmt 0 discriminator 2
 5742 1d58 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5743 1d5c 8111      		cpse r24,__zero_reg__
 5744 1d5e 00C0      		rjmp .L549
 949:main_sim900.h ****     zapal_diode_led(10);
 5745               		.loc 2 949 0 discriminator 4
 5746 1d60 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5747 1d64 8111      		cpse r24,__zero_reg__
 5748 1d66 00C0      		rjmp .L549
 949:main_sim900.h ****     zapal_diode_led(10);
 5749               		.loc 2 949 0 discriminator 6
 5750 1d68 F999      		sbic 0x1f,1
 5751 1d6a 00C0      		rjmp .L549
 950:main_sim900.h ****     wykonanie_polecenia_sms();
 5752               		.loc 2 950 0 is_stmt 1
 5753 1d6c 8BE0      		ldi r24,lo8(11)
 5754 1d6e 8093 0000 		sts licznik_100ms_dioda_led,r24
 951:main_sim900.h ****     flaga_odczytywanie_smsa = FALSE;
 5755               		.loc 2 951 0
 5756 1d72 0E94 0000 		call wykonanie_polecenia_sms
 5757               	.LVL477:
 5758 1d76 00C0      		rjmp .L658
 5759               	.L522:
 5760               	.LBB592:
 975:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5761               		.loc 2 975 0
 5762 1d78 9111      		cpse r25,__zero_reg__
 5763 1d7a 00C0      		rjmp .L662
 975:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5764               		.loc 2 975 0 is_stmt 0 discriminator 2
 5765 1d7c 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5766 1d80 8111      		cpse r24,__zero_reg__
 5767 1d82 00C0      		rjmp .L662
 975:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5768               		.loc 2 975 0 discriminator 4
 5769 1d84 8091 0000 		lds r24,licznik_bezpieczenstwa_wykonywana_rozmowa
 5770 1d88 9091 0000 		lds r25,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5771 1d8c 892B      		or r24,r25
 5772 1d8e 01F0      		breq .+2
 5773 1d90 00C0      		rjmp .L662
 975:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5774               		.loc 2 975 0 discriminator 6
 5775 1d92 8091 0000 		lds r24,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 5776 1d96 8111      		cpse r24,__zero_reg__
 5777 1d98 00C0      		rjmp .L662
 975:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5778               		.loc 2 975 0 discriminator 8
 5779 1d9a 8091 0000 		lds r24,czekanie_na_odebranie_zachety
 5780 1d9e 8111      		cpse r24,__zero_reg__
 5781 1da0 00C0      		rjmp .L662
 978:main_sim900.h ****     static const char instrukcja_usun_smsa[] PROGMEM = "+cmgd=";
 5782               		.loc 2 978 0 is_stmt 1
 5783 1da2 0023      		tst r16
 5784 1da4 01F4      		brne .+2
 5785 1da6 00C0      		rjmp .L662
 978:main_sim900.h ****     static const char instrukcja_usun_smsa[] PROGMEM = "+cmgd=";
 5786               		.loc 2 978 0 is_stmt 0 discriminator 2
 5787 1da8 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5788 1dac 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5789 1db0 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
 980:main_sim900.h ****     const uint nr_smsa = wykonywana_komenda - KOMENDA_KOLEJKI_USUN_SMSA_1 + 1;
 5790               		.loc 2 980 0 is_stmt 1 discriminator 2
 5791 1db4 46E0      		ldi r20,lo8(6)
 5792 1db6 50E0      		ldi r21,0
 5793 1db8 60E0      		ldi r22,lo8(instrukcja_usun_smsa.3421)
 5794 1dba 70E0      		ldi r23,hi8(instrukcja_usun_smsa.3421)
 5795 1dbc 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 5796 1dbe 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 5797 1dc0 0E94 0000 		call memcpy_P
 5798               	.LVL478:
 5799               	.LBB584:
 5800               	.LBB583:
 5801               		.loc 6 527 0 discriminator 2
 5802 1dc4 4AE0      		ldi r20,lo8(10)
 5803 1dc6 60E0      		ldi r22,lo8(wysylany_blok_SIM900+8)
 5804 1dc8 70E0      		ldi r23,hi8(wysylany_blok_SIM900+8)
 5805               	.LVL479:
 5806 1dca C701      		movw r24,r14
 5807 1dcc 8D5B      		subi r24,-67
 5808 1dce 9109      		sbc r25,__zero_reg__
 5809               	.LVL480:
 5810 1dd0 00C0      		rjmp .L663
 5811               	.LVL481:
 5812               	.L518:
 5813               	.LBE583:
 5814               	.LBE584:
 5815               	.LBE592:
 5816               	.LBB593:
 989:main_sim900.h ****     zapal_diode_led(10);
 5817               		.loc 2 989 0
 5818 1dd2 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5819 1dd6 8111      		cpse r24,__zero_reg__
 5820 1dd8 00C0      		rjmp .L554
 989:main_sim900.h ****     zapal_diode_led(10);
 5821               		.loc 2 989 0 is_stmt 0 discriminator 2
 5822 1dda 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5823 1dde 8111      		cpse r24,__zero_reg__
 5824 1de0 00C0      		rjmp .L554
 989:main_sim900.h ****     zapal_diode_led(10);
 5825               		.loc 2 989 0 discriminator 4
 5826 1de2 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5827 1de6 8111      		cpse r24,__zero_reg__
 5828 1de8 00C0      		rjmp .L554
 989:main_sim900.h ****     zapal_diode_led(10);
 5829               		.loc 2 989 0 discriminator 6
 5830 1dea F99B      		sbis 0x1f,1
 5831 1dec 00C0      		rjmp .L555
 5832               	.L554:
 989:main_sim900.h ****     zapal_diode_led(10);
 5833               		.loc 2 989 0 discriminator 7
 5834 1dee 88E9      		ldi r24,lo8(-104)
 5835 1df0 00C0      		rjmp .L656
 5836               	.L555:
 990:main_sim900.h **** 
 5837               		.loc 2 990 0 is_stmt 1
 5838 1df2 8BE0      		ldi r24,lo8(11)
 5839 1df4 8093 0000 		sts licznik_100ms_dioda_led,r24
 992:main_sim900.h ****         sprawdz_przychodzaca_rozmowe(); // Returns TRUE if number authorized
 5840               		.loc 2 992 0
 5841 1df8 0E94 0000 		call sprawdz_przychodzaca_rozmowe
 5842               	.LVL482:
 995:main_sim900.h ****       if (tryb_clip) {
 5843               		.loc 2 995 0
 5844 1dfc 8823      		tst r24
 5845 1dfe 01F0      		breq .L556
 996:main_sim900.h ****         // Tryb CLIP: wlacz wyjscie i ODRZUC polaczenie
 5846               		.loc 2 996 0
 5847 1e00 8091 0000 		lds r24,tryb_clip
 5848               	.LVL483:
 5849 1e04 8823      		tst r24
 5850 1e06 01F0      		breq .L557
 998:main_sim900.h ****           ustaw_wyjscie_clip();
 5851               		.loc 2 998 0
 5852 1e08 80E0      		ldi r24,lo8(__c.3425)
 5853 1e0a 90E0      		ldi r25,hi8(__c.3425)
 5854 1e0c 0E94 0000 		call polozenie_polecenia_SIM900
 5855               	.LVL484:
 5856 1e10 892B      		or r24,r25
 5857 1e12 01F4      		brne .L556
 999:main_sim900.h ****         }
 5858               		.loc 2 999 0
 5859 1e14 0E94 0000 		call ustaw_wyjscie_clip
 5860               	.LVL485:
 5861               	.L556:
1001:main_sim900.h ****       } else {
 5862               		.loc 2 1001 0
 5863 1e18 87E9      		ldi r24,lo8(-105)
 5864               	.L655:
1004:main_sim900.h ****       }
 5865               		.loc 2 1004 0
 5866 1e1a 0E94 0000 		call dodaj_komende
 5867               	.LVL486:
1010:main_sim900.h ****     break;
 5868               		.loc 2 1010 0
 5869 1e1e 8FEF      		ldi r24,lo8(-1)
 5870 1e20 8093 0000 		sts blokada_clip,r24
1011:main_sim900.h ****   }
 5871               		.loc 2 1011 0
 5872 1e24 00C0      		rjmp .L493
 5873               	.L557:
1004:main_sim900.h ****       }
 5874               		.loc 2 1004 0
 5875 1e26 86E9      		ldi r24,lo8(-106)
 5876 1e28 00C0      		rjmp .L655
 5877               	.L512:
 5878               	.LBE593:
 5879               	.LBB594:
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5880               		.loc 2 1014 0
 5881 1e2a 8091 0000 		lds r24,flaga_wysylanie_smsa
 5882 1e2e 8111      		cpse r24,__zero_reg__
 5883 1e30 00C0      		rjmp .L559
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5884               		.loc 2 1014 0 is_stmt 0 discriminator 2
 5885 1e32 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5886 1e36 8111      		cpse r24,__zero_reg__
 5887 1e38 00C0      		rjmp .L559
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5888               		.loc 2 1014 0 discriminator 4
 5889 1e3a 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 5890 1e3e 8111      		cpse r24,__zero_reg__
 5891 1e40 00C0      		rjmp .L559
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5892               		.loc 2 1014 0 discriminator 6
 5893 1e42 8091 0000 		lds r24,czekanie_na_odebranie_zachety
 5894 1e46 8111      		cpse r24,__zero_reg__
 5895 1e48 00C0      		rjmp .L559
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5896               		.loc 2 1014 0 discriminator 10
 5897 1e4a 8091 C100 		lds r24,193
 5898 1e4e 86FD      		sbrc r24,6
 5899 1e50 00C0      		rjmp .L559
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5900               		.loc 2 1014 0 discriminator 12
 5901 1e52 8091 0000 		lds r24,podlaczony_modul_gsm_SIM900
 5902 1e56 8823      		tst r24
 5903 1e58 01F0      		breq .L559
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5904               		.loc 2 1014 0 discriminator 14
 5905 1e5a 8091 0000 		lds r24,komenda_SIM900
 5906 1e5e 8823      		tst r24
 5907 1e60 01F0      		breq .L560
 5908               	.L559:
1014:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5909               		.loc 2 1014 0 discriminator 15
 5910 1e62 87E9      		ldi r24,lo8(-105)
 5911 1e64 00C0      		rjmp .L656
 5912               	.L560:
1019:main_sim900.h ****     static const char instrukcja_odrzuc_rozmowe[] PROGMEM = "h";
 5913               		.loc 2 1019 0 is_stmt 1
 5914 1e66 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5915 1e6a 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5916 1e6e 87E9      		ldi r24,lo8(-105)
 5917 1e70 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1021:main_sim900.h ****     break;
 5918               		.loc 2 1021 0
 5919 1e74 80E0      		ldi r24,lo8(instrukcja_odrzuc_rozmowe.3428)
 5920 1e76 90E0      		ldi r25,hi8(instrukcja_odrzuc_rozmowe.3428)
 5921               	.L659:
 5922               	.LBE594:
 5923               	.LBB595:
1196:main_sim900.h ****     break;
 5924               		.loc 2 1196 0 discriminator 2
 5925 1e78 0E94 0000 		call wyslij_polecenie_ROM_SIM900
 5926               	.LVL487:
 5927 1e7c 00C0      		rjmp .L615
 5928               	.L515:
 5929               	.LBE595:
 5930               	.LBB596:
1025:main_sim900.h ****     static const char instrukcja_odbierz_rozmowe[] PROGMEM = "a";
 5931               		.loc 2 1025 0
 5932 1e7e 86E9      		ldi r24,lo8(-106)
 5933 1e80 0023      		tst r16
 5934 1e82 01F4      		brne .+2
 5935 1e84 00C0      		rjmp .L656
1025:main_sim900.h ****     static const char instrukcja_odbierz_rozmowe[] PROGMEM = "a";
 5936               		.loc 2 1025 0 is_stmt 0 discriminator 2
 5937 1e86 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5938 1e8a 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5939 1e8e 86E9      		ldi r24,lo8(-106)
 5940 1e90 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1027:main_sim900.h ****     POMOC_DODAJ2('#', 'p');
 5941               		.loc 2 1027 0 is_stmt 1 discriminator 2
 5942 1e94 80E0      		ldi r24,lo8(instrukcja_odbierz_rozmowe.3430)
 5943 1e96 90E0      		ldi r25,hi8(instrukcja_odbierz_rozmowe.3430)
 5944 1e98 00C0      		rjmp .L659
 5945               	.L523:
 5946               	.LBE596:
 5947               	.LBB597:
1033:main_sim900.h ****     if (!CZY_MOZNA_WYSYLAC_DANE_SIM900() || !czy_jest_bezczynny_SIM900() ||
 5948               		.loc 2 1033 0
 5949 1e9a 8091 0000 		lds r24,opoznienie_SIM900_100MS
 5950 1e9e 8823      		tst r24
 5951 1ea0 01F0      		breq .L562
 5952               	.L563:
1033:main_sim900.h ****     if (!CZY_MOZNA_WYSYLAC_DANE_SIM900() || !czy_jest_bezczynny_SIM900() ||
 5953               		.loc 2 1033 0 is_stmt 0 discriminator 1
 5954 1ea2 85EA      		ldi r24,lo8(-91)
 5955 1ea4 00C0      		rjmp .L656
 5956               	.L562:
1034:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 5957               		.loc 2 1034 0 is_stmt 1
 5958 1ea6 8091 C100 		lds r24,193
 5959 1eaa 86FD      		sbrc r24,6
 5960 1eac 00C0      		rjmp .L563
1034:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 5961               		.loc 2 1034 0 is_stmt 0 discriminator 1
 5962 1eae 8091 0000 		lds r24,podlaczony_modul_gsm_SIM900
 5963 1eb2 8823      		tst r24
 5964 1eb4 01F0      		breq .L563
1034:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 5965               		.loc 2 1034 0 discriminator 2
 5966 1eb6 8091 0000 		lds r24,komenda_SIM900
 5967 1eba 8111      		cpse r24,__zero_reg__
 5968 1ebc 00C0      		rjmp .L563
1034:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 5969               		.loc 2 1034 0 discriminator 3
 5970 1ebe 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 5971 1ec2 8111      		cpse r24,__zero_reg__
 5972 1ec4 00C0      		rjmp .L563
1039:main_sim900.h ****     static const char instrukcja_vts[] PROGMEM = "+vts=1";
 5973               		.loc 2 1039 0 is_stmt 1
 5974 1ec6 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5975 1eca 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5976 1ece 85EA      		ldi r24,lo8(-91)
 5977 1ed0 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1041:main_sim900.h ****     POMOC_DODAJ2('#', 'V');
 5978               		.loc 2 1041 0
 5979 1ed4 80E0      		ldi r24,lo8(instrukcja_vts.3432)
 5980 1ed6 90E0      		ldi r25,hi8(instrukcja_vts.3432)
 5981 1ed8 00C0      		rjmp .L659
 5982               	.L565:
 5983               	.LBE597:
 5984               	.LBB598:
1047:main_sim900.h ****       break;
 5985               		.loc 2 1047 0
 5986 1eda 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5987 1ede 8111      		cpse r24,__zero_reg__
 5988 1ee0 00C0      		rjmp .L615
1049:main_sim900.h ****     zapal_diode_led(20);
 5989               		.loc 2 1049 0
 5990 1ee2 0023      		tst r16
 5991 1ee4 01F4      		brne .+2
 5992 1ee6 00C0      		rjmp .L564
1049:main_sim900.h ****     zapal_diode_led(20);
 5993               		.loc 2 1049 0 is_stmt 0 discriminator 2
 5994 1ee8 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5995 1eec 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5996 1ef0 86ED      		ldi r24,lo8(-42)
 5997 1ef2 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1050:main_sim900.h ****     wysylane_dane_RAM_SIM900[0] = 'd';
 5998               		.loc 2 1050 0 is_stmt 1 discriminator 2
 5999 1ef6 85E1      		ldi r24,lo8(21)
 6000 1ef8 8093 0000 		sts licznik_100ms_dioda_led,r24
1051:main_sim900.h ****     // static const char doladowanie[] PROGMEM = "*100*59484869838559#";
 6001               		.loc 2 1051 0 discriminator 2
 6002 1efc 84E6      		ldi r24,lo8(100)
 6003 1efe 8093 0000 		sts wysylany_blok_SIM900+2,r24
1054:main_sim900.h ****     uchar l = strlen(numer_telefonu_do_ktorego_dzwonic) + 1;
 6004               		.loc 2 1054 0 discriminator 2
 6005 1f02 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 6006 1f04 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 6007 1f06 80E0      		ldi r24,lo8(wysylany_blok_SIM900+3)
 6008 1f08 90E0      		ldi r25,hi8(wysylany_blok_SIM900+3)
 6009 1f0a 0E94 0000 		call strcpy
 6010               	.LVL488:
1055:main_sim900.h ****     wysylane_dane_RAM_SIM900[l] = ';';
 6011               		.loc 2 1055 0 discriminator 2
 6012 1f0e 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 6013 1f10 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 6014 1f12 FC01      		movw r30,r24
 6015               		0:
 6016 1f14 0190      		ld __tmp_reg__,Z+
 6017 1f16 0020      		tst __tmp_reg__
 6018 1f18 01F4      		brne 0b
 6019 1f1a CF01      		movw r24,r30
 6020 1f1c 8050      		subi r24,lo8(numer_telefonu_do_ktorego_dzwonic+1)
 6021 1f1e 9040      		sbci r25,hi8(numer_telefonu_do_ktorego_dzwonic+1)
 6022               	.LVL489:
 6023 1f20 8F5F      		subi r24,lo8(-(1))
 6024               	.LVL490:
1056:main_sim900.h ****     wysylane_dane_RAM_SIM900[l + 1] = '\0';
 6025               		.loc 2 1056 0 discriminator 2
 6026 1f22 90E0      		ldi r25,0
 6027 1f24 FC01      		movw r30,r24
 6028               	.LVL491:
 6029 1f26 E050      		subi r30,lo8(-(wysylany_blok_SIM900+2))
 6030 1f28 F040      		sbci r31,hi8(-(wysylany_blok_SIM900+2))
 6031 1f2a 2BE3      		ldi r18,lo8(59)
 6032 1f2c 2083      		st Z,r18
1057:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 6033               		.loc 2 1057 0 discriminator 2
 6034 1f2e 8050      		subi r24,lo8(-(wysylany_blok_SIM900+3))
 6035 1f30 9040      		sbci r25,hi8(-(wysylany_blok_SIM900+3))
 6036 1f32 FC01      		movw r30,r24
 6037 1f34 1082      		st Z,__zero_reg__
1058:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 300;
 6038               		.loc 2 1058 0 discriminator 2
 6039 1f36 0E94 0000 		call wyslij_polecenie_RAM_SIM900
 6040               	.LVL492:
1059:main_sim900.h ****     POMOC_DODAJ2('#', 'h');
 6041               		.loc 2 1059 0 discriminator 2
 6042 1f3a 8CE2      		ldi r24,lo8(44)
 6043 1f3c 91E0      		ldi r25,lo8(1)
 6044 1f3e 9093 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,r25
 6045 1f42 8093 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,r24
 6046               	.LVL493:
 6047 1f46 00C0      		rjmp .L615
 6048               	.LVL494:
 6049               	.L567:
 6050               	.LBE598:
 6051               	.LBB599:
1077:main_sim900.h ****     static const char instrukcja_poziom_sieci[] PROGMEM = "+csq";
 6052               		.loc 2 1077 0
 6053 1f48 8BE9      		ldi r24,lo8(-101)
 6054 1f4a 0023      		tst r16
 6055 1f4c 01F4      		brne .+2
 6056 1f4e 00C0      		rjmp .L656
1077:main_sim900.h ****     static const char instrukcja_poziom_sieci[] PROGMEM = "+csq";
 6057               		.loc 2 1077 0 is_stmt 0 discriminator 2
 6058 1f50 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6059 1f54 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6060 1f58 8BE9      		ldi r24,lo8(-101)
 6061 1f5a 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1079:main_sim900.h ****     break;
 6062               		.loc 2 1079 0 is_stmt 1 discriminator 2
 6063 1f5e 80E0      		ldi r24,lo8(instrukcja_poziom_sieci.3436)
 6064 1f60 90E0      		ldi r25,hi8(instrukcja_poziom_sieci.3436)
 6065 1f62 00C0      		rjmp .L659
 6066               	.L499:
 6067               	.LBE599:
 6068               	.LBB600:
1084:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6069               		.loc 2 1084 0
 6070 1f64 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 6071 1f68 9111      		cpse r25,__zero_reg__
 6072 1f6a 00C0      		rjmp .L615
1084:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6073               		.loc 2 1084 0 is_stmt 0 discriminator 1
 6074 1f6c 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 6075 1f70 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 6076 1f74 232B      		or r18,r19
 6077 1f76 01F0      		breq .+2
 6078 1f78 00C0      		rjmp .L615
1084:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6079               		.loc 2 1084 0 discriminator 2
 6080 1f7a 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6081 1f7e 9111      		cpse r25,__zero_reg__
 6082 1f80 00C0      		rjmp .L615
1085:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 6083               		.loc 2 1085 0 is_stmt 1
 6084 1f82 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 6085 1f86 9111      		cpse r25,__zero_reg__
 6086 1f88 00C0      		rjmp .L615
1086:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 6087               		.loc 2 1086 0
 6088 1f8a 8111      		cpse r24,__zero_reg__
 6089 1f8c 00C0      		rjmp .L615
1086:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 6090               		.loc 2 1086 0 is_stmt 0 discriminator 1
 6091 1f8e 8091 0000 		lds r24,wysylanie_smsa_clipa
 6092 1f92 8111      		cpse r24,__zero_reg__
 6093 1f94 00C0      		rjmp .L615
1090:main_sim900.h ****     static const char instrukcja_creg[] PROGMEM = "+creg?";
 6094               		.loc 2 1090 0 is_stmt 1
 6095 1f96 8DE9      		ldi r24,lo8(-99)
 6096 1f98 0023      		tst r16
 6097 1f9a 01F4      		brne .+2
 6098 1f9c 00C0      		rjmp .L656
1090:main_sim900.h ****     static const char instrukcja_creg[] PROGMEM = "+creg?";
 6099               		.loc 2 1090 0 is_stmt 0 discriminator 2
 6100 1f9e 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6101 1fa2 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6102 1fa6 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
1092:main_sim900.h ****     break;
 6103               		.loc 2 1092 0 is_stmt 1 discriminator 2
 6104 1faa 80E0      		ldi r24,lo8(instrukcja_creg.3438)
 6105 1fac 90E0      		ldi r25,hi8(instrukcja_creg.3438)
 6106 1fae 00C0      		rjmp .L659
 6107               	.L517:
 6108               	.LBE600:
 6109               	.LBB601:
1096:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6110               		.loc 2 1096 0
 6111 1fb0 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 6112 1fb4 9111      		cpse r25,__zero_reg__
 6113 1fb6 00C0      		rjmp .L571
1096:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6114               		.loc 2 1096 0 is_stmt 0 discriminator 1
 6115 1fb8 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 6116 1fbc 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 6117 1fc0 232B      		or r18,r19
 6118 1fc2 01F4      		brne .L571
1096:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6119               		.loc 2 1096 0 discriminator 2
 6120 1fc4 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6121 1fc8 9111      		cpse r25,__zero_reg__
 6122 1fca 00C0      		rjmp .L571
1097:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 6123               		.loc 2 1097 0 is_stmt 1
 6124 1fcc 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 6125 1fd0 9111      		cpse r25,__zero_reg__
 6126 1fd2 00C0      		rjmp .L571
1098:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 6127               		.loc 2 1098 0
 6128 1fd4 8111      		cpse r24,__zero_reg__
 6129 1fd6 00C0      		rjmp .L571
1098:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 6130               		.loc 2 1098 0 is_stmt 0 discriminator 1
 6131 1fd8 8091 0000 		lds r24,wysylanie_smsa_clipa
 6132 1fdc 8823      		tst r24
 6133 1fde 01F0      		breq .L572
 6134               	.L571:
1100:main_sim900.h ****       break;
 6135               		.loc 2 1100 0 is_stmt 1
 6136 1fe0 1092 0000 		sts licznik_blad_stanu_karty_SIM,__zero_reg__
 6137 1fe4 00C0      		rjmp .L615
 6138               	.L572:
1103:main_sim900.h ****     static const char instrukcja_odczyt_ksiazki[] PROGMEM = "+cpbr=26";
 6139               		.loc 2 1103 0
 6140 1fe6 89E9      		ldi r24,lo8(-103)
 6141 1fe8 0023      		tst r16
 6142 1fea 01F4      		brne .+2
 6143 1fec 00C0      		rjmp .L656
1103:main_sim900.h ****     static const char instrukcja_odczyt_ksiazki[] PROGMEM = "+cpbr=26";
 6144               		.loc 2 1103 0 is_stmt 0 discriminator 2
 6145 1fee 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6146 1ff2 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6147 1ff6 89E9      		ldi r24,lo8(-103)
 6148 1ff8 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1105:main_sim900.h ****     break;
 6149               		.loc 2 1105 0 is_stmt 1 discriminator 2
 6150 1ffc 80E0      		ldi r24,lo8(instrukcja_odczyt_ksiazki.3440)
 6151 1ffe 90E0      		ldi r25,hi8(instrukcja_odczyt_ksiazki.3440)
 6152 2000 00C0      		rjmp .L659
 6153               	.L519:
 6154               	.LBE601:
 6155               	.LBB602:
1109:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6156               		.loc 2 1109 0
 6157 2002 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 6158 2006 9111      		cpse r25,__zero_reg__
 6159 2008 00C0      		rjmp .L574
1109:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6160               		.loc 2 1109 0 is_stmt 0 discriminator 1
 6161 200a 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 6162 200e 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 6163 2012 232B      		or r18,r19
 6164 2014 01F4      		brne .L574
1109:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6165               		.loc 2 1109 0 discriminator 2
 6166 2016 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6167 201a 9111      		cpse r25,__zero_reg__
 6168 201c 00C0      		rjmp .L574
1110:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 6169               		.loc 2 1110 0 is_stmt 1
 6170 201e 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 6171 2022 9111      		cpse r25,__zero_reg__
 6172 2024 00C0      		rjmp .L574
1111:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 6173               		.loc 2 1111 0
 6174 2026 8111      		cpse r24,__zero_reg__
 6175 2028 00C0      		rjmp .L574
1111:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 6176               		.loc 2 1111 0 is_stmt 0 discriminator 1
 6177 202a 8091 0000 		lds r24,wysylanie_smsa_clipa
 6178 202e 8823      		tst r24
 6179 2030 01F0      		breq .L575
 6180               	.L574:
1113:main_sim900.h ****       break;
 6181               		.loc 2 1113 0 is_stmt 1
 6182 2032 1092 0000 		sts licznik_blad_zalogowania_u_operatora,__zero_reg__
 6183 2036 00C0      		rjmp .L615
 6184               	.L575:
1116:main_sim900.h ****     static const char instrukcja_sprawdz_operatora[] PROGMEM = "+cops?";
 6185               		.loc 2 1116 0
 6186 2038 8AE9      		ldi r24,lo8(-102)
 6187 203a 0023      		tst r16
 6188 203c 01F4      		brne .+2
 6189 203e 00C0      		rjmp .L656
1116:main_sim900.h ****     static const char instrukcja_sprawdz_operatora[] PROGMEM = "+cops?";
 6190               		.loc 2 1116 0 is_stmt 0 discriminator 2
 6191 2040 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6192 2044 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6193 2048 8AE9      		ldi r24,lo8(-102)
 6194 204a 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1118:main_sim900.h ****     break;
 6195               		.loc 2 1118 0 is_stmt 1 discriminator 2
 6196 204e 80E0      		ldi r24,lo8(instrukcja_sprawdz_operatora.3442)
 6197 2050 90E0      		ldi r25,hi8(instrukcja_sprawdz_operatora.3442)
 6198 2052 00C0      		rjmp .L659
 6199               	.L525:
 6200               	.LBE602:
 6201               	.LBB603:
1122:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6202               		.loc 2 1122 0
 6203 2054 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 6204 2058 9111      		cpse r25,__zero_reg__
 6205 205a 00C0      		rjmp .L615
1122:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6206               		.loc 2 1122 0 is_stmt 0 discriminator 1
 6207 205c 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 6208 2060 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 6209 2064 232B      		or r18,r19
 6210 2066 01F0      		breq .+2
 6211 2068 00C0      		rjmp .L615
1122:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 6212               		.loc 2 1122 0 discriminator 2
 6213 206a 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6214 206e 9111      		cpse r25,__zero_reg__
 6215 2070 00C0      		rjmp .L615
1123:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 6216               		.loc 2 1123 0 is_stmt 1
 6217 2072 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 6218 2076 9111      		cpse r25,__zero_reg__
 6219 2078 00C0      		rjmp .L615
1124:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK)
 6220               		.loc 2 1124 0
 6221 207a 8111      		cpse r24,__zero_reg__
 6222 207c 00C0      		rjmp .L615
1124:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK)
 6223               		.loc 2 1124 0 is_stmt 0 discriminator 1
 6224 207e 8091 0000 		lds r24,wysylanie_smsa_clipa
 6225 2082 8111      		cpse r24,__zero_reg__
 6226 2084 00C0      		rjmp .L615
1127:main_sim900.h ****     static const char instrukcja_cclk[] PROGMEM = "+cclk?";
 6227               		.loc 2 1127 0 is_stmt 1
 6228 2086 8EE9      		ldi r24,lo8(-98)
 6229 2088 0023      		tst r16
 6230 208a 01F4      		brne .+2
 6231 208c 00C0      		rjmp .L656
1127:main_sim900.h ****     static const char instrukcja_cclk[] PROGMEM = "+cclk?";
 6232               		.loc 2 1127 0 is_stmt 0 discriminator 2
 6233 208e 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6234 2092 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6235 2096 8EE9      		ldi r24,lo8(-98)
 6236 2098 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1129:main_sim900.h ****     break;
 6237               		.loc 2 1129 0 is_stmt 1 discriminator 2
 6238 209c 80E0      		ldi r24,lo8(instrukcja_cclk.3444)
 6239 209e 90E0      		ldi r25,hi8(instrukcja_cclk.3444)
 6240 20a0 00C0      		rjmp .L659
 6241               	.L514:
 6242               	.LBE603:
 6243               	.LBB604:
1133:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM = "+cdscb";
 6244               		.loc 2 1133 0
 6245 20a2 85E9      		ldi r24,lo8(-107)
 6246 20a4 0023      		tst r16
 6247 20a6 01F4      		brne .+2
 6248 20a8 00C0      		rjmp .L656
1133:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM = "+cdscb";
 6249               		.loc 2 1133 0 is_stmt 0 discriminator 2
 6250 20aa 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6251 20ae 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6252 20b2 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
1135:main_sim900.h ****     break;
 6253               		.loc 2 1135 0 is_stmt 1 discriminator 2
 6254 20b6 80E0      		ldi r24,lo8(instrukcja_ustawienie_pamieci.3446)
 6255 20b8 90E0      		ldi r25,hi8(instrukcja_ustawienie_pamieci.3446)
 6256 20ba 00C0      		rjmp .L659
 6257               	.L508:
 6258               	.LBE604:
 6259               	.LBB605:
1139:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM =
 6260               		.loc 2 1139 0
 6261 20bc 8FE8      		ldi r24,lo8(-113)
 6262 20be 0023      		tst r16
 6263 20c0 01F4      		brne .+2
 6264 20c2 00C0      		rjmp .L656
1139:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM =
 6265               		.loc 2 1139 0 is_stmt 0 discriminator 2
 6266 20c4 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6267 20c8 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6268 20cc 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
1142:main_sim900.h ****         KOMENDA_KOLEJKI_WSTAWIENIE_MORING_GDY_DZWONI;
 6269               		.loc 2 1142 0 is_stmt 1 discriminator 2
 6270 20d0 81EA      		ldi r24,lo8(-95)
 6271 20d2 8093 0000 		sts nastepne_wysylane_polecenie_SIM900,r24
1144:main_sim900.h ****     break;
 6272               		.loc 2 1144 0 discriminator 2
 6273 20d6 80E0      		ldi r24,lo8(instrukcja_ustawienie_pamieci.3448)
 6274 20d8 90E0      		ldi r25,hi8(instrukcja_ustawienie_pamieci.3448)
 6275 20da 00C0      		rjmp .L659
 6276               	.L505:
 6277               	.LBE605:
1148:main_sim900.h ****     opoznienie_zatrzymaj_odpytywanie_urzadzenia = 20;
 6278               		.loc 2 1148 0
 6279 20dc 8CE8      		ldi r24,lo8(-116)
 6280 20de 0E94 0000 		call dodaj_komende
 6281               	.LVL495:
1149:main_sim900.h ****     ustaw_odbior_SIM900();
 6282               		.loc 2 1149 0
 6283 20e2 84E1      		ldi r24,lo8(20)
 6284 20e4 8093 0000 		sts opoznienie_zatrzymaj_odpytywanie_urzadzenia,r24
1150:main_sim900.h ****     break;
 6285               		.loc 2 1150 0
 6286 20e8 1092 0000 		sts liczba_odebranych_znakow_SIM900+1,__zero_reg__
 6287 20ec 1092 0000 		sts liczba_odebranych_znakow_SIM900,__zero_reg__
 6288 20f0 1092 0000 		sts licznik_opoznienie_oczekiwania_na_bajt_SIM900,__zero_reg__
 6289 20f4 80B7      		in r24,0x30
 6290 20f6 8260      		ori r24,lo8(2)
 6291 20f8 80BF      		out 0x30,r24
 6292               	/* #APP */
 6293               	 ;  1150 "main_sim900.h" 1
 6294 20fa F894      		cli
 6295               	 ;  0 "" 2
 6296               	/* #NOAPP */
 6297 20fc 8091 C100 		lds r24,193
 6298 2100 8068      		ori r24,lo8(-128)
 6299 2102 8093 C100 		sts 193,r24
 6300               	/* #APP */
 6301               	 ;  1150 "main_sim900.h" 1
 6302 2106 7894      		sei
 6303               	 ;  0 "" 2
 6304               	 ;  1150 "main_sim900.h" 1
 6305 2108 0000      		nop
 6306               	 ;  0 "" 2
 6307               	/* #NOAPP */
 6308 210a 4598      		cbi 0x8,5
 6309 210c 00C0      		rjmp .L615
 6310               	.L506:
 6311               	.LBB606:
1157:main_sim900.h ****       break;
 6312               		.loc 2 1157 0
 6313 210e 8091 0000 		lds r24,max_oczekiwanie_na_odpowiedz_at
 6314 2112 8111      		cpse r24,__zero_reg__
 6315 2114 00C0      		rjmp .L615
1159:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
 6316               		.loc 2 1159 0
 6317 2116 8091 0000 		lds r24,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6318 211a 8823      		tst r24
 6319 211c 01F0      		breq .L580
 6320               	.L581:
1160:main_sim900.h ****       break;
 6321               		.loc 2 1160 0
 6322 211e 8CE8      		ldi r24,lo8(-116)
 6323 2120 00C0      		rjmp .L656
 6324               	.L580:
1163:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
 6325               		.loc 2 1163 0
 6326 2122 8091 C100 		lds r24,193
 6327 2126 86FD      		sbrc r24,6
 6328 2128 00C0      		rjmp .L581
1167:main_sim900.h ****     wysylane_polecenie_SIM900 = wykonywana_komenda;
 6329               		.loc 2 1167 0
 6330 212a 1092 0000 		sts liczba_odebranych_znakow_SIM900+1,__zero_reg__
 6331 212e 1092 0000 		sts liczba_odebranych_znakow_SIM900,__zero_reg__
 6332 2132 1092 0000 		sts licznik_opoznienie_oczekiwania_na_bajt_SIM900,__zero_reg__
 6333 2136 80B7      		in r24,0x30
 6334 2138 8260      		ori r24,lo8(2)
 6335 213a 80BF      		out 0x30,r24
 6336               	/* #APP */
 6337               	 ;  1167 "main_sim900.h" 1
 6338 213c F894      		cli
 6339               	 ;  0 "" 2
 6340               	/* #NOAPP */
 6341 213e 8091 C100 		lds r24,193
 6342 2142 8068      		ori r24,lo8(-128)
 6343 2144 8093 C100 		sts 193,r24
 6344               	/* #APP */
 6345               	 ;  1167 "main_sim900.h" 1
 6346 2148 7894      		sei
 6347               	 ;  0 "" 2
 6348               	 ;  1167 "main_sim900.h" 1
 6349 214a 0000      		nop
 6350               	 ;  0 "" 2
 6351               	/* #NOAPP */
 6352 214c 4598      		cbi 0x8,5
1168:main_sim900.h ****     max_oczekiwanie_na_odpowiedz_at = 20;
 6353               		.loc 2 1168 0
 6354 214e 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6355 2152 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6356 2156 8CE8      		ldi r24,lo8(-116)
 6357 2158 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1169:main_sim900.h ****     static const char instrukcja_at[] PROGMEM = "+ifc=2,2";
 6358               		.loc 2 1169 0
 6359 215c 84E1      		ldi r24,lo8(20)
 6360 215e 8093 0000 		sts max_oczekiwanie_na_odpowiedz_at,r24
1171:main_sim900.h ****     break;
 6361               		.loc 2 1171 0
 6362 2162 80E0      		ldi r24,lo8(instrukcja_at.3451)
 6363 2164 90E0      		ldi r25,hi8(instrukcja_at.3451)
 6364 2166 00C0      		rjmp .L659
 6365               	.L503:
 6366               	.LBE606:
1175:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_PIN);
 6367               		.loc 2 1175 0
 6368 2168 8FEF      		ldi r24,lo8(-1)
 6369 216a 8093 0000 		sts podlaczony_modul_gsm_SIM900,r24
1176:main_sim900.h ****     opoznienie_SIM900_100MS = 40;
 6370               		.loc 2 1176 0
 6371 216e 8FE9      		ldi r24,lo8(-97)
 6372 2170 0E94 0000 		call dodaj_komende
 6373               	.LVL496:
1177:main_sim900.h ****     break;
 6374               		.loc 2 1177 0
 6375 2174 88E2      		ldi r24,lo8(40)
 6376 2176 8093 0000 		sts opoznienie_SIM900_100MS,r24
 6377 217a 00C0      		rjmp .L615
 6378               	.L509:
 6379               	.LBB607:
1181:main_sim900.h ****     static const char instrukcja_podaj_pin[] PROGMEM = "+cpin=\"1976\"";
 6380               		.loc 2 1181 0
 6381 217c 8EE8      		ldi r24,lo8(-114)
 6382 217e 0023      		tst r16
 6383 2180 01F4      		brne .+2
 6384 2182 00C0      		rjmp .L656
1181:main_sim900.h ****     static const char instrukcja_podaj_pin[] PROGMEM = "+cpin=\"1976\"";
 6385               		.loc 2 1181 0 is_stmt 0 discriminator 2
 6386 2184 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6387 2188 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6388 218c 8EE8      		ldi r24,lo8(-114)
 6389 218e 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1183:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 6390               		.loc 2 1183 0 is_stmt 1 discriminator 2
 6391 2192 60E0      		ldi r22,lo8(instrukcja_podaj_pin.3454)
 6392 2194 70E0      		ldi r23,hi8(instrukcja_podaj_pin.3454)
 6393 2196 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 6394 2198 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 6395 219a 0E94 0000 		call strcpy_P
 6396               	.LVL497:
 6397 219e 00C0      		rjmp .L657
 6398               	.L501:
 6399               	.LBE607:
 6400               	.LBB608:
1189:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW);
 6401               		.loc 2 1189 0
 6402 21a0 8091 0000 		lds r24,drugi_raz.3456
 6403 21a4 8823      		tst r24
 6404 21a6 01F0      		breq .L583
1190:main_sim900.h ****       break;
 6405               		.loc 2 1190 0
 6406 21a8 80EA      		ldi r24,lo8(-96)
 6407 21aa 00C0      		rjmp .L656
 6408               	.L583:
1193:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6409               		.loc 2 1193 0
 6410 21ac 8FEF      		ldi r24,lo8(-1)
 6411 21ae 8093 0000 		sts drugi_raz.3456,r24
1194:main_sim900.h ****     static const char instrukcja_usun_wszystkie_smsy[] PROGMEM = "+cmgda=6";
 6412               		.loc 2 1194 0
 6413 21b2 82E9      		ldi r24,lo8(-110)
 6414 21b4 0023      		tst r16
 6415 21b6 01F4      		brne .+2
 6416 21b8 00C0      		rjmp .L656
1194:main_sim900.h ****     static const char instrukcja_usun_wszystkie_smsy[] PROGMEM = "+cmgda=6";
 6417               		.loc 2 1194 0 is_stmt 0 discriminator 2
 6418 21ba 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6419 21be 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6420 21c2 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
1196:main_sim900.h ****     break;
 6421               		.loc 2 1196 0 is_stmt 1 discriminator 2
 6422 21c6 80E0      		ldi r24,lo8(instrukcja_usun_wszystkie_smsy.3457)
 6423 21c8 90E0      		ldi r25,hi8(instrukcja_usun_wszystkie_smsy.3457)
 6424 21ca 00C0      		rjmp .L659
 6425               	.L507:
 6426               	.LBE608:
1200:main_sim900.h ****     if (komenda_SIM900 != KOMENDA_SIM900_WYSLANE_POLECENIE)
 6427               		.loc 2 1200 0
 6428 21cc 0E94 0000 		call obsluga_komendy_SIM900
 6429               	.LVL498:
1201:main_sim900.h ****       max_oczekiwanie_na_odpowiedz = 20;
 6430               		.loc 2 1201 0
 6431 21d0 8091 0000 		lds r24,komenda_SIM900
 6432 21d4 8138      		cpi r24,lo8(-127)
 6433 21d6 01F0      		breq .L585
1202:main_sim900.h ****     resetuj_komende_SIM900();
 6434               		.loc 2 1202 0
 6435 21d8 84E1      		ldi r24,lo8(20)
 6436 21da 8093 0000 		sts max_oczekiwanie_na_odpowiedz,r24
 6437               	.L585:
1203:main_sim900.h ****     break;
 6438               		.loc 2 1203 0
 6439 21de 1092 0000 		sts komenda_SIM900,__zero_reg__
 6440 21e2 00C0      		rjmp .L615
 6441               	.L587:
 6442               	.LBB609:
1208:main_sim900.h ****     static const char instrukcja[] PROGMEM =
 6443               		.loc 2 1208 0
 6444 21e4 0023      		tst r16
 6445 21e6 01F4      		brne .+2
 6446 21e8 00C0      		rjmp .L586
1208:main_sim900.h ****     static const char instrukcja[] PROGMEM =
 6447               		.loc 2 1208 0 is_stmt 0 discriminator 2
 6448 21ea 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6449 21ee 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6450 21f2 84E9      		ldi r24,lo8(-108)
 6451 21f4 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1211:main_sim900.h ****     nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_ROZPOCZNIJ_PRACE;
 6452               		.loc 2 1211 0 is_stmt 1 discriminator 2
 6453 21f8 60E0      		ldi r22,lo8(instrukcja.3460)
 6454 21fa 70E0      		ldi r23,hi8(instrukcja.3460)
 6455 21fc 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 6456 21fe 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 6457 2200 0E94 0000 		call strcpy_P
 6458               	.LVL499:
1212:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 6459               		.loc 2 1212 0 discriminator 2
 6460 2204 80E9      		ldi r24,lo8(-112)
 6461 2206 8093 0000 		sts nastepne_wysylane_polecenie_SIM900,r24
 6462 220a 00C0      		rjmp .L657
 6463               	.L510:
 6464               	.LVL500:
 6465               	.LBE609:
1218:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS);
 6466               		.loc 2 1218 0
 6467 220c 8091 0000 		lds r24,podlaczona_karta_SIM_SIM900
 6468 2210 8823      		tst r24
 6469 2212 01F4      		brne .+2
 6470 2214 00C0      		rjmp .L615
1219:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_MODUL_ZALOGOWANY);
 6471               		.loc 2 1219 0
 6472 2216 85E9      		ldi r24,lo8(-107)
 6473 2218 0E94 0000 		call dodaj_komende
 6474               	.LVL501:
1220:main_sim900.h ****     }
 6475               		.loc 2 1220 0
 6476 221c 81E9      		ldi r24,lo8(-111)
 6477 221e 00C0      		rjmp .L656
 6478               	.LVL502:
 6479               	.L533:
1230:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6480               		.loc 2 1230 0
 6481 2220 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 6482 2224 8111      		cpse r24,__zero_reg__
 6483 2226 00C0      		rjmp .L588
1230:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6484               		.loc 2 1230 0 is_stmt 0 discriminator 2
 6485 2228 8091 0000 		lds r24,liczba_znakow_do_zapisu
 6486 222c 8111      		cpse r24,__zero_reg__
 6487 222e 00C0      		rjmp .L588
1230:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6488               		.loc 2 1230 0 discriminator 4
 6489 2230 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 6490 2234 8111      		cpse r24,__zero_reg__
 6491 2236 00C0      		rjmp .L588
1230:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6492               		.loc 2 1230 0 discriminator 6
 6493 2238 F99B      		sbis 0x1f,1
 6494 223a 00C0      		rjmp .L589
 6495               	.L588:
1230:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6496               		.loc 2 1230 0 discriminator 7
 6497 223c 8EEF      		ldi r24,lo8(-2)
 6498 223e 00C0      		rjmp .L656
 6499               	.L589:
1231:main_sim900.h ****     strcpy(wysylane_dane_RAM_SIM900, bufor_ustaw_czas);
 6500               		.loc 2 1231 0 is_stmt 1
 6501 2240 0023      		tst r16
 6502 2242 01F0      		breq .L588
1231:main_sim900.h ****     strcpy(wysylane_dane_RAM_SIM900, bufor_ustaw_czas);
 6503               		.loc 2 1231 0 is_stmt 0 discriminator 2
 6504 2244 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6505 2248 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6506 224c 8EEF      		ldi r24,lo8(-2)
 6507 224e 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1232:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 6508               		.loc 2 1232 0 is_stmt 1 discriminator 2
 6509 2252 60E0      		ldi r22,lo8(bufor_ustaw_czas)
 6510 2254 70E0      		ldi r23,hi8(bufor_ustaw_czas)
 6511 2256 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 6512 2258 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 6513 225a 0E94 0000 		call strcpy
 6514               	.LVL503:
 6515 225e 00C0      		rjmp .L657
 6516               		.cfi_endproc
 6517               	.LFE54:
 6519               	.global	steruj_SIM900_100MS
 6521               	steruj_SIM900_100MS:
 6522               	.LFB55:
1282:main_sim900.h **** 
1283:main_sim900.h **** void steruj_SIM900_100MS(void) {
 6523               		.loc 2 1283 0
 6524               		.cfi_startproc
 6525               	/* prologue: function */
 6526               	/* frame size = 0 */
 6527               	/* stack size = 0 */
 6528               	.L__stack_usage = 0
1284:main_sim900.h ****   if (opoznienie_SIM900_100MS && --opoznienie_SIM900_100MS == 0)
 6529               		.loc 2 1284 0
 6530 2260 8091 0000 		lds r24,opoznienie_SIM900_100MS
 6531 2264 8823      		tst r24
 6532 2266 01F0      		breq .L666
 6533               		.loc 2 1284 0 is_stmt 0 discriminator 1
 6534 2268 8150      		subi r24,lo8(-(-1))
 6535 226a 8093 0000 		sts opoznienie_SIM900_100MS,r24
 6536 226e 8111      		cpse r24,__zero_reg__
 6537 2270 00C0      		rjmp .L666
1285:main_sim900.h ****     oproznij_bufor_SIM900_po_bledzie = FALSE;
 6538               		.loc 2 1285 0 is_stmt 1
 6539 2272 1092 0000 		sts oproznij_bufor_SIM900_po_bledzie,__zero_reg__
 6540               	.L666:
1286:main_sim900.h **** 
1287:main_sim900.h ****   if (opoznienie_wysylania_clipow_100MS)
 6541               		.loc 2 1287 0
 6542 2276 8091 0000 		lds r24,opoznienie_wysylania_clipow_100MS
 6543 227a 9091 0000 		lds r25,opoznienie_wysylania_clipow_100MS+1
 6544 227e 0097      		sbiw r24,0
 6545 2280 01F0      		breq .L668
1288:main_sim900.h ****     --opoznienie_wysylania_clipow_100MS;
 6546               		.loc 2 1288 0
 6547 2282 0197      		sbiw r24,1
 6548 2284 9093 0000 		sts opoznienie_wysylania_clipow_100MS+1,r25
 6549 2288 8093 0000 		sts opoznienie_wysylania_clipow_100MS,r24
 6550               	.L668:
1289:main_sim900.h **** 
1290:main_sim900.h ****   // Timeout rozmowy - automatyczne rozlaczenie po 30 sekundach
1291:main_sim900.h ****   if (licznik_timeout_rozmowy_100ms) {
 6551               		.loc 2 1291 0
 6552 228c 8091 0000 		lds r24,licznik_timeout_rozmowy_100ms
 6553 2290 9091 0000 		lds r25,licznik_timeout_rozmowy_100ms+1
 6554 2294 0097      		sbiw r24,0
 6555 2296 01F0      		breq .L670
1292:main_sim900.h ****     if (--licznik_timeout_rozmowy_100ms == 0 &&
 6556               		.loc 2 1292 0
 6557 2298 0197      		sbiw r24,1
 6558 229a 9093 0000 		sts licznik_timeout_rozmowy_100ms+1,r25
 6559 229e 8093 0000 		sts licznik_timeout_rozmowy_100ms,r24
 6560 22a2 892B      		or r24,r25
 6561 22a4 01F4      		brne .L670
 6562               		.loc 2 1292 0 is_stmt 0 discriminator 1
 6563 22a6 8091 0000 		lds r24,trwa_rozmowa_przychodzaca_od_uzytkownika
 6564 22aa 8823      		tst r24
 6565 22ac 01F0      		breq .L670
1293:main_sim900.h ****         trwa_rozmowa_przychodzaca_od_uzytkownika) {
1294:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
 6566               		.loc 2 1294 0 is_stmt 1
 6567 22ae 87E9      		ldi r24,lo8(-105)
 6568 22b0 0E94 0000 		call dodaj_komende
 6569               	.LVL504:
 6570               	.L670:
1295:main_sim900.h ****       POMOC_DODAJ2('#', 'X'); // Timeout marker
1296:main_sim900.h ****     }
1297:main_sim900.h ****   }
1298:main_sim900.h **** 
1299:main_sim900.h ****   if (max_oczekiwanie_na_odpowiedz_at) {
 6571               		.loc 2 1299 0
 6572 22b4 8091 0000 		lds r24,max_oczekiwanie_na_odpowiedz_at
 6573 22b8 8823      		tst r24
 6574 22ba 01F0      		breq .L673
1300:main_sim900.h ****     if (--max_oczekiwanie_na_odpowiedz_at == 0) {
 6575               		.loc 2 1300 0
 6576 22bc 8150      		subi r24,lo8(-(-1))
 6577 22be 8093 0000 		sts max_oczekiwanie_na_odpowiedz_at,r24
 6578 22c2 8111      		cpse r24,__zero_reg__
 6579 22c4 00C0      		rjmp .L673
1301:main_sim900.h ****       wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 6580               		.loc 2 1301 0
 6581 22c6 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6582 22ca 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6583 22ce 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
1302:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT);
 6584               		.loc 2 1302 0
 6585 22d2 8CE8      		ldi r24,lo8(-116)
 6586 22d4 0E94 0000 		call dodaj_komende
 6587               	.LVL505:
1303:main_sim900.h ****       sprawdzaj_wejscie_CTS_SIM900 = FALSE;
 6588               		.loc 2 1303 0
 6589 22d8 1092 0000 		sts sprawdzaj_wejscie_CTS_SIM900,__zero_reg__
1304:main_sim900.h ****       zakoncz_wysylanie_SIM900();
 6590               		.loc 2 1304 0
 6591               	/* #APP */
 6592               	 ;  1304 "main_sim900.h" 1
 6593 22dc F894      		cli
 6594               	 ;  0 "" 2
 6595               	/* #NOAPP */
 6596 22de 8091 C100 		lds r24,193
 6597 22e2 8F7B      		andi r24,lo8(-65)
 6598 22e4 8093 C100 		sts 193,r24
 6599               	/* #APP */
 6600               	 ;  1304 "main_sim900.h" 1
 6601 22e8 7894      		sei
 6602               	 ;  0 "" 2
 6603               	 ;  1304 "main_sim900.h" 1
 6604 22ea 0000      		nop
 6605               	 ;  0 "" 2
 6606               	/* #NOAPP */
 6607               	.L673:
1305:main_sim900.h ****     }
1306:main_sim900.h ****   }
1307:main_sim900.h **** 
1308:main_sim900.h ****   if (procedura_inicjalizacyjna_SIM900_100MS())
 6608               		.loc 2 1308 0
 6609 22ec 0E94 0000 		call procedura_inicjalizacyjna_SIM900_100MS
 6610               	.LVL506:
 6611 22f0 8823      		tst r24
 6612 22f2 01F0      		breq .L675
1309:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_PODLACZONY_MODUL_GSM);
 6613               		.loc 2 1309 0
 6614 22f4 8BE8      		ldi r24,lo8(-117)
 6615 22f6 0E94 0000 		call dodaj_komende
 6616               	.LVL507:
 6617               	.L675:
1310:main_sim900.h **** 
1311:main_sim900.h ****   if (maksymalny_czas_dzwonienia) {
 6618               		.loc 2 1311 0
 6619 22fa 8091 0000 		lds r24,maksymalny_czas_dzwonienia
 6620 22fe 8823      		tst r24
 6621 2300 01F0      		breq .L677
1312:main_sim900.h ****     if (--maksymalny_czas_dzwonienia == 0) {
 6622               		.loc 2 1312 0
 6623 2302 8150      		subi r24,lo8(-(-1))
 6624 2304 8093 0000 		sts maksymalny_czas_dzwonienia,r24
 6625 2308 8111      		cpse r24,__zero_reg__
 6626 230a 00C0      		rjmp .L677
 6627               	.LVL508:
1313:main_sim900.h ****       POMOC_DODAJ2('#', 'i');
1314:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
 6628               		.loc 2 1314 0
 6629 230c 87E9      		ldi r24,lo8(-105)
 6630 230e 0E94 0000 		call dodaj_komende
 6631               	.LVL509:
 6632               	.L677:
1315:main_sim900.h ****     }
1316:main_sim900.h ****   }
1317:main_sim900.h **** 
1318:main_sim900.h ****   if (licznik_bezpieczenstwa_wykonywana_rozmowa) {
 6633               		.loc 2 1318 0
 6634 2312 8091 0000 		lds r24,licznik_bezpieczenstwa_wykonywana_rozmowa
 6635 2316 9091 0000 		lds r25,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 6636 231a 0097      		sbiw r24,0
 6637 231c 01F0      		breq .L680
1319:main_sim900.h ****     if (--licznik_bezpieczenstwa_wykonywana_rozmowa == 0) {
 6638               		.loc 2 1319 0
 6639 231e 0197      		sbiw r24,1
 6640 2320 9093 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,r25
 6641 2324 8093 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,r24
 6642 2328 892B      		or r24,r25
 6643 232a 01F4      		brne .L680
 6644               	.LVL510:
1320:main_sim900.h ****       POMOC_DODAJ2('#', 'j');
1321:main_sim900.h ****       zakonczono_rozmowe_telefoniczna(
 6645               		.loc 2 1321 0
 6646 232c 82E0      		ldi r24,lo8(2)
 6647 232e 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 6648               	.LVL511:
1322:main_sim900.h ****           powod_zakonczenia_rozmowy_przekroczony_czas);
1323:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 6649               		.loc 2 1323 0
 6650 2332 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
1324:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 6651               		.loc 2 1324 0
 6652 2336 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 6653               	.LVL512:
 6654               	.L680:
 6655               	.LBB610:
1325:main_sim900.h ****     }
1326:main_sim900.h ****   }
1327:main_sim900.h **** 
1328:main_sim900.h **** #ifndef WYLACZ_AUTOMATYCZNE_KONTROLOWANIE_SIMCOM
1329:main_sim900.h **** 
1330:main_sim900.h ****   { // poziom sieci i zalogowanie u operatora
1331:main_sim900.h ****     static uchar licznik_cyklu_8_sek = 0;
1332:main_sim900.h ****     if (++licznik_cyklu_8_sek == 48)
 6656               		.loc 2 1332 0
 6657 233a 8091 0000 		lds r24,licznik_cyklu_8_sek.3484
 6658 233e 8F5F      		subi r24,lo8(-(1))
 6659 2340 8093 0000 		sts licznik_cyklu_8_sek.3484,r24
 6660 2344 8033      		cpi r24,lo8(48)
 6661 2346 01F0      		breq .+2
 6662 2348 00C0      		rjmp .L682
1333:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_POZIOM_SIECI);
 6663               		.loc 2 1333 0
 6664 234a 8BE9      		ldi r24,lo8(-101)
 6665               	.L724:
1334:main_sim900.h ****     else if (licznik_cyklu_8_sek == 52)
1335:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_ZAREJESTROWANIE);
1336:main_sim900.h ****     else if (licznik_cyklu_8_sek == 56)
1337:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_ZALOGOWANIE_U_OPERATORA);
1338:main_sim900.h ****     else if (licznik_cyklu_8_sek == 60) {
1339:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_STAN_KARTY_SIM);
1340:main_sim900.h ****     } else if (licznik_cyklu_8_sek >= 80) {
1341:main_sim900.h ****       licznik_cyklu_8_sek = 0;
1342:main_sim900.h ****       if (modul_zalogowany_w_sieci)
1343:main_sim900.h ****         filtruj_i_dodaj_komende(
 6666               		.loc 2 1343 0
 6667 234c 0E94 0000 		call filtruj_i_dodaj_komende
 6668               	.LVL513:
 6669               	.L683:
 6670               	.LBE610:
1344:main_sim900.h ****             KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE);
1345:main_sim900.h ****     }
1346:main_sim900.h ****   }
1347:main_sim900.h **** 
1348:main_sim900.h ****   if (opoznienie_zatrzymaj_odpytywanie_urzadzenia)
 6671               		.loc 2 1348 0
 6672 2350 8091 0000 		lds r24,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6673 2354 8823      		tst r24
 6674 2356 01F0      		breq .L689
1349:main_sim900.h ****     --opoznienie_zatrzymaj_odpytywanie_urzadzenia;
 6675               		.loc 2 1349 0
 6676 2358 8150      		subi r24,lo8(-(-1))
 6677 235a 8093 0000 		sts opoznienie_zatrzymaj_odpytywanie_urzadzenia,r24
 6678               	.L689:
1350:main_sim900.h **** 
1351:main_sim900.h ****   if (modul_zalogowany_w_sieci &&
 6679               		.loc 2 1351 0
 6680 235e 8091 0000 		lds r24,modul_zalogowany_w_sieci
 6681 2362 8823      		tst r24
 6682 2364 01F4      		brne .+2
 6683 2366 00C0      		rjmp .L690
1352:main_sim900.h ****       (poziom_sieci_gsm == POZIOM_SIECI_BLAD || poziom_sieci_gsm == 0)) {
 6684               		.loc 2 1352 0 discriminator 1
 6685 2368 8091 0000 		lds r24,poziom_sieci_gsm
1351:main_sim900.h ****       (poziom_sieci_gsm == POZIOM_SIECI_BLAD || poziom_sieci_gsm == 0)) {
 6686               		.loc 2 1351 0 discriminator 1
 6687 236c 8336      		cpi r24,lo8(99)
 6688 236e 01F0      		breq .L691
 6689               		.loc 2 1352 0
 6690 2370 8111      		cpse r24,__zero_reg__
 6691 2372 00C0      		rjmp .L690
 6692               	.L691:
1353:main_sim900.h ****     if (licznik_awaria_brak_zasiegu < MAX_LICZNIK_AWARIA_BRAK_ZASIEGU) {
 6693               		.loc 2 1353 0
 6694 2374 8091 0000 		lds r24,licznik_awaria_brak_zasiegu
 6695 2378 9091 0000 		lds r25,licznik_awaria_brak_zasiegu+1
 6696 237c 8835      		cpi r24,88
 6697 237e 22E0      		ldi r18,2
 6698 2380 9207      		cpc r25,r18
 6699 2382 00F4      		brsh .L693
1354:main_sim900.h ****       if (++licznik_awaria_brak_zasiegu == MAX_LICZNIK_AWARIA_BRAK_ZASIEGU) {
 6700               		.loc 2 1354 0
 6701 2384 0196      		adiw r24,1
 6702 2386 8835      		cpi r24,88
 6703 2388 22E0      		ldi r18,2
 6704 238a 9207      		cpc r25,r18
 6705 238c 01F4      		brne .+2
 6706 238e 00C0      		rjmp .L694
 6707 2390 9093 0000 		sts licznik_awaria_brak_zasiegu+1,r25
 6708 2394 8093 0000 		sts licznik_awaria_brak_zasiegu,r24
 6709               	.L693:
1355:main_sim900.h ****         licznik_awaria_brak_zasiegu = 0;
1356:main_sim900.h ****         POMOC_DODAJ2('*', 'j');
1357:main_sim900.h ****         reset_modulu_SIM900();
1358:main_sim900.h ****       }
1359:main_sim900.h ****     }
1360:main_sim900.h ****   } else
1361:main_sim900.h ****     licznik_awaria_brak_zasiegu = 0;
1362:main_sim900.h **** 
1363:main_sim900.h ****   if (CZY_BLAD_KARTY_SIM() || CZY_BLAD_ZALOGOWANIA_U_OPERATORA()) {
 6710               		.loc 2 1363 0
 6711 2398 8091 0000 		lds r24,licznik_blad_stanu_karty_SIM
 6712 239c 8630      		cpi r24,lo8(6)
 6713 239e 00F4      		brsh .L696
 6714               		.loc 2 1363 0 is_stmt 0 discriminator 1
 6715 23a0 8091 0000 		lds r24,licznik_blad_zalogowania_u_operatora
 6716 23a4 8431      		cpi r24,lo8(20)
 6717 23a6 00F0      		brlo .L697
 6718               	.L696:
 6719               	.LVL514:
1364:main_sim900.h ****     POMOC_DODAJ2('*', 'k');
1365:main_sim900.h ****     reset_modulu_SIM900();
 6720               		.loc 2 1365 0 is_stmt 1
 6721 23a8 0E94 0000 		call reset_modulu_SIM900
 6722               	.LVL515:
 6723               	.L697:
1366:main_sim900.h ****   }
1367:main_sim900.h **** #endif
1368:main_sim900.h **** 
1369:main_sim900.h ****   if (licznik_reset_modulu_SIM900) {
 6724               		.loc 2 1369 0
 6725 23ac 8091 0000 		lds r24,licznik_reset_modulu_SIM900
 6726 23b0 8823      		tst r24
 6727 23b2 01F0      		breq .L699
1370:main_sim900.h ****     if (--licznik_reset_modulu_SIM900 == 0) {
 6728               		.loc 2 1370 0
 6729 23b4 8150      		subi r24,lo8(-(-1))
 6730 23b6 8093 0000 		sts licznik_reset_modulu_SIM900,r24
 6731 23ba 8111      		cpse r24,__zero_reg__
 6732 23bc 00C0      		rjmp .L699
 6733               	.LVL516:
1371:main_sim900.h ****       POMOC_DODAJ2('*', 'l');
1372:main_sim900.h ****       reset_modulu_SIM900();
 6734               		.loc 2 1372 0
 6735 23be 0E94 0000 		call reset_modulu_SIM900
 6736               	.LVL517:
 6737               	.L699:
1373:main_sim900.h ****     }
1374:main_sim900.h ****   }
1375:main_sim900.h **** 
1376:main_sim900.h ****   if (!modul_zalogowany_w_sieci) {
 6738               		.loc 2 1376 0
 6739 23c2 8091 0000 		lds r24,modul_zalogowany_w_sieci
 6740 23c6 8111      		cpse r24,__zero_reg__
 6741 23c8 00C0      		rjmp .L701
1377:main_sim900.h ****     if (++licznik_ogolny_blad_zalogowania > MAX_LICZNIK_OGOLNY_BLAD_ZALOGOWANIA)
 6742               		.loc 2 1377 0
 6743 23ca 8091 0000 		lds r24,licznik_ogolny_blad_zalogowania
 6744 23ce 9091 0000 		lds r25,licznik_ogolny_blad_zalogowania+1
 6745 23d2 0196      		adiw r24,1
 6746 23d4 9093 0000 		sts licznik_ogolny_blad_zalogowania+1,r25
 6747 23d8 8093 0000 		sts licznik_ogolny_blad_zalogowania,r24
 6748 23dc 813B      		cpi r24,-79
 6749 23de 9440      		sbci r25,4
 6750 23e0 00F0      		brlo .L664
1378:main_sim900.h ****       reset_modulu_SIM900();
 6751               		.loc 2 1378 0
 6752 23e2 0C94 0000 		jmp reset_modulu_SIM900
 6753               	.LVL518:
 6754               	.L682:
 6755               	.LBB611:
1334:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_ZAREJESTROWANIE);
 6756               		.loc 2 1334 0
 6757 23e6 8433      		cpi r24,lo8(52)
 6758 23e8 01F4      		brne .L684
1335:main_sim900.h ****     else if (licznik_cyklu_8_sek == 56)
 6759               		.loc 2 1335 0
 6760 23ea 8DE9      		ldi r24,lo8(-99)
 6761 23ec 00C0      		rjmp .L724
 6762               	.L684:
1336:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_ZALOGOWANIE_U_OPERATORA);
 6763               		.loc 2 1336 0
 6764 23ee 8833      		cpi r24,lo8(56)
 6765 23f0 01F4      		brne .L685
1337:main_sim900.h ****     else if (licznik_cyklu_8_sek == 60) {
 6766               		.loc 2 1337 0
 6767 23f2 8AE9      		ldi r24,lo8(-102)
 6768 23f4 00C0      		rjmp .L724
 6769               	.L685:
1338:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_STAN_KARTY_SIM);
 6770               		.loc 2 1338 0
 6771 23f6 8C33      		cpi r24,lo8(60)
 6772 23f8 01F4      		brne .L686
1339:main_sim900.h ****     } else if (licznik_cyklu_8_sek >= 80) {
 6773               		.loc 2 1339 0
 6774 23fa 89E9      		ldi r24,lo8(-103)
 6775 23fc 00C0      		rjmp .L724
 6776               	.L686:
1340:main_sim900.h ****       licznik_cyklu_8_sek = 0;
 6777               		.loc 2 1340 0
 6778 23fe 8035      		cpi r24,lo8(80)
 6779 2400 00F4      		brsh .+2
 6780 2402 00C0      		rjmp .L683
 6781 2404 8091 0000 		lds r24,modul_zalogowany_w_sieci
1341:main_sim900.h ****       if (modul_zalogowany_w_sieci)
 6782               		.loc 2 1341 0
 6783 2408 1092 0000 		sts licznik_cyklu_8_sek.3484,__zero_reg__
1342:main_sim900.h ****         filtruj_i_dodaj_komende(
 6784               		.loc 2 1342 0
 6785 240c 8823      		tst r24
 6786 240e 01F4      		brne .+2
 6787 2410 00C0      		rjmp .L683
1343:main_sim900.h ****             KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE);
 6788               		.loc 2 1343 0
 6789 2412 8EE9      		ldi r24,lo8(-98)
 6790 2414 00C0      		rjmp .L724
 6791               	.L694:
 6792               	.LBE611:
1355:main_sim900.h ****         POMOC_DODAJ2('*', 'j');
 6793               		.loc 2 1355 0
 6794 2416 1092 0000 		sts licznik_awaria_brak_zasiegu+1,__zero_reg__
 6795 241a 1092 0000 		sts licznik_awaria_brak_zasiegu,__zero_reg__
 6796               	.LVL519:
1357:main_sim900.h ****       }
 6797               		.loc 2 1357 0
 6798 241e 0E94 0000 		call reset_modulu_SIM900
 6799               	.LVL520:
 6800 2422 00C0      		rjmp .L693
 6801               	.LVL521:
 6802               	.L690:
1361:main_sim900.h **** 
 6803               		.loc 2 1361 0
 6804 2424 1092 0000 		sts licznik_awaria_brak_zasiegu+1,__zero_reg__
 6805 2428 1092 0000 		sts licznik_awaria_brak_zasiegu,__zero_reg__
 6806 242c 00C0      		rjmp .L693
 6807               	.L701:
1379:main_sim900.h ****   } else
1380:main_sim900.h ****     licznik_ogolny_blad_zalogowania = 0;
 6808               		.loc 2 1380 0
 6809 242e 1092 0000 		sts licznik_ogolny_blad_zalogowania+1,__zero_reg__
 6810 2432 1092 0000 		sts licznik_ogolny_blad_zalogowania,__zero_reg__
 6811               	.L664:
 6812               	/* epilogue start */
1381:main_sim900.h **** }
 6813               		.loc 2 1381 0
 6814 2436 0895      		ret
 6815               		.cfi_endproc
 6816               	.LFE55:
 6818               	.global	steruj_SIM900_10MS
 6820               	steruj_SIM900_10MS:
 6821               	.LFB56:
1382:main_sim900.h **** 
1383:main_sim900.h **** void steruj_SIM900_10MS(void) {
 6822               		.loc 2 1383 0
 6823               		.cfi_startproc
 6824               	/* prologue: function */
 6825               	/* frame size = 0 */
 6826               	/* stack size = 0 */
 6827               	.L__stack_usage = 0
1384:main_sim900.h ****   if (czy_jest_komenda_SIM900())
 6828               		.loc 2 1384 0
 6829 2438 8091 0000 		lds r24,komenda_SIM900
 6830 243c 8823      		tst r24
 6831 243e 01F4      		brne .+2
 6832 2440 00C0      		rjmp .L726
 6833               	.L728:
1385:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_KOMENDA_SIM900);
 6834               		.loc 2 1385 0
 6835 2442 8AE8      		ldi r24,lo8(-118)
 6836 2444 0E94 0000 		call dodaj_komende
 6837               	.LVL522:
 6838               	.L727:
1386:main_sim900.h **** 
1387:main_sim900.h ****   if (flaga_odebrany_znak_zachety) {
 6839               		.loc 2 1387 0
 6840 2448 8091 0000 		lds r24,flaga_odebrany_znak_zachety
 6841 244c 8823      		tst r24
 6842 244e 01F0      		breq .L729
1388:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_PDU);
 6843               		.loc 2 1388 0
 6844 2450 85ED      		ldi r24,lo8(-43)
 6845 2452 0E94 0000 		call dodaj_komende
 6846               	.LVL523:
1389:main_sim900.h ****     // czekanie_na_odebranie_zachety = FALSE;	// byo
1390:main_sim900.h ****     flaga_odebrany_znak_zachety = FALSE;
 6847               		.loc 2 1390 0
 6848 2456 1092 0000 		sts flaga_odebrany_znak_zachety,__zero_reg__
 6849               	.LVL524:
 6850               	.L729:
 6851               	.LBB612:
1391:main_sim900.h ****     POMOC_DODAJ2('#', 'm');
1392:main_sim900.h ****   }
1393:main_sim900.h **** 
1394:main_sim900.h ****   { // kontrola wysyania sms-w i clipw
1395:main_sim900.h ****     static uint licznik_bezpieczenstwa = 0;
1396:main_sim900.h ****     if (modul_zalogowany_w_sieci && flaga_wysylanie_smsa) {
 6852               		.loc 2 1396 0
 6853 245a 8091 0000 		lds r24,modul_zalogowany_w_sieci
 6854 245e 8823      		tst r24
 6855 2460 01F4      		brne .+2
 6856 2462 00C0      		rjmp .L730
 6857               		.loc 2 1396 0 is_stmt 0 discriminator 1
 6858 2464 8091 0000 		lds r24,flaga_wysylanie_smsa
 6859 2468 8823      		tst r24
 6860 246a 01F4      		brne .+2
 6861 246c 00C0      		rjmp .L730
1397:main_sim900.h ****       if (++licznik_bezpieczenstwa >= 5000) // 50 sek
 6862               		.loc 2 1397 0 is_stmt 1
 6863 246e 8091 0000 		lds r24,licznik_bezpieczenstwa.3488
 6864 2472 9091 0000 		lds r25,licznik_bezpieczenstwa.3488+1
 6865 2476 0196      		adiw r24,1
 6866 2478 8838      		cpi r24,-120
 6867 247a 23E1      		ldi r18,19
 6868 247c 9207      		cpc r25,r18
 6869 247e 00F0      		brlo .+2
 6870 2480 00C0      		rjmp .L731
 6871 2482 9093 0000 		sts licznik_bezpieczenstwa.3488+1,r25
 6872 2486 8093 0000 		sts licznik_bezpieczenstwa.3488,r24
 6873               	.L732:
 6874               	.LBE612:
 6875               	.LBB613:
1398:main_sim900.h ****       {
1399:main_sim900.h ****         POMOC_DODAJ2('#', 'Z');
1400:main_sim900.h ****         licznik_bezpieczenstwa = 0;
1401:main_sim900.h ****         komenda_SIM900 = ERROR_KOMENDA_SIM900;
1402:main_sim900.h ****         obsluga_wysylania_sms();
1403:main_sim900.h ****       }
1404:main_sim900.h ****     } else
1405:main_sim900.h ****       licznik_bezpieczenstwa = 0;
1406:main_sim900.h ****   }
1407:main_sim900.h **** 
1408:main_sim900.h ****   { // kontrola programu: zbyt dugi okres wykonywania polecenia do SIM900 lub
1409:main_sim900.h ****     // jego brak
1410:main_sim900.h ****     static komenda_typ poprzednia_komenda;
1411:main_sim900.h ****     static uint licznik_poprzednia_komenda;
1412:main_sim900.h ****     static uint licznik_odebranych_znakow;
1413:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY &&
 6876               		.loc 2 1413 0
 6877 248a 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 6878 248e 9091 0000 		lds r25,trwa_rozmowa_przychodzaca_od_uzytkownika
 6879 2492 8823      		tst r24
 6880 2494 01F4      		brne .+2
 6881 2496 00C0      		rjmp .L733
 6882               		.loc 2 1413 0 is_stmt 0 discriminator 1
 6883 2498 2091 0000 		lds r18,poprzednia_komenda.3489
 6884 249c 8213      		cpse r24,r18
 6885 249e 00C0      		rjmp .L734
1414:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 == poprzednia_komenda &&
 6886               		.loc 2 1414 0 is_stmt 1
 6887 24a0 9111      		cpse r25,__zero_reg__
 6888 24a2 00C0      		rjmp .L735
 6889               	.LVL525:
 6890               	.LBB614:
1415:main_sim900.h ****         !trwa_rozmowa_przychodzaca_od_uzytkownika) {
1416:main_sim900.h ****       uint max_licznik_poprzednia_komenda = 5 * 100; // 5 sek;
1417:main_sim900.h ****       if (aktualnie_wysylane_polecenie_SIM900 ==
 6891               		.loc 2 1417 0
 6892 24a4 8C38      		cpi r24,lo8(-116)
 6893 24a6 01F0      		breq .L749
1418:main_sim900.h ****               KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT ||
 6894               		.loc 2 1418 0
 6895 24a8 9BE2      		ldi r25,lo8(43)
 6896 24aa 980F      		add r25,r24
1416:main_sim900.h ****       if (aktualnie_wysylane_polecenie_SIM900 ==
 6897               		.loc 2 1416 0
 6898 24ac 44EF      		ldi r20,lo8(-12)
 6899 24ae 51E0      		ldi r21,lo8(1)
 6900               		.loc 2 1418 0
 6901 24b0 9230      		cpi r25,lo8(2)
 6902 24b2 00F4      		brsh .L736
 6903               	.L749:
1419:main_sim900.h ****           aktualnie_wysylane_polecenie_SIM900 == KOMENDA_KOLEJKI_WYSLIJ_PDU ||
1420:main_sim900.h ****           aktualnie_wysylane_polecenie_SIM900 ==
1421:main_sim900.h ****               KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE)
1422:main_sim900.h ****         max_licznik_poprzednia_komenda = 2 * 60 * 100; // 2 minuty
 6904               		.loc 2 1422 0
 6905 24b4 40EE      		ldi r20,lo8(-32)
 6906 24b6 5EE2      		ldi r21,lo8(46)
 6907               	.L736:
 6908               	.LVL526:
1423:main_sim900.h **** 
1424:main_sim900.h ****       if (aktualnie_wysylane_polecenie_SIM900 ==
1425:main_sim900.h ****               KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT // zmienione (1)
1426:main_sim900.h ****           || aktualnie_wysylane_polecenie_SIM900 ==
 6909               		.loc 2 1426 0
 6910 24b8 9DE2      		ldi r25,lo8(45)
 6911 24ba 980F      		add r25,r24
1424:main_sim900.h ****               KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT // zmienione (1)
 6912               		.loc 2 1424 0
 6913 24bc 9230      		cpi r25,lo8(2)
 6914 24be 00F4      		brsh .L737
1427:main_sim900.h ****                  KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
1428:main_sim900.h ****         max_licznik_poprzednia_komenda = 15 * 100;
 6915               		.loc 2 1428 0
 6916 24c0 4CED      		ldi r20,lo8(-36)
 6917 24c2 55E0      		ldi r21,lo8(5)
 6918               	.LVL527:
 6919               	.L737:
1429:main_sim900.h **** 
1430:main_sim900.h ****       if (++licznik_poprzednia_komenda >= max_licznik_poprzednia_komenda) {
 6920               		.loc 2 1430 0
 6921 24c4 2091 0000 		lds r18,licznik_poprzednia_komenda.3490
 6922 24c8 3091 0000 		lds r19,licznik_poprzednia_komenda.3490+1
 6923 24cc 2F5F      		subi r18,-1
 6924 24ce 3F4F      		sbci r19,-1
 6925 24d0 2417      		cp r18,r20
 6926 24d2 3507      		cpc r19,r21
 6927 24d4 00F4      		brsh .L738
 6928 24d6 3093 0000 		sts licznik_poprzednia_komenda.3490+1,r19
 6929 24da 2093 0000 		sts licznik_poprzednia_komenda.3490,r18
 6930               	.LVL528:
 6931               	.L739:
1431:main_sim900.h ****         licznik_poprzednia_komenda = 0;
1432:main_sim900.h ****         POMOC_DODAJ2('#', 'r');
1433:main_sim900.h ****         POMOC_DODAJ_HEX(aktualnie_wysylane_polecenie_SIM900 >> 8);
1434:main_sim900.h ****         POMOC_DODAJ_HEX(aktualnie_wysylane_polecenie_SIM900);
1435:main_sim900.h ****         if (aktualnie_wysylane_polecenie_SIM900 !=
1436:main_sim900.h ****             KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1) {
1437:main_sim900.h ****           if (aktualnie_wysylane_polecenie_SIM900 ==
1438:main_sim900.h ****                   KOMENDA_KOLEJKI_ODRZUC_ROZMOWE ||
1439:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
1440:main_sim900.h ****                   KOMENDA_KOLEJKI_PODAJ_PIN ||
1441:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
1442:main_sim900.h ****                   KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW ||
1443:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
1444:main_sim900.h ****                   KOMENDA_KOLEJKI_USTAW_WZMOCNIENIE_MIKROFONU ||
1445:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
1446:main_sim900.h ****                   KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS ||
1447:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
1448:main_sim900.h ****                    KOMENDA_KOLEJKI_SPRAWDZ_PIN &&
1449:main_sim900.h ****                aktualnie_wysylane_polecenie_SIM900 <=
1450:main_sim900.h ****                    KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ) ||
1451:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
1452:main_sim900.h ****                    KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
1453:main_sim900.h ****                aktualnie_wysylane_polecenie_SIM900 <=
1454:main_sim900.h ****                    KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) ||
1455:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
1456:main_sim900.h ****                    KOMENDA_KOLEJKI_USUN_SMSA_1 &&
1457:main_sim900.h ****                aktualnie_wysylane_polecenie_SIM900 <=
1458:main_sim900.h ****                    KOMENDA_KOLEJKI_USUN_SMSA_20)) {
1459:main_sim900.h ****             nastepne_wysylane_polecenie_SIM900 =
1460:main_sim900.h ****                 aktualnie_wysylane_polecenie_SIM900;
1461:main_sim900.h ****           } else
1462:main_sim900.h ****             nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
1463:main_sim900.h ****           wyzerowanie_danych_SIM900();
1464:main_sim900.h ****           wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1;
1465:main_sim900.h ****           wysylane_dane_RAM_SIM900[0] = '\0';
1466:main_sim900.h ****           wyslij_polecenie_RAM_SIM900();
1467:main_sim900.h ****         } else
1468:main_sim900.h ****           reset_modulu_SIM900();
1469:main_sim900.h ****       }
1470:main_sim900.h ****       licznik_odebranych_znakow = 0;
 6932               		.loc 2 1470 0
 6933 24de 1092 0000 		sts licznik_odebranych_znakow.3491+1,__zero_reg__
 6934 24e2 1092 0000 		sts licznik_odebranych_znakow.3491,__zero_reg__
 6935               	.L743:
 6936               	.LBE614:
1471:main_sim900.h ****     } else if (aktualnie_wysylane_polecenie_SIM900 !=
1472:main_sim900.h ****                    KOMENDA_KOLEJKI_BRAK_KOMENDY &&
1473:main_sim900.h ****                trwa_rozmowa_przychodzaca_od_uzytkownika &&
1474:main_sim900.h ****                czy_jest_bezczynny_SIM900()) {
1475:main_sim900.h ****       {
1476:main_sim900.h ****         cli();
1477:main_sim900.h ****         const uint l = liczba_odebranych_znakow_SIM900;
1478:main_sim900.h ****         sei();
1479:main_sim900.h ****         if (licznik_odebranych_znakow < l)
1480:main_sim900.h ****           licznik_odebranych_znakow = l;
1481:main_sim900.h ****       }
1482:main_sim900.h ****       if (licznik_odebranych_znakow >=
1483:main_sim900.h ****           MIN_LICZBA_ODEBRANYCH_ZNAKOW_KONCZACYCH_ROZMOWE_W_TRAKCIE_PODSLUCHU) {
1484:main_sim900.h ****         if (++licznik_poprzednia_komenda >= 5 * 100) // 5 sek
1485:main_sim900.h ****         {
1486:main_sim900.h ****           licznik_poprzednia_komenda = 0;
1487:main_sim900.h ****           zakonczono_rozmowe_telefoniczna(
1488:main_sim900.h ****               powod_zakonczenia_rozmowy_zakonczenie);
1489:main_sim900.h ****           licznik_odebranych_znakow = 0;
1490:main_sim900.h ****           POMOC_DODAJ2('#', 'q');
1491:main_sim900.h ****           reset_modulu_SIM900();
1492:main_sim900.h ****         }
1493:main_sim900.h ****       }
1494:main_sim900.h ****     } else {
1495:main_sim900.h ****       licznik_poprzednia_komenda = 0;
1496:main_sim900.h ****       if (!trwa_rozmowa_przychodzaca_od_uzytkownika)
1497:main_sim900.h ****         licznik_odebranych_znakow = 0;
1498:main_sim900.h ****     }
1499:main_sim900.h **** 
1500:main_sim900.h ****     poprzednia_komenda = aktualnie_wysylane_polecenie_SIM900;
 6937               		.loc 2 1500 0
 6938 24e6 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 6939 24ea 8093 0000 		sts poprzednia_komenda.3489,r24
 6940               	/* epilogue start */
 6941               	.LBE613:
1501:main_sim900.h ****   }
1502:main_sim900.h **** }
 6942               		.loc 2 1502 0
 6943 24ee 0895      		ret
 6944               	.L726:
1384:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_KOMENDA_SIM900);
 6945               		.loc 2 1384 0 discriminator 1
 6946 24f0 0E94 0000 		call czy_jest_nowa_komenda_SIM900
 6947               	.LVL529:
 6948 24f4 8111      		cpse r24,__zero_reg__
 6949 24f6 00C0      		rjmp .L728
 6950 24f8 00C0      		rjmp .L727
 6951               	.L731:
 6952               	.LVL530:
 6953               	.LBB617:
1400:main_sim900.h ****         komenda_SIM900 = ERROR_KOMENDA_SIM900;
 6954               		.loc 2 1400 0
 6955 24fa 1092 0000 		sts licznik_bezpieczenstwa.3488+1,__zero_reg__
 6956 24fe 1092 0000 		sts licznik_bezpieczenstwa.3488,__zero_reg__
1401:main_sim900.h ****         obsluga_wysylania_sms();
 6957               		.loc 2 1401 0
 6958 2502 84E0      		ldi r24,lo8(4)
 6959 2504 8093 0000 		sts komenda_SIM900,r24
1402:main_sim900.h ****       }
 6960               		.loc 2 1402 0
 6961 2508 0E94 0000 		call obsluga_wysylania_sms
 6962               	.LVL531:
 6963 250c 00C0      		rjmp .L732
 6964               	.LVL532:
 6965               	.L730:
1405:main_sim900.h ****   }
 6966               		.loc 2 1405 0
 6967 250e 1092 0000 		sts licznik_bezpieczenstwa.3488+1,__zero_reg__
 6968 2512 1092 0000 		sts licznik_bezpieczenstwa.3488,__zero_reg__
 6969 2516 00C0      		rjmp .L732
 6970               	.LVL533:
 6971               	.L738:
 6972               	.LBE617:
 6973               	.LBB618:
 6974               	.LBB615:
1431:main_sim900.h ****         POMOC_DODAJ2('#', 'r');
 6975               		.loc 2 1431 0
 6976 2518 1092 0000 		sts licznik_poprzednia_komenda.3490+1,__zero_reg__
 6977 251c 1092 0000 		sts licznik_poprzednia_komenda.3490,__zero_reg__
 6978               	.LVL534:
1435:main_sim900.h ****             KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1) {
 6979               		.loc 2 1435 0
 6980 2520 8D3F      		cpi r24,lo8(-3)
 6981 2522 01F0      		breq .L740
1437:main_sim900.h ****                   KOMENDA_KOLEJKI_ODRZUC_ROZMOWE ||
 6982               		.loc 2 1437 0
 6983 2524 8739      		cpi r24,lo8(-105)
 6984 2526 01F0      		breq .L741
1438:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
 6985               		.loc 2 1438 0
 6986 2528 92E7      		ldi r25,lo8(114)
 6987 252a 980F      		add r25,r24
 6988 252c 9230      		cpi r25,lo8(2)
 6989 252e 00F0      		brlo .L741
1442:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
 6990               		.loc 2 1442 0
 6991 2530 9CE6      		ldi r25,lo8(108)
 6992 2532 980F      		add r25,r24
 6993 2534 9230      		cpi r25,lo8(2)
 6994 2536 00F0      		brlo .L741
1448:main_sim900.h ****                aktualnie_wysylane_polecenie_SIM900 <=
 6995               		.loc 2 1448 0
 6996 2538 91E6      		ldi r25,lo8(97)
 6997 253a 980F      		add r25,r24
1446:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
 6998               		.loc 2 1446 0
 6999 253c 9A30      		cpi r25,lo8(10)
 7000 253e 00F0      		brlo .L741
1450:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
 7001               		.loc 2 1450 0
 7002 2540 96E5      		ldi r25,lo8(86)
 7003 2542 980F      		add r25,r24
 7004 2544 9832      		cpi r25,lo8(40)
 7005 2546 00F0      		brlo .L741
1462:main_sim900.h ****           wyzerowanie_danych_SIM900();
 7006               		.loc 2 1462 0
 7007 2548 1092 0000 		sts nastepne_wysylane_polecenie_SIM900,__zero_reg__
 7008               	.L742:
1463:main_sim900.h ****           wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1;
 7009               		.loc 2 1463 0
 7010 254c 0E94 0000 		call wyzerowanie_danych_SIM900
 7011               	.LVL535:
1464:main_sim900.h ****           wysylane_dane_RAM_SIM900[0] = '\0';
 7012               		.loc 2 1464 0
 7013 2550 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 7014 2554 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 7015 2558 8DEF      		ldi r24,lo8(-3)
 7016 255a 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1465:main_sim900.h ****           wyslij_polecenie_RAM_SIM900();
 7017               		.loc 2 1465 0
 7018 255e 1092 0000 		sts wysylany_blok_SIM900+2,__zero_reg__
1466:main_sim900.h ****         } else
 7019               		.loc 2 1466 0
 7020 2562 0E94 0000 		call wyslij_polecenie_RAM_SIM900
 7021               	.LVL536:
 7022 2566 00C0      		rjmp .L739
 7023               	.LVL537:
 7024               	.L741:
1459:main_sim900.h ****                 aktualnie_wysylane_polecenie_SIM900;
 7025               		.loc 2 1459 0
 7026 2568 8093 0000 		sts nastepne_wysylane_polecenie_SIM900,r24
 7027 256c 00C0      		rjmp .L742
 7028               	.L740:
1468:main_sim900.h ****       }
 7029               		.loc 2 1468 0
 7030 256e 0E94 0000 		call reset_modulu_SIM900
 7031               	.LVL538:
 7032 2572 00C0      		rjmp .L739
 7033               	.LVL539:
 7034               	.L734:
 7035               	.LBE615:
1472:main_sim900.h ****                trwa_rozmowa_przychodzaca_od_uzytkownika &&
 7036               		.loc 2 1472 0
 7037 2574 9923      		tst r25
 7038 2576 01F0      		breq .L733
 7039               	.L735:
1474:main_sim900.h ****       {
 7040               		.loc 2 1474 0
 7041 2578 8091 0000 		lds r24,komenda_SIM900
1473:main_sim900.h ****                czy_jest_bezczynny_SIM900()) {
 7042               		.loc 2 1473 0
 7043 257c 8111      		cpse r24,__zero_reg__
 7044 257e 00C0      		rjmp .L733
 7045               	.LBB616:
1476:main_sim900.h ****         const uint l = liczba_odebranych_znakow_SIM900;
 7046               		.loc 2 1476 0
 7047               	/* #APP */
 7048               	 ;  1476 "main_sim900.h" 1
 7049 2580 F894      		cli
 7050               	 ;  0 "" 2
1477:main_sim900.h ****         sei();
 7051               		.loc 2 1477 0
 7052               	/* #NOAPP */
 7053 2582 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 7054 2586 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
 7055               	.LVL540:
1478:main_sim900.h ****         if (licznik_odebranych_znakow < l)
 7056               		.loc 2 1478 0
 7057               	/* #APP */
 7058               	 ;  1478 "main_sim900.h" 1
 7059 258a 7894      		sei
 7060               	 ;  0 "" 2
1479:main_sim900.h ****           licznik_odebranych_znakow = l;
 7061               		.loc 2 1479 0
 7062               	/* #NOAPP */
 7063 258c 2091 0000 		lds r18,licznik_odebranych_znakow.3491
 7064 2590 3091 0000 		lds r19,licznik_odebranych_znakow.3491+1
 7065 2594 2817      		cp r18,r24
 7066 2596 3907      		cpc r19,r25
 7067 2598 00F4      		brsh .L744
1480:main_sim900.h ****       }
 7068               		.loc 2 1480 0
 7069 259a 9093 0000 		sts licznik_odebranych_znakow.3491+1,r25
 7070 259e 8093 0000 		sts licznik_odebranych_znakow.3491,r24
 7071               	.L744:
 7072               	.LBE616:
1482:main_sim900.h ****           MIN_LICZBA_ODEBRANYCH_ZNAKOW_KONCZACYCH_ROZMOWE_W_TRAKCIE_PODSLUCHU) {
 7073               		.loc 2 1482 0
 7074 25a2 8091 0000 		lds r24,licznik_odebranych_znakow.3491
 7075 25a6 9091 0000 		lds r25,licznik_odebranych_znakow.3491+1
 7076               	.LVL541:
 7077 25aa 0A97      		sbiw r24,10
 7078 25ac 00F4      		brsh .+2
 7079 25ae 00C0      		rjmp .L743
1484:main_sim900.h ****         {
 7080               		.loc 2 1484 0
 7081 25b0 8091 0000 		lds r24,licznik_poprzednia_komenda.3490
 7082 25b4 9091 0000 		lds r25,licznik_poprzednia_komenda.3490+1
 7083 25b8 0196      		adiw r24,1
 7084 25ba 843F      		cpi r24,-12
 7085 25bc 21E0      		ldi r18,1
 7086 25be 9207      		cpc r25,r18
 7087 25c0 00F4      		brsh .L746
 7088 25c2 9093 0000 		sts licznik_poprzednia_komenda.3490+1,r25
 7089 25c6 8093 0000 		sts licznik_poprzednia_komenda.3490,r24
 7090 25ca 00C0      		rjmp .L743
 7091               	.L746:
1486:main_sim900.h ****           zakonczono_rozmowe_telefoniczna(
 7092               		.loc 2 1486 0
 7093 25cc 1092 0000 		sts licznik_poprzednia_komenda.3490+1,__zero_reg__
 7094 25d0 1092 0000 		sts licznik_poprzednia_komenda.3490,__zero_reg__
1487:main_sim900.h ****               powod_zakonczenia_rozmowy_zakonczenie);
 7095               		.loc 2 1487 0
 7096 25d4 81E0      		ldi r24,lo8(1)
 7097 25d6 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 7098               	.LVL542:
1489:main_sim900.h ****           POMOC_DODAJ2('#', 'q');
 7099               		.loc 2 1489 0
 7100 25da 1092 0000 		sts licznik_odebranych_znakow.3491+1,__zero_reg__
 7101 25de 1092 0000 		sts licznik_odebranych_znakow.3491,__zero_reg__
 7102               	.LVL543:
1491:main_sim900.h ****         }
 7103               		.loc 2 1491 0
 7104 25e2 0E94 0000 		call reset_modulu_SIM900
 7105               	.LVL544:
 7106 25e6 00C0      		rjmp .L743
 7107               	.LVL545:
 7108               	.L733:
1495:main_sim900.h ****       if (!trwa_rozmowa_przychodzaca_od_uzytkownika)
 7109               		.loc 2 1495 0
 7110 25e8 1092 0000 		sts licznik_poprzednia_komenda.3490+1,__zero_reg__
 7111 25ec 1092 0000 		sts licznik_poprzednia_komenda.3490,__zero_reg__
1496:main_sim900.h ****         licznik_odebranych_znakow = 0;
 7112               		.loc 2 1496 0
 7113 25f0 9923      		tst r25
 7114 25f2 01F4      		brne .+2
 7115 25f4 00C0      		rjmp .L739
 7116 25f6 00C0      		rjmp .L743
 7117               	.LBE618:
 7118               		.cfi_endproc
 7119               	.LFE56:
 7121               	.global	wykonanie_komend_powiadomien
 7123               	wykonanie_komend_powiadomien:
 7124               	.LFB60:
1379:main.c        ****   const komenda_typ aktualnie_wykonywana_komenda = komendy_kolejka[0];
 7125               		.loc 1 1379 0
 7126               		.cfi_startproc
 7127 25f8 BF92      		push r11
 7128               	.LCFI79:
 7129               		.cfi_def_cfa_offset 3
 7130               		.cfi_offset 11, -2
 7131 25fa CF92      		push r12
 7132               	.LCFI80:
 7133               		.cfi_def_cfa_offset 4
 7134               		.cfi_offset 12, -3
 7135 25fc DF92      		push r13
 7136               	.LCFI81:
 7137               		.cfi_def_cfa_offset 5
 7138               		.cfi_offset 13, -4
 7139 25fe EF92      		push r14
 7140               	.LCFI82:
 7141               		.cfi_def_cfa_offset 6
 7142               		.cfi_offset 14, -5
 7143 2600 FF92      		push r15
 7144               	.LCFI83:
 7145               		.cfi_def_cfa_offset 7
 7146               		.cfi_offset 15, -6
 7147 2602 0F93      		push r16
 7148               	.LCFI84:
 7149               		.cfi_def_cfa_offset 8
 7150               		.cfi_offset 16, -7
 7151 2604 1F93      		push r17
 7152               	.LCFI85:
 7153               		.cfi_def_cfa_offset 9
 7154               		.cfi_offset 17, -8
 7155 2606 CF93      		push r28
 7156               	.LCFI86:
 7157               		.cfi_def_cfa_offset 10
 7158               		.cfi_offset 28, -9
 7159 2608 DF93      		push r29
 7160               	.LCFI87:
 7161               		.cfi_def_cfa_offset 11
 7162               		.cfi_offset 29, -10
 7163               	/* prologue: function */
 7164               	/* frame size = 0 */
 7165               	/* stack size = 9 */
 7166               	.L__stack_usage = 9
1380:main.c        **** 
 7167               		.loc 1 1380 0
 7168 260a 8091 0000 		lds r24,komendy_kolejka
 7169               	.LVL546:
1387:main.c        **** 
 7170               		.loc 1 1387 0
 7171 260e 9091 0000 		lds r25,flaga_odczytywanie_smsa
 7172 2612 9111      		cpse r25,__zero_reg__
 7173 2614 00C0      		rjmp .L775
1383:main.c        ****       wykonywanie_rozmowy_telefonicznej ||
 7174               		.loc 1 1383 0
 7175 2616 9091 0000 		lds r25,flaga_wysylanie_smsa
 7176 261a 9111      		cpse r25,__zero_reg__
 7177 261c 00C0      		rjmp .L775
1383:main.c        ****       wykonywanie_rozmowy_telefonicznej ||
 7178               		.loc 1 1383 0 is_stmt 0 discriminator 1
 7179 261e 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 7180 2622 9111      		cpse r25,__zero_reg__
 7181 2624 00C0      		rjmp .L775
1384:main.c        ****       trwa_rozmowa_przychodzaca_od_uzytkownika ||
 7182               		.loc 1 1384 0 is_stmt 1
 7183 2626 9091 0000 		lds r25,trwa_rozmowa_przychodzaca_od_uzytkownika
 7184 262a 9111      		cpse r25,__zero_reg__
 7185 262c 00C0      		rjmp .L775
1385:main.c        ****       aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
 7186               		.loc 1 1385 0
 7187 262e 9091 0000 		lds r25,aktualnie_wysylane_polecenie_SIM900
 7188 2632 9111      		cpse r25,__zero_reg__
 7189 2634 00C0      		rjmp .L775
1386:main.c        ****       opoznienie_SIM900_100MS || czekanie_na_odebranie_zachety;
 7190               		.loc 1 1386 0
 7191 2636 9091 0000 		lds r25,opoznienie_SIM900_100MS
 7192 263a 9111      		cpse r25,__zero_reg__
 7193 263c 00C0      		rjmp .L775
1387:main.c        **** 
 7194               		.loc 1 1387 0 discriminator 2
 7195 263e 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 7196 2642 21E0      		ldi r18,lo8(1)
 7197 2644 30E0      		ldi r19,0
 7198 2646 9111      		cpse r25,__zero_reg__
 7199 2648 00C0      		rjmp .L774
 7200 264a 30E0      		ldi r19,0
 7201 264c 20E0      		ldi r18,0
 7202               	.L774:
 7203               	.LVL547:
1390:main.c        ****       czy_jest_bezczynny_SIM900();
 7204               		.loc 1 1390 0 discriminator 2
 7205 264e 232B      		or r18,r19
 7206 2650 01F4      		brne .L775
 7207               	.LVL548:
1390:main.c        ****       czy_jest_bezczynny_SIM900();
 7208               		.loc 1 1390 0 is_stmt 0 discriminator 1
 7209 2652 9091 C100 		lds r25,193
 7210 2656 96FD      		sbrc r25,6
 7211 2658 00C0      		rjmp .L775
1390:main.c        ****       czy_jest_bezczynny_SIM900();
 7212               		.loc 1 1390 0 discriminator 3
 7213 265a 9091 0000 		lds r25,podlaczony_modul_gsm_SIM900
 7214 265e 9923      		tst r25
 7215 2660 01F0      		breq .L775
1391:main.c        **** 
 7216               		.loc 1 1391 0 is_stmt 1 discriminator 5
 7217 2662 9091 0000 		lds r25,komenda_SIM900
1390:main.c        ****       czy_jest_bezczynny_SIM900();
 7218               		.loc 1 1390 0 discriminator 5
 7219 2666 9923      		tst r25
 7220 2668 01F4      		brne .+2
 7221 266a 00C0      		rjmp .L776
 7222               	.LVL549:
 7223               	.L775:
1393:main.c        ****   case KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW: {
 7224               		.loc 1 1393 0
 7225 266c 8938      		cpi r24,lo8(-119)
 7226 266e 01F0      		breq .+2
 7227 2670 00C0      		rjmp .L811
 7228 2672 00C0      		rjmp .L777
 7229               	.LVL550:
 7230               	.L809:
 7231               	.LBB619:
1400:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
 7232               		.loc 1 1400 0
 7233 2674 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 7234 2678 8111      		cpse r24,__zero_reg__
 7235 267a 00C0      		rjmp .L777
1400:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
 7236               		.loc 1 1400 0 is_stmt 0 discriminator 2
 7237 267c 8091 0000 		lds r24,liczba_znakow_do_zapisu
 7238 2680 8111      		cpse r24,__zero_reg__
 7239 2682 00C0      		rjmp .L777
1400:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
 7240               		.loc 1 1400 0 discriminator 4
 7241 2684 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 7242 2688 8111      		cpse r24,__zero_reg__
 7243 268a 00C0      		rjmp .L777
1400:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
 7244               		.loc 1 1400 0 discriminator 6
 7245 268c F999      		sbic 0x1f,1
 7246 268e 00C0      		rjmp .L777
 7247               	.LVL551:
1402:main.c        ****     for (;;) {
 7248               		.loc 1 1402 0 is_stmt 1
 7249 2690 8AE2      		ldi r24,lo8(42)
 7250 2692 8093 0000 		sts tekst_wysylanego_smsa,r24
 7251 2696 00E0      		ldi r16,lo8(tekst_wysylanego_smsa+1)
 7252 2698 10E0      		ldi r17,hi8(tekst_wysylanego_smsa+1)
 7253               	.LVL552:
1404:main.c        ****               numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama)) {
 7254               		.loc 1 1404 0
 7255 269a 85E0      		ldi r24,lo8(5)
 7256 269c D82E      		mov r13,r24
1410:main.c        ****         *sms++ = '\n';
 7257               		.loc 1 1410 0
 7258 269e 93E2      		ldi r25,lo8(35)
 7259 26a0 C92E      		mov r12,r25
1411:main.c        ****         ++numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama;
 7260               		.loc 1 1411 0
 7261 26a2 2AE0      		ldi r18,lo8(10)
 7262 26a4 B22E      		mov r11,r18
 7263               	.LVL553:
 7264               	.L779:
1404:main.c        ****               numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama)) {
 7265               		.loc 1 1404 0
 7266 26a6 C091 0000 		lds r28,numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama
 7267 26aa CD9D      		mul r28,r13
 7268 26ac 7001      		movw r14,r0
 7269 26ae 1124      		clr __zero_reg__
 7270 26b0 88E0      		ldi r24,8
 7271 26b2 E80E      		add r14,r24
 7272 26b4 F11C      		adc r15,__zero_reg__
 7273 26b6 C701      		movw r24,r14
 7274 26b8 0E94 0000 		call eeprom_read_byte
 7275               	.LVL554:
 7276 26bc 8F3F      		cpi r24,lo8(-1)
 7277 26be 01F0      		breq .L780
1406:main.c        ****             (void *)EEPROM_NUMER_TELEFONU_BRAMA(
 7278               		.loc 1 1406 0
 7279 26c0 4FEF      		ldi r20,lo8(-1)
 7280 26c2 B801      		movw r22,r16
 7281 26c4 C701      		movw r24,r14
 7282 26c6 0E94 0000 		call kopiuj_blok_eeprom_na_telefon
 7283               	.LVL555:
 7284 26ca E801      		movw r28,r16
 7285 26cc C80F      		add r28,r24
 7286 26ce D11D      		adc r29,__zero_reg__
 7287               	.LVL556:
1410:main.c        ****         *sms++ = '\n';
 7288               		.loc 1 1410 0
 7289 26d0 C882      		st Y,r12
1411:main.c        ****         ++numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama;
 7290               		.loc 1 1411 0
 7291 26d2 8E01      		movw r16,r28
 7292 26d4 0E5F      		subi r16,-2
 7293 26d6 1F4F      		sbci r17,-1
 7294               	.LVL557:
 7295 26d8 B982      		std Y+1,r11
1412:main.c        ****         if ((sms + MAX_LICZBA_ZNAKOW_TELEFON + 1 >=
 7296               		.loc 1 1412 0
 7297 26da 8091 0000 		lds r24,numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama
 7298 26de 8F5F      		subi r24,lo8(-(1))
 7299 26e0 8093 0000 		sts numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama,r24
1413:main.c        ****              &tekst_wysylanego_smsa[MAX_LICZBA_ZNAKOW_SMS]) ||
 7300               		.loc 1 1413 0
 7301 26e4 9E01      		movw r18,r28
 7302 26e6 2D5E      		subi r18,-19
 7303 26e8 3F4F      		sbci r19,-1
 7304 26ea 2050      		subi r18,lo8(tekst_wysylanego_smsa+160)
 7305 26ec 3040      		sbci r19,hi8(tekst_wysylanego_smsa+160)
 7306 26ee 00F4      		brsh .L781
1414:main.c        ****             (numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama >=
 7307               		.loc 1 1414 0
 7308 26f0 8F3F      		cpi r24,lo8(-1)
 7309 26f2 01F4      		brne .L779
 7310               	.L782:
1420:main.c        ****           dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 7311               		.loc 1 1420 0
 7312 26f4 1A82      		std Y+2,__zero_reg__
1421:main.c        ****           wysylanie_smsa_clipa = WYSYLANIE_SMSA_WYSYLANIE;
 7313               		.loc 1 1421 0
 7314 26f6 83ED      		ldi r24,lo8(-45)
 7315 26f8 0E94 0000 		call dodaj_komende
 7316               	.LVL558:
1422:main.c        ****           break;
 7317               		.loc 1 1422 0
 7318 26fc 81E0      		ldi r24,lo8(1)
 7319 26fe 8093 0000 		sts wysylanie_smsa_clipa,r24
 7320 2702 00C0      		rjmp .L812
 7321               	.L781:
1417:main.c        ****                MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER))
 7322               		.loc 1 1417 0
 7323 2704 8F3F      		cpi r24,lo8(-1)
 7324 2706 01F0      		breq .L782
1419:main.c        ****           *sms = '\0';
 7325               		.loc 1 1419 0
 7326 2708 89E8      		ldi r24,lo8(-119)
 7327 270a 0E94 0000 		call dodaj_komende
 7328               	.LVL559:
 7329 270e 00C0      		rjmp .L782
 7330               	.L780:
1426:main.c        ****             MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER) {
 7331               		.loc 1 1426 0
 7332 2710 CF5F      		subi r28,lo8(-(1))
 7333 2712 C093 0000 		sts numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama,r28
 7334 2716 CF3F      		cpi r28,lo8(-1)
 7335 2718 01F4      		brne .L779
1428:main.c        ****             *sms = '\0';
 7336               		.loc 1 1428 0
 7337 271a E0E0      		ldi r30,hi8(tekst_wysylanego_smsa)
 7338 271c 0030      		cpi r16,lo8(tekst_wysylanego_smsa)
 7339 271e 1E07      		cpc r17,r30
 7340 2720 01F0      		breq .L772
1429:main.c        ****             dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 7341               		.loc 1 1429 0
 7342 2722 F801      		movw r30,r16
 7343 2724 1082      		st Z,__zero_reg__
1430:main.c        ****             wysylanie_smsa_clipa = WYSYLANIE_SMSA_WYSYLANIE;
 7344               		.loc 1 1430 0
 7345 2726 83ED      		ldi r24,lo8(-45)
 7346 2728 0E94 0000 		call dodaj_komende
 7347               	.LVL560:
1431:main.c        ****           }
 7348               		.loc 1 1431 0
 7349 272c 81E0      		ldi r24,lo8(1)
 7350 272e 8093 0000 		sts wysylanie_smsa_clipa,r24
 7351 2732 00C0      		rjmp .L772
 7352               	.LVL561:
 7353               	.L784:
1395:main.c        ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 7354               		.loc 1 1395 0
 7355 2734 8091 0000 		lds r24,wysylanie_smsa_clipa
 7356               	.LVL562:
 7357 2738 8823      		tst r24
 7358 273a 01F4      		brne .+2
 7359 273c 00C0      		rjmp .L809
 7360               	.LVL563:
 7361               	.L777:
1397:main.c        ****       break;
 7362               		.loc 1 1397 0
 7363 273e 89E8      		ldi r24,lo8(-119)
 7364 2740 0E94 0000 		call dodaj_komende
 7365               	.LVL564:
 7366               	.L812:
 7367               	.LBE619:
1442:main.c        **** }
 7368               		.loc 1 1442 0
 7369 2744 CFEF      		ldi r28,lo8(-1)
 7370               	.L772:
1443:main.c        **** 
 7371               		.loc 1 1443 0
 7372 2746 8C2F      		mov r24,r28
 7373               	/* epilogue start */
 7374 2748 DF91      		pop r29
 7375 274a CF91      		pop r28
 7376 274c 1F91      		pop r17
 7377 274e 0F91      		pop r16
 7378 2750 FF90      		pop r15
 7379 2752 EF90      		pop r14
 7380 2754 DF90      		pop r13
 7381 2756 CF90      		pop r12
 7382 2758 BF90      		pop r11
 7383 275a 0895      		ret
 7384               	.LVL565:
 7385               	.L776:
1393:main.c        ****   case KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW: {
 7386               		.loc 1 1393 0
 7387 275c 8938      		cpi r24,lo8(-119)
 7388 275e 01F0      		breq .L784
 7389               	.LVL566:
 7390               	.L811:
1440:main.c        ****   }
 7391               		.loc 1 1440 0
 7392 2760 C0E0      		ldi r28,0
 7393 2762 00C0      		rjmp .L772
 7394               		.cfi_endproc
 7395               	.LFE60:
 7397               	.global	test_sms_clip_100ms
 7399               	test_sms_clip_100ms:
 7400               	.LFB62:
1457:main.c        ****   // static ulong licznik_sms;
 7401               		.loc 1 1457 0
 7402               		.cfi_startproc
 7403               	/* prologue: function */
 7404               	/* frame size = 0 */
 7405               	/* stack size = 0 */
 7406               	.L__stack_usage = 0
 7407               	/* epilogue start */
1476:main.c        **** 
 7408               		.loc 1 1476 0
 7409 2764 0895      		ret
 7410               		.cfi_endproc
 7411               	.LFE62:
 7413               	.global	steruj_wejscia_wyjscia_100ms
 7415               	steruj_wejscia_wyjscia_100ms:
 7416               	.LFB63:
1478:main.c        ****   aktualizuj_stan_wyzwolenia_wejsc_100ms();
 7417               		.loc 1 1478 0
 7418               		.cfi_startproc
 7419               	/* prologue: function */
 7420               	/* frame size = 0 */
 7421               	/* stack size = 0 */
 7422               	.L__stack_usage = 0
1479:main.c        ****   steruj_wejsciem_reset_100ms();
 7423               		.loc 1 1479 0
 7424 2766 0E94 0000 		call aktualizuj_stan_wyzwolenia_wejsc_100ms
 7425               	.LVL567:
1480:main.c        ****   steruj_wyjscia_100ms();
 7426               		.loc 1 1480 0
 7427 276a 0E94 0000 		call steruj_wejsciem_reset_100ms
 7428               	.LVL568:
1481:main.c        **** }
 7429               		.loc 1 1481 0
 7430 276e 0C94 0000 		jmp steruj_wyjscia_100ms
 7431               	.LVL569:
 7432               		.cfi_endproc
 7433               	.LFE63:
 7435               	.global	zapis_w_eeprom_stanu_wyjsc
 7437               	zapis_w_eeprom_stanu_wyjsc:
 7438               	.LFB64:
1484:main.c        ****   if (not czy_wolny_eeprom())
 7439               		.loc 1 1484 0
 7440               		.cfi_startproc
 7441 2772 CF93      		push r28
 7442               	.LCFI88:
 7443               		.cfi_def_cfa_offset 3
 7444               		.cfi_offset 28, -2
 7445 2774 DF93      		push r29
 7446               	.LCFI89:
 7447               		.cfi_def_cfa_offset 4
 7448               		.cfi_offset 29, -3
 7449 2776 1F92      		push __zero_reg__
 7450               	.LCFI90:
 7451               		.cfi_def_cfa_offset 5
 7452 2778 CDB7      		in r28,__SP_L__
 7453 277a DEB7      		in r29,__SP_H__
 7454               	.LCFI91:
 7455               		.cfi_def_cfa_register 28
 7456               	/* prologue: function */
 7457               	/* frame size = 1 */
 7458               	/* stack size = 3 */
 7459               	.L__stack_usage = 3
1485:main.c        ****     return;
 7460               		.loc 1 1485 0
 7461 277c 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 7462 2780 8111      		cpse r24,__zero_reg__
 7463 2782 00C0      		rjmp .L815
1485:main.c        ****     return;
 7464               		.loc 1 1485 0 is_stmt 0 discriminator 1
 7465 2784 8091 0000 		lds r24,liczba_znakow_do_zapisu
 7466 2788 8111      		cpse r24,__zero_reg__
 7467 278a 00C0      		rjmp .L815
1485:main.c        ****     return;
 7468               		.loc 1 1485 0 discriminator 2
 7469 278c 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 7470 2790 8111      		cpse r24,__zero_reg__
 7471 2792 00C0      		rjmp .L815
1485:main.c        ****     return;
 7472               		.loc 1 1485 0 discriminator 3
 7473 2794 F999      		sbic 0x1f,1
 7474 2796 00C0      		rjmp .L815
 7475               	.LBB622:
 7476               	.LBB623:
1487:main.c        ****   if ((stan_wyjscie[0] != 0) ^ (licznik_przelacznik_wyjscia[0] != 0))
 7477               		.loc 1 1487 0 is_stmt 1
 7478 2798 1982      		std Y+1,__zero_reg__
1488:main.c        ****     par |= BIT(0);
 7479               		.loc 1 1488 0
 7480 279a 91E0      		ldi r25,lo8(1)
 7481 279c 8091 0000 		lds r24,stan_wyjscie
 7482 27a0 8111      		cpse r24,__zero_reg__
 7483 27a2 00C0      		rjmp .L818
 7484 27a4 90E0      		ldi r25,0
 7485               	.L818:
 7486 27a6 81E0      		ldi r24,lo8(1)
 7487 27a8 4091 0000 		lds r20,licznik_przelacznik_wyjscia
 7488 27ac 5091 0000 		lds r21,licznik_przelacznik_wyjscia+1
 7489 27b0 6091 0000 		lds r22,licznik_przelacznik_wyjscia+2
 7490 27b4 7091 0000 		lds r23,licznik_przelacznik_wyjscia+3
 7491 27b8 452B      		or r20,r21
 7492 27ba 462B      		or r20,r22
 7493 27bc 472B      		or r20,r23
 7494 27be 01F4      		brne .L819
 7495 27c0 80E0      		ldi r24,0
 7496               	.L819:
 7497 27c2 9817      		cp r25,r24
 7498 27c4 01F0      		breq .L817
1489:main.c        ****   if (par != eeprom_read_byte((void *)EEPROM_USTAWIENIE_STANOW_WYJSC))
 7499               		.loc 1 1489 0
 7500 27c6 81E0      		ldi r24,lo8(1)
 7501 27c8 8983      		std Y+1,r24
 7502               	.L817:
1490:main.c        ****     zapisz_znaki_w_eeprom(&par, (uint)EEPROM_USTAWIENIE_STANOW_WYJSC, 1);
 7503               		.loc 1 1490 0
 7504 27ca 85E0      		ldi r24,lo8(5)
 7505 27cc 90E0      		ldi r25,0
 7506 27ce 0E94 0000 		call eeprom_read_byte
 7507               	.LVL570:
 7508 27d2 9981      		ldd r25,Y+1
 7509 27d4 8917      		cp r24,r25
 7510 27d6 01F0      		breq .L815
1491:main.c        **** }
 7511               		.loc 1 1491 0
 7512 27d8 41E0      		ldi r20,lo8(1)
 7513 27da 65E0      		ldi r22,lo8(5)
 7514 27dc 70E0      		ldi r23,0
 7515 27de CE01      		movw r24,r28
 7516 27e0 0196      		adiw r24,1
 7517 27e2 0E94 0000 		call zapisz_znaki_w_eeprom
 7518               	.LVL571:
 7519               	.L815:
 7520               	/* epilogue start */
 7521               	.LBE623:
 7522               	.LBE622:
1492:main.c        **** 
 7523               		.loc 1 1492 0
 7524 27e6 0F90      		pop __tmp_reg__
 7525 27e8 DF91      		pop r29
 7526 27ea CF91      		pop r28
 7527 27ec 0895      		ret
 7528               		.cfi_endproc
 7529               	.LFE64:
 7531               	.global	steruj_urzadzeniem_100MS
 7533               	steruj_urzadzeniem_100MS:
 7534               	.LFB65:
1507:main.c        ****   steruj_wejscia_wyjscia_100ms();
 7535               		.loc 1 1507 0
 7536               		.cfi_startproc
 7537               	/* prologue: function */
 7538               	/* frame size = 0 */
 7539               	/* stack size = 0 */
 7540               	.L__stack_usage = 0
1508:main.c        ****   steruj_SIM900_100MS();
 7541               		.loc 1 1508 0
 7542 27ee 0E94 0000 		call steruj_wejscia_wyjscia_100ms
 7543               	.LVL572:
1509:main.c        ****   if (licznik_100ms_dioda_led) {
 7544               		.loc 1 1509 0
 7545 27f2 0E94 0000 		call steruj_SIM900_100MS
 7546               	.LVL573:
1510:main.c        ****     if (--licznik_100ms_dioda_led == 0)
 7547               		.loc 1 1510 0
 7548 27f6 8091 0000 		lds r24,licznik_100ms_dioda_led
 7549 27fa 8823      		tst r24
 7550 27fc 01F0      		breq .L822
1511:main.c        ****       ustaw_stan_led(FALSE);
 7551               		.loc 1 1511 0
 7552 27fe 8150      		subi r24,lo8(-(-1))
 7553 2800 8093 0000 		sts licznik_100ms_dioda_led,r24
 7554 2804 8111      		cpse r24,__zero_reg__
 7555 2806 00C0      		rjmp .L823
1512:main.c        ****     else
 7556               		.loc 1 1512 0 discriminator 1
 7557 2808 409A      		sbi 0x8,0
 7558               	.L822:
1518:main.c        ****     --timer_report_user_100ms;
 7559               		.loc 1 1518 0
 7560 280a 8091 0000 		lds r24,timer_report_user_100ms
 7561 280e 9091 0000 		lds r25,timer_report_user_100ms+1
 7562 2812 0097      		sbiw r24,0
 7563 2814 01F0      		breq .L824
1519:main.c        ****     if (timer_report_user_100ms == 0) {
 7564               		.loc 1 1519 0
 7565 2816 0197      		sbiw r24,1
 7566 2818 9093 0000 		sts timer_report_user_100ms+1,r25
 7567 281c 8093 0000 		sts timer_report_user_100ms,r24
1520:main.c        ****       // Okno czasowe minelo - resetuj licznik
 7568               		.loc 1 1520 0
 7569 2820 892B      		or r24,r25
 7570 2822 01F4      		brne .L825
 7571               	.L824:
1522:main.c        ****     }
 7572               		.loc 1 1522 0
 7573 2824 1092 0000 		sts licznik_report_user,__zero_reg__
 7574               	.L825:
1534:main.c        ****       modul_zalogowany_w_sieci) {
 7575               		.loc 1 1534 0
 7576 2828 8091 0000 		lds r24,autosync_czas_aktywny
 7577 282c 8823      		tst r24
 7578 282e 01F0      		breq .L826
1534:main.c        ****       modul_zalogowany_w_sieci) {
 7579               		.loc 1 1534 0 is_stmt 0 discriminator 1
 7580 2830 8091 0000 		lds r24,autosync_sms_wyslany.3741
 7581 2834 8111      		cpse r24,__zero_reg__
 7582 2836 00C0      		rjmp .L826
1534:main.c        ****       modul_zalogowany_w_sieci) {
 7583               		.loc 1 1534 0 discriminator 2
 7584 2838 8091 0000 		lds r24,modul_zalogowany_w_sieci
 7585 283c 8823      		tst r24
 7586 283e 01F0      		breq .L826
1537:main.c        ****       autosync_timer_100ms++;
 7587               		.loc 1 1537 0 is_stmt 1
 7588 2840 8091 0000 		lds r24,autosync_timer_100ms.3742
 7589 2844 9091 0000 		lds r25,autosync_timer_100ms.3742+1
 7590 2848 8E31      		cpi r24,30
 7591 284a 9105      		cpc r25,__zero_reg__
 7592 284c 00F0      		brlo .+2
 7593 284e 00C0      		rjmp .L827
1538:main.c        ****     } else {
 7594               		.loc 1 1538 0
 7595 2850 0196      		adiw r24,1
 7596 2852 9093 0000 		sts autosync_timer_100ms.3742+1,r25
 7597 2856 8093 0000 		sts autosync_timer_100ms.3742,r24
 7598               	.L826:
1558:main.c        ****     autosync_sms_wyslany = FALSE;
 7599               		.loc 1 1558 0
 7600 285a 8091 0000 		lds r24,autosync_czas_aktywny
 7601 285e 8111      		cpse r24,__zero_reg__
 7602 2860 00C0      		rjmp .L829
1559:main.c        ****     autosync_timer_100ms = 0;
 7603               		.loc 1 1559 0
 7604 2862 1092 0000 		sts autosync_sms_wyslany.3741,__zero_reg__
1560:main.c        ****   }
 7605               		.loc 1 1560 0
 7606 2866 1092 0000 		sts autosync_timer_100ms.3742+1,__zero_reg__
 7607 286a 1092 0000 		sts autosync_timer_100ms.3742,__zero_reg__
 7608               	.L829:
1565:main.c        ****   if (pierwsza_komenda != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 7609               		.loc 1 1565 0
 7610 286e 8091 0000 		lds r24,komendy_kolejka
 7611               	.LVL574:
1566:main.c        ****     // Sprawdz czy pierwsza komenda to SMS - jesli tak i stoi zbyt dlugo,
 7612               		.loc 1 1566 0
 7613 2872 8823      		tst r24
 7614 2874 01F4      		brne .+2
 7615 2876 00C0      		rjmp .L830
1569:main.c        ****         pierwsza_komenda <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU) {
 7616               		.loc 1 1569 0
 7617 2878 9DE2      		ldi r25,lo8(45)
 7618 287a 980F      		add r25,r24
 7619 287c 9230      		cpi r25,lo8(2)
 7620 287e 00F0      		brlo .+2
 7621 2880 00C0      		rjmp .L831
1572:main.c        ****         // Ta sama komenda SMS jest na poczatku kolejki - kolejka moze stac
 7622               		.loc 1 1572 0
 7623 2882 9091 0000 		lds r25,ostatnia_pierwsza_komenda
 7624 2886 9813      		cpse r25,r24
 7625 2888 00C0      		rjmp .L831
1574:main.c        ****           ++licznik_kolejka_stoi_100ms;
 7626               		.loc 1 1574 0
 7627 288a 8091 0000 		lds r24,licznik_kolejka_stoi_100ms
 7628 288e 9091 0000 		lds r25,licznik_kolejka_stoi_100ms+1
 7629               	.LVL575:
 7630 2892 8639      		cpi r24,-106
 7631 2894 9105      		cpc r25,__zero_reg__
 7632 2896 00F0      		brlo .+2
 7633 2898 00C0      		rjmp .L833
1575:main.c        ****         else {
 7634               		.loc 1 1575 0
 7635 289a 0196      		adiw r24,1
 7636 289c 9093 0000 		sts licznik_kolejka_stoi_100ms+1,r25
 7637 28a0 8093 0000 		sts licznik_kolejka_stoi_100ms,r24
 7638               	.LVL576:
 7639               	.L834:
1614:main.c        ****     if (licznik_watchdog_wysylanie_smsa_100ms < WATCHDOG_WYSYLANIA_SMS_100MS) {
 7640               		.loc 1 1614 0
 7641 28a4 8091 0000 		lds r24,flaga_wysylanie_smsa
 7642 28a8 8823      		tst r24
 7643 28aa 01F4      		brne .+2
 7644 28ac 00C0      		rjmp .L836
1615:main.c        ****       ++licznik_watchdog_wysylanie_smsa_100ms;
 7645               		.loc 1 1615 0
 7646 28ae 8091 0000 		lds r24,licznik_watchdog_wysylanie_smsa_100ms
 7647 28b2 9091 0000 		lds r25,licznik_watchdog_wysylanie_smsa_100ms+1
 7648 28b6 8C32      		cpi r24,44
 7649 28b8 21E0      		ldi r18,1
 7650 28ba 9207      		cpc r25,r18
 7651 28bc 00F0      		brlo .+2
 7652 28be 00C0      		rjmp .L837
1616:main.c        ****     } else {
 7653               		.loc 1 1616 0
 7654 28c0 0196      		adiw r24,1
 7655 28c2 9093 0000 		sts licznik_watchdog_wysylanie_smsa_100ms+1,r25
 7656 28c6 8093 0000 		sts licznik_watchdog_wysylanie_smsa_100ms,r24
 7657               	.L838:
1638:main.c        ****     if (watchdog_sms_licznik_100ms < WATCHDOG_SMS_TIMEOUT_100MS)
 7658               		.loc 1 1638 0
 7659 28ca 8091 0000 		lds r24,watchdog_sms_aktywny
 7660 28ce 8823      		tst r24
 7661 28d0 01F4      		brne .+2
 7662 28d2 00C0      		rjmp .L840
1639:main.c        ****       ++watchdog_sms_licznik_100ms;
 7663               		.loc 1 1639 0
 7664 28d4 8091 0000 		lds r24,watchdog_sms_licznik_100ms
 7665 28d8 9091 0000 		lds r25,watchdog_sms_licznik_100ms+1
 7666 28dc 8436      		cpi r24,100
 7667 28de 9105      		cpc r25,__zero_reg__
 7668 28e0 00F0      		brlo .+2
 7669 28e2 00C0      		rjmp .L841
1640:main.c        ****     else {
 7670               		.loc 1 1640 0
 7671 28e4 8091 0000 		lds r24,watchdog_sms_licznik_100ms
 7672 28e8 9091 0000 		lds r25,watchdog_sms_licznik_100ms+1
 7673 28ec 0196      		adiw r24,1
 7674 28ee 9093 0000 		sts watchdog_sms_licznik_100ms+1,r25
 7675 28f2 8093 0000 		sts watchdog_sms_licznik_100ms,r24
 7676               	.L842:
1653:main.c        ****     ++stan_cyklu_blysku;
 7677               		.loc 1 1653 0
 7678 28f6 8091 0000 		lds r24,liczba_blyskow_led
 7679 28fa 8823      		tst r24
 7680 28fc 01F4      		brne .+2
 7681 28fe 00C0      		rjmp .L844
1654:main.c        ****     if (stan_cyklu_blysku >= 6) {
 7682               		.loc 1 1654 0
 7683 2900 9091 0000 		lds r25,stan_cyklu_blysku
 7684 2904 9F5F      		subi r25,lo8(-(1))
 7685 2906 9093 0000 		sts stan_cyklu_blysku,r25
1655:main.c        ****       stan_cyklu_blysku = 0;
 7686               		.loc 1 1655 0
 7687 290a 9630      		cpi r25,lo8(6)
 7688 290c 00F0      		brlo .L845
1656:main.c        ****       --liczba_blyskow_led;
 7689               		.loc 1 1656 0
 7690 290e 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
1657:main.c        ****     }
 7691               		.loc 1 1657 0
 7692 2912 8150      		subi r24,lo8(-(-1))
 7693 2914 8093 0000 		sts liczba_blyskow_led,r24
 7694               	.L845:
1659:main.c        ****     return;
 7695               		.loc 1 1659 0
 7696 2918 8091 0000 		lds r24,stan_cyklu_blysku
 7697 291c 8230      		cpi r24,lo8(2)
 7698 291e 00F4      		brsh .+2
 7699 2920 00C0      		rjmp .L846
1659:main.c        ****     return;
 7700               		.loc 1 1659 0 is_stmt 0 discriminator 1
 7701 2922 409A      		sbi 0x8,0
 7702 2924 0895      		ret
 7703               	.L823:
1514:main.c        ****   }
 7704               		.loc 1 1514 0 is_stmt 1 discriminator 2
 7705 2926 4098      		cbi 0x8,0
 7706 2928 00C0      		rjmp .L822
 7707               	.L827:
1541:main.c        ****           !flaga_wysylanie_smsa) {
 7708               		.loc 1 1541 0
 7709 292a 8091 0000 		lds r24,moj_numer_telefonu
 7710 292e 8150      		subi r24,lo8(-(-1))
 7711 2930 8E3F      		cpi r24,lo8(-2)
 7712 2932 00F4      		brsh .L828
1541:main.c        ****           !flaga_wysylanie_smsa) {
 7713               		.loc 1 1541 0 is_stmt 0 discriminator 1
 7714 2934 8091 0000 		lds r24,flaga_wysylanie_smsa
 7715 2938 8111      		cpse r24,__zero_reg__
 7716 293a 00C0      		rjmp .L828
1544:main.c        ****                (char *)moj_numer_telefonu);
 7717               		.loc 1 1544 0 is_stmt 1
 7718 293c 60E0      		ldi r22,lo8(moj_numer_telefonu)
 7719 293e 70E0      		ldi r23,hi8(moj_numer_telefonu)
 7720 2940 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 7721 2942 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 7722 2944 0E94 0000 		call strcpy
 7723               	.LVL577:
1546:main.c        ****         dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 7724               		.loc 1 1546 0
 7725 2948 60E0      		ldi r22,lo8(__c.3743)
 7726 294a 70E0      		ldi r23,hi8(__c.3743)
 7727 294c 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 7728 294e 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 7729 2950 0E94 0000 		call strcpy_P
 7730               	.LVL578:
1547:main.c        ****         autosync_sms_wyslany = TRUE;
 7731               		.loc 1 1547 0
 7732 2954 83ED      		ldi r24,lo8(-45)
 7733 2956 0E94 0000 		call dodaj_komende
 7734               	.LVL579:
 7735               	.L828:
1552:main.c        ****       }
 7736               		.loc 1 1552 0
 7737 295a 8FEF      		ldi r24,lo8(-1)
 7738 295c 8093 0000 		sts autosync_sms_wyslany.3741,r24
 7739 2960 00C0      		rjmp .L826
 7740               	.LVL580:
 7741               	.L833:
1579:main.c        ****                                        KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
 7742               		.loc 1 1579 0
 7743 2962 64ED      		ldi r22,lo8(-44)
 7744 2964 83ED      		ldi r24,lo8(-45)
 7745 2966 0E94 0000 		call filtruj_komendy_z_przedzialu
 7746               	.LVL581:
1581:main.c        ****             ++licznik_awaryjnych_resetow_kolejki;
 7747               		.loc 1 1581 0
 7748 296a 8091 0000 		lds r24,licznik_awaryjnych_resetow_kolejki
 7749 296e 9091 0000 		lds r25,licznik_awaryjnych_resetow_kolejki+1
 7750 2972 8F3F      		cpi r24,-1
 7751 2974 9807      		cpc r25,r24
 7752 2976 01F0      		breq .L835
1582:main.c        **** 
 7753               		.loc 1 1582 0
 7754 2978 0196      		adiw r24,1
 7755 297a 9093 0000 		sts licznik_awaryjnych_resetow_kolejki+1,r25
 7756 297e 8093 0000 		sts licznik_awaryjnych_resetow_kolejki,r24
 7757               	.L835:
1584:main.c        **** 
 7758               		.loc 1 1584 0
 7759 2982 82E9      		ldi r24,lo8(-110)
 7760 2984 0E94 0000 		call filtruj_i_dodaj_komende
 7761               	.LVL582:
1587:main.c        ****           timer_report_user_100ms = 0;
 7762               		.loc 1 1587 0
 7763 2988 1092 0000 		sts licznik_report_user,__zero_reg__
1588:main.c        **** 
 7764               		.loc 1 1588 0
 7765 298c 1092 0000 		sts timer_report_user_100ms+1,__zero_reg__
 7766 2990 1092 0000 		sts timer_report_user_100ms,__zero_reg__
1591:main.c        ****           ostatnia_pierwsza_komenda = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 7767               		.loc 1 1591 0
 7768 2994 1092 0000 		sts licznik_kolejka_stoi_100ms+1,__zero_reg__
 7769 2998 1092 0000 		sts licznik_kolejka_stoi_100ms,__zero_reg__
1592:main.c        **** 
 7770               		.loc 1 1592 0
 7771 299c 1092 0000 		sts ostatnia_pierwsza_komenda,__zero_reg__
1595:main.c        ****         }
 7772               		.loc 1 1595 0
 7773 29a0 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
 7774 29a4 00C0      		rjmp .L834
 7775               	.LVL583:
 7776               	.L831:
1604:main.c        ****       licznik_kolejka_stoi_100ms = 0;
 7777               		.loc 1 1604 0
 7778 29a6 8093 0000 		sts ostatnia_pierwsza_komenda,r24
 7779               	.L881:
1610:main.c        ****   }
 7780               		.loc 1 1610 0
 7781 29aa 1092 0000 		sts licznik_kolejka_stoi_100ms+1,__zero_reg__
 7782 29ae 1092 0000 		sts licznik_kolejka_stoi_100ms,__zero_reg__
 7783 29b2 00C0      		rjmp .L834
 7784               	.L830:
1609:main.c        ****     licznik_kolejka_stoi_100ms = 0;
 7785               		.loc 1 1609 0
 7786 29b4 1092 0000 		sts ostatnia_pierwsza_komenda,__zero_reg__
 7787 29b8 00C0      		rjmp .L881
 7788               	.LVL584:
 7789               	.L837:
1618:main.c        ****       // Awaryjne odblokowanie
 7790               		.loc 1 1618 0
 7791 29ba 1092 0000 		sts licznik_watchdog_wysylanie_smsa_100ms+1,__zero_reg__
 7792 29be 1092 0000 		sts licznik_watchdog_wysylanie_smsa_100ms,__zero_reg__
1620:main.c        ****       flaga_wysylanie_smsa = 0;
 7793               		.loc 1 1620 0
 7794 29c2 0E94 0000 		call watchdog_sms_disarm
 7795               	.LVL585:
1621:main.c        ****       liczba_prob_wyslania_smsa = 0;
 7796               		.loc 1 1621 0
 7797 29c6 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
1622:main.c        ****       czekanie_na_odebranie_zachety = FALSE;
 7798               		.loc 1 1622 0
 7799 29ca 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
1623:main.c        ****       wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
 7800               		.loc 1 1623 0
 7801 29ce 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
1624:main.c        **** 
 7802               		.loc 1 1624 0
 7803 29d2 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
1626:main.c        ****         ++liczba_kolejnych_watchdogow_wysylania;
 7804               		.loc 1 1626 0
 7805 29d6 8091 0000 		lds r24,liczba_kolejnych_watchdogow_wysylania
 7806 29da 8F3F      		cpi r24,lo8(-1)
 7807 29dc 01F0      		breq .L839
1627:main.c        ****       if (liczba_kolejnych_watchdogow_wysylania >= 3) {
 7808               		.loc 1 1627 0
 7809 29de 8F5F      		subi r24,lo8(-(1))
 7810 29e0 8093 0000 		sts liczba_kolejnych_watchdogow_wysylania,r24
 7811               	.L839:
1628:main.c        ****         liczba_kolejnych_watchdogow_wysylania = 0;
 7812               		.loc 1 1628 0
 7813 29e4 8091 0000 		lds r24,liczba_kolejnych_watchdogow_wysylania
 7814 29e8 8330      		cpi r24,lo8(3)
 7815 29ea 00F4      		brsh .+2
 7816 29ec 00C0      		rjmp .L838
1629:main.c        ****         reset_modulu_SIM900();
 7817               		.loc 1 1629 0
 7818 29ee 1092 0000 		sts liczba_kolejnych_watchdogow_wysylania,__zero_reg__
1630:main.c        ****       }
 7819               		.loc 1 1630 0
 7820 29f2 0E94 0000 		call reset_modulu_SIM900
 7821               	.LVL586:
 7822 29f6 00C0      		rjmp .L838
 7823               	.L836:
1634:main.c        ****     liczba_kolejnych_watchdogow_wysylania = 0;
 7824               		.loc 1 1634 0
 7825 29f8 1092 0000 		sts licznik_watchdog_wysylanie_smsa_100ms+1,__zero_reg__
 7826 29fc 1092 0000 		sts licznik_watchdog_wysylanie_smsa_100ms,__zero_reg__
1635:main.c        ****   }
 7827               		.loc 1 1635 0
 7828 2a00 1092 0000 		sts liczba_kolejnych_watchdogow_wysylania,__zero_reg__
 7829 2a04 00C0      		rjmp .L838
 7830               	.L841:
1642:main.c        ****       cli();
 7831               		.loc 1 1642 0
 7832 2a06 8FEF      		ldi r24,lo8(-1)
 7833 2a08 8093 0000 		sts watchdog_sms_trwa_reset,r24
1643:main.c        ****       wdt_enable(WDTO_15MS);
 7834               		.loc 1 1643 0
 7835               	/* #APP */
 7836               	 ;  1643 "main.c" 1
 7837 2a0c F894      		cli
 7838               	 ;  0 "" 2
 7839               	.LVL587:
 7840               	/* #NOAPP */
 7841               	.LBB624:
 7842               	.LBB625:
 7843               		.file 7 "/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h"
   1:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
   5:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
   8:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  11:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      distribution.
  15:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  16:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  20:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  32:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /* $Id$ */
  33:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  34:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /*
  35:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****  */
  37:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  38:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  41:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  44:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /** \file */
  45:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  48:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  57:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  61:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     the following:
  68:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  69:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     \code
  70:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  73:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  75:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     {
  80:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     }
  84:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     \endcode
  85:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  86:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** */
  91:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  92:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /**
  93:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** */
  98:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  99:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 101:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #ifndef __DOXYGEN__
 102:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 103:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined(WDP3)
 104:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 105:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else
 106:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 107:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif
 108:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 109:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 110:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 111:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 112:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 113:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else
 114:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 115:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif
 116:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 117:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined(WDTOE)
 118:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 119:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else
 120:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 121:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif
 122:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 123:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif	/* !__DOXYGEN__ */
 124:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 125:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 126:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /**
 127:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 128:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 129:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 130:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 131:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 132:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 133:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 134:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 135:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** */
 136:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 137:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 138:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 139:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 140:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined (WDT_CTRLA) && !defined(RAMPD)
 141:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 142:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 143:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** do { \
 144:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** uint8_t temp; \
 145:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 146:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"wdr"									"\n\t" \
 147:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]"		"\n\t" \
 148:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"				"\n\t" \
 149:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"sbr %[tmp], %[wdt_enable_timeout]"		"\n\t" \
 150:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"				"\n\t" \
 151:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"1:lds %[tmp], %[wdt_status_reg]"		"\n\t" \
 152:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"sbrc %[tmp], %[wdt_syncbusy_bit]"		"\n\t" \
 153:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"rjmp 1b"								"\n\t" \
 154:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	: [tmp]					"=r" (temp) \
 155:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	: [ccp_reg]				"I"  (_SFR_IO_ADDR(CCP)), \
 156:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [ioreg_cen_mask]		"r"  ((uint8_t)CCP_IOREG_gc), \
 157:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [wdt_reg]				"n"  (_SFR_MEM_ADDR(WDT_CTRLA)), \
 158:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [wdt_enable_timeout]	"M"  (timeout), \
 159:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [wdt_status_reg]		"n"  (_SFR_MEM_ADDR(WDT_STATUS)), \
 160:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [wdt_syncbusy_bit]	"I"  (WDT_SYNCBUSY_bm) \
 161:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ); \
 162:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** } while(0)
 163:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 164:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_disable() \
 165:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** do { \
 166:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** uint8_t temp; \
 167:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 168:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"wdr"								"\n\t" \
 169:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 170:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"			"\n\t" \
 171:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"cbr %[tmp], %[timeout_mask]"       "\n\t" \
 172:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"			"\n\t" \
 173:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [tmp]            "=r" (temp) \
 174:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [ccp_reg]        "I" (_SFR_IO_ADDR(CCP)),       \
 175:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ioreg_cen_mask] "r" ((uint8_t)CCP_IOREG_gc),   \
 176:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_reg]        "n" (_SFR_MEM_ADDR(WDT_CTRLA)),\
 177:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [timeout_mask]   "I" (WDT_PERIOD_gm) \
 178:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ); \
 179:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** } while(0)
 180:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 181:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else // defined (WDT_CTRLA) && !defined(RAMPD)
 182:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 183:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /*
 184:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 185:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 186:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    registers to the CCP register
 187:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ** At the same time,
 188:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 189:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 190:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 191:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 192:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 193:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    sync is finished).
 194:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** */
 195:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 196:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** do { \
 197:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** uint8_t temp; \
 198:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 199:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 200:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 201:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 202:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 203:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 204:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 205:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 206:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 207:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 208:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 209:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 210:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 211:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 212:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 213:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 214:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 215:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : "r0" \
 216:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ); \
 217:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** } while(0)
 218:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 219:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_disable() \
 220:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 221:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 222:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 223:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 224:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 225:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 226:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : \
 227:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 228:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 229:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 230:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 231:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 232:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : "r0" \
 233:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** );
 234:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 235:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif // defined (WDT_CTRLA) && !defined(RAMPD)
 236:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 237:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 238:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 239:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 240:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 241:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 242:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 243:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 244:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 245:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 246:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 247:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : /* no outputs */  \
 248:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 249:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 250:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 251:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 252:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 253:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : "r16" \
 254:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** )
 255:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 256:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_disable() \
 257:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** do { \
 258:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 259:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 260:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 261:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 262:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 263:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 264:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 265:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 266:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 267:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 268:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : /*no output */ \
 269:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 270:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 271:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 272:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 273:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 274:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : "r16" \
 275:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ); \
 276:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** }while(0)
 277:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 278:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #elif defined(CCP)
 279:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 280:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** static __inline__
 281:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 282:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 283:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** {
 284:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 285:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 286:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 287:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 288:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 289:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 290:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 291:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 292:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 293:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: /* no outputs */
 294:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 295:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 296:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 297:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 298:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 299:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: "r0"
 300:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			);
 301:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 302:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 303:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 304:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 305:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 306:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 307:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 308:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 309:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 310:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 311:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: /* no outputs */
 312:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 313:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 314:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 315:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 316:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 317:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: "r0"
 318:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			);
 319:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 320:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 321:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 322:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 323:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 324:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 325:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 326:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 327:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 328:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 329:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: /* no outputs */
 330:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 331:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 332:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 333:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 334:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 335:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: "r0"
 336:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			);
 337:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 338:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else
 339:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****  	{
 340:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 341:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 342:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 343:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 344:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 345:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 346:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 347:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: /* no outputs */
 348:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 349:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 350:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 351:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 352:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 353:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: "r0"
 354:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			);
 355:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 356:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** }
 357:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 358:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** static __inline__
 359:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 360:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** void wdt_disable (void)
 361:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** {
 362:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 363:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 364:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 365:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 366:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 367:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 368:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 369:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 370:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 371:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 372:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 373:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 374:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /*no output */
 375:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 376:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 377:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 378:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 379:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 380:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 381:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				);
 382:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 383:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 384:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 385:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 386:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 387:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 388:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 389:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 390:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 391:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 392:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 393:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 394:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 395:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /*no output */
 396:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 397:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 398:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 399:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 400:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 401:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 402:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				);
 403:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 404:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 405:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 406:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 407:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 408:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 409:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 410:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 411:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 412:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 413:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 414:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 415:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 416:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /*no output */
 417:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 418:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 419:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 420:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 421:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 422:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 423:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				);
 424:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 425:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else
 426:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 427:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 428:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 429:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 430:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 431:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 432:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 433:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 434:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 435:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 436:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 437:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /*no output */
 438:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 439:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 440:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 441:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 442:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 443:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 444:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				);
 445:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 446:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** }
 447:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 448:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else
 449:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 450:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** static __inline__
 451:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 452:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 453:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** {
 454:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 455:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 456:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 457:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 458:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 459:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 460:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 461:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 462:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 463:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /* no outputs */
 464:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 465:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 466:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 467:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 468:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 469:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		);
 470:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 471:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else
 472:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 473:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 7844               		.loc 7 473 0
 7845 2a0e 88E1      		ldi r24,lo8(24)
 7846 2a10 98E0      		ldi r25,lo8(8)
 7847               	/* #APP */
 7848               	 ;  473 "/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h" 1
 7849 2a12 0FB6      		in __tmp_reg__,__SREG__
 7850 2a14 F894      		cli
 7851 2a16 A895      		wdr
 7852 2a18 8093 6000 		sts 96, r24
 7853 2a1c 0FBE      		out __SREG__,__tmp_reg__
 7854 2a1e 9093 6000 		sts 96, r25
 7855               	 	
 7856               	 ;  0 "" 2
 7857               	/* #NOAPP */
 7858               	.L843:
 7859 2a22 00C0      		rjmp .L843
 7860               	.LVL588:
 7861               	.L840:
 7862               	.LBE625:
 7863               	.LBE624:
1648:main.c        ****     --watchdog_sms_safe_mode_100ms;
 7864               		.loc 1 1648 0
 7865 2a24 8091 0000 		lds r24,watchdog_sms_safe_mode_100ms
 7866 2a28 9091 0000 		lds r25,watchdog_sms_safe_mode_100ms+1
 7867 2a2c 892B      		or r24,r25
 7868 2a2e 01F4      		brne .+2
 7869 2a30 00C0      		rjmp .L842
1649:main.c        ****   }
 7870               		.loc 1 1649 0
 7871 2a32 8091 0000 		lds r24,watchdog_sms_safe_mode_100ms
 7872 2a36 9091 0000 		lds r25,watchdog_sms_safe_mode_100ms+1
 7873 2a3a 0197      		sbiw r24,1
 7874 2a3c 9093 0000 		sts watchdog_sms_safe_mode_100ms+1,r25
 7875 2a40 8093 0000 		sts watchdog_sms_safe_mode_100ms,r24
 7876 2a44 00C0      		rjmp .L842
 7877               	.L846:
1659:main.c        ****     return;
 7878               		.loc 1 1659 0 discriminator 2
 7879 2a46 4098      		cbi 0x8,0
 7880               	/* epilogue start */
1689:main.c        **** 
 7881               		.loc 1 1689 0 discriminator 2
 7882 2a48 0895      		ret
 7883               	.L844:
1665:main.c        ****     // Nie zalogowany - dioda swiecei ciagle
 7884               		.loc 1 1665 0
 7885 2a4a 8091 0000 		lds r24,modul_zalogowany_w_sieci
 7886 2a4e 8111      		cpse r24,__zero_reg__
 7887 2a50 00C0      		rjmp .L848
 7888               	.L853:
 7889               	.LBB626:
1682:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7890               		.loc 1 1682 0 discriminator 6
 7891 2a52 4098      		cbi 0x8,0
 7892 2a54 00C0      		rjmp .L849
 7893               	.L848:
 7894               	.LBE626:
1670:main.c        ****       // Mrugniecie (SMS, etc.)
 7895               		.loc 1 1670 0
 7896 2a56 8091 0000 		lds r24,licznik_100ms_dioda_led
 7897 2a5a 8111      		cpse r24,__zero_reg__
 7898 2a5c 00C0      		rjmp .L853
 7899               	.LBB627:
1676:main.c        ****         if (++licznik_dioda_led_poziom_sieci >= 50)
 7900               		.loc 1 1676 0
 7901 2a5e 8091 0000 		lds r24,poziom_sieci_gsm
 7902 2a62 8031      		cpi r24,lo8(16)
 7903 2a64 00F4      		brsh .L851
1677:main.c        ****           licznik_dioda_led_poziom_sieci = 1;
 7904               		.loc 1 1677 0
 7905 2a66 8091 0000 		lds r24,licznik_dioda_led_poziom_sieci.3747
 7906 2a6a 8F5F      		subi r24,lo8(-(1))
 7907 2a6c 8093 0000 		sts licznik_dioda_led_poziom_sieci.3747,r24
 7908 2a70 8233      		cpi r24,lo8(50)
 7909 2a72 00F0      		brlo .L852
1678:main.c        ****       } else
 7910               		.loc 1 1678 0
 7911 2a74 81E0      		ldi r24,lo8(1)
 7912 2a76 8093 0000 		sts licznik_dioda_led_poziom_sieci.3747,r24
 7913               	.L852:
1682:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7914               		.loc 1 1682 0
 7915 2a7a 8091 0000 		lds r24,licznik_dioda_led_poziom_sieci.3747
 7916 2a7e 8832      		cpi r24,lo8(40)
 7917 2a80 01F0      		breq .L853
1682:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7918               		.loc 1 1682 0 is_stmt 0 discriminator 1
 7919 2a82 8B32      		cpi r24,lo8(43)
 7920 2a84 01F0      		breq .L853
1682:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7921               		.loc 1 1682 0 discriminator 3
 7922 2a86 8E52      		subi r24,lo8(-(-46))
 7923 2a88 8430      		cpi r24,lo8(4)
 7924 2a8a 00F0      		brlo .L853
1682:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7925               		.loc 1 1682 0 discriminator 5
 7926 2a8c 409A      		sbi 0x8,0
 7927               	.L849:
 7928               	.LBE627:
1688:main.c        **** }
 7929               		.loc 1 1688 0 is_stmt 1
 7930 2a8e 0C94 0000 		jmp zapis_w_eeprom_stanu_wyjsc
 7931               	.LVL589:
 7932               	.L851:
 7933               	.LBB628:
1680:main.c        **** 
 7934               		.loc 1 1680 0
 7935 2a92 1092 0000 		sts licznik_dioda_led_poziom_sieci.3747,__zero_reg__
 7936 2a96 00C0      		rjmp .L852
 7937               	.LBE628:
 7938               		.cfi_endproc
 7939               	.LFE65:
 7941               	.global	steruj_urzadzeniem_10MS
 7943               	steruj_urzadzeniem_10MS:
 7944               	.LFB66:
1691:main.c        ****   steruj_wejscia_10ms();
 7945               		.loc 1 1691 0
 7946               		.cfi_startproc
 7947               	/* prologue: function */
 7948               	/* frame size = 0 */
 7949               	/* stack size = 0 */
 7950               	.L__stack_usage = 0
1692:main.c        ****   steruj_SIM900_10MS();
 7951               		.loc 1 1692 0
 7952 2a98 0E94 0000 		call steruj_wejscia_10ms
 7953               	.LVL590:
1693:main.c        ****   zapisz_bajt_w_EEPROM();
 7954               		.loc 1 1693 0
 7955 2a9c 0E94 0000 		call steruj_SIM900_10MS
 7956               	.LVL591:
1694:main.c        ****   // test_dioda_wyjscia();
 7957               		.loc 1 1694 0
 7958 2aa0 0C94 0000 		jmp zapisz_bajt_w_EEPROM
 7959               	.LVL592:
 7960               		.cfi_endproc
 7961               	.LFE66:
 7963               	.global	wolne_zdarzenie_timer
 7965               	wolne_zdarzenie_timer:
 7966               	.LFB67:
1699:main.c        ****   WYKONAJ_CLI_SEI(WYLACZ_PRZERWANIE_TIMER());
 7967               		.loc 1 1699 0
 7968               		.cfi_startproc
 7969               	/* prologue: function */
 7970               	/* frame size = 0 */
 7971               	/* stack size = 0 */
 7972               	.L__stack_usage = 0
1700:main.c        ****   if (!CZY_WYKONAC_ZDARZENIE_TIMER()) {
 7973               		.loc 1 1700 0
 7974               	/* #APP */
 7975               	 ;  1700 "main.c" 1
 7976 2aa4 F894      		cli
 7977               	 ;  0 "" 2
 7978               	/* #NOAPP */
 7979 2aa6 8091 6E00 		lds r24,110
 7980 2aaa 8D7F      		andi r24,lo8(-3)
 7981 2aac 8093 6E00 		sts 110,r24
 7982               	/* #APP */
 7983               	 ;  1700 "main.c" 1
 7984 2ab0 7894      		sei
 7985               	 ;  0 "" 2
 7986               	 ;  1700 "main.c" 1
 7987 2ab2 0000      		nop
 7988               	 ;  0 "" 2
1701:main.c        ****     WYKONAJ_CLI_SEI(WLACZ_PRZERWANIE_TIMER());
 7989               		.loc 1 1701 0
 7990               	/* #NOAPP */
 7991 2ab4 8091 0000 		lds r24,wykonaj_zdarzenie_timer
 7992 2ab8 8111      		cpse r24,__zero_reg__
 7993 2aba 00C0      		rjmp .L884
1702:main.c        ****     return;
 7994               		.loc 1 1702 0
 7995               	/* #APP */
 7996               	 ;  1702 "main.c" 1
 7997 2abc F894      		cli
 7998               	 ;  0 "" 2
 7999               	/* #NOAPP */
 8000 2abe 8091 6E00 		lds r24,110
 8001 2ac2 8260      		ori r24,lo8(2)
 8002 2ac4 8093 6E00 		sts 110,r24
 8003               	/* #APP */
 8004               	 ;  1702 "main.c" 1
 8005 2ac8 7894      		sei
 8006               	 ;  0 "" 2
 8007               	 ;  1702 "main.c" 1
 8008 2aca 0000      		nop
 8009               	 ;  0 "" 2
1703:main.c        ****   }
 8010               		.loc 1 1703 0
 8011               	/* #NOAPP */
 8012 2acc 0895      		ret
 8013               	.L884:
1705:main.c        ****   if (wykonac_watki_10MS) {
 8014               		.loc 1 1705 0
 8015 2ace 1092 0000 		sts wykonaj_zdarzenie_timer,__zero_reg__
1706:main.c        ****     wykonac_watki = WYKONAJ_WATKI_10MS;
 8016               		.loc 1 1706 0
 8017 2ad2 8091 0000 		lds r24,wykonac_watki_10MS
 8018 2ad6 8823      		tst r24
 8019 2ad8 01F0      		breq .L886
1707:main.c        ****     wykonac_watki_10MS = FALSE;
 8020               		.loc 1 1707 0
 8021 2ada 81E0      		ldi r24,lo8(1)
 8022 2adc 8093 0000 		sts wykonac_watki,r24
1708:main.c        ****   }
 8023               		.loc 1 1708 0
 8024 2ae0 1092 0000 		sts wykonac_watki_10MS,__zero_reg__
 8025               	.L886:
1710:main.c        ****   if (CZY_WYKONAC_WATKI_10MS()) {
 8026               		.loc 1 1710 0
 8027               	/* #APP */
 8028               	 ;  1710 "main.c" 1
 8029 2ae4 F894      		cli
 8030               	 ;  0 "" 2
 8031               	/* #NOAPP */
 8032 2ae6 8091 6E00 		lds r24,110
 8033 2aea 8260      		ori r24,lo8(2)
 8034 2aec 8093 6E00 		sts 110,r24
 8035               	/* #APP */
 8036               	 ;  1710 "main.c" 1
 8037 2af0 7894      		sei
 8038               	 ;  0 "" 2
 8039               	 ;  1710 "main.c" 1
 8040 2af2 0000      		nop
 8041               	 ;  0 "" 2
1711:main.c        ****     static uchar licznik_wybuc_watki_100MS = 0;
 8042               		.loc 1 1711 0
 8043               	/* #NOAPP */
 8044 2af4 8091 0000 		lds r24,wykonac_watki
 8045 2af8 80FF      		sbrs r24,0
 8046 2afa 00C0      		rjmp .L883
 8047               	.LBB632:
1714:main.c        ****       licznik_wybuc_watki_100MS = 0;
 8048               		.loc 1 1714 0
 8049 2afc 8091 0000 		lds r24,licznik_wybuc_watki_100MS.3754
 8050 2b00 8F5F      		subi r24,lo8(-(1))
 8051 2b02 8A30      		cpi r24,lo8(10)
 8052 2b04 01F0      		breq .L887
 8053 2b06 8093 0000 		sts licznik_wybuc_watki_100MS.3754,r24
 8054               	.L888:
1718:main.c        ****     cli();
 8055               		.loc 1 1718 0
 8056               	/* #APP */
 8057               	 ;  1718 "main.c" 1
 8058 2b0a 0000      		nop
 8059               	 ;  0 "" 2
1719:main.c        ****     if (CZY_ODBIERANIE_DANYCH_SIM900()) {
 8060               		.loc 1 1719 0
 8061               	 ;  1719 "main.c" 1
 8062 2b0c F894      		cli
 8063               	 ;  0 "" 2
1720:main.c        ****       WYLACZ_PRZERWANIE_ODBIORU_DANYCH_SIM900();
 8064               		.loc 1 1720 0
 8065               	/* #NOAPP */
 8066 2b0e 00B6      		in __tmp_reg__,0x30
 8067 2b10 01FE      		sbrs __tmp_reg__,1
 8068 2b12 00C0      		rjmp .L889
1721:main.c        ****       sei();
 8069               		.loc 1 1721 0
 8070 2b14 8091 C100 		lds r24,193
 8071 2b18 8F77      		andi r24,lo8(127)
 8072 2b1a 8093 C100 		sts 193,r24
1722:main.c        ****       if (liczba_odebranych_znakow_SIM900 != 0 &&
 8073               		.loc 1 1722 0
 8074               	/* #APP */
 8075               	 ;  1722 "main.c" 1
 8076 2b1e 7894      		sei
 8077               	 ;  0 "" 2
1723:main.c        ****           ++licznik_opoznienie_oczekiwania_na_bajt_SIM900 >
 8078               		.loc 1 1723 0
 8079               	/* #NOAPP */
 8080 2b20 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 8081 2b24 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
 8082 2b28 892B      		or r24,r25
 8083 2b2a 01F0      		breq .L890
1724:main.c        ****               MAX_OPOZNIENIE_OCZEKIWANIA_NA_BAJT_SIM900_500_MS) {
 8084               		.loc 1 1724 0
 8085 2b2c 8091 0000 		lds r24,licznik_opoznienie_oczekiwania_na_bajt_SIM900
 8086 2b30 8F5F      		subi r24,lo8(-(1))
1723:main.c        ****           ++licznik_opoznienie_oczekiwania_na_bajt_SIM900 >
 8087               		.loc 1 1723 0
 8088 2b32 8093 0000 		sts licznik_opoznienie_oczekiwania_na_bajt_SIM900,r24
 8089 2b36 8333      		cpi r24,lo8(51)
 8090 2b38 00F0      		brlo .L890
1726:main.c        ****       } else {
 8091               		.loc 1 1726 0
 8092 2b3a 459A      		sbi 0x8,5
 8093 2b3c 8091 C100 		lds r24,193
 8094 2b40 8F77      		andi r24,lo8(127)
 8095 2b42 8093 C100 		sts 193,r24
 8096 2b46 80B7      		in r24,0x30
 8097 2b48 8D7F      		andi r24,lo8(-3)
 8098 2b4a 80BF      		out 0x30,r24
 8099 2b4c 1092 0000 		sts poczatek_polecenia_SIM900+1,__zero_reg__
 8100 2b50 1092 0000 		sts poczatek_polecenia_SIM900,__zero_reg__
 8101 2b54 1092 0000 		sts zakonczenie_polecenia_SIM900+1,__zero_reg__
 8102 2b58 1092 0000 		sts zakonczenie_polecenia_SIM900,__zero_reg__
 8103 2b5c 1092 0000 		sts czy_jest_nowe_polecenie_SIM900,__zero_reg__
 8104               	.L889:
1731:main.c        ****   }
 8105               		.loc 1 1731 0
 8106               	/* #APP */
 8107               	 ;  1731 "main.c" 1
 8108 2b60 7894      		sei
 8109               	 ;  0 "" 2
 8110               	/* #NOAPP */
 8111               	.L883:
 8112               	/* epilogue start */
 8113               	.LBE632:
1733:main.c        **** 
 8114               		.loc 1 1733 0
 8115 2b62 0895      		ret
 8116               	.L887:
 8117               	.LBB633:
1715:main.c        ****       wykonac_watki = WYKONAJ_WATKI_100MS | WYKONAJ_WATKI_10MS;
 8118               		.loc 1 1715 0
 8119 2b64 1092 0000 		sts licznik_wybuc_watki_100MS.3754,__zero_reg__
1716:main.c        ****     }
 8120               		.loc 1 1716 0
 8121 2b68 83E0      		ldi r24,lo8(3)
 8122 2b6a 8093 0000 		sts wykonac_watki,r24
 8123 2b6e 00C0      		rjmp .L888
 8124               	.L890:
1728:main.c        ****       }
 8125               		.loc 1 1728 0
 8126               	/* #APP */
 8127               	 ;  1728 "main.c" 1
 8128 2b70 F894      		cli
 8129               	 ;  0 "" 2
 8130               	/* #NOAPP */
 8131 2b72 8091 C100 		lds r24,193
 8132 2b76 8068      		ori r24,lo8(-128)
 8133 2b78 8093 C100 		sts 193,r24
 8134               	/* #APP */
 8135               	 ;  1728 "main.c" 1
 8136 2b7c 7894      		sei
 8137               	 ;  0 "" 2
 8138               	 ;  1728 "main.c" 1
 8139 2b7e 0000      		nop
 8140               	 ;  0 "" 2
 8141               	/* #NOAPP */
 8142 2b80 00C0      		rjmp .L889
 8143               	.LBE633:
 8144               		.cfi_endproc
 8145               	.LFE67:
 8147               	.global	ustaw_parametry_dla_bezpieczenstwa
 8149               	ustaw_parametry_dla_bezpieczenstwa:
 8150               	.LFB68:
1735:main.c        ****   wdt_reset();
 8151               		.loc 1 1735 0
 8152               		.cfi_startproc
 8153               	/* prologue: function */
 8154               	/* frame size = 0 */
 8155               	/* stack size = 0 */
 8156               	.L__stack_usage = 0
1736:main.c        ****   ustaw_parametry_dla_bezpieczenstwa_rejestry();
 8157               		.loc 1 1736 0
 8158               	/* #APP */
 8159               	 ;  1736 "main.c" 1
 8160 2b82 A895      		wdr
 8161               	 ;  0 "" 2
1737:main.c        ****   set_sleep_mode(SLEEP_MODE_IDLE);
 8162               		.loc 1 1737 0
 8163               	/* #NOAPP */
 8164 2b84 82E0      		ldi r24,lo8(2)
 8165 2b86 84BD      		out 0x24,r24
 8166 2b88 83E0      		ldi r24,lo8(3)
 8167 2b8a 85BD      		out 0x25,r24
 8168 2b8c 8FE3      		ldi r24,lo8(63)
 8169 2b8e 87BD      		out 0x27,r24
 8170 2b90 EEE6      		ldi r30,lo8(110)
 8171 2b92 F0E0      		ldi r31,0
 8172 2b94 8081      		ld r24,Z
 8173 2b96 8260      		ori r24,lo8(2)
 8174 2b98 8083      		st Z,r24
1738:main.c        **** }
 8175               		.loc 1 1738 0
 8176 2b9a 83B7      		in r24,0x33
 8177 2b9c 817F      		andi r24,lo8(-15)
 8178 2b9e 83BF      		out 0x33,r24
 8179               	/* epilogue start */
1739:main.c        **** 
 8180               		.loc 1 1739 0
 8181 2ba0 0895      		ret
 8182               		.cfi_endproc
 8183               	.LFE68:
 8185               	.global	inicjalizuj_parametry_modulu
 8187               	inicjalizuj_parametry_modulu:
 8188               	.LFB69:
1741:main.c        ****   memcpy_E(kod_modulu, ADRES_EEPROM_KOD_DOSTEPU, LICZBA_BAJTOW_KODU_DOSTEPU);
 8189               		.loc 1 1741 0
 8190               		.cfi_startproc
 8191 2ba2 CF93      		push r28
 8192               	.LCFI92:
 8193               		.cfi_def_cfa_offset 3
 8194               		.cfi_offset 28, -2
 8195 2ba4 DF93      		push r29
 8196               	.LCFI93:
 8197               		.cfi_def_cfa_offset 4
 8198               		.cfi_offset 29, -3
 8199               	/* prologue: function */
 8200               	/* frame size = 0 */
 8201               	/* stack size = 2 */
 8202               	.L__stack_usage = 2
1742:main.c        **** 
 8203               		.loc 1 1742 0
 8204 2ba6 44E0      		ldi r20,lo8(4)
 8205 2ba8 50E0      		ldi r21,0
 8206 2baa 61E0      		ldi r22,lo8(1)
 8207 2bac 70E0      		ldi r23,0
 8208 2bae 80E0      		ldi r24,lo8(kod_modulu)
 8209 2bb0 90E0      		ldi r25,hi8(kod_modulu)
 8210 2bb2 0E94 0000 		call eeprom_read_block
 8211               	.LVL593:
1745:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8212               		.loc 1 1745 0
 8213 2bb6 8091 0000 		lds r24,kod_modulu
 8214 2bba 8150      		subi r24,lo8(-(-1))
 8215 2bbc 8E3F      		cpi r24,lo8(-2)
 8216 2bbe 00F0      		brlo .L905
1746:main.c        ****     kod_modulu[1] = bufor_eeprom[1] = 'B';
 8217               		.loc 1 1746 0
 8218 2bc0 81E4      		ldi r24,lo8(65)
 8219 2bc2 8093 0000 		sts bufor_eeprom,r24
 8220 2bc6 8093 0000 		sts kod_modulu,r24
1747:main.c        ****     kod_modulu[2] = bufor_eeprom[2] = 'C';
 8221               		.loc 1 1747 0
 8222 2bca 82E4      		ldi r24,lo8(66)
 8223 2bcc 8093 0000 		sts bufor_eeprom+1,r24
 8224 2bd0 8093 0000 		sts kod_modulu+1,r24
1748:main.c        ****     kod_modulu[3] = bufor_eeprom[3] = 'D';
 8225               		.loc 1 1748 0
 8226 2bd4 83E4      		ldi r24,lo8(67)
 8227 2bd6 8093 0000 		sts bufor_eeprom+2,r24
 8228 2bda 8093 0000 		sts kod_modulu+2,r24
1749:main.c        ****     // Zapisz do EEPROM natychmiast (BLOCKING)
 8229               		.loc 1 1749 0
 8230 2bde 84E4      		ldi r24,lo8(68)
 8231 2be0 8093 0000 		sts bufor_eeprom+3,r24
 8232 2be4 8093 0000 		sts kod_modulu+3,r24
 8233               	.L906:
1751:main.c        ****       ;
 8234               		.loc 1 1751 0 discriminator 1
 8235 2be8 F999      		sbic 0x1f,1
 8236 2bea 00C0      		rjmp .L906
1753:main.c        ****                         LICZBA_BAJTOW_KODU_DOSTEPU);
 8237               		.loc 1 1753 0
 8238 2bec 44E0      		ldi r20,lo8(4)
 8239 2bee 50E0      		ldi r21,0
 8240 2bf0 61E0      		ldi r22,lo8(1)
 8241 2bf2 70E0      		ldi r23,0
 8242 2bf4 80E0      		ldi r24,lo8(kod_modulu)
 8243 2bf6 90E0      		ldi r25,hi8(kod_modulu)
 8244 2bf8 0E94 0000 		call eeprom_update_block
 8245               	.LVL594:
 8246               	.L905:
1759:main.c        ****   if (tryb_pracy == 0xFF) {
 8247               		.loc 1 1759 0
 8248 2bfc 8EEF      		ldi r24,lo8(-2)
 8249 2bfe 9FE0      		ldi r25,lo8(15)
 8250 2c00 0E94 0000 		call eeprom_read_byte
 8251               	.LVL595:
1760:main.c        ****     tryb_pracy = 1; // Domyślnie Publiczny
 8252               		.loc 1 1760 0
 8253 2c04 8F3F      		cpi r24,lo8(-1)
 8254 2c06 01F4      		brne .+2
 8255 2c08 00C0      		rjmp .L907
1759:main.c        ****   if (tryb_pracy == 0xFF) {
 8256               		.loc 1 1759 0
 8257 2c0a 8093 0000 		sts tryb_pracy,r24
 8258               	.L908:
1768:main.c        ****   if (tryb_clip == 0xFF) {
 8259               		.loc 1 1768 0
 8260 2c0e 8FEF      		ldi r24,lo8(-1)
 8261 2c10 9FE0      		ldi r25,lo8(15)
 8262 2c12 0E94 0000 		call eeprom_read_byte
 8263               	.LVL596:
1769:main.c        ****     tryb_clip = 1; // Domyślnie CLIP (1)
 8264               		.loc 1 1769 0
 8265 2c16 8F3F      		cpi r24,lo8(-1)
 8266 2c18 01F4      		brne .+2
 8267 2c1a 00C0      		rjmp .L910
1768:main.c        ****   if (tryb_clip == 0xFF) {
 8268               		.loc 1 1768 0
 8269 2c1c 8093 0000 		sts tryb_clip,r24
 8270               	.L911:
1777:main.c        ****   czas_start_m = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_START_M);
 8271               		.loc 1 1777 0
 8272 2c20 8AEF      		ldi r24,lo8(-6)
 8273 2c22 9FE0      		ldi r25,lo8(15)
 8274 2c24 0E94 0000 		call eeprom_read_byte
 8275               	.LVL597:
 8276 2c28 8093 0000 		sts czas_start_h,r24
1778:main.c        ****   czas_stop_h = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_STOP_H);
 8277               		.loc 1 1778 0
 8278 2c2c 8BEF      		ldi r24,lo8(-5)
 8279 2c2e 9FE0      		ldi r25,lo8(15)
 8280 2c30 0E94 0000 		call eeprom_read_byte
 8281               	.LVL598:
 8282 2c34 8093 0000 		sts czas_start_m,r24
1779:main.c        ****   czas_stop_m = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_STOP_M);
 8283               		.loc 1 1779 0
 8284 2c38 8CEF      		ldi r24,lo8(-4)
 8285 2c3a 9FE0      		ldi r25,lo8(15)
 8286 2c3c 0E94 0000 		call eeprom_read_byte
 8287               	.LVL599:
 8288 2c40 8093 0000 		sts czas_stop_h,r24
1780:main.c        **** 
 8289               		.loc 1 1780 0
 8290 2c44 8DEF      		ldi r24,lo8(-3)
 8291 2c46 9FE0      		ldi r25,lo8(15)
 8292 2c48 0E94 0000 		call eeprom_read_byte
 8293               	.LVL600:
 8294 2c4c 8093 0000 		sts czas_stop_m,r24
1783:main.c        ****   if (skryba_wlaczona == 0xFF)
 8295               		.loc 1 1783 0
 8296 2c50 89EF      		ldi r24,lo8(-7)
 8297 2c52 9FE0      		ldi r25,lo8(15)
 8298 2c54 0E94 0000 		call eeprom_read_byte
 8299               	.LVL601:
1784:main.c        ****     skryba_wlaczona = FALSE;
 8300               		.loc 1 1784 0
 8301 2c58 8F3F      		cpi r24,lo8(-1)
 8302 2c5a 01F4      		brne .+2
 8303 2c5c 00C0      		rjmp .L913
1783:main.c        ****   if (skryba_wlaczona == 0xFF)
 8304               		.loc 1 1783 0
 8305 2c5e 8093 0000 		sts skryba_wlaczona,r24
 8306               	.L914:
1788:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA_LIMIT_L);
 8307               		.loc 1 1788 0
 8308 2c62 85EF      		ldi r24,lo8(-11)
 8309 2c64 9FE0      		ldi r25,lo8(15)
 8310 2c66 0E94 0000 		call eeprom_read_byte
 8311               	.LVL602:
 8312 2c6a C82F      		mov r28,r24
 8313               	.LVL603:
1790:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA_LIMIT_H);
 8314               		.loc 1 1790 0
 8315 2c6c 86EF      		ldi r24,lo8(-10)
 8316 2c6e 9FE0      		ldi r25,lo8(15)
 8317               	.LVL604:
 8318 2c70 0E94 0000 		call eeprom_read_byte
 8319               	.LVL605:
1792:main.c        ****     // Nie ustawiono - domyslnie 800
 8320               		.loc 1 1792 0
 8321 2c74 CF3F      		cpi r28,lo8(-1)
 8322 2c76 01F0      		breq .+2
 8323 2c78 00C0      		rjmp .L915
1792:main.c        ****     // Nie ustawiono - domyslnie 800
 8324               		.loc 1 1792 0 is_stmt 0 discriminator 1
 8325 2c7a 8F3F      		cpi r24,lo8(-1)
 8326 2c7c 01F0      		breq .+2
 8327 2c7e 00C0      		rjmp .L915
 8328               	.LVL606:
 8329               	.L917:
1794:main.c        ****   } else {
 8330               		.loc 1 1794 0 is_stmt 1
 8331 2c80 80E2      		ldi r24,lo8(32)
 8332 2c82 93E0      		ldi r25,lo8(3)
 8333 2c84 9093 0000 		sts skryba_limit+1,r25
 8334 2c88 8093 0000 		sts skryba_limit,r24
 8335               	.L916:
1803:main.c        **** 
 8336               		.loc 1 1803 0
 8337 2c8c 81E0      		ldi r24,lo8(1)
 8338 2c8e 9091 0000 		lds r25,skryba_wlaczona
 8339 2c92 9111      		cpse r25,__zero_reg__
 8340 2c94 00C0      		rjmp .L918
 8341 2c96 80E0      		ldi r24,0
 8342               	.L918:
 8343 2c98 6091 0000 		lds r22,skryba_limit
 8344 2c9c 0E94 0000 		call zapisz_debug_do_eeprom
 8345               	.LVL607:
1807:main.c        ****       (czas_start_m > 59 && czas_start_m != 0xFF) ||
 8346               		.loc 1 1807 0
 8347 2ca0 8091 0000 		lds r24,czas_start_h
 8348 2ca4 8851      		subi r24,lo8(-(-24))
 8349 2ca6 873E      		cpi r24,lo8(-25)
 8350 2ca8 00F0      		brlo .L938
1808:main.c        ****       (czas_stop_h > 23 && czas_stop_h != 0xFF) ||
 8351               		.loc 1 1808 0 discriminator 1
 8352 2caa 8091 0000 		lds r24,czas_start_m
 8353 2cae 8C53      		subi r24,lo8(-(-60))
1807:main.c        ****       (czas_start_m > 59 && czas_start_m != 0xFF) ||
 8354               		.loc 1 1807 0 discriminator 1
 8355 2cb0 833C      		cpi r24,lo8(-61)
 8356 2cb2 00F0      		brlo .L938
1809:main.c        ****       (czas_stop_m > 59 && czas_stop_m != 0xFF)) {
 8357               		.loc 1 1809 0
 8358 2cb4 8091 0000 		lds r24,czas_stop_h
 8359 2cb8 8851      		subi r24,lo8(-(-24))
1808:main.c        ****       (czas_stop_h > 23 && czas_stop_h != 0xFF) ||
 8360               		.loc 1 1808 0
 8361 2cba 873E      		cpi r24,lo8(-25)
 8362 2cbc 00F0      		brlo .L938
1810:main.c        ****     // Zapisz wartosci wylaczajace (0xFF) - BLOCKING
 8363               		.loc 1 1810 0
 8364 2cbe 8091 0000 		lds r24,czas_stop_m
 8365 2cc2 8C53      		subi r24,lo8(-(-60))
1809:main.c        ****       (czas_stop_m > 59 && czas_stop_m != 0xFF)) {
 8366               		.loc 1 1809 0
 8367 2cc4 833C      		cpi r24,lo8(-61)
 8368 2cc6 00F4      		brsh .L920
 8369               	.L938:
1812:main.c        ****       ;
 8370               		.loc 1 1812 0 discriminator 1
 8371 2cc8 F999      		sbic 0x1f,1
 8372 2cca 00C0      		rjmp .L938
1814:main.c        ****     while (!eeprom_is_ready())
 8373               		.loc 1 1814 0
 8374 2ccc 6FEF      		ldi r22,lo8(-1)
 8375 2cce 8AEF      		ldi r24,lo8(-6)
 8376 2cd0 9FE0      		ldi r25,lo8(15)
 8377 2cd2 0E94 0000 		call eeprom_update_byte
 8378               	.LVL608:
 8379               	.L921:
1815:main.c        ****       ;
 8380               		.loc 1 1815 0 discriminator 1
 8381 2cd6 F999      		sbic 0x1f,1
 8382 2cd8 00C0      		rjmp .L921
1817:main.c        ****     while (!eeprom_is_ready())
 8383               		.loc 1 1817 0
 8384 2cda 6FEF      		ldi r22,lo8(-1)
 8385 2cdc 8BEF      		ldi r24,lo8(-5)
 8386 2cde 9FE0      		ldi r25,lo8(15)
 8387 2ce0 0E94 0000 		call eeprom_update_byte
 8388               	.LVL609:
 8389               	.L922:
1818:main.c        ****       ;
 8390               		.loc 1 1818 0 discriminator 1
 8391 2ce4 F999      		sbic 0x1f,1
 8392 2ce6 00C0      		rjmp .L922
1820:main.c        ****     while (!eeprom_is_ready())
 8393               		.loc 1 1820 0
 8394 2ce8 6FEF      		ldi r22,lo8(-1)
 8395 2cea 8CEF      		ldi r24,lo8(-4)
 8396 2cec 9FE0      		ldi r25,lo8(15)
 8397 2cee 0E94 0000 		call eeprom_update_byte
 8398               	.LVL610:
 8399               	.L923:
1821:main.c        ****       ;
 8400               		.loc 1 1821 0 discriminator 1
 8401 2cf2 F999      		sbic 0x1f,1
 8402 2cf4 00C0      		rjmp .L923
1823:main.c        **** 
 8403               		.loc 1 1823 0
 8404 2cf6 6FEF      		ldi r22,lo8(-1)
 8405 2cf8 8DEF      		ldi r24,lo8(-3)
 8406 2cfa 9FE0      		ldi r25,lo8(15)
 8407 2cfc 0E94 0000 		call eeprom_update_byte
 8408               	.LVL611:
1825:main.c        ****     czas_start_m = 0xFF;
 8409               		.loc 1 1825 0
 8410 2d00 8FEF      		ldi r24,lo8(-1)
 8411 2d02 8093 0000 		sts czas_start_h,r24
1826:main.c        ****     czas_stop_h = 0xFF;
 8412               		.loc 1 1826 0
 8413 2d06 8093 0000 		sts czas_start_m,r24
1827:main.c        ****     czas_stop_m = 0xFF;
 8414               		.loc 1 1827 0
 8415 2d0a 8093 0000 		sts czas_stop_h,r24
1828:main.c        ****   }
 8416               		.loc 1 1828 0
 8417 2d0e 8093 0000 		sts czas_stop_m,r24
 8418               	.L920:
1831:main.c        ****       FALSE; // Domyślnie odblokowane, zaktualizuje sie przy odczycie czasu
 8419               		.loc 1 1831 0
 8420 2d12 1092 0000 		sts blokada_sterowania_czasowa,__zero_reg__
1836:main.c        ****   if (blokada_systemu == 0xFF) {
 8421               		.loc 1 1836 0
 8422 2d16 87EF      		ldi r24,lo8(-9)
 8423 2d18 9FE0      		ldi r25,lo8(15)
 8424 2d1a 0E94 0000 		call eeprom_read_byte
 8425               	.LVL612:
1837:main.c        ****     blokada_systemu = FALSE; // Domyślnie odblokowany
 8426               		.loc 1 1837 0
 8427 2d1e 8F3F      		cpi r24,lo8(-1)
 8428 2d20 01F4      		brne .+2
 8429 2d22 00C0      		rjmp .L924
1835:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_BLOKADA_SYSTEMU);
 8430               		.loc 1 1835 0
 8431 2d24 8093 0000 		sts blokada_systemu,r24
 8432               	.L925:
1741:main.c        ****   memcpy_E(kod_modulu, ADRES_EEPROM_KOD_DOSTEPU, LICZBA_BAJTOW_KODU_DOSTEPU);
 8433               		.loc 1 1741 0
 8434 2d28 C0EF      		ldi r28,lo8(-16)
 8435 2d2a DFE0      		ldi r29,lo8(15)
 8436               	.LVL613:
 8437               	.L928:
 8438               	.LBB634:
1844:main.c        ****       while (!eeprom_is_ready())
 8439               		.loc 1 1844 0
 8440 2d2c CE01      		movw r24,r28
 8441 2d2e 0E94 0000 		call eeprom_read_byte
 8442               	.LVL614:
 8443 2d32 8F3F      		cpi r24,lo8(-1)
 8444 2d34 01F4      		brne .L926
 8445               	.L927:
1845:main.c        ****         ;
 8446               		.loc 1 1845 0 discriminator 1
 8447 2d36 F999      		sbic 0x1f,1
 8448 2d38 00C0      		rjmp .L927
1847:main.c        ****     }
 8449               		.loc 1 1847 0
 8450 2d3a 60E0      		ldi r22,0
 8451 2d3c CE01      		movw r24,r28
 8452 2d3e 0E94 0000 		call eeprom_update_byte
 8453               	.LVL615:
 8454               	.L926:
1843:main.c        ****     if (eeprom_read_byte((const uint8_t *)addr) == 0xFF) {
 8455               		.loc 1 1843 0
 8456 2d42 2196      		adiw r28,1
 8457               	.LVL616:
1842:main.c        ****        addr <= ADRES_EEPROM_DEBUG_SKRYBA_5; ++addr) {
 8458               		.loc 1 1842 0
 8459 2d44 C53F      		cpi r28,-11
 8460 2d46 8FE0      		ldi r24,15
 8461 2d48 D807      		cpc r29,r24
 8462 2d4a 01F4      		brne .L928
 8463               	.LBE634:
 8464               	.LBB635:
1852:main.c        ****        addr <= ADRES_EEPROM_DEBUG_USER_7; ++addr) {
 8465               		.loc 1 1852 0
 8466 2d4c C6EE      		ldi r28,lo8(-26)
 8467 2d4e DFE0      		ldi r29,lo8(15)
 8468               	.LVL617:
 8469               	.L931:
1854:main.c        ****       while (!eeprom_is_ready())
 8470               		.loc 1 1854 0
 8471 2d50 CE01      		movw r24,r28
 8472 2d52 0E94 0000 		call eeprom_read_byte
 8473               	.LVL618:
 8474 2d56 8F3F      		cpi r24,lo8(-1)
 8475 2d58 01F4      		brne .L929
 8476               	.L930:
1855:main.c        ****         ;
 8477               		.loc 1 1855 0 discriminator 1
 8478 2d5a F999      		sbic 0x1f,1
 8479 2d5c 00C0      		rjmp .L930
1857:main.c        ****     }
 8480               		.loc 1 1857 0
 8481 2d5e 60E0      		ldi r22,0
 8482 2d60 CE01      		movw r24,r28
 8483 2d62 0E94 0000 		call eeprom_update_byte
 8484               	.LVL619:
 8485               	.L929:
1853:main.c        ****     if (eeprom_read_byte((const uint8_t *)addr) == 0xFF) {
 8486               		.loc 1 1853 0
 8487 2d66 2196      		adiw r28,1
 8488               	.LVL620:
1852:main.c        ****        addr <= ADRES_EEPROM_DEBUG_USER_7; ++addr) {
 8489               		.loc 1 1852 0
 8490 2d68 CD3E      		cpi r28,-19
 8491 2d6a 2FE0      		ldi r18,15
 8492 2d6c D207      		cpc r29,r18
 8493 2d6e 01F4      		brne .L931
 8494               	.LBE635:
1863:main.c        ****   timer_report_user_100ms = 0;
 8495               		.loc 1 1863 0
 8496 2d70 1092 0000 		sts licznik_report_user,__zero_reg__
1864:main.c        **** 
 8497               		.loc 1 1864 0
 8498 2d74 1092 0000 		sts timer_report_user_100ms+1,__zero_reg__
 8499 2d78 1092 0000 		sts timer_report_user_100ms,__zero_reg__
1867:main.c        **** 
 8500               		.loc 1 1867 0
 8501 2d7c 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
1871:main.c        ****     ++licznik_resetow;
 8502               		.loc 1 1871 0
 8503 2d80 8091 0000 		lds r24,licznik_resetow.3798
 8504 2d84 8F3F      		cpi r24,lo8(-1)
 8505 2d86 01F0      		breq .L933
1872:main.c        ****   while (!eeprom_is_ready())
 8506               		.loc 1 1872 0
 8507 2d88 8F5F      		subi r24,lo8(-(1))
 8508 2d8a 8093 0000 		sts licznik_resetow.3798,r24
 8509               	.L933:
1873:main.c        ****     ;
 8510               		.loc 1 1873 0 discriminator 1
 8511 2d8e F999      		sbic 0x1f,1
 8512 2d90 00C0      		rjmp .L933
1875:main.c        ****   while (!eeprom_is_ready())
 8513               		.loc 1 1875 0
 8514 2d92 6091 0000 		lds r22,licznik_resetow.3798
 8515 2d96 8CED      		ldi r24,lo8(-36)
 8516 2d98 9FE0      		ldi r25,lo8(15)
 8517 2d9a 0E94 0000 		call eeprom_update_byte
 8518               	.LVL621:
 8519               	.L934:
1876:main.c        ****     ;
 8520               		.loc 1 1876 0 discriminator 1
 8521 2d9e F999      		sbic 0x1f,1
 8522 2da0 00C0      		rjmp .L934
1878:main.c        **** 
 8523               		.loc 1 1878 0
 8524 2da2 62E0      		ldi r22,lo8(2)
 8525 2da4 80E0      		ldi r24,0
 8526 2da6 0E94 0000 		call zapisz_debug_do_eeprom
 8527               	.LVL622:
1881:main.c        ****                     (const void *)ADRES_EEPROM_MOJE_NUMER_START,
 8528               		.loc 1 1881 0
 8529 2daa 41E1      		ldi r20,lo8(17)
 8530 2dac 50E0      		ldi r21,0
 8531 2dae 68EC      		ldi r22,lo8(-56)
 8532 2db0 7FE0      		ldi r23,lo8(15)
 8533 2db2 80E0      		ldi r24,lo8(moj_numer_telefonu)
 8534 2db4 90E0      		ldi r25,hi8(moj_numer_telefonu)
 8535 2db6 0E94 0000 		call eeprom_read_block
 8536               	.LVL623:
1884:main.c        **** 
 8537               		.loc 1 1884 0
 8538 2dba 1092 0000 		sts moj_numer_telefonu+16,__zero_reg__
1887:main.c        ****       rtc_czas[4] == '0' && moj_numer_telefonu[0] != 0xFF &&
 8539               		.loc 1 1887 0
 8540 2dbe 8091 0000 		lds r24,rtc_czas
 8541 2dc2 8033      		cpi r24,lo8(48)
 8542 2dc4 01F4      		brne .L904
1887:main.c        ****       rtc_czas[4] == '0' && moj_numer_telefonu[0] != 0xFF &&
 8543               		.loc 1 1887 0 is_stmt 0 discriminator 1
 8544 2dc6 8091 0000 		lds r24,rtc_czas+1
 8545 2dca 8033      		cpi r24,lo8(48)
 8546 2dcc 01F4      		brne .L904
1887:main.c        ****       rtc_czas[4] == '0' && moj_numer_telefonu[0] != 0xFF &&
 8547               		.loc 1 1887 0 discriminator 2
 8548 2dce 8091 0000 		lds r24,rtc_czas+3
 8549 2dd2 8033      		cpi r24,lo8(48)
 8550 2dd4 01F4      		brne .L904
1887:main.c        ****       rtc_czas[4] == '0' && moj_numer_telefonu[0] != 0xFF &&
 8551               		.loc 1 1887 0 discriminator 3
 8552 2dd6 8091 0000 		lds r24,rtc_czas+4
 8553 2dda 8033      		cpi r24,lo8(48)
 8554 2ddc 01F4      		brne .L904
1888:main.c        ****       moj_numer_telefonu[0] != 0) {
 8555               		.loc 1 1888 0 is_stmt 1
 8556 2dde 8091 0000 		lds r24,moj_numer_telefonu
 8557 2de2 8150      		subi r24,lo8(-(-1))
 8558 2de4 8E3F      		cpi r24,lo8(-2)
 8559 2de6 00F4      		brsh .L904
1891:main.c        ****   }
 8560               		.loc 1 1891 0
 8561 2de8 8FEF      		ldi r24,lo8(-1)
 8562 2dea 8093 0000 		sts autosync_czas_aktywny,r24
 8563               	.L904:
 8564               	/* epilogue start */
1893:main.c        **** 
 8565               		.loc 1 1893 0
 8566 2dee DF91      		pop r29
 8567 2df0 CF91      		pop r28
 8568               	.LVL624:
 8569 2df2 0895      		ret
 8570               	.L907:
1761:main.c        ****     while (!eeprom_is_ready())
 8571               		.loc 1 1761 0
 8572 2df4 81E0      		ldi r24,lo8(1)
 8573 2df6 8093 0000 		sts tryb_pracy,r24
 8574               	.L909:
1762:main.c        ****       ;
 8575               		.loc 1 1762 0 discriminator 1
 8576 2dfa F999      		sbic 0x1f,1
 8577 2dfc 00C0      		rjmp .L909
1764:main.c        ****   }
 8578               		.loc 1 1764 0
 8579 2dfe 61E0      		ldi r22,lo8(1)
 8580 2e00 8EEF      		ldi r24,lo8(-2)
 8581 2e02 9FE0      		ldi r25,lo8(15)
 8582 2e04 0E94 0000 		call eeprom_update_byte
 8583               	.LVL625:
 8584 2e08 00C0      		rjmp .L908
 8585               	.L910:
1770:main.c        ****     while (!eeprom_is_ready())
 8586               		.loc 1 1770 0
 8587 2e0a 81E0      		ldi r24,lo8(1)
 8588 2e0c 8093 0000 		sts tryb_clip,r24
 8589               	.L912:
1771:main.c        ****       ;
 8590               		.loc 1 1771 0 discriminator 1
 8591 2e10 F999      		sbic 0x1f,1
 8592 2e12 00C0      		rjmp .L912
1773:main.c        ****   }
 8593               		.loc 1 1773 0
 8594 2e14 61E0      		ldi r22,lo8(1)
 8595 2e16 8FEF      		ldi r24,lo8(-1)
 8596 2e18 9FE0      		ldi r25,lo8(15)
 8597 2e1a 0E94 0000 		call eeprom_update_byte
 8598               	.LVL626:
 8599 2e1e 00C0      		rjmp .L911
 8600               	.L913:
1785:main.c        **** 
 8601               		.loc 1 1785 0
 8602 2e20 1092 0000 		sts skryba_wlaczona,__zero_reg__
 8603 2e24 00C0      		rjmp .L914
 8604               	.LVL627:
 8605               	.L915:
1796:main.c        ****     // Walidacja zakresu
 8606               		.loc 1 1796 0
 8607 2e26 982F      		mov r25,r24
 8608 2e28 8C2F      		mov r24,r28
 8609               	.LVL628:
 8610 2e2a 9093 0000 		sts skryba_limit+1,r25
 8611 2e2e 8093 0000 		sts skryba_limit,r24
1798:main.c        ****       skryba_limit = 800;
 8612               		.loc 1 1798 0
 8613 2e32 0197      		sbiw r24,1
 8614 2e34 8032      		cpi r24,32
 8615 2e36 9340      		sbci r25,3
 8616 2e38 00F0      		brlo .+2
 8617 2e3a 00C0      		rjmp .L917
 8618 2e3c 00C0      		rjmp .L916
 8619               	.LVL629:
 8620               	.L924:
1838:main.c        ****   }
 8621               		.loc 1 1838 0
 8622 2e3e 1092 0000 		sts blokada_systemu,__zero_reg__
 8623 2e42 00C0      		rjmp .L925
 8624               		.cfi_endproc
 8625               	.LFE69:
 8627               		.section	.rodata.str1.1
 8628               	.LC7:
 8629 00a1 5375 7065 		.string	"Super User dodany na pozycji %u"
 8629      7220 5573 
 8629      6572 2064 
 8629      6F64 616E 
 8629      7920 6E61 
 8630               		.text
 8631               	.global	wykonanie_komend_ukladow
 8633               	wykonanie_komend_ukladow:
 8634               	.LFB59:
 890:main.c        ****   const komenda_typ aktualnie_wykonywana_komenda = komendy_kolejka[0];
 8635               		.loc 1 890 0
 8636               		.cfi_startproc
 8637 2e44 CF92      		push r12
 8638               	.LCFI94:
 8639               		.cfi_def_cfa_offset 3
 8640               		.cfi_offset 12, -2
 8641 2e46 DF92      		push r13
 8642               	.LCFI95:
 8643               		.cfi_def_cfa_offset 4
 8644               		.cfi_offset 13, -3
 8645 2e48 EF92      		push r14
 8646               	.LCFI96:
 8647               		.cfi_def_cfa_offset 5
 8648               		.cfi_offset 14, -4
 8649 2e4a FF92      		push r15
 8650               	.LCFI97:
 8651               		.cfi_def_cfa_offset 6
 8652               		.cfi_offset 15, -5
 8653 2e4c 0F93      		push r16
 8654               	.LCFI98:
 8655               		.cfi_def_cfa_offset 7
 8656               		.cfi_offset 16, -6
 8657 2e4e 1F93      		push r17
 8658               	.LCFI99:
 8659               		.cfi_def_cfa_offset 8
 8660               		.cfi_offset 17, -7
 8661 2e50 CF93      		push r28
 8662               	.LCFI100:
 8663               		.cfi_def_cfa_offset 9
 8664               		.cfi_offset 28, -8
 8665 2e52 DF93      		push r29
 8666               	.LCFI101:
 8667               		.cfi_def_cfa_offset 10
 8668               		.cfi_offset 29, -9
 8669 2e54 CDB7      		in r28,__SP_L__
 8670 2e56 DEB7      		in r29,__SP_H__
 8671               	.LCFI102:
 8672               		.cfi_def_cfa_register 28
 8673 2e58 A597      		sbiw r28,37
 8674               	.LCFI103:
 8675               		.cfi_def_cfa_offset 47
 8676 2e5a 0FB6      		in __tmp_reg__,__SREG__
 8677 2e5c F894      		cli
 8678 2e5e DEBF      		out __SP_H__,r29
 8679 2e60 0FBE      		out __SREG__,__tmp_reg__
 8680 2e62 CDBF      		out __SP_L__,r28
 8681               	/* prologue: function */
 8682               	/* frame size = 37 */
 8683               	/* stack size = 45 */
 8684               	.L__stack_usage = 45
 891:main.c        **** 
 8685               		.loc 1 891 0
 8686 2e64 1091 0000 		lds r17,komendy_kolejka
 8687               	.LVL630:
 893:main.c        ****   case KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU: {
 8688               		.loc 1 893 0
 8689 2e68 1438      		cpi r17,lo8(-124)
 8690 2e6a 01F4      		brne .+2
 8691 2e6c 00C0      		rjmp .L955
 8692 2e6e 00F4      		brsh .L956
 8693 2e70 1338      		cpi r17,lo8(-125)
 8694 2e72 00F0      		brlo .+2
 8695 2e74 00C0      		rjmp .L957
 8696 2e76 1330      		cpi r17,lo8(3)
 8697 2e78 00F0      		brlo .+2
 8698 2e7a 00C0      		rjmp .L958
 8699 2e7c 1230      		cpi r17,lo8(2)
 8700 2e7e 01F0      		breq .L959
 8701               	.L1029:
1374:main.c        ****   }
 8702               		.loc 1 1374 0
 8703 2e80 80E0      		ldi r24,0
 8704 2e82 00C0      		rjmp .L953
 8705               	.L956:
 893:main.c        ****   case KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU: {
 8706               		.loc 1 893 0
 8707 2e84 1638      		cpi r17,lo8(-122)
 8708 2e86 01F4      		brne .+2
 8709 2e88 00C0      		rjmp .L960
 8710 2e8a 00F4      		brsh .+2
 8711 2e8c 00C0      		rjmp .L961
 8712 2e8e 1738      		cpi r17,lo8(-121)
 8713 2e90 01F4      		brne .+2
 8714 2e92 00C0      		rjmp .L962
 8715 2e94 1838      		cpi r17,lo8(-120)
 8716 2e96 01F4      		brne .L1029
1348:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8717               		.loc 1 1348 0
 8718 2e98 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8719 2e9c 8111      		cpse r24,__zero_reg__
 8720 2e9e 00C0      		rjmp .L1025
1348:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8721               		.loc 1 1348 0 is_stmt 0 discriminator 2
 8722 2ea0 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8723 2ea4 8111      		cpse r24,__zero_reg__
 8724 2ea6 00C0      		rjmp .L1025
1348:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8725               		.loc 1 1348 0 discriminator 4
 8726 2ea8 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 8727 2eac 8111      		cpse r24,__zero_reg__
 8728 2eae 00C0      		rjmp .L1025
1348:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8729               		.loc 1 1348 0 discriminator 6
 8730 2eb0 F99B      		sbis 0x1f,1
 8731 2eb2 00C0      		rjmp .L1026
 8732               	.L1025:
1348:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8733               		.loc 1 1348 0 discriminator 7
 8734 2eb4 88E8      		ldi r24,lo8(-120)
 8735 2eb6 00C0      		rjmp .L1066
 8736               	.L959:
 895:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8737               		.loc 1 895 0 is_stmt 1
 8738 2eb8 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8739 2ebc 8111      		cpse r24,__zero_reg__
 8740 2ebe 00C0      		rjmp .L964
 895:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8741               		.loc 1 895 0 is_stmt 0 discriminator 2
 8742 2ec0 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8743 2ec4 8111      		cpse r24,__zero_reg__
 8744 2ec6 00C0      		rjmp .L964
 895:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8745               		.loc 1 895 0 discriminator 4
 8746 2ec8 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 8747 2ecc 8111      		cpse r24,__zero_reg__
 8748 2ece 00C0      		rjmp .L964
 895:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8749               		.loc 1 895 0 discriminator 6
 8750 2ed0 F99B      		sbis 0x1f,1
 8751 2ed2 00C0      		rjmp .L965
 8752               	.L964:
 895:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8753               		.loc 1 895 0 discriminator 7
 8754 2ed4 82E0      		ldi r24,lo8(2)
 8755               	.LVL631:
 8756               	.L1066:
1348:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8757               		.loc 1 1348 0 is_stmt 1 discriminator 7
 8758 2ed6 0E94 0000 		call dodaj_komende
 8759               	.LVL632:
 8760 2eda 00C0      		rjmp .L1065
 8761               	.LVL633:
 8762               	.L965:
 896:main.c        ****     kod_modulu[1] = bufor_eeprom[1] = 'B';
 8763               		.loc 1 896 0
 8764 2edc 81E4      		ldi r24,lo8(65)
 8765 2ede 8093 0000 		sts bufor_eeprom,r24
 8766 2ee2 8093 0000 		sts kod_modulu,r24
 897:main.c        ****     kod_modulu[2] = bufor_eeprom[2] = 'C';
 8767               		.loc 1 897 0
 8768 2ee6 82E4      		ldi r24,lo8(66)
 8769 2ee8 8093 0000 		sts bufor_eeprom+1,r24
 8770 2eec 8093 0000 		sts kod_modulu+1,r24
 898:main.c        ****     kod_modulu[3] = bufor_eeprom[3] = 'D';
 8771               		.loc 1 898 0
 8772 2ef0 83E4      		ldi r24,lo8(67)
 8773 2ef2 8093 0000 		sts bufor_eeprom+2,r24
 8774 2ef6 8093 0000 		sts kod_modulu+2,r24
 899:main.c        ****     zapisz_znaki_w_eeprom_bez_kopiowania(ADRES_EEPROM_KOD_DOSTEPU,
 8775               		.loc 1 899 0
 8776 2efa 84E4      		ldi r24,lo8(68)
 8777 2efc 8093 0000 		sts bufor_eeprom+3,r24
 8778 2f00 8093 0000 		sts kod_modulu+3,r24
 900:main.c        ****                                          LICZBA_BAJTOW_KODU_DOSTEPU);
 8779               		.loc 1 900 0
 8780 2f04 64E0      		ldi r22,lo8(4)
 8781 2f06 81E0      		ldi r24,lo8(1)
 8782 2f08 90E0      		ldi r25,0
 8783 2f0a 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 8784               	.LVL634:
 8785               	.L1068:
 8786               	.LBB660:
1051:main.c        ****     break;
 8787               		.loc 1 1051 0
 8788 2f0e 83E3      		ldi r24,lo8(51)
 8789 2f10 8093 0000 		sts licznik_100ms_dioda_led,r24
 8790               	.LVL635:
 8791               	.L1065:
 8792               	.LBE660:
1376:main.c        **** }
 8793               		.loc 1 1376 0
 8794 2f14 8FEF      		ldi r24,lo8(-1)
 8795               	.L953:
 8796               	/* epilogue start */
1377:main.c        **** 
 8797               		.loc 1 1377 0
 8798 2f16 A596      		adiw r28,37
 8799 2f18 0FB6      		in __tmp_reg__,__SREG__
 8800 2f1a F894      		cli
 8801 2f1c DEBF      		out __SP_H__,r29
 8802 2f1e 0FBE      		out __SREG__,__tmp_reg__
 8803 2f20 CDBF      		out __SP_L__,r28
 8804 2f22 DF91      		pop r29
 8805 2f24 CF91      		pop r28
 8806 2f26 1F91      		pop r17
 8807 2f28 0F91      		pop r16
 8808 2f2a FF90      		pop r15
 8809 2f2c EF90      		pop r14
 8810 2f2e DF90      		pop r13
 8811 2f30 CF90      		pop r12
 8812 2f32 0895      		ret
 8813               	.LVL636:
 8814               	.L958:
 8815               	.LBB661:
1033:main.c        ****     const uchar nr_bloku =
 8816               		.loc 1 1033 0
 8817 2f34 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8818 2f38 8111      		cpse r24,__zero_reg__
 8819 2f3a 00C0      		rjmp .L966
1033:main.c        ****     const uchar nr_bloku =
 8820               		.loc 1 1033 0 is_stmt 0 discriminator 2
 8821 2f3c 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8822 2f40 8111      		cpse r24,__zero_reg__
 8823 2f42 00C0      		rjmp .L966
1033:main.c        ****     const uchar nr_bloku =
 8824               		.loc 1 1033 0 discriminator 4
 8825 2f44 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 8826 2f48 8111      		cpse r24,__zero_reg__
 8827 2f4a 00C0      		rjmp .L966
1033:main.c        ****     const uchar nr_bloku =
 8828               		.loc 1 1033 0 discriminator 6
 8829 2f4c F99B      		sbis 0x1f,1
 8830 2f4e 00C0      		rjmp .L967
 8831               	.L966:
1033:main.c        ****     const uchar nr_bloku =
 8832               		.loc 1 1033 0 discriminator 7
 8833 2f50 812F      		mov r24,r17
 8834 2f52 00C0      		rjmp .L1066
 8835               	.L967:
1034:main.c        ****         aktualnie_wykonywana_komenda - KOMENDA_KOLEJKI_RESET_USTAWIEN_0;
 8836               		.loc 1 1034 0 is_stmt 1
 8837 2f54 0DEF      		ldi r16,lo8(-3)
 8838 2f56 010F      		add r16,r17
 8839               	.LVL637:
1037:main.c        ****     if (nr_bloku == 0) {
 8840               		.loc 1 1037 0
 8841 2f58 40E2      		ldi r20,lo8(32)
 8842 2f5a 50E0      		ldi r21,0
 8843 2f5c 6FEF      		ldi r22,lo8(-1)
 8844 2f5e 70E0      		ldi r23,0
 8845 2f60 80E0      		ldi r24,lo8(bufor_eeprom)
 8846 2f62 90E0      		ldi r25,hi8(bufor_eeprom)
 8847 2f64 0E94 0000 		call memset
 8848               	.LVL638:
1038:main.c        ****       kod_modulu[0] = bufor_eeprom[1] = 'A';
 8849               		.loc 1 1038 0
 8850 2f68 0111      		cpse r16,__zero_reg__
 8851 2f6a 00C0      		rjmp .L968
1039:main.c        ****       kod_modulu[1] = bufor_eeprom[2] = 'B';
 8852               		.loc 1 1039 0
 8853 2f6c 81E4      		ldi r24,lo8(65)
 8854 2f6e 8093 0000 		sts bufor_eeprom+1,r24
 8855 2f72 8093 0000 		sts kod_modulu,r24
1040:main.c        ****       kod_modulu[2] = bufor_eeprom[3] = 'C';
 8856               		.loc 1 1040 0
 8857 2f76 82E4      		ldi r24,lo8(66)
 8858 2f78 8093 0000 		sts bufor_eeprom+2,r24
 8859 2f7c 8093 0000 		sts kod_modulu+1,r24
1041:main.c        ****       kod_modulu[3] = bufor_eeprom[4] = 'D';
 8860               		.loc 1 1041 0
 8861 2f80 83E4      		ldi r24,lo8(67)
 8862 2f82 8093 0000 		sts bufor_eeprom+3,r24
 8863 2f86 8093 0000 		sts kod_modulu+2,r24
1042:main.c        ****       bufor_eeprom[5] = 0;
 8864               		.loc 1 1042 0
 8865 2f8a 84E4      		ldi r24,lo8(68)
 8866 2f8c 8093 0000 		sts bufor_eeprom+4,r24
 8867 2f90 8093 0000 		sts kod_modulu+3,r24
1043:main.c        ****       stan_wyjscie[0] = 0;
 8868               		.loc 1 1043 0
 8869 2f94 1092 0000 		sts bufor_eeprom+5,__zero_reg__
1044:main.c        ****       licznik_przelacznik_wyjscia[0] = 0;
 8870               		.loc 1 1044 0
 8871 2f98 1092 0000 		sts stan_wyjscie,__zero_reg__
1045:main.c        ****     }
 8872               		.loc 1 1045 0
 8873 2f9c 1092 0000 		sts licznik_przelacznik_wyjscia,__zero_reg__
 8874 2fa0 1092 0000 		sts licznik_przelacznik_wyjscia+1,__zero_reg__
 8875 2fa4 1092 0000 		sts licznik_przelacznik_wyjscia+2,__zero_reg__
 8876 2fa8 1092 0000 		sts licznik_przelacznik_wyjscia+3,__zero_reg__
 8877               	.L968:
1047:main.c        ****         nr_bloku * LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE,
 8878               		.loc 1 1047 0
 8879 2fac 60E2      		ldi r22,lo8(32)
 8880 2fae 20E2      		ldi r18,lo8(32)
 8881 2fb0 029F      		mul r16,r18
 8882 2fb2 C001      		movw r24,r0
 8883 2fb4 1124      		clr __zero_reg__
 8884 2fb6 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 8885               	.LVL639:
1050:main.c        ****     zapal_diode_led(50);
 8886               		.loc 1 1050 0
 8887 2fba 81E0      		ldi r24,lo8(1)
 8888 2fbc 810F      		add r24,r17
 8889 2fbe 0E94 0000 		call dodaj_komende
 8890               	.LVL640:
 8891 2fc2 00C0      		rjmp .L1068
 8892               	.LVL641:
 8893               	.L957:
 8894               	.LBE661:
 8895               	.LBB662:
1055:main.c        ****     uchar bledny_zapis = FALSE;
 8896               		.loc 1 1055 0
 8897 2fc4 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8898 2fc8 8111      		cpse r24,__zero_reg__
 8899 2fca 00C0      		rjmp .L969
1055:main.c        ****     uchar bledny_zapis = FALSE;
 8900               		.loc 1 1055 0 is_stmt 0 discriminator 2
 8901 2fcc 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8902 2fd0 8111      		cpse r24,__zero_reg__
 8903 2fd2 00C0      		rjmp .L969
1055:main.c        ****     uchar bledny_zapis = FALSE;
 8904               		.loc 1 1055 0 discriminator 4
 8905 2fd4 F090 0000 		lds r15,czy_zajety_bufor_eeprom
 8906 2fd8 F110      		cpse r15,__zero_reg__
 8907 2fda 00C0      		rjmp .L969
1055:main.c        ****     uchar bledny_zapis = FALSE;
 8908               		.loc 1 1055 0 discriminator 6
 8909 2fdc F99B      		sbis 0x1f,1
 8910 2fde 00C0      		rjmp .L1030
 8911               	.L969:
1055:main.c        ****     uchar bledny_zapis = FALSE;
 8912               		.loc 1 1055 0 discriminator 7
 8913 2fe0 83E8      		ldi r24,lo8(-125)
 8914 2fe2 00C0      		rjmp .L1066
 8915               	.L1030:
 8916               	.LBB663:
1060:main.c        ****       if (eeprom_read_byte((void *)i) !=
 8917               		.loc 1 1060 0 is_stmt 1
 8918 2fe4 10E0      		ldi r17,0
 8919               	.LVL642:
 8920 2fe6 00E0      		ldi r16,0
 8921               	.LVL643:
 8922               	.L970:
1061:main.c        ****           pgm_read_byte(tab_eeprom_fabryczny + i))
 8923               		.loc 1 1061 0
 8924 2fe8 C801      		movw r24,r16
 8925 2fea 0E94 0000 		call eeprom_read_byte
 8926               	.LVL644:
 8927               	.LBB664:
1062:main.c        ****         bledny_zapis = TRUE;
 8928               		.loc 1 1062 0
 8929 2fee F801      		movw r30,r16
 8930 2ff0 E050      		subi r30,lo8(-(tab_eeprom_fabryczny.3646))
 8931 2ff2 F040      		sbci r31,hi8(-(tab_eeprom_fabryczny.3646))
 8932               	.LVL645:
 8933               	/* #APP */
 8934               	 ;  1062 "main.c" 1
 8935 2ff4 E491      		lpm r30, Z
 8936               		
 8937               	 ;  0 "" 2
 8938               	.LVL646:
 8939               	/* #NOAPP */
 8940               	.LBE664:
1061:main.c        ****           pgm_read_byte(tab_eeprom_fabryczny + i))
 8941               		.loc 1 1061 0
 8942 2ff6 8E17      		cp r24,r30
 8943 2ff8 01F0      		breq .L971
1063:main.c        ****     }
 8944               		.loc 1 1063 0
 8945 2ffa FF24      		clr r15
 8946 2ffc FA94      		dec r15
 8947               	.LVL647:
 8948               	.L971:
1060:main.c        ****       if (eeprom_read_byte((void *)i) !=
 8949               		.loc 1 1060 0 discriminator 2
 8950 2ffe 0F5F      		subi r16,-1
 8951 3000 1F4F      		sbci r17,-1
 8952               	.LVL648:
 8953 3002 0630      		cpi r16,6
 8954 3004 1105      		cpc r17,__zero_reg__
 8955 3006 01F4      		brne .L970
 8956               	.LBE663:
 8957               	.LBB665:
1065:main.c        ****          i < EEPROM_NUMER_TELEFONU_BRAMA_0 +
 8958               		.loc 1 1065 0
 8959 3008 08E0      		ldi r16,lo8(8)
 8960 300a 10E0      		ldi r17,0
 8961               	.LVL649:
 8962               	.L973:
1070:main.c        ****         bledny_zapis = TRUE;
 8963               		.loc 1 1070 0
 8964 300c C801      		movw r24,r16
 8965 300e 0E94 0000 		call eeprom_read_byte
 8966               	.LVL650:
 8967 3012 8F3F      		cpi r24,lo8(-1)
 8968 3014 01F4      		brne .L972
1069:main.c        ****       if (eeprom_read_byte((void *)i) != 0xff) {
 8969               		.loc 1 1069 0
 8970 3016 0F5F      		subi r16,-1
 8971 3018 1F4F      		sbci r17,-1
 8972               	.LVL651:
1065:main.c        ****          i < EEPROM_NUMER_TELEFONU_BRAMA_0 +
 8973               		.loc 1 1065 0
 8974 301a 083A      		cpi r16,-88
 8975 301c 8FE0      		ldi r24,15
 8976 301e 1807      		cpc r17,r24
 8977 3020 01F4      		brne .L973
 8978               	.LBE665:
1075:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
 8979               		.loc 1 1075 0
 8980 3022 FF20      		tst r15
 8981 3024 01F0      		breq .L974
 8982               	.L972:
 8983               	.LVL652:
1076:main.c        ****       break;
 8984               		.loc 1 1076 0
 8985 3026 83E0      		ldi r24,lo8(3)
 8986 3028 00C0      		rjmp .L1066
 8987               	.LVL653:
 8988               	.L974:
1079:main.c        ****     ustaw_stan_led(FALSE); // Wylacz diode po zakonczeniu resetu
 8989               		.loc 1 1079 0
 8990 302a 0E94 0000 		call inicjalizuj_parametry_modulu
 8991               	.LVL654:
1080:main.c        ****     break;
 8992               		.loc 1 1080 0
 8993 302e 409A      		sbi 0x8,0
 8994 3030 00C0      		rjmp .L1065
 8995               	.LVL655:
 8996               	.L955:
 8997               	.LBE662:
 8998               	.LBB666:
1084:main.c        **** 
 8999               		.loc 1 1084 0
 9000 3032 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 9001 3036 8111      		cpse r24,__zero_reg__
 9002 3038 00C0      		rjmp .L975
1084:main.c        **** 
 9003               		.loc 1 1084 0 is_stmt 0 discriminator 2
 9004 303a 8091 0000 		lds r24,liczba_znakow_do_zapisu
 9005 303e 8111      		cpse r24,__zero_reg__
 9006 3040 00C0      		rjmp .L975
1084:main.c        **** 
 9007               		.loc 1 1084 0 discriminator 4
 9008 3042 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 9009 3046 8111      		cpse r24,__zero_reg__
 9010 3048 00C0      		rjmp .L975
1084:main.c        **** 
 9011               		.loc 1 1084 0 discriminator 6
 9012 304a F99B      		sbis 0x1f,1
 9013 304c 00C0      		rjmp .L976
 9014               	.L975:
1084:main.c        **** 
 9015               		.loc 1 1084 0 discriminator 7
 9016 304e 84E8      		ldi r24,lo8(-124)
 9017 3050 00C0      		rjmp .L1066
 9018               	.L976:
1086:main.c        ****       // Poza dozwolonym czasem - ignoruj
 9019               		.loc 1 1086 0 is_stmt 1
 9020 3052 D090 0000 		lds r13,blokada_sterowania_czasowa
 9021 3056 D110      		cpse r13,__zero_reg__
 9022 3058 00C0      		rjmp .L1065
1094:main.c        **** 
 9023               		.loc 1 1094 0
 9024 305a 8E01      		movw r16,r28
 9025 305c 0B5E      		subi r16,-21
 9026 305e 1F4F      		sbci r17,-1
 9027 3060 60E0      		ldi r22,lo8(numer_telefonu_ktory_dzwoni)
 9028 3062 70E0      		ldi r23,hi8(numer_telefonu_ktory_dzwoni)
 9029 3064 C801      		movw r24,r16
 9030 3066 0E94 0000 		call strcpy
 9031               	.LVL656:
1098:main.c        ****         &bufor_eeprom[0]);
 9032               		.loc 1 1098 0
 9033 306a F801      		movw r30,r16
 9034               		0:
 9035 306c 0190      		ld __tmp_reg__,Z+
 9036 306e 0020      		tst __tmp_reg__
 9037 3070 01F4      		brne 0b
 9038 3072 BF01      		movw r22,r30
 9039 3074 6150      		subi r22,1
 9040 3076 7109      		sbc r23,__zero_reg__
1097:main.c        ****         &numer_lokalny[0], &numer_lokalny[strlen((char *)numer_lokalny)],
 9041               		.loc 1 1097 0
 9042 3078 40E0      		ldi r20,lo8(bufor_eeprom)
 9043 307a 50E0      		ldi r21,hi8(bufor_eeprom)
 9044 307c C801      		movw r24,r16
 9045 307e 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9046               	.LVL657:
1103:main.c        ****       // Tylko w trybie prywatnym sprawdzamy listę
 9047               		.loc 1 1103 0
 9048 3082 8091 0000 		lds r24,tryb_pracy
 9049 3086 8130      		cpi r24,lo8(1)
 9050 3088 01F0      		breq .L980
 9051 308a 38E0      		ldi r19,lo8(8)
 9052 308c E32E      		mov r14,r19
 9053 308e F12C      		mov r15,__zero_reg__
 9054               	.L981:
 9055               	.LBB667:
1107:main.c        ****                 &bufor_eeprom[0],
 9056               		.loc 1 1107 0
 9057 3090 B701      		movw r22,r14
 9058 3092 80E0      		ldi r24,lo8(bufor_eeprom)
 9059 3094 90E0      		ldi r25,hi8(bufor_eeprom)
 9060 3096 0E94 0000 		call porownaj_numer_telefonu_blok
 9061               	.LVL658:
 9062 309a 8111      		cpse r24,__zero_reg__
 9063 309c 00C0      		rjmp .L1032
 9064               	.LVL659:
 9065 309e F5E0      		ldi r31,5
 9066 30a0 EF0E      		add r14,r31
 9067 30a2 F11C      		adc r15,__zero_reg__
1105:main.c        ****            nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 9068               		.loc 1 1105 0
 9069 30a4 28EA      		ldi r18,-88
 9070 30a6 E216      		cp r14,r18
 9071 30a8 2FE0      		ldi r18,15
 9072 30aa F206      		cpc r15,r18
 9073 30ac 01F4      		brne .L981
 9074               	.L980:
 9075               	.LVL660:
 9076               	.LBE667:
1118:main.c        ****       wyciagnij_ostatnie_cyfry(numer_lokalny, numer_skrocony, 9);
 9077               		.loc 1 1118 0
 9078 30ae 8091 0000 		lds r24,skryba_wlaczona
 9079 30b2 8823      		tst r24
 9080 30b4 01F0      		breq .L982
1118:main.c        ****       wyciagnij_ostatnie_cyfry(numer_lokalny, numer_skrocony, 9);
 9081               		.loc 1 1118 0 is_stmt 0 discriminator 1
 9082 30b6 DD20      		tst r13
 9083 30b8 01F4      		brne .+2
 9084 30ba 00C0      		rjmp .L983
 9085               	.L987:
 9086 30bc DD24      		clr r13
 9087 30be DA94      		dec r13
 9088               	.LVL661:
 9089               	.L982:
1141:main.c        ****                          ADRES_EEPROM_DEBUG_SKRYBA_2); // DEBUG
 9090               		.loc 1 1141 0 is_stmt 1
 9091 30c0 81E0      		ldi r24,lo8(1)
 9092 30c2 9091 0000 		lds r25,skryba_wlaczona
 9093 30c6 9111      		cpse r25,__zero_reg__
 9094 30c8 00C0      		rjmp .L989
 9095 30ca 80E0      		ldi r24,0
 9096               	.L989:
 9097 30cc 61EF      		ldi r22,lo8(-15)
 9098 30ce 7FE0      		ldi r23,lo8(15)
 9099 30d0 0E94 0000 		call zapisz_znak_w_eeprom
 9100               	.LVL662:
1143:main.c        ****                          ADRES_EEPROM_DEBUG_SKRYBA_3); // DEBUG
 9101               		.loc 1 1143 0
 9102 30d4 81E0      		ldi r24,lo8(1)
 9103 30d6 D110      		cpse r13,__zero_reg__
 9104 30d8 80E0      		ldi r24,0
 9105               	.L990:
 9106 30da 62EF      		ldi r22,lo8(-14)
 9107 30dc 7FE0      		ldi r23,lo8(15)
 9108 30de 0E94 0000 		call zapisz_znak_w_eeprom
 9109               	.LVL663:
1146:main.c        ****       uchar len_full = strlen((char *)numer_lokalny);
 9110               		.loc 1 1146 0
 9111 30e2 8091 0000 		lds r24,skryba_wlaczona
 9112 30e6 8823      		tst r24
 9113 30e8 01F0      		breq .L992
1146:main.c        ****       uchar len_full = strlen((char *)numer_lokalny);
 9114               		.loc 1 1146 0 is_stmt 0 discriminator 1
 9115 30ea D110      		cpse r13,__zero_reg__
 9116 30ec 00C0      		rjmp .L992
 9117               	.LBB668:
1147:main.c        **** 
 9118               		.loc 1 1147 0 is_stmt 1
 9119 30ee F801      		movw r30,r16
 9120               		0:
 9121 30f0 0190      		ld __tmp_reg__,Z+
 9122 30f2 0020      		tst __tmp_reg__
 9123 30f4 01F4      		brne 0b
 9124 30f6 3197      		sbiw r30,1
 9125 30f8 CF01      		movw r24,r30
 9126 30fa 801B      		sub r24,r16
 9127 30fc 910B      		sbc r25,r17
 9128 30fe 182F      		mov r17,r24
 9129               	.LVL664:
1150:main.c        **** 
 9130               		.loc 1 1150 0
 9131 3100 64EF      		ldi r22,lo8(-12)
 9132 3102 7FE0      		ldi r23,lo8(15)
 9133 3104 0E94 0000 		call zapisz_znak_w_eeprom
 9134               	.LVL665:
1152:main.c        ****         // Skopiuj skrócony numer do numer_telefonu_skryba
 9135               		.loc 1 1152 0
 9136 3108 1330      		cpi r17,lo8(3)
 9137 310a 00F0      		brlo .L992
1154:main.c        **** 
 9138               		.loc 1 1154 0
 9139 310c BE01      		movw r22,r28
 9140 310e 6F5F      		subi r22,-1
 9141 3110 7F4F      		sbci r23,-1
 9142 3112 80E0      		ldi r24,lo8(numer_telefonu_skryba)
 9143 3114 90E0      		ldi r25,hi8(numer_telefonu_skryba)
 9144 3116 0E94 0000 		call strcpy
 9145               	.LVL666:
1157:main.c        ****           zapisz_znak_w_eeprom(
 9146               		.loc 1 1157 0
 9147 311a 80E0      		ldi r24,lo8(numer_telefonu_skryba)
 9148 311c 90E0      		ldi r25,hi8(numer_telefonu_skryba)
 9149 311e FC01      		movw r30,r24
 9150               		0:
 9151 3120 0190      		ld __tmp_reg__,Z+
 9152 3122 0020      		tst __tmp_reg__
 9153 3124 01F4      		brne 0b
 9154 3126 CF01      		movw r24,r30
 9155 3128 8050      		subi r24,lo8(numer_telefonu_skryba+1)
 9156 312a 9040      		sbci r25,hi8(numer_telefonu_skryba+1)
 9157 312c 0397      		sbiw r24,3
 9158 312e 00F0      		brlo .L992
1158:main.c        ****               1, ADRES_EEPROM_DEBUG_SKRYBA_4); // DEBUG: komenda dodana
 9159               		.loc 1 1158 0
 9160 3130 63EF      		ldi r22,lo8(-13)
 9161 3132 7FE0      		ldi r23,lo8(15)
 9162 3134 81E0      		ldi r24,lo8(1)
 9163 3136 0E94 0000 		call zapisz_znak_w_eeprom
 9164               	.LVL667:
1162:main.c        ****         }
 9165               		.loc 1 1162 0
 9166 313a 86E8      		ldi r24,lo8(-122)
 9167 313c 0E94 0000 		call dodaj_komende
 9168               	.LVL668:
 9169               	.L992:
 9170               	.LBE668:
1168:main.c        ****       if (tryb_pracy == 1) {
 9171               		.loc 1 1168 0
 9172 3140 8091 0000 		lds r24,tryb_clip
 9173 3144 8823      		tst r24
 9174 3146 01F4      		brne .+2
 9175 3148 00C0      		rjmp .L1065
1169:main.c        ****         // Tryb publiczny - otwórz dla każdego
 9176               		.loc 1 1169 0
 9177 314a 8091 0000 		lds r24,tryb_pracy
 9178 314e 8130      		cpi r24,lo8(1)
 9179 3150 01F0      		breq .+2
 9180 3152 00C0      		rjmp .L995
 9181               	.L996:
1171:main.c        ****       } else if (znaleziono) {
 9182               		.loc 1 1171 0
 9183 3154 0E94 0000 		call ustaw_wyjscie_clip
 9184               	.LVL669:
 9185 3158 00C0      		rjmp .L1065
 9186               	.LVL670:
 9187               	.L1032:
 9188               	.LBB669:
1110:main.c        ****           break;
 9189               		.loc 1 1110 0
 9190 315a DD24      		clr r13
 9191 315c DA94      		dec r13
 9192 315e 00C0      		rjmp .L980
 9193               	.LVL671:
 9194               	.L983:
 9195               	.LBE669:
 9196               	.LBB670:
 9197               	.LBB671:
 857:main.c        **** 
 9198               		.loc 1 857 0
 9199 3160 F801      		movw r30,r16
 9200               		0:
 9201 3162 0190      		ld __tmp_reg__,Z+
 9202 3164 0020      		tst __tmp_reg__
 9203 3166 01F4      		brne 0b
 9204 3168 3197      		sbiw r30,1
 9205 316a E01B      		sub r30,r16
 9206 316c F10B      		sbc r31,r17
 9207               	.LVL672:
 9208 316e CE01      		movw r24,r28
 9209 3170 0196      		adiw r24,1
 9210 3172 7C01      		movw r14,r24
 859:main.c        ****     // Take last max_digits
 9211               		.loc 1 859 0
 9212 3174 EA30      		cpi r30,lo8(10)
 9213 3176 00F0      		brlo .L984
 861:main.c        ****   } else {
 9214               		.loc 1 861 0
 9215 3178 E950      		subi r30,9
 9216 317a FF0B      		sbc r31,r31
 9217               	.LVL673:
 9218 317c B801      		movw r22,r16
 9219 317e 6E0F      		add r22,r30
 9220 3180 7F1F      		adc r23,r31
 9221               	.L1063:
 864:main.c        ****   }
 9222               		.loc 1 864 0
 9223 3182 0E94 0000 		call strcpy
 9224               	.LVL674:
 9225               	.LBE671:
 9226               	.LBE670:
1123:main.c        ****           &bufor_eeprom[0]);
 9227               		.loc 1 1123 0
 9228 3186 F701      		movw r30,r14
 9229               		0:
 9230 3188 0190      		ld __tmp_reg__,Z+
 9231 318a 0020      		tst __tmp_reg__
 9232 318c 01F4      		brne 0b
 9233 318e BF01      		movw r22,r30
 9234 3190 6150      		subi r22,1
 9235 3192 7109      		sbc r23,__zero_reg__
1122:main.c        ****           &numer_skrocony[0], &numer_skrocony[strlen((char *)numer_skrocony)],
 9236               		.loc 1 1122 0
 9237 3194 40E0      		ldi r20,lo8(bufor_eeprom)
 9238 3196 50E0      		ldi r21,hi8(bufor_eeprom)
 9239 3198 C701      		movw r24,r14
 9240 319a 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9241               	.LVL675:
1126:main.c        ****         for (uint nr_uzyt_clip = 0;
 9242               		.loc 1 1126 0
 9243 319e 8091 0000 		lds r24,tryb_pracy
 9244 31a2 8130      		cpi r24,lo8(1)
 9245 31a4 01F4      		brne .+2
 9246 31a6 00C0      		rjmp .L982
 9247 31a8 28E0      		ldi r18,lo8(8)
 9248 31aa E22E      		mov r14,r18
 9249 31ac F12C      		mov r15,__zero_reg__
 9250               	.L986:
 9251               	.LBB673:
1130:main.c        ****                   &bufor_eeprom[0],
 9252               		.loc 1 1130 0
 9253 31ae B701      		movw r22,r14
 9254 31b0 80E0      		ldi r24,lo8(bufor_eeprom)
 9255 31b2 90E0      		ldi r25,hi8(bufor_eeprom)
 9256 31b4 0E94 0000 		call porownaj_numer_telefonu_blok
 9257               	.LVL676:
 9258 31b8 8111      		cpse r24,__zero_reg__
 9259 31ba 00C0      		rjmp .L987
 9260               	.LVL677:
 9261 31bc F5E0      		ldi r31,5
 9262 31be EF0E      		add r14,r31
 9263 31c0 F11C      		adc r15,__zero_reg__
1127:main.c        ****              nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 9264               		.loc 1 1127 0
 9265 31c2 28EA      		ldi r18,-88
 9266 31c4 E216      		cp r14,r18
 9267 31c6 2FE0      		ldi r18,15
 9268 31c8 F206      		cpc r15,r18
 9269 31ca 01F4      		brne .L986
 9270 31cc 00C0      		rjmp .L982
 9271               	.LVL678:
 9272               	.L984:
 9273               	.LBE673:
 9274               	.LBB674:
 9275               	.LBB672:
 864:main.c        ****   }
 9276               		.loc 1 864 0
 9277 31ce B801      		movw r22,r16
 9278 31d0 00C0      		rjmp .L1063
 9279               	.LVL679:
 9280               	.L995:
 9281               	.LBE672:
 9282               	.LBE674:
1172:main.c        ****         // Tryb prywatny - otwórz tylko dla znalezionych
 9283               		.loc 1 1172 0
 9284 31d2 DD20      		tst r13
 9285 31d4 01F4      		brne .+2
 9286 31d6 00C0      		rjmp .L1065
 9287 31d8 00C0      		rjmp .L996
 9288               	.LVL680:
 9289               	.L961:
 9290               	.LBE666:
 9291               	.LBB675:
1182:main.c        **** 
 9292               		.loc 1 1182 0
 9293 31da 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 9294 31de 8111      		cpse r24,__zero_reg__
 9295 31e0 00C0      		rjmp .L997
1182:main.c        **** 
 9296               		.loc 1 1182 0 is_stmt 0 discriminator 2
 9297 31e2 8091 0000 		lds r24,liczba_znakow_do_zapisu
 9298 31e6 8111      		cpse r24,__zero_reg__
 9299 31e8 00C0      		rjmp .L997
1182:main.c        **** 
 9300               		.loc 1 1182 0 discriminator 4
 9301 31ea 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 9302 31ee 8111      		cpse r24,__zero_reg__
 9303 31f0 00C0      		rjmp .L997
1182:main.c        **** 
 9304               		.loc 1 1182 0 discriminator 6
 9305 31f2 F99B      		sbis 0x1f,1
 9306 31f4 00C0      		rjmp .L998
 9307               	.L997:
1182:main.c        **** 
 9308               		.loc 1 1182 0 discriminator 7
 9309 31f6 85E8      		ldi r24,lo8(-123)
 9310 31f8 00C0      		rjmp .L1066
 9311               	.L998:
1185:main.c        ****       return TRUE; // Duplicate found, abort
 9312               		.loc 1 1185 0 is_stmt 1
 9313 31fa 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 9314 31fc 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 9315 31fe 0E94 0000 		call czy_numer_istnieje
 9316               	.LVL681:
 9317 3202 8111      		cpse r24,__zero_reg__
 9318 3204 00C0      		rjmp .L1065
1194:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
 9319               		.loc 1 1194 0
 9320 3206 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 9321 3208 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 9322 320a FB01      		movw r30,r22
 9323               		0:
 9324 320c 0190      		ld __tmp_reg__,Z+
 9325 320e 0020      		tst __tmp_reg__
 9326 3210 01F4      		brne 0b
 9327 3212 BF01      		movw r22,r30
 9328 3214 6150      		subi r22,1
 9329 3216 7109      		sbc r23,__zero_reg__
1192:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
 9330               		.loc 1 1192 0
 9331 3218 40E0      		ldi r20,lo8(bufor_eeprom)
 9332 321a 50E0      		ldi r21,hi8(bufor_eeprom)
 9333 321c 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 9334 321e 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 9335 3220 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9336               	.LVL682:
1201:main.c        ****     for (uint nr_uzyt_clip = 0; nr_uzyt_clip < max_pozycja; ++nr_uzyt_clip) {
 9337               		.loc 1 1201 0
 9338 3224 E090 0000 		lds r14,skryba_limit
 9339 3228 F090 0000 		lds r15,skryba_limit+1
 9340 322c FCE1      		ldi r31,28
 9341 322e EF16      		cp r14,r31
 9342 3230 F3E0      		ldi r31,3
 9343 3232 FF06      		cpc r15,r31
 9344 3234 00F0      		brlo .L1000
 9345 3236 9BE1      		ldi r25,lo8(27)
 9346 3238 E92E      		mov r14,r25
 9347 323a 93E0      		ldi r25,lo8(3)
 9348 323c F92E      		mov r15,r25
 9349               	.L1000:
 9350               	.LVL683:
 9351               	.LBB676:
1202:main.c        ****       if (not czy_aktywny_numer_telefonu_brama(nr_uzyt_clip)) {
 9352               		.loc 1 1202 0
 9353 323e 08E0      		ldi r16,lo8(8)
 9354 3240 10E0      		ldi r17,0
 9355 3242 D12C      		mov r13,__zero_reg__
 9356 3244 C12C      		mov r12,__zero_reg__
 9357               	.LVL684:
 9358               	.L1001:
1202:main.c        ****       if (not czy_aktywny_numer_telefonu_brama(nr_uzyt_clip)) {
 9359               		.loc 1 1202 0 is_stmt 0 discriminator 1
 9360 3246 CE14      		cp r12,r14
 9361 3248 DF04      		cpc r13,r15
 9362 324a 01F4      		brne .+2
 9363 324c 00C0      		rjmp .L1065
1203:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
 9364               		.loc 1 1203 0 is_stmt 1
 9365 324e C801      		movw r24,r16
 9366 3250 0E94 0000 		call eeprom_read_byte
 9367               	.LVL685:
 9368 3254 9801      		movw r18,r16
 9369 3256 2B5F      		subi r18,-5
 9370 3258 3F4F      		sbci r19,-1
 9371 325a 8F3F      		cpi r24,lo8(-1)
 9372 325c 01F4      		brne .L1002
1204:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
 9373               		.loc 1 1204 0
 9374 325e 65E0      		ldi r22,lo8(5)
 9375 3260 C801      		movw r24,r16
 9376 3262 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 9377               	.LVL686:
 9378               	.LBE676:
1213:main.c        ****       // Policz aktywnych uzytkownikow
 9379               		.loc 1 1213 0
 9380 3266 8091 0000 		lds r24,skryba_wlaczona
 9381 326a 08E0      		ldi r16,lo8(8)
 9382 326c 10E0      		ldi r17,0
 9383               	.LBB677:
1215:main.c        ****       for (uint i = 0; i < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++i) {
 9384               		.loc 1 1215 0
 9385 326e F12C      		mov r15,__zero_reg__
 9386 3270 E12C      		mov r14,__zero_reg__
 9387               	.LVL687:
 9388               	.LBE677:
1213:main.c        ****       // Policz aktywnych uzytkownikow
 9389               		.loc 1 1213 0
 9390 3272 8823      		tst r24
 9391 3274 01F4      		brne .+2
 9392 3276 00C0      		rjmp .L1065
 9393               	.L1003:
 9394               	.LVL688:
 9395               	.LBB679:
 9396               	.LBB678:
1217:main.c        ****           ++aktywne_numery;
 9397               		.loc 1 1217 0
 9398 3278 C801      		movw r24,r16
 9399 327a 0E94 0000 		call eeprom_read_byte
 9400               	.LVL689:
 9401 327e 8F3F      		cpi r24,lo8(-1)
 9402 3280 01F0      		breq .L1006
1218:main.c        ****         }
 9403               		.loc 1 1218 0
 9404 3282 9FEF      		ldi r25,-1
 9405 3284 E91A      		sub r14,r25
 9406 3286 F90A      		sbc r15,r25
 9407               	.LVL690:
 9408               	.L1006:
 9409 3288 0B5F      		subi r16,-5
 9410 328a 1F4F      		sbci r17,-1
1216:main.c        ****         if (czy_aktywny_numer_telefonu_brama(i)) {
 9411               		.loc 1 1216 0 discriminator 2
 9412 328c 083A      		cpi r16,-88
 9413 328e EFE0      		ldi r30,15
 9414 3290 1E07      		cpc r17,r30
 9415 3292 01F4      		brne .L1003
 9416               	.LVL691:
 9417               	.L1070:
 9418               	.LBE678:
 9419               	.LBE679:
 9420               	.LBE675:
 9421               	.LBB681:
 9422               	.LBB682:
1279:main.c        ****         skryba_wlaczona = FALSE;
 9423               		.loc 1 1279 0
 9424 3294 8091 0000 		lds r24,skryba_limit
 9425 3298 9091 0000 		lds r25,skryba_limit+1
 9426 329c E816      		cp r14,r24
 9427 329e F906      		cpc r15,r25
 9428 32a0 00F4      		brsh .+2
 9429 32a2 00C0      		rjmp .L1065
1280:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_SKRYBA);
 9430               		.loc 1 1280 0
 9431 32a4 1092 0000 		sts skryba_wlaczona,__zero_reg__
1281:main.c        **** 
 9432               		.loc 1 1281 0
 9433 32a8 69EF      		ldi r22,lo8(-7)
 9434 32aa 7FE0      		ldi r23,lo8(15)
 9435 32ac 80E0      		ldi r24,0
 9436 32ae 0E94 0000 		call zapisz_znak_w_eeprom
 9437               	.LVL692:
1283:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_TRYB_PRACY);
 9438               		.loc 1 1283 0
 9439 32b2 1092 0000 		sts tryb_pracy,__zero_reg__
1284:main.c        ****       }
 9440               		.loc 1 1284 0
 9441 32b6 6EEF      		ldi r22,lo8(-2)
 9442 32b8 7FE0      		ldi r23,lo8(15)
 9443 32ba 80E0      		ldi r24,0
 9444 32bc 0E94 0000 		call zapisz_znak_w_eeprom
 9445               	.LVL693:
 9446 32c0 00C0      		rjmp .L1065
 9447               	.LVL694:
 9448               	.L1002:
 9449               	.LBE682:
 9450               	.LBE681:
 9451               	.LBB688:
 9452               	.LBB680:
1202:main.c        ****       if (not czy_aktywny_numer_telefonu_brama(nr_uzyt_clip)) {
 9453               		.loc 1 1202 0 discriminator 2
 9454 32c2 8FEF      		ldi r24,-1
 9455 32c4 C81A      		sub r12,r24
 9456 32c6 D80A      		sbc r13,r24
 9457               	.LVL695:
 9458 32c8 8901      		movw r16,r18
 9459 32ca 00C0      		rjmp .L1001
 9460               	.LVL696:
 9461               	.L960:
 9462               	.LBE680:
 9463               	.LBE688:
 9464               	.LBB689:
1234:main.c        **** 
 9465               		.loc 1 1234 0
 9466 32cc 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 9467 32d0 8111      		cpse r24,__zero_reg__
 9468 32d2 00C0      		rjmp .L1007
1234:main.c        **** 
 9469               		.loc 1 1234 0 is_stmt 0 discriminator 2
 9470 32d4 8091 0000 		lds r24,liczba_znakow_do_zapisu
 9471 32d8 8111      		cpse r24,__zero_reg__
 9472 32da 00C0      		rjmp .L1007
1234:main.c        **** 
 9473               		.loc 1 1234 0 discriminator 4
 9474 32dc 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 9475 32e0 8111      		cpse r24,__zero_reg__
 9476 32e2 00C0      		rjmp .L1007
1234:main.c        **** 
 9477               		.loc 1 1234 0 discriminator 6
 9478 32e4 F99B      		sbis 0x1f,1
 9479 32e6 00C0      		rjmp .L1008
 9480               	.L1007:
1234:main.c        **** 
 9481               		.loc 1 1234 0 discriminator 7
 9482 32e8 86E8      		ldi r24,lo8(-122)
 9483 32ea 00C0      		rjmp .L1066
 9484               	.L1008:
1242:main.c        ****         bufor_skryba);
 9485               		.loc 1 1242 0 is_stmt 1
 9486 32ec 60E0      		ldi r22,lo8(numer_telefonu_skryba)
 9487 32ee 70E0      		ldi r23,hi8(numer_telefonu_skryba)
 9488 32f0 FB01      		movw r30,r22
 9489               		0:
 9490 32f2 0190      		ld __tmp_reg__,Z+
 9491 32f4 0020      		tst __tmp_reg__
 9492 32f6 01F4      		brne 0b
 9493 32f8 BF01      		movw r22,r30
 9494 32fa 6150      		subi r22,1
 9495 32fc 7109      		sbc r23,__zero_reg__
1240:main.c        ****         &numer_telefonu_skryba[0],
 9496               		.loc 1 1240 0
 9497 32fe AE01      		movw r20,r28
 9498 3300 4F5F      		subi r20,-1
 9499 3302 5F4F      		sbci r21,-1
 9500 3304 80E0      		ldi r24,lo8(numer_telefonu_skryba)
 9501 3306 90E0      		ldi r25,hi8(numer_telefonu_skryba)
 9502 3308 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9503               	.LVL697:
1248:main.c        ****       return TRUE; // Duplicate found, abort
 9504               		.loc 1 1248 0
 9505 330c 80E0      		ldi r24,lo8(numer_telefonu_skryba)
 9506 330e 90E0      		ldi r25,hi8(numer_telefonu_skryba)
 9507 3310 0E94 0000 		call czy_numer_istnieje
 9508               	.LVL698:
 9509 3314 8111      		cpse r24,__zero_reg__
 9510 3316 00C0      		rjmp .L1065
1253:main.c        **** 
 9511               		.loc 1 1253 0
 9512 3318 85E0      		ldi r24,lo8(5)
 9513 331a FE01      		movw r30,r28
 9514 331c 3196      		adiw r30,1
 9515 331e A0E0      		ldi r26,lo8(bufor_eeprom)
 9516 3320 B0E0      		ldi r27,hi8(bufor_eeprom)
 9517               		0:
 9518 3322 0190      		ld r0,Z+
 9519 3324 0D92      		st X+,r0
 9520 3326 8A95      		dec r24
 9521 3328 01F4      		brne 0b
 9522               	.LVL699:
 9523 332a 08E0      		ldi r16,lo8(8)
 9524 332c 10E0      		ldi r17,0
 9525               	.LVL700:
 9526               	.L1013:
 9527               	.LBB684:
1258:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
 9528               		.loc 1 1258 0
 9529 332e C801      		movw r24,r16
 9530 3330 0E94 0000 		call eeprom_read_byte
 9531               	.LVL701:
 9532 3334 8F3F      		cpi r24,lo8(-1)
 9533 3336 01F4      		brne .L1011
1259:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
 9534               		.loc 1 1259 0
 9535 3338 65E0      		ldi r22,lo8(5)
 9536 333a C801      		movw r24,r16
 9537 333c 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 9538               	.LVL702:
 9539               	.LBE684:
1269:main.c        ****       // Policz aktywnych uzytkownikow
 9540               		.loc 1 1269 0
 9541 3340 8091 0000 		lds r24,skryba_wlaczona
 9542 3344 08E0      		ldi r16,lo8(8)
 9543 3346 10E0      		ldi r17,0
 9544               	.LBB685:
1271:main.c        ****       for (uint i = 0; i < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++i) {
 9545               		.loc 1 1271 0
 9546 3348 F12C      		mov r15,__zero_reg__
 9547 334a E12C      		mov r14,__zero_reg__
 9548               	.LBE685:
1269:main.c        ****       // Policz aktywnych uzytkownikow
 9549               		.loc 1 1269 0
 9550 334c 8823      		tst r24
 9551 334e 01F4      		brne .+2
 9552 3350 00C0      		rjmp .L1065
 9553               	.L1012:
 9554               	.LVL703:
 9555               	.LBB686:
 9556               	.LBB683:
1273:main.c        ****           ++aktywne_numery;
 9557               		.loc 1 1273 0
 9558 3352 C801      		movw r24,r16
 9559 3354 0E94 0000 		call eeprom_read_byte
 9560               	.LVL704:
 9561 3358 8F3F      		cpi r24,lo8(-1)
 9562 335a 01F0      		breq .L1015
1274:main.c        ****         }
 9563               		.loc 1 1274 0
 9564 335c 2FEF      		ldi r18,-1
 9565 335e E21A      		sub r14,r18
 9566 3360 F20A      		sbc r15,r18
 9567               	.LVL705:
 9568               	.L1015:
 9569 3362 0B5F      		subi r16,-5
 9570 3364 1F4F      		sbci r17,-1
1272:main.c        ****         if (czy_aktywny_numer_telefonu_brama(i)) {
 9571               		.loc 1 1272 0 discriminator 2
 9572 3366 083A      		cpi r16,-88
 9573 3368 8FE0      		ldi r24,15
 9574 336a 1807      		cpc r17,r24
 9575 336c 01F4      		brne .L1012
 9576 336e 00C0      		rjmp .L1070
 9577               	.LVL706:
 9578               	.L1011:
 9579 3370 0B5F      		subi r16,-5
 9580 3372 1F4F      		sbci r17,-1
 9581               	.LBE683:
 9582               	.LBE686:
 9583               	.LBB687:
1256:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 9584               		.loc 1 1256 0
 9585 3374 083A      		cpi r16,-88
 9586 3376 FFE0      		ldi r31,15
 9587 3378 1F07      		cpc r17,r31
 9588 337a 01F4      		brne .L1013
 9589 337c 00C0      		rjmp .L1065
 9590               	.LVL707:
 9591               	.L962:
 9592               	.LBE687:
 9593               	.LBE689:
 9594               	.LBB690:
1290:main.c        **** 
 9595               		.loc 1 1290 0
 9596 337e 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 9597 3382 8111      		cpse r24,__zero_reg__
 9598 3384 00C0      		rjmp .L1016
1290:main.c        **** 
 9599               		.loc 1 1290 0 is_stmt 0 discriminator 2
 9600 3386 8091 0000 		lds r24,liczba_znakow_do_zapisu
 9601 338a 8111      		cpse r24,__zero_reg__
 9602 338c 00C0      		rjmp .L1016
1290:main.c        **** 
 9603               		.loc 1 1290 0 discriminator 4
 9604 338e 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 9605 3392 8111      		cpse r24,__zero_reg__
 9606 3394 00C0      		rjmp .L1016
1290:main.c        **** 
 9607               		.loc 1 1290 0 discriminator 6
 9608 3396 F99B      		sbis 0x1f,1
 9609 3398 00C0      		rjmp .L1017
 9610               	.L1016:
1290:main.c        **** 
 9611               		.loc 1 1290 0 discriminator 7
 9612 339a 87E8      		ldi r24,lo8(-121)
 9613 339c 00C0      		rjmp .L1066
 9614               	.L1017:
1298:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
 9615               		.loc 1 1298 0 is_stmt 1
 9616 339e 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 9617 33a0 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 9618 33a2 FB01      		movw r30,r22
 9619               		0:
 9620 33a4 0190      		ld __tmp_reg__,Z+
 9621 33a6 0020      		tst __tmp_reg__
 9622 33a8 01F4      		brne 0b
 9623 33aa BF01      		movw r22,r30
 9624 33ac 6150      		subi r22,1
 9625 33ae 7109      		sbc r23,__zero_reg__
1296:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
 9626               		.loc 1 1296 0
 9627 33b0 AE01      		movw r20,r28
 9628 33b2 4F5F      		subi r20,-1
 9629 33b4 5F4F      		sbci r21,-1
 9630 33b6 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 9631 33b8 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 9632 33ba 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9633               	.LVL708:
1305:main.c        ****       // Numer juz istnieje - wyslij komunikat
 9634               		.loc 1 1305 0
 9635 33be 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 9636 33c0 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 9637 33c2 0E94 0000 		call czy_numer_istnieje
 9638               	.LVL709:
 9639 33c6 D82E      		mov r13,r24
 9640 33c8 8823      		tst r24
 9641 33ca 01F0      		breq .L1018
1307:main.c        ****              (char *)numer_telefonu_odebranego_smsa);
 9642               		.loc 1 1307 0
 9643 33cc 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 9644 33ce 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 9645 33d0 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 9646 33d2 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 9647 33d4 0E94 0000 		call strcpy
 9648               	.LVL710:
1309:main.c        ****                PSTR("Numer juz istnieje w systemie"));
 9649               		.loc 1 1309 0
 9650 33d8 60E0      		ldi r22,lo8(__c.3697)
 9651 33da 70E0      		ldi r23,hi8(__c.3697)
 9652               	.LVL711:
 9653               	.L1064:
1340:main.c        ****                PSTR("Brak wolnych pozycji Super User (795-800)"));
 9654               		.loc 1 1340 0
 9655 33dc 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 9656 33de 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 9657 33e0 0E94 0000 		call strcpy_P
 9658               	.LVL712:
 9659 33e4 00C0      		rjmp .L1024
 9660               	.LVL713:
 9661               	.L1018:
1316:main.c        **** 
 9662               		.loc 1 1316 0
 9663 33e6 85E0      		ldi r24,lo8(5)
 9664 33e8 FE01      		movw r30,r28
 9665 33ea 3196      		adiw r30,1
 9666 33ec A0E0      		ldi r26,lo8(bufor_eeprom)
 9667 33ee B0E0      		ldi r27,hi8(bufor_eeprom)
 9668               		0:
 9669 33f0 0190      		ld r0,Z+
 9670 33f2 0D92      		st X+,r0
 9671 33f4 8A95      		dec r24
 9672 33f6 01F4      		brne 0b
 9673               	.LVL714:
 9674 33f8 8AE8      		ldi r24,lo8(-118)
 9675 33fa E82E      		mov r14,r24
 9676 33fc 8FE0      		ldi r24,lo8(15)
 9677 33fe F82E      		mov r15,r24
 9678               	.LBB691:
1321:main.c        ****          ++nr_uzyt) {
 9679               		.loc 1 1321 0
 9680 3400 0AE1      		ldi r16,lo8(26)
 9681 3402 13E0      		ldi r17,lo8(3)
 9682               	.LVL715:
 9683               	.L1022:
1323:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
 9684               		.loc 1 1323 0
 9685 3404 C701      		movw r24,r14
 9686 3406 0E94 0000 		call eeprom_read_byte
 9687               	.LVL716:
 9688 340a 0F5F      		subi r16,-1
 9689 340c 1F4F      		sbci r17,-1
 9690               	.LVL717:
 9691 340e 8F3F      		cpi r24,lo8(-1)
 9692 3410 01F4      		brne .L1020
1324:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt),
 9693               		.loc 1 1324 0
 9694 3412 65E0      		ldi r22,lo8(5)
 9695 3414 C701      		movw r24,r14
 9696 3416 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 9697               	.LVL718:
1327:main.c        ****         pozycja_dodana = nr_uzyt + 1; // User-facing (1-indexed)
 9698               		.loc 1 1327 0
 9699 341a DD24      		clr r13
 9700 341c DA94      		dec r13
 9701               	.LVL719:
 9702               	.L1021:
 9703               	.LBE691:
1334:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 9704               		.loc 1 1334 0
 9705 341e 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 9706 3420 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 9707 3422 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 9708 3424 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 9709 3426 0E94 0000 		call strcpy
 9710               	.LVL720:
1336:main.c        ****       sprintf((char *)tekst_wysylanego_smsa, "Super User dodany na pozycji %u",
 9711               		.loc 1 1336 0
 9712 342a DD20      		tst r13
 9713 342c 01F0      		breq .L1023
1337:main.c        ****               pozycja_dodana);
 9714               		.loc 1 1337 0
 9715 342e 1F93      		push r17
 9716 3430 0F93      		push r16
 9717 3432 80E0      		ldi r24,lo8(.LC7)
 9718 3434 90E0      		ldi r25,hi8(.LC7)
 9719 3436 9F93      		push r25
 9720 3438 8F93      		push r24
 9721 343a 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 9722 343c 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 9723 343e 9F93      		push r25
 9724 3440 8F93      		push r24
 9725 3442 0E94 0000 		call sprintf
 9726               	.LVL721:
 9727 3446 0F90      		pop __tmp_reg__
 9728 3448 0F90      		pop __tmp_reg__
 9729 344a 0F90      		pop __tmp_reg__
 9730 344c 0F90      		pop __tmp_reg__
 9731 344e 0F90      		pop __tmp_reg__
 9732 3450 0F90      		pop __tmp_reg__
 9733               	.L1024:
1343:main.c        **** 
 9734               		.loc 1 1343 0
 9735 3452 83ED      		ldi r24,lo8(-45)
 9736 3454 00C0      		rjmp .L1066
 9737               	.LVL722:
 9738               	.L1020:
 9739 3456 F5E0      		ldi r31,5
 9740 3458 EF0E      		add r14,r31
 9741 345a F11C      		adc r15,__zero_reg__
 9742               	.LBB692:
1321:main.c        ****          ++nr_uzyt) {
 9743               		.loc 1 1321 0
 9744 345c 0032      		cpi r16,32
 9745 345e 23E0      		ldi r18,3
 9746 3460 1207      		cpc r17,r18
 9747 3462 01F4      		brne .L1022
 9748               	.LVL723:
 9749               	.LBE692:
1320:main.c        ****     for (uint nr_uzyt = 794; nr_uzyt < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 9750               		.loc 1 1320 0
 9751 3464 10E0      		ldi r17,0
 9752               	.LVL724:
 9753 3466 00E0      		ldi r16,0
 9754 3468 00C0      		rjmp .L1021
 9755               	.LVL725:
 9756               	.L1023:
1340:main.c        ****                PSTR("Brak wolnych pozycji Super User (795-800)"));
 9757               		.loc 1 1340 0
 9758 346a 60E0      		ldi r22,lo8(__c.3705)
 9759 346c 70E0      		ldi r23,hi8(__c.3705)
 9760 346e 00C0      		rjmp .L1064
 9761               	.LVL726:
 9762               	.L1026:
 9763               	.LBE690:
1350:main.c        ****                                          numer_telefonu_do_ktorego_dzwonic)],
 9764               		.loc 1 1350 0
 9765 3470 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 9766 3472 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 9767 3474 FB01      		movw r30,r22
 9768               		0:
 9769 3476 0190      		ld __tmp_reg__,Z+
 9770 3478 0020      		tst __tmp_reg__
 9771 347a 01F4      		brne 0b
 9772 347c BF01      		movw r22,r30
 9773 347e 6150      		subi r22,1
 9774 3480 7109      		sbc r23,__zero_reg__
1349:main.c        ****                                      &numer_telefonu_do_ktorego_dzwonic[strlen(
 9775               		.loc 1 1349 0
 9776 3482 40E0      		ldi r20,lo8(bufor_eeprom)
 9777 3484 50E0      		ldi r21,hi8(bufor_eeprom)
 9778 3486 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 9779 3488 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 9780 348a 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9781               	.LVL727:
 9782 348e 08E0      		ldi r16,lo8(8)
 9783 3490 10E0      		ldi r17,0
 9784               	.LVL728:
 9785               	.L1028:
 9786               	.LBB693:
1357:main.c        ****               &bufor_eeprom[0], // 1 porwnanie zajmuje ~10us, czyli 170 numerw ~
 9787               		.loc 1 1357 0
 9788 3492 B801      		movw r22,r16
 9789 3494 80E0      		ldi r24,lo8(bufor_eeprom)
 9790 3496 90E0      		ldi r25,hi8(bufor_eeprom)
 9791 3498 0E94 0000 		call porownaj_numer_telefonu_blok
 9792               	.LVL729:
 9793 349c 8823      		tst r24
 9794 349e 01F0      		breq .L1027
1361:main.c        ****         konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 9795               		.loc 1 1361 0
 9796 34a0 1092 0000 		sts numer_telefonu_do_ktorego_dzwonic,__zero_reg__
1362:main.c        ****                                          &numer_telefonu_do_ktorego_dzwonic[1],
 9797               		.loc 1 1362 0
 9798 34a4 40E0      		ldi r20,lo8(bufor_eeprom)
 9799 34a6 50E0      		ldi r21,hi8(bufor_eeprom)
 9800 34a8 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic+1)
 9801 34aa 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic+1)
 9802 34ac 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 9803 34ae 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 9804 34b0 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9805               	.LVL730:
1365:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
 9806               		.loc 1 1365 0
 9807 34b4 65E0      		ldi r22,lo8(5)
 9808 34b6 C801      		movw r24,r16
 9809 34b8 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 9810               	.LVL731:
 9811 34bc 00C0      		rjmp .L1065
 9812               	.L1027:
 9813 34be 0B5F      		subi r16,-5
 9814 34c0 1F4F      		sbci r17,-1
1355:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 9815               		.loc 1 1355 0
 9816 34c2 083A      		cpi r16,-88
 9817 34c4 FFE0      		ldi r31,15
 9818 34c6 1F07      		cpc r17,r31
 9819 34c8 01F4      		brne .L1028
 9820 34ca 00C0      		rjmp .L1065
 9821               	.LBE693:
 9822               		.cfi_endproc
 9823               	.LFE59:
 9825               	.global	wykonanie_komend
 9827               	wykonanie_komend:
 9828               	.LFB61:
1445:main.c        ****   if (wykonanie_komend_SIM900())
 9829               		.loc 1 1445 0
 9830               		.cfi_startproc
 9831               	/* prologue: function */
 9832               	/* frame size = 0 */
 9833               	/* stack size = 0 */
 9834               	.L__stack_usage = 0
1446:main.c        ****     ;
 9835               		.loc 1 1446 0
 9836 34cc 0E94 0000 		call wykonanie_komend_SIM900
 9837               	.LVL732:
 9838 34d0 8111      		cpse r24,__zero_reg__
 9839 34d2 00C0      		rjmp .L1073
1448:main.c        ****     ;
 9840               		.loc 1 1448 0
 9841 34d4 0E94 0000 		call wykonanie_komend_ukladow
 9842               	.LVL733:
 9843 34d8 8111      		cpse r24,__zero_reg__
 9844 34da 00C0      		rjmp .L1073
1450:main.c        ****     ;
 9845               		.loc 1 1450 0
 9846 34dc 0E94 0000 		call wykonanie_komend_powiadomien
 9847               	.LVL734:
 9848               	.L1073:
1454:main.c        **** }
 9849               		.loc 1 1454 0
 9850 34e0 0C94 0000 		jmp usun_komende
 9851               	.LVL735:
 9852               		.cfi_endproc
 9853               	.LFE61:
 9855               		.section	.text.startup,"ax",@progbits
 9856               	.global	main
 9858               	main:
 9859               	.LFB71:
1900:main.c        **** 
1901:main.c        **** #include "test_debug.h"
1902:main.c        **** 
1903:main.c        **** int main(void) {
 9860               		.loc 1 1903 0
 9861               		.cfi_startproc
 9862               	/* prologue: function */
 9863               	/* frame size = 0 */
 9864               	/* stack size = 0 */
 9865               	.L__stack_usage = 0
 9866               	.LVL736:
 9867               	.LBB694:
 9868               	.LBB695:
 9869               		.loc 7 473 0
 9870 0000 88E1      		ldi r24,lo8(24)
 9871 0002 9BE0      		ldi r25,lo8(11)
 9872               	/* #APP */
 9873               	 ;  473 "/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h" 1
 9874 0004 0FB6      		in __tmp_reg__,__SREG__
 9875 0006 F894      		cli
 9876 0008 A895      		wdr
 9877 000a 8093 6000 		sts 96, r24
 9878 000e 0FBE      		out __SREG__,__tmp_reg__
 9879 0010 9093 6000 		sts 96, r25
 9880               	 	
 9881               	 ;  0 "" 2
 9882               	.LVL737:
 9883               	/* #NOAPP */
 9884               	.LBE695:
 9885               	.LBE694:
1904:main.c        ****   // POMOC_DODAJ2('*', 'u');
1905:main.c        ****   { // inicjalizacja
1906:main.c        **** #ifndef DEBUG
1907:main.c        ****     wdt_enable(WDTO_120MS);
1908:main.c        ****     opoznienie_startowe();
 9886               		.loc 1 1908 0
 9887 0014 0E94 0000 		call opoznienie_startowe
 9888               	.LVL738:
1909:main.c        ****     opoznienie_startowe();
 9889               		.loc 1 1909 0
 9890 0018 0E94 0000 		call opoznienie_startowe
 9891               	.LVL739:
1910:main.c        ****     opoznienie_startowe();
 9892               		.loc 1 1910 0
 9893 001c 0E94 0000 		call opoznienie_startowe
 9894               	.LVL740:
1911:main.c        ****     opoznienie_startowe();
 9895               		.loc 1 1911 0
 9896 0020 0E94 0000 		call opoznienie_startowe
 9897               	.LVL741:
1912:main.c        **** #endif
1913:main.c        ****     inicjalizacja_portow();
 9898               		.loc 1 1913 0
 9899 0024 81E0      		ldi r24,lo8(1)
 9900 0026 87B9      		out 0x7,r24
 9901 0028 88B9      		out 0x8,r24
 9902 002a 80E2      		ldi r24,lo8(32)
 9903 002c 8AB9      		out 0xa,r24
1914:main.c        ****     inicjalizuj_parametry_modulu();
 9904               		.loc 1 1914 0
 9905 002e 0E94 0000 		call inicjalizuj_parametry_modulu
 9906               	.LVL742:
1915:main.c        ****     inicjalizacja_SIM900();
 9907               		.loc 1 1915 0
 9908 0032 0E94 0000 		call inicjalizacja_SIM900
 9909               	.LVL743:
1916:main.c        **** #ifdef DEBUG
1917:main.c        ****     debug_main();
1918:main.c        **** #endif
1919:main.c        ****     ustaw_parametry_dla_bezpieczenstwa();
 9910               		.loc 1 1919 0
 9911 0036 0E94 0000 		call ustaw_parametry_dla_bezpieczenstwa
 9912               	.LVL744:
1920:main.c        ****   }
1921:main.c        **** 
1922:main.c        ****   sei();
 9913               		.loc 1 1922 0
 9914               	/* #APP */
 9915               	 ;  1922 "main.c" 1
 9916 003a 7894      		sei
 9917               	 ;  0 "" 2
 9918               	/* #NOAPP */
 9919               	.L1080:
1923:main.c        **** 
1924:main.c        ****   for (;;) {
1925:main.c        ****     // wykonanie watkw moe trwa maksymalnie 10 ms
1926:main.c        ****     if (CZY_WYKONAC_WATKI_10MS())
 9920               		.loc 1 1926 0
 9921 003c 8091 0000 		lds r24,wykonac_watki
 9922 0040 80FD      		sbrc r24,0
1927:main.c        ****       ustaw_parametry_dla_bezpieczenstwa();
 9923               		.loc 1 1927 0
 9924 0042 0E94 0000 		call ustaw_parametry_dla_bezpieczenstwa
 9925               	.LVL745:
 9926               	.L1076:
1928:main.c        ****     if (CZY_WYKONAC_WATKI_100MS()) {
 9927               		.loc 1 1928 0
 9928 0046 8091 0000 		lds r24,wykonac_watki
 9929 004a 81FD      		sbrc r24,1
1929:main.c        ****       steruj_urzadzeniem_100MS();
 9930               		.loc 1 1929 0
 9931 004c 0E94 0000 		call steruj_urzadzeniem_100MS
 9932               	.LVL746:
 9933               	.L1077:
1930:main.c        **** #ifdef TEST_PCB
1931:main.c        ****       testPCB();
1932:main.c        **** #endif
1933:main.c        ****     }
1934:main.c        ****     if (CZY_WYKONAC_WATKI_10MS()) {
 9934               		.loc 1 1934 0
 9935 0050 8091 0000 		lds r24,wykonac_watki
 9936 0054 80FF      		sbrs r24,0
 9937 0056 00C0      		rjmp .L1078
1935:main.c        ****       steruj_urzadzeniem_10MS();
 9938               		.loc 1 1935 0
 9939 0058 0E94 0000 		call steruj_urzadzeniem_10MS
 9940               	.LVL747:
1936:main.c        ****       wykonanie_komend();
 9941               		.loc 1 1936 0
 9942 005c 0E94 0000 		call wykonanie_komend
 9943               	.LVL748:
1937:main.c        **** 
1938:main.c        ****       RESETUJ_WYKONANIE_WATKOW();
 9944               		.loc 1 1938 0
 9945 0060 1092 0000 		sts wykonac_watki,__zero_reg__
 9946               	.L1078:
1939:main.c        ****     }
1940:main.c        **** 
1941:main.c        ****     { // tryb SLEEP
1942:main.c        ****       cli();
 9947               		.loc 1 1942 0
 9948               	/* #APP */
 9949               	 ;  1942 "main.c" 1
 9950 0064 F894      		cli
 9951               	 ;  0 "" 2
1943:main.c        ****       if (!wykonaj_zdarzenie_timer) {
 9952               		.loc 1 1943 0
 9953               	/* #NOAPP */
 9954 0066 8091 0000 		lds r24,wykonaj_zdarzenie_timer
 9955 006a 8111      		cpse r24,__zero_reg__
 9956 006c 00C0      		rjmp .L1079
1944:main.c        ****         sleep_enable();
 9957               		.loc 1 1944 0
 9958 006e 83B7      		in r24,0x33
 9959 0070 8160      		ori r24,lo8(1)
 9960 0072 83BF      		out 0x33,r24
1945:main.c        ****         sei();
 9961               		.loc 1 1945 0
 9962               	/* #APP */
 9963               	 ;  1945 "main.c" 1
 9964 0074 7894      		sei
 9965               	 ;  0 "" 2
1946:main.c        ****         sleep_cpu();
 9966               		.loc 1 1946 0
 9967               	 ;  1946 "main.c" 1
 9968 0076 8895      		sleep
 9969               		
 9970               	 ;  0 "" 2
1947:main.c        ****         cli();
 9971               		.loc 1 1947 0
 9972               	 ;  1947 "main.c" 1
 9973 0078 F894      		cli
 9974               	 ;  0 "" 2
1948:main.c        ****         sleep_disable();
 9975               		.loc 1 1948 0
 9976               	/* #NOAPP */
 9977 007a 83B7      		in r24,0x33
 9978 007c 8E7F      		andi r24,lo8(-2)
 9979 007e 83BF      		out 0x33,r24
 9980               	.L1079:
1949:main.c        ****       }
1950:main.c        ****       sei();
 9981               		.loc 1 1950 0
 9982               	/* #APP */
 9983               	 ;  1950 "main.c" 1
 9984 0080 7894      		sei
 9985               	 ;  0 "" 2
1951:main.c        ****       wolne_zdarzenie_timer();
 9986               		.loc 1 1951 0
 9987               	/* #NOAPP */
 9988 0082 0E94 0000 		call wolne_zdarzenie_timer
 9989               	.LVL749:
1926:main.c        ****       ustaw_parametry_dla_bezpieczenstwa();
 9990               		.loc 1 1926 0
 9991 0086 00C0      		rjmp .L1080
 9992               		.cfi_endproc
 9993               	.LFE71:
 9995               		.local	licznik_resetow.3798
 9996               		.comm	licznik_resetow.3798,1,1
 9997               		.local	licznik_wybuc_watki_100MS.3754
 9998               		.comm	licznik_wybuc_watki_100MS.3754,1,1
 9999               		.local	licznik_dioda_led_poziom_sieci.3747
 10000               		.comm	licznik_dioda_led_poziom_sieci.3747,1,1
 10001               		.section	.progmem.data,"a",@progbits
 10004               	__c.3743:
 10005 0000 5379 6E63 		.string	"Synchronizacja Czasu"
 10005      6872 6F6E 
 10005      697A 6163 
 10005      6A61 2043 
 10005      7A61 7375 
 10006               		.local	autosync_timer_100ms.3742
 10007               		.comm	autosync_timer_100ms.3742,2,1
 10008               		.local	autosync_sms_wyslany.3741
 10009               		.comm	autosync_sms_wyslany.3741,1,1
 10012               	__c.3705:
 10013 0015 4272 616B 		.string	"Brak wolnych pozycji Super User (795-800)"
 10013      2077 6F6C 
 10013      6E79 6368 
 10013      2070 6F7A 
 10013      7963 6A69 
 10016               	__c.3697:
 10017 003f 4E75 6D65 		.string	"Numer juz istnieje w systemie"
 10017      7220 6A75 
 10017      7A20 6973 
 10017      746E 6965 
 10017      6A65 2077 
 10020               	tab_eeprom_fabryczny.3646:
 10021 005d FF        		.byte	-1
 10022 005e 41        		.byte	65
 10023 005f 42        		.byte	66
 10024 0060 43        		.byte	67
 10025 0061 44        		.byte	68
 10026 0062 00        		.byte	0
 10027               		.local	licznik_odebranych_znakow.3491
 10028               		.comm	licznik_odebranych_znakow.3491,2,1
 10029               		.local	licznik_poprzednia_komenda.3490
 10030               		.comm	licznik_poprzednia_komenda.3490,2,1
 10031               		.local	poprzednia_komenda.3489
 10032               		.comm	poprzednia_komenda.3489,1,1
 10033               		.local	licznik_bezpieczenstwa.3488
 10034               		.comm	licznik_bezpieczenstwa.3488,2,1
 10035               		.local	licznik_cyklu_8_sek.3484
 10036               		.comm	licznik_cyklu_8_sek.3484,1,1
 10039               	nastepna_komenda.3475:
 10040 0063 00        		.byte	0
 10041 0064 00        		.byte	0
 10042 0065 A2        		.byte	-94
 10043 0066 A3        		.byte	-93
 10044 0067 A4        		.byte	-92
 10045 0068 A6        		.byte	-90
 10046 0069 A7        		.byte	-89
 10047 006a A8        		.byte	-88
 10048 006b A9        		.byte	-87
 10049 006c 94        		.byte	-108
 10052               	instrukcje.3474:
 10053 006d 2B63 7069 		.string	"+cpin?"
 10053      6E3F 00
 10054 0074 0000 0000 		.zero	7
 10054      0000 00
 10055 007b 2B63 6E6D 		.string	"+cnmi=2,1,2,1"
 10055      693D 322C 
 10055      312C 322C 
 10055      3100 
 10056 0089 2B6D 6F72 		.string	"+moring=1"
 10056      696E 673D 
 10056      3100 
 10057 0093 0000 0000 		.zero	4
 10058 0097 2B63 6C69 		.string	"+clip=1"
 10058      703D 3100 
 10059 009f 0000 0000 		.zero	6
 10059      0000 
 10060 00a5 2B64 6465 		.string	"+ddet=1,10,1"
 10060      743D 312C 
 10060      3130 2C31 
 10060      00
 10061 00b2 00        		.zero	1
 10062 00b3 2B63 616C 		.string	"+calm=1"
 10062      6D3D 3100 
 10063 00bb 0000 0000 		.zero	6
 10063      0000 
 10064 00c1 2B63 7273 		.string	"+crsl=1"
 10064      6C3D 3100 
 10065 00c9 0000 0000 		.zero	6
 10065      0000 
 10066 00cf 2B63 7573 		.string	"+cusd=1"
 10066      643D 3100 
 10067 00d7 0000 0000 		.zero	6
 10067      0000 
 10068 00dd 2B63 7062 		.string	"+cpbw=26,\"1\""
 10068      773D 3236 
 10068      2C22 3122 
 10068      00
 10069 00ea 00        		.zero	1
 10070 00eb 2B63 6C74 		.string	"+clts=0"
 10070      733D 3000 
 10071 00f3 0000 0000 		.zero	6
 10071      0000 
 10074               	instrukcja.3460:
 10075 00f9 2B63 6D69 		.string	"+cmic=0,15"
 10075      633D 302C 
 10075      3135 00
 10078               	instrukcja_usun_wszystkie_smsy.3457:
 10079 0104 2B63 6D67 		.string	"+cmgda=6"
 10079      6461 3D36 
 10079      00
 10080               		.local	drugi_raz.3456
 10081               		.comm	drugi_raz.3456,1,1
 10084               	instrukcja_podaj_pin.3454:
 10085 010d 2B63 7069 		.string	"+cpin=\"1976\""
 10085      6E3D 2231 
 10085      3937 3622 
 10085      00
 10088               	instrukcja_at.3451:
 10089 011a 2B69 6663 		.string	"+ifc=2,2"
 10089      3D32 2C32 
 10089      00
 10092               	instrukcja_ustawienie_pamieci.3448:
 10093 0123 2B63 706D 		.string	"+cpms=\"SM\",\"SM\",\"SM\""
 10093      733D 2253 
 10093      4D22 2C22 
 10093      534D 222C 
 10093      2253 4D22 
 10096               	instrukcja_ustawienie_pamieci.3446:
 10097 0138 2B63 6473 		.string	"+cdscb"
 10097      6362 00
 10100               	instrukcja_cclk.3444:
 10101 013f 2B63 636C 		.string	"+cclk?"
 10101      6B3F 00
 10104               	instrukcja_sprawdz_operatora.3442:
 10105 0146 2B63 6F70 		.string	"+cops?"
 10105      733F 00
 10108               	instrukcja_odczyt_ksiazki.3440:
 10109 014d 2B63 7062 		.string	"+cpbr=26"
 10109      723D 3236 
 10109      00
 10112               	instrukcja_creg.3438:
 10113 0156 2B63 7265 		.string	"+creg?"
 10113      673F 00
 10116               	instrukcja_poziom_sieci.3436:
 10117 015d 2B63 7371 		.string	"+csq"
 10117      00
 10120               	instrukcja_vts.3432:
 10121 0162 2B76 7473 		.string	"+vts=1"
 10121      3D31 00
 10124               	instrukcja_odbierz_rozmowe.3430:
 10125 0169 6100      		.string	"a"
 10128               	instrukcja_odrzuc_rozmowe.3428:
 10129 016b 6800      		.string	"h"
 10132               	__c.3425:
 10133 016d 2B43 4D54 		.string	"+CMTI:"
 10133      493A 00
 10136               	instrukcja_usun_smsa.3421:
 10137 0174 2B63 6D67 		.string	"+cmgd="
 10137      643D 00
 10140               	instrukcja_odczytaj_smsa.3388:
 10141 017b 2B63 6D67 		.string	"+cmgr="
 10141      723D 00
 10144               	instrukcja_wyslij_smsa.3356:
 10145 0182 2B63 6D67 		.string	"+cmgs="
 10145      733D 00
 10148               	__c.3336:
 10149 0189 2B43 4D54 		.string	"+CMTI:"
 10149      493A 00
 10152               	__c.3329:
 10153 0190 2B44 544D 		.string	"+DTMF:"
 10153      463A 00
 10156               	__c.3324:
 10157 0197 2B43 4C49 		.string	"+CLIP:"
 10157      503A 00
 10160               	__c.3311:
 10161 019e 3E00      		.string	">"
 10164               	__c.3282:
 10165 01a0 2B43 4D47 		.string	"+CMGR:"
 10165      523A 00
 10168               	polecenie_operator.3253:
 10169 01a7 2B43 4F50 		.string	"+COPS:"
 10169      533A 00
 10172               	urc.3248:
 10173 01ae 2B43 5245 		.string	"+CREG:"
 10173      473A 00
 10176               	urc.3245:
 10177 01b5 2B43 5351 		.string	"+CSQ:"
 10177      3A00 
 10178               		.local	nr_zapytania_o_pin.3239
 10179               		.comm	nr_zapytania_o_pin.3239,1,1
 10182               	polecenie_pin_ready.3238:
 10183 01bb 2B43 5049 		.string	"+CPIN: READY"
 10183      4E3A 2052 
 10183      4541 4459 
 10183      00
 10186               	polecenie_zegar.3227:
 10187 01c8 2B43 434C 		.string	"+CCLK:"
 10187      4B3A 00
 10188               		.local	licznik_reset.3173
 10189               		.comm	licznik_reset.3173,1,1
 10192               	__c.3152:
 10193 01cf 313D 5243 		.string	"1=RCV 2=BSY 3=CNT 4=QSM 5=QAL 6=FND 7=ADD"
 10193      5620 323D 
 10193      4253 5920 
 10193      333D 434E 
 10193      5420 343D 
 10196               	__c.3150:
 10197 01f9 2055 373D 		.string	" U7="
 10197      00
 10200               	__c.3148:
 10201 01fe 2055 363D 		.string	" U6="
 10201      00
 10204               	__c.3146:
 10205 0203 2055 353D 		.string	" U5="
 10205      00
 10208               	__c.3144:
 10209 0208 5534 3D00 		.string	"U4="
 10212               	__c.3142:
 10213 020c 2055 333D 		.string	" U3="
 10213      00
 10216               	__c.3140:
 10217 0211 2055 323D 		.string	" U2="
 10217      00
 10220               	__c.3138:
 10221 0216 5531 3D00 		.string	"U1="
 10224               	__c.3136:
 10225 021a 534B 5259 		.string	"SKRYBA:"
 10225      4241 3A00 
 10228               	__c.3133:
 10229 0222 4445 4255 		.string	"DEBUG\n"
 10229      470A 00
 10232               	tekst_demo.3059:
 10233 0229 7777 772E 		.string	"www.sonfy.pl"
 10233      736F 6E66 
 10233      792E 706C 
 10233      00
 10236               	__c.3057:
 10237 0236 2D2D 2D2D 		.string	"----"
 10237      00
 10240               	__c.3055:
 10241 023b 4D6F 6A20 		.string	"Moj nr: "
 10241      6E72 3A20 
 10241      00
 10244               	__c.3053:
 10245 0244 536B 7279 		.string	"Skryba: Wylaczona"
 10245      6261 3A20 
 10245      5779 6C61 
 10245      637A 6F6E 
 10245      6100 
 10248               	__c.3051:
 10249 0256 536B 7279 		.string	"Skryba: Wlaczona"
 10249      6261 3A20 
 10249      576C 6163 
 10249      7A6F 6E61 
 10249      00
 10252               	__c.3049:
 10253 0267 4861 726D 		.string	"Harm: Wylaczony"
 10253      3A20 5779 
 10253      6C61 637A 
 10253      6F6E 7900 
 10256               	__c.3047:
 10257 0277 2044 544D 		.string	" DTMF"
 10257      4600 
 10260               	__c.3045:
 10261 027d 2043 4C49 		.string	" CLIP"
 10261      5000 
 10264               	__c.3043:
 10265 0283 5472 7962 		.string	"Tryb: Publiczny"
 10265      3A20 5075 
 10265      626C 6963 
 10265      7A6E 7900 
 10268               	__c.3041:
 10269 0293 5472 7962 		.string	"Tryb: Prywatny"
 10269      3A20 5072 
 10269      7977 6174 
 10269      6E79 00
 10272               	__c.3039:
 10273 02a2 5374 6174 		.string	"Status: Aktywny"
 10273      7573 3A20 
 10273      416B 7479 
 10273      776E 7900 
 10276               	__c.3037:
 10277 02b2 5374 6174 		.string	"Status: Zablokowany"
 10277      7573 3A20 
 10277      5A61 626C 
 10277      6F6B 6F77 
 10277      616E 7900 
 10280               	tekst_gsm.3023:
 10281 02c6 557A 7974 		.string	"Uzytkownicy "
 10281      6B6F 776E 
 10281      6963 7920 
 10281      00
 10284               	tekst_gsm.3012:
 10285 02d3 557A 7974 		.string	"Uzyt: "
 10285      3A20 00
 10288               	text_sygnal.3008:
 10289 02da 4753 4D3A 		.string	"GSM: "
 10289      2000 
 10292               	__c.3006:
 10293 02e0 437A 6173 		.string	"Czas: "
 10293      3A20 00
 10296               	tekst_gsm.3004:
 10297 02e7 4143 3830 		.string	"AC800-DTM-TS"
 10297      302D 4454 
 10297      4D2D 5453 
 10297      00
 10298               		.local	stan.2971
 10299               		.comm	stan.2971,1,1
 10300               		.local	opoznienie_1s.2970
 10301               		.comm	opoznienie_1s.2970,1,1
 10302               	.global	wysylanie_smsa_clipa
 10303               		.section .bss
 10306               	wysylanie_smsa_clipa:
 10307 0000 00        		.zero	1
 10308               		.comm	ptr_start_pdu_z_wiadomoscia,2,1
 10309               	.global	wysylanie_echa_przez_pdu
 10312               	wysylanie_echa_przez_pdu:
 10313 0001 00        		.zero	1
 10314               		.local	liczba_kolejnych_watchdogow_wysylania
 10315               		.comm	liczba_kolejnych_watchdogow_wysylania,1,1
 10316               		.local	licznik_watchdog_wysylanie_smsa_100ms
 10317               		.comm	licznik_watchdog_wysylanie_smsa_100ms,2,1
 10318               		.local	licznik_awaryjnych_resetow_kolejki
 10319               		.comm	licznik_awaryjnych_resetow_kolejki,2,1
 10320               		.local	licznik_usunietych_sms_przez_limit
 10321               		.comm	licznik_usunietych_sms_przez_limit,2,1
 10322               		.local	licznik_kolejka_stoi_100ms
 10323               		.comm	licznik_kolejka_stoi_100ms,2,1
 10324               		.local	ostatnia_pierwsza_komenda
 10325               		.comm	ostatnia_pierwsza_komenda,1,1
 10326               		.local	timer_report_user_100ms
 10327               		.comm	timer_report_user_100ms,2,1
 10328               		.local	licznik_report_user
 10329               		.comm	licznik_report_user,1,1
 10330               		.comm	numer_telefonu_skryba,20,1
 10331               		.comm	numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama,1,1
 10332               		.comm	nie_wysylaj_echa_z_powodu_nietypowego_smsa,1,1
 10333               		.comm	kod_modulu,4,1
 10334               	.global	tryb_pracy
 10335               		.data
 10338               	tryb_pracy:
 10339 0000 01        		.byte	1
 10340               	.global	blokada_systemu
 10341               		.section .bss
 10344               	blokada_systemu:
 10345 0002 00        		.zero	1
 10346               		.comm	moj_numer_telefonu,17,1
 10347               	.global	autosync_czas_aktywny
 10350               	autosync_czas_aktywny:
 10351 0003 00        		.zero	1
 10352               	.global	opoznienie_wysylania_clipow_100MS
 10355               	opoznienie_wysylania_clipow_100MS:
 10356 0004 0000      		.zero	2
 10357               	.global	licznik_reset_urzadzenia
 10360               	licznik_reset_urzadzenia:
 10361 0006 00        		.zero	1
 10362               	.global	licznik_reset_modulu_SIM900
 10365               	licznik_reset_modulu_SIM900:
 10366 0007 00        		.zero	1
 10367               	.global	modul_zalogowany_w_sieci
 10370               	modul_zalogowany_w_sieci:
 10371 0008 00        		.zero	1
 10372               	.global	licznik_wybudz_watki_10MS
 10375               	licznik_wybudz_watki_10MS:
 10376 0009 00        		.zero	1
 10377               	.global	wykonac_watki
 10380               	wykonac_watki:
 10381 000a 00        		.zero	1
 10382               	.global	wykonac_watki_10MS
 10385               	wykonac_watki_10MS:
 10386 000b 00        		.zero	1
 10387               	.global	wykonaj_zdarzenie_timer
 10390               	wykonaj_zdarzenie_timer:
 10391 000c 00        		.zero	1
 10392               	.global	stan_cyklu_blysku
 10395               	stan_cyklu_blysku:
 10396 000d 00        		.zero	1
 10397               	.global	liczba_blyskow_led
 10400               	liczba_blyskow_led:
 10401 000e 00        		.zero	1
 10402               		.comm	licznik_100ms_dioda_led,1,1
 10403               	.global	g_czas_systemowy_100ms
 10406               	g_czas_systemowy_100ms:
 10407 000f 0000 0000 		.zero	4
 10408               	.global	licznik_timeout_rozmowy_100ms
 10411               	licznik_timeout_rozmowy_100ms:
 10412 0013 0000      		.zero	2
 10413               	.global	tryb_clip
 10414               		.data
 10417               	tryb_clip:
 10418 0001 FF        		.byte	-1
 10419               	.global	skryba_limit
 10422               	skryba_limit:
 10423 0002 1B03      		.word	795
 10424               	.global	skryba_wlaczona
 10425               		.section .bss
 10428               	skryba_wlaczona:
 10429 0015 00        		.zero	1
 10430               		.comm	stan_wyjscie,1,1
 10431               	.global	sms_pomijaj_aktualizacje_czasu
 10434               	sms_pomijaj_aktualizacje_czasu:
 10435 0016 00        		.zero	1
 10436               	.global	sms_timestamp_sekunda
 10439               	sms_timestamp_sekunda:
 10440 0017 00        		.zero	1
 10441               	.global	sms_timestamp_minuta
 10444               	sms_timestamp_minuta:
 10445 0018 00        		.zero	1
 10446               	.global	sms_timestamp_godzina
 10449               	sms_timestamp_godzina:
 10450 0019 00        		.zero	1
 10451               	.global	watchdog_sms_safe_mode_100ms
 10454               	watchdog_sms_safe_mode_100ms:
 10455 001a 0000      		.zero	2
 10456               	.global	watchdog_sms_trwa_reset
 10459               	watchdog_sms_trwa_reset:
 10460 001c 00        		.zero	1
 10461               	.global	watchdog_sms_licznik_100ms
 10464               	watchdog_sms_licznik_100ms:
 10465 001d 0000      		.zero	2
 10466               	.global	watchdog_sms_aktywny
 10469               	watchdog_sms_aktywny:
 10470 001f 00        		.zero	1
 10471               		.comm	opoznienie_zatrzymaj_odpytywanie_urzadzenia,1,1
 10472               	.global	blokada_clip
 10475               	blokada_clip:
 10476 0020 00        		.zero	1
 10477               	.global	max_oczekiwanie_na_odpowiedz_at
 10480               	max_oczekiwanie_na_odpowiedz_at:
 10481 0021 00        		.zero	1
 10482               		.comm	licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow,1,1
 10483               	.global	licznik_bezpieczenstwa_opoznienie_wysylania_sms
 10486               	licznik_bezpieczenstwa_opoznienie_wysylania_sms:
 10487 0022 0000      		.zero	2
 10488               	.global	licznik_ogolny_blad_zalogowania
 10491               	licznik_ogolny_blad_zalogowania:
 10492 0024 0000      		.zero	2
 10493               	.global	licznik_blad_zalogowania_u_operatora
 10496               	licznik_blad_zalogowania_u_operatora:
 10497 0026 00        		.zero	1
 10498               	.global	licznik_blad_stanu_karty_SIM
 10501               	licznik_blad_stanu_karty_SIM:
 10502 0027 00        		.zero	1
 10503               	.global	licznik_awaria_brak_zasiegu
 10506               	licznik_awaria_brak_zasiegu:
 10507 0028 0000      		.zero	2
 10508               	.global	liczba_smsow_ech_do_wyslania
 10511               	liczba_smsow_ech_do_wyslania:
 10512 002a 00        		.zero	1
 10513               	.global	ustaw_maksymalny_czas_dzwonienia
 10516               	ustaw_maksymalny_czas_dzwonienia:
 10517 002b 00        		.zero	1
 10518               	.global	maksymalny_czas_dzwonienia
 10521               	maksymalny_czas_dzwonienia:
 10522 002c 00        		.zero	1
 10523               		.comm	numer_telefonu_do_ktorego_dzwonic,33,1
 10524               		.comm	numer_telefonu_ktory_dzwoni,17,1
 10525               	.global	liczba_prob_wyslania_smsa
 10528               	liczba_prob_wyslania_smsa:
 10529 002d 00        		.zero	1
 10530               	.global	flaga_wysylanie_smsa
 10533               	flaga_wysylanie_smsa:
 10534 002e 00        		.zero	1
 10535               		.comm	numer_telefonu_wysylanego_smsa,33,1
 10536               	.global	flaga_odczytywanie_smsa
 10539               	flaga_odczytywanie_smsa:
 10540 002f 00        		.zero	1
 10541               		.comm	numer_telefonu_odebranego_smsa,17,1
 10542               	.global	dlugosc_pdu
 10545               	dlugosc_pdu:
 10546 0030 00        		.zero	1
 10547               		.comm	bufor_pdu,200,1
 10548               	.global	licznik_bezpieczenstwa_wykonywana_rozmowa
 10551               	licznik_bezpieczenstwa_wykonywana_rozmowa:
 10552 0031 0000      		.zero	2
 10553               	.global	trwa_rozmowa_przychodzaca_od_uzytkownika
 10556               	trwa_rozmowa_przychodzaca_od_uzytkownika:
 10557 0033 00        		.zero	1
 10558               	.global	max_oczekiwanie_na_odpowiedz
 10559               		.data
 10562               	max_oczekiwanie_na_odpowiedz:
 10563 0004 03        		.byte	3
 10564               		.comm	liczba_wykonanych_komend_identycznego_polecenia,1,1
 10565               	.global	nastepne_wysylane_polecenie_SIM900
 10566               		.section .bss
 10569               	nastepne_wysylane_polecenie_SIM900:
 10570 0034 00        		.zero	1
 10571               	.global	licznik_wysylane_polecenie_SIM900
 10574               	licznik_wysylane_polecenie_SIM900:
 10575 0035 0000      		.zero	2
 10576               	.global	aktualnie_wysylane_polecenie_SIM900
 10579               	aktualnie_wysylane_polecenie_SIM900:
 10580 0037 00        		.zero	1
 10581               		.comm	nazwa_operatora,11,1
 10582               	.global	oproznij_bufor_SIM900_po_bledzie
 10585               	oproznij_bufor_SIM900_po_bledzie:
 10586 0038 00        		.zero	1
 10587               	.global	opoznienie_SIM900_100MS
 10590               	opoznienie_SIM900_100MS:
 10591 0039 00        		.zero	1
 10592               		.text
 10593               	.Letext0:
 10594               		.file 8 "narzedzia.h"
 10595               		.file 9 "/usr/local/avr8-gnu-toolchain/avr/include/stdint.h"
 10596               		.file 10 "/usr/local/avr8-gnu-toolchain/lib/gcc/avr/7.3.0/include/stddef.h"
 10597               		.file 11 "/usr/local/avr8-gnu-toolchain/avr/include/stdio.h"
 10598               		.file 12 "enumkomendy.h"
 10599               		.file 13 "data_sim900.h"
 10600               		.file 14 "pamiec_ram.h"
 10601               		.file 15 "interpretacjaSMS.h"
 10602               		.file 16 "komendy.h"
 10603               		.file 17 "poleceniagsm.h"
 10604               		.file 18 "sim900.h"
 10605               		.file 19 "zapiseeprom.h"
 10606               		.file 20 "bufpomoc.h"
 10607               		.file 21 "/usr/local/avr8-gnu-toolchain/avr/include/avr/eeprom.h"
 10608               		.file 22 "/usr/local/avr8-gnu-toolchain/avr/include/string.h"
 10609               		.file 23 "/usr/local/avr8-gnu-toolchain/avr/include/avr/pgmspace.h"
 10610               		.file 24 "konfiguracja.h"
 10611               		.file 25 "pdu.h"
 10612               		.file 26 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:4      *ABS*:000000000000003f __SREG__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:5      *ABS*:000000000000003b __RAMPZ__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:6      *ABS*:0000000000000000 __tmp_reg__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:7      *ABS*:0000000000000001 __zero_reg__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:12     .text:0000000000000000 watchdog_sms_disarm
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10469  .bss:000000000000001f watchdog_sms_aktywny
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10464  .bss:000000000000001d watchdog_sms_licznik_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:33     .text:000000000000000e czy_numer_istnieje
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:100    .text:000000000000004e usun_zablokowany_sms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10579  .bss:0000000000000037 aktualnie_wysylane_polecenie_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:128    .text:0000000000000062 zareaguj_na_usuniety_sms_z_powodu_limitu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10319  .bss:0000000000000052 licznik_usunietych_sms_przez_limit
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10400  .bss:000000000000000e liczba_blyskow_led
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10395  .bss:000000000000000d stan_cyklu_blysku
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:166    .text:000000000000008e polozenie_polecenia_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:187    .text:0000000000000098 opoznienie_startowe
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:252    .text:00000000000000d8 zapisz_debug_do_eeprom
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10327  .bss:0000000000000059 licznik_report_user
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10325  .bss:0000000000000057 timer_report_user_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10533  .bss:000000000000002e flaga_wysylanie_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:368    .text:000000000000015c test_dioda_wyjscia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10299  .bss:000000000000004c opoznienie_1s.2970
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10189  .bss:000000000000004b stan.2971
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:411    .text:000000000000018a test_wejscie
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:443    .text:000000000000019a __vector_16
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10375  .bss:0000000000000009 licznik_wybudz_watki_10MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10385  .bss:000000000000000b wykonac_watki_10MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10390  .bss:000000000000000c wykonaj_zdarzenie_timer
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:658    .text:000000000000029c generuj_raport_sieci
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10296  .progmem.data:00000000000002e7 tekst_gsm.3004
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10292  .progmem.data:00000000000002e0 __c.3006
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10288  .progmem.data:00000000000002da text_sygnal.3008
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10370  .bss:0000000000000008 modul_zalogowany_w_sieci
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:840    .text:0000000000000364 generuj_raport_uzytkownikow_1
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10284  .progmem.data:00000000000002d3 tekst_gsm.3012
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:1026   .text:0000000000000416 generuj_raport_uzytkownikow
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10280  .progmem.data:00000000000002c6 tekst_gsm.3023
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:1202   .text:00000000000004b8 generuj_raport_stanu_urzadzenia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10344  .bss:0000000000000002 blokada_systemu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10276  .progmem.data:00000000000002b2 __c.3037
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10272  .progmem.data:00000000000002a2 __c.3039
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10338  .data:0000000000000000 tryb_pracy
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10268  .progmem.data:0000000000000293 __c.3041
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10264  .progmem.data:0000000000000283 __c.3043
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10417  .data:0000000000000001 tryb_clip
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10260  .progmem.data:000000000000027d __c.3045
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10256  .progmem.data:0000000000000277 __c.3047
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10252  .progmem.data:0000000000000267 __c.3049
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10428  .bss:0000000000000015 skryba_wlaczona
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10248  .progmem.data:0000000000000256 __c.3051
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10244  .progmem.data:0000000000000244 __c.3053
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10240  .progmem.data:000000000000023b __c.3055
                            *COM*:0000000000000011 moj_numer_telefonu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10232  .progmem.data:0000000000000229 tekst_demo.3059
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10236  .progmem.data:0000000000000236 __c.3057
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:1508   .text:0000000000000688 czy_numer_jest_super_userem
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:1602   .text:00000000000006e8 ustaw_wyjscie_clip
                            *COM*:0000000000000001 stan_wyjscie
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:1644   .text:0000000000000708 wykonanie_polecenia_sms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10434  .bss:0000000000000016 sms_pomijaj_aktualizacje_czasu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10439  .bss:0000000000000017 sms_timestamp_sekunda
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10444  .bss:0000000000000018 sms_timestamp_minuta
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10449  .bss:0000000000000019 sms_timestamp_godzina
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10350  .bss:0000000000000003 autosync_czas_aktywny
                            *COM*:0000000000000011 numer_telefonu_odebranego_smsa
                            *COM*:0000000000000021 numer_telefonu_wysylanego_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10228  .progmem.data:0000000000000222 __c.3133
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10224  .progmem.data:000000000000021a __c.3136
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10220  .progmem.data:0000000000000216 __c.3138
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10216  .progmem.data:0000000000000211 __c.3140
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10212  .progmem.data:000000000000020c __c.3142
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10208  .progmem.data:0000000000000208 __c.3144
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10204  .progmem.data:0000000000000203 __c.3146
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10200  .progmem.data:00000000000001fe __c.3148
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10196  .progmem.data:00000000000001f9 __c.3150
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10192  .progmem.data:00000000000001cf __c.3152
                            *COM*:0000000000000021 numer_telefonu_do_ktorego_dzwonic
                            *COM*:0000000000000001 numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:2659   .text:0000000000000ca0 steruj_wejsciem_reset_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10179  .bss:000000000000004a licznik_reset.3173
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:2730   .text:0000000000000ce8 sprawdz_przychodzaca_rozmowe
                            *COM*:0000000000000011 numer_telefonu_ktory_dzwoni
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:2867   .text:0000000000000d8c zakonczono_rozmowe_telefoniczna
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10590  .bss:0000000000000039 opoznienie_SIM900_100MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10551  .bss:0000000000000031 licznik_bezpieczenstwa_wykonywana_rozmowa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10516  .bss:000000000000002b ustaw_maksymalny_czas_dzwonienia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10521  .bss:000000000000002c maksymalny_czas_dzwonienia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10475  .bss:0000000000000020 blokada_clip
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:2897   .text:0000000000000da8 zakonczono_wysylanie_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10306  .bss:0000000000000000 wysylanie_smsa_clipa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:2920   .text:0000000000000db4 problem_z_wyslaniem_powiadomienia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10574  .bss:0000000000000035 licznik_wysylane_polecenie_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:2952   .text:0000000000000ddc wyzerowanie_danych_SIM900
                            *COM*:0000000000000001 licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10556  .bss:0000000000000033 trwa_rozmowa_przychodzaca_od_uzytkownika
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10539  .bss:000000000000002f flaga_odczytywanie_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:2991   .text:0000000000000e0a reset_modulu_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10501  .bss:0000000000000027 licznik_blad_stanu_karty_SIM
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10496  .bss:0000000000000026 licznik_blad_zalogowania_u_operatora
                            *COM*:000000000000000b nazwa_operatora
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10491  .bss:0000000000000024 licznik_ogolny_blad_zalogowania
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10569  .bss:0000000000000034 nastepne_wysylane_polecenie_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:3055   .text:0000000000000e64 obsluga_wysylania_sms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10528  .bss:000000000000002d liczba_prob_wyslania_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:3267   .text:0000000000000f6e odpowiedz_na_polecenie
                            *COM*:0000000000000001 liczba_wykonanych_komend_identycznego_polecenia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10172  .progmem.data:00000000000001ae urc.3248
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10160  .progmem.data:000000000000019e __c.3311
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10480  .bss:0000000000000021 max_oczekiwanie_na_odpowiedz_at
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10186  .progmem.data:00000000000001c8 polecenie_zegar.3227
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10182  .progmem.data:00000000000001bb polecenie_pin_ready.3238
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10081  .bss:0000000000000049 nr_zapytania_o_pin.3239
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10176  .progmem.data:00000000000001b5 urc.3245
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10168  .progmem.data:00000000000001a7 polecenie_operator.3253
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10411  .bss:0000000000000013 licznik_timeout_rozmowy_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10164  .progmem.data:00000000000001a0 __c.3282
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10545  .bss:0000000000000030 dlugosc_pdu
                            *COM*:00000000000000c8 bufor_pdu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:4422   .text:00000000000015ea obsluga_komendy_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10585  .bss:0000000000000038 oproznij_bufor_SIM900_po_bledzie
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10156  .progmem.data:0000000000000197 __c.3324
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10152  .progmem.data:0000000000000190 __c.3329
                            *COM*:0000000000000001 licznik_100ms_dioda_led
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10148  .progmem.data:0000000000000189 __c.3336
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:4898   .text:0000000000001890 wyslanie_polecenia_ROM
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:4941   .text:00000000000018b8 wyslij_sms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10144  .progmem.data:0000000000000182 instrukcja_wyslij_smsa.3356
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10562  .data:0000000000000004 max_oczekiwanie_na_odpowiedz
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:5117   .text:00000000000019b2 wykonanie_komend_SIM900
                            *COM*:0000000000000001 opoznienie_zatrzymaj_odpytywanie_urzadzenia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10039  .progmem.data:0000000000000063 nastepna_komenda.3475
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10052  .progmem.data:000000000000006d instrukcje.3474
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10140  .progmem.data:000000000000017b instrukcja_odczytaj_smsa.3388
                            *COM*:0000000000000001 nie_wysylaj_echa_z_powodu_nietypowego_smsa
                            *COM*:0000000000000002 ptr_start_pdu_z_wiadomoscia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10136  .progmem.data:0000000000000174 instrukcja_usun_smsa.3421
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10132  .progmem.data:000000000000016d __c.3425
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10128  .progmem.data:000000000000016b instrukcja_odrzuc_rozmowe.3428
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10124  .progmem.data:0000000000000169 instrukcja_odbierz_rozmowe.3430
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10120  .progmem.data:0000000000000162 instrukcja_vts.3432
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10116  .progmem.data:000000000000015d instrukcja_poziom_sieci.3436
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10112  .progmem.data:0000000000000156 instrukcja_creg.3438
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10108  .progmem.data:000000000000014d instrukcja_odczyt_ksiazki.3440
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10104  .progmem.data:0000000000000146 instrukcja_sprawdz_operatora.3442
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10100  .progmem.data:000000000000013f instrukcja_cclk.3444
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10096  .progmem.data:0000000000000138 instrukcja_ustawienie_pamieci.3446
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10092  .progmem.data:0000000000000123 instrukcja_ustawienie_pamieci.3448
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10088  .progmem.data:000000000000011a instrukcja_at.3451
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10084  .progmem.data:000000000000010d instrukcja_podaj_pin.3454
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10036  .bss:0000000000000048 drugi_raz.3456
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10078  .progmem.data:0000000000000104 instrukcja_usun_wszystkie_smsy.3457
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10074  .progmem.data:00000000000000f9 instrukcja.3460
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:6521   .text:0000000000002260 steruj_SIM900_100MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10355  .bss:0000000000000004 opoznienie_wysylania_clipow_100MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10034  .bss:0000000000000047 licznik_cyklu_8_sek.3484
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10506  .bss:0000000000000028 licznik_awaria_brak_zasiegu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10365  .bss:0000000000000007 licznik_reset_modulu_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:6820   .text:0000000000002438 steruj_SIM900_10MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10032  .bss:0000000000000045 licznik_bezpieczenstwa.3488
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10030  .bss:0000000000000044 poprzednia_komenda.3489
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10028  .bss:0000000000000042 licznik_poprzednia_komenda.3490
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10009  .bss:0000000000000040 licznik_odebranych_znakow.3491
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:7123   .text:00000000000025f8 wykonanie_komend_powiadomien
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:7399   .text:0000000000002764 test_sms_clip_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:7415   .text:0000000000002766 steruj_wejscia_wyjscia_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:7437   .text:0000000000002772 zapis_w_eeprom_stanu_wyjsc
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:7533   .text:00000000000027ee steruj_urzadzeniem_100MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10007  .bss:000000000000003f autosync_sms_wyslany.3741
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10000  .bss:000000000000003d autosync_timer_100ms.3742
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10323  .bss:0000000000000056 ostatnia_pierwsza_komenda
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10321  .bss:0000000000000054 licznik_kolejka_stoi_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10315  .bss:000000000000004e licznik_watchdog_wysylanie_smsa_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10004  .progmem.data:0000000000000000 __c.3743
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10317  .bss:0000000000000050 licznik_awaryjnych_resetow_kolejki
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10301  .bss:000000000000004d liczba_kolejnych_watchdogow_wysylania
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10459  .bss:000000000000001c watchdog_sms_trwa_reset
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10454  .bss:000000000000001a watchdog_sms_safe_mode_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:9998   .bss:000000000000003c licznik_dioda_led_poziom_sieci.3747
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:7943   .text:0000000000002a98 steruj_urzadzeniem_10MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:7965   .text:0000000000002aa4 wolne_zdarzenie_timer
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10380  .bss:000000000000000a wykonac_watki
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:9996   .bss:000000000000003b licznik_wybuc_watki_100MS.3754
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:8149   .text:0000000000002b82 ustaw_parametry_dla_bezpieczenstwa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:8187   .text:0000000000002ba2 inicjalizuj_parametry_modulu
                            *COM*:0000000000000004 kod_modulu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10422  .data:0000000000000002 skryba_limit
                             .bss:000000000000003a licznik_resetow.3798
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:8633   .text:0000000000002e44 wykonanie_komend_ukladow
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10020  .progmem.data:000000000000005d tab_eeprom_fabryczny.3646
                            *COM*:0000000000000014 numer_telefonu_skryba
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10016  .progmem.data:000000000000003f __c.3697
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10012  .progmem.data:0000000000000015 __c.3705
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:9827   .text:00000000000034cc wykonanie_komend
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:9858   .text.startup:0000000000000000 main
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10312  .bss:0000000000000001 wysylanie_echa_przez_pdu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10360  .bss:0000000000000006 licznik_reset_urzadzenia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10406  .bss:000000000000000f g_czas_systemowy_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10486  .bss:0000000000000022 licznik_bezpieczenstwa_opoznienie_wysylania_sms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccTd73OI.s:10511  .bss:000000000000002a liczba_smsow_ech_do_wyslania

UNDEFINED SYMBOLS
bufor_eeprom
konwertuj_telefon_na_blok_eeprom
porownaj_numer_telefonu_blok
filtruj_i_dodaj_komende
odebrany_blok_SIM900
strstr_P
bufor_pomoc_liczba_znakow_do_zapisu
liczba_znakow_do_zapisu
czy_zajety_bufor_eeprom
komendy_kolejka
zapisz_znaki_w_eeprom
licznik_wejscie
komenda_SIM900
liczba_odebranych_znakow_SIM900
licznik_opoznienie_oczekiwania_na_bajt_SIM900
sprawdzaj_wejscie_CTS_SIM900
podlaczony_modul_gsm_SIM900
nr_wyslanego_znaku_SIM900
wysylany_blok_SIM900
memcpy_P
strcpy_P
rtc_czas
strcat
poziom_sieci_gsm
__divmodhi4
__utoa_ncheck
eeprom_read_byte
tekst_wysylanego_smsa
czas_start_h
strcpy
czas_stop_m
czas_stop_h
czas_start_m
sprintf
licznik_przelacznik_wyjscia
interpretuj_wiadomosc_sms
bufor_ustaw_czas
dodaj_komende
blokada_sterowania_czasowa
__tablejump2__
konwertuj_blok_eeprom_na_telefon
czy_sa_komendy_z_przedzialu
stan_logiczny_na_wejsciu
wykonywanie_rozmowy_telefonicznej
czekanie_na_odebranie_zachety
liczba_komend_w_kolejce_SIM900
flaga_odebrany_znak_zachety
licznik_100ms_procedura_inicjalizacyjna_SIM900
podlaczona_karta_SIM_SIM900
filtruj_komendy_z_przedzialu
numer_bledu_cms
numer_bledu_cme
strtol
strchr
bledny_PIN
strncmp_P
memcpy
konwertuj_blok_dwa_znaki_na_znak_pdu
liczba_wysylanych_znakow_SIM900
memcmp
strtoul
wyslij_polecenie_ROM_SIM900
zapisz_naglowek_pdu
ascii_to_pdu_blok
wyslij_polecenie_RAM_SIM900
pobierz_numer_telefonu_nadawcy_z_PDU
konwertuj_pdu_na_blok_wysylany
wyslij_znaki_SIM900
pobierz_date_z_PDU
pobierz_czas_z_PDU
pdu_to_ascii
procedura_inicjalizacyjna_SIM900_100MS
czy_jest_nowa_komenda_SIM900
kopiuj_blok_eeprom_na_telefon
aktualizuj_stan_wyzwolenia_wejsc_100ms
steruj_wyjscia_100ms
steruj_wejscia_10ms
zapisz_bajt_w_EEPROM
poczatek_polecenia_SIM900
zakonczenie_polecenia_SIM900
czy_jest_nowe_polecenie_SIM900
eeprom_read_block
eeprom_update_block
eeprom_update_byte
zapisz_znaki_w_eeprom_bez_kopiowania
memset
zapisz_znak_w_eeprom
usun_komende
inicjalizacja_SIM900
__do_copy_data
__do_clear_bss
