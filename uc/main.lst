   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	watchdog_sms_disarm:
  13               	.LFB33:
  14               		.file 1 "main.c"
   1:main.c        **** 
   2:main.c        **** #ifndef INCLUDE
   3:main.c        **** #include "narzedzia.h"
   4:main.c        **** #include <avr/eeprom.h>
   5:main.c        **** #include <avr/interrupt.h>
   6:main.c        **** #include <avr/io.h>
   7:main.c        **** #include <avr/pgmspace.h>
   8:main.c        **** #include <avr/sleep.h>
   9:main.c        **** #include <avr/wdt.h>
  10:main.c        **** #include <ctype.h>
  11:main.c        **** #include <stdio.h>
  12:main.c        **** #include <stdlib.h>
  13:main.c        **** #include <string.h>
  14:main.c        **** #include <util/crc16.h>
  15:main.c        **** #include <util/delay.h>
  16:main.c        **** 
  17:main.c        **** #ifndef TEST_ATMEGA128
  18:main.c        **** #include "pin_ATmega328.h"
  19:main.c        **** #else
  20:main.c        **** #include "pin_ATmega128.h"
  21:main.c        **** #endif
  22:main.c        **** #include "bufpomoc.h"
  23:main.c        **** #include "data_sim900.h"
  24:main.c        **** #include "interpretacjaSMS.h"
  25:main.c        **** #include "komendy.h"
  26:main.c        **** #include "konfiguracja.h"
  27:main.c        **** #include "pdu.h"
  28:main.c        **** #include "sim900.h"
  29:main.c        **** #include "wewy.h"
  30:main.c        **** #include "zapiseeprom.h"
  31:main.c        **** 
  32:main.c        **** #include "test_pcb.h"
  33:main.c        **** 
  34:main.c        **** #endif
  35:main.c        **** 
  36:main.c        **** // static const char nazwa_urzadzenia[12 + 1] PROGMEM = "BRAMA";
  37:main.c        **** 
  38:main.c        **** uchar skryba_wlaczona = FALSE;
  39:main.c        **** uint skryba_limit = 800; // Domyslny limit uzytkownikow dla Skryby
  40:main.c        **** uchar tryb_clip = TRUE;
  41:main.c        **** uint licznik_timeout_rozmowy_100ms = 0;
  42:main.c        **** 
  43:main.c        **** volatile uint32_t g_czas_systemowy_100ms = 0;
  44:main.c        **** 
  45:main.c        **** #define INFORMACJA_W_RAPORCIE "www.sonfy.pl"
  46:main.c        **** 
  47:main.c        **** uchar licznik_100ms_dioda_led;
  48:main.c        **** uchar liczba_blyskow_led = 0;
  49:main.c        **** uchar stan_cyklu_blysku =
  50:main.c        ****     0; // 0-5: 0-1=ON (200ms), 2-5=OFF (400ms), 1 blysk=600ms
  51:main.c        **** 
  52:main.c        **** #define zapal_diode_led(czas_100ms) (licznik_100ms_dioda_led = (czas_100ms) + 1)
  53:main.c        **** #define zapal_diode_led_blyski(liczba)                                         \
  54:main.c        ****   (liczba_blyskow_led = (liczba), stan_cyklu_blysku = 0)
  55:main.c        **** // #define zapal_diode_led(czas_100ms)
  56:main.c        **** 
  57:main.c        **** volatile uchar wykonaj_zdarzenie_timer = FALSE;
  58:main.c        **** #define CZY_WYKONAC_ZDARZENIE_TIMER() wykonaj_zdarzenie_timer
  59:main.c        **** 
  60:main.c        **** #define WYKONAJ_WATKI_BRAK 0
  61:main.c        **** #define WYKONAJ_WATKI_10MS BIT(0)
  62:main.c        **** #define WYKONAJ_WATKI_100MS BIT(1)
  63:main.c        **** volatile uchar wykonac_watki_10MS = FALSE;
  64:main.c        **** uchar wykonac_watki = WYKONAJ_WATKI_BRAK;
  65:main.c        **** #define CZY_WYKONAC_WATKI_10MS() (wykonac_watki & WYKONAJ_WATKI_10MS)
  66:main.c        **** #define CZY_WYKONAC_WATKI_100MS() (wykonac_watki & WYKONAJ_WATKI_100MS)
  67:main.c        **** #define RESETUJ_WYKONANIE_WATKOW() (wykonac_watki = 0)
  68:main.c        **** 
  69:main.c        **** volatile uchar licznik_wybudz_watki_10MS = 0;
  70:main.c        **** #define OPOZNIENIE_TIMERA_0 18
  71:main.c        **** #define czy_pozostal_czas(procent)                                             \
  72:main.c        ****   (licznik_wybudz_watki_10MS < (100 - (procent)) * OPOZNIENIE_TIMERA_0 / 100)
  73:main.c        **** 
  74:main.c        **** przerwanie_timer() {
  75:main.c        ****   if (++licznik_wybudz_watki_10MS >= OPOZNIENIE_TIMERA_0) {
  76:main.c        ****     licznik_wybudz_watki_10MS = 0;
  77:main.c        ****     wykonac_watki_10MS = TRUE;
  78:main.c        ****   }
  79:main.c        **** 
  80:main.c        ****   if (STATUS_WLACZONY_SIM900()) {
  81:main.c        ****     if (!CZY_ODBIERANIE_DANYCH_SIM900() && czy_jest_bezczynny_SIM900()) {
  82:main.c        ****       ustaw_odbior_SIM900();
  83:main.c        ****     }
  84:main.c        ****     if (CZY_HANDSHAKING_CTS_ZEZWALA_NA_TRANSMISJE_SIM900()) {
  85:main.c        ****       cli();
  86:main.c        ****       if (CZY_WYSYLANIE_DANYCH_SIM900()) {
  87:main.c        ****         WYLACZ_PRZERWANIE_WYSYLANIA_DANYCH_SIM900();
  88:main.c        ****         sei();
  89:main.c        ****         uchar p = sprawdzaj_wejscie_CTS_SIM900;
  90:main.c        ****         if (p && (podlaczony_modul_gsm_SIM900 ||
  91:main.c        ****                   aktualnie_wysylane_polecenie_SIM900 ==
  92:main.c        ****                       KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT)) {
  93:main.c        ****           p = FALSE;
  94:main.c        ****           sprawdzaj_wejscie_CTS_SIM900 = p;
  95:main.c        ****           WSTAW_ZNAK_DO_BUFORA_SIM900();
  96:main.c        ****         }
  97:main.c        ****         cli();
  98:main.c        ****         WLACZ_PRZERWANIE_WYSYLANIA_DANYCH_SIM900();
  99:main.c        ****       }
 100:main.c        ****       sei();
 101:main.c        ****     }
 102:main.c        ****   } else {
 103:main.c        ****     zakoncz_przesylanie_SIM900();
 104:main.c        ****   }
 105:main.c        **** 
 106:main.c        ****   wykonaj_zdarzenie_timer =
 107:main.c        ****       TRUE; // uruchamia zdarzenie_timer, ktra korzysta z pozostaych zmiennych
 108:main.c        **** }
 109:main.c        **** 
 110:main.c        **** uchar modul_zalogowany_w_sieci = FALSE;
 111:main.c        **** 
 112:main.c        **** uchar licznik_reset_modulu_SIM900 = 0;
 113:main.c        **** #define START_LICZNIK_RESET_MODULU_SIM900 30
 114:main.c        **** 
 115:main.c        **** uchar licznik_reset_urzadzenia = 0;
 116:main.c        **** #define LICZNIK_RESET_URZADZENIA_RESET_SIM900 200
 117:main.c        **** #define START_LICZNIK_RESET_URZADZENIA 220
 118:main.c        **** 
 119:main.c        **** uint opoznienie_wysylania_clipow_100MS = 0;
 120:main.c        **** 
 121:main.c        **** void generuj_raport_sieci(uchar **buf_sms) {
 122:main.c        ****   static const char tekst_gsm[] PROGMEM = "AC800-TS";
 123:main.c        ****   uchar *ptr = *buf_sms;
 124:main.c        **** 
 125:main.c        ****   memcpy_R(ptr, tekst_gsm);
 126:main.c        ****   ptr += sizeof tekst_gsm - 1;
 127:main.c        ****   *ptr++ = '\n';
 128:main.c        **** 
 129:main.c        ****   strcpy_P((char *)ptr, PSTR("Czas: "));
 130:main.c        ****   ptr += strlen((char *)ptr);
 131:main.c        ****   strcat((char *)ptr, rtc_czas);
 132:main.c        ****   ptr += strlen((char *)ptr);
 133:main.c        ****   *ptr++ = '\n';
 134:main.c        **** 
 135:main.c        ****   static const char text_sygnal[] PROGMEM = "Sygnal GSM ";
 136:main.c        ****   memcpy_R(ptr, text_sygnal);
 137:main.c        ****   ptr += sizeof text_sygnal - 1;
 138:main.c        **** 
 139:main.c        ****   if (poziom_sieci_gsm <= 31 && modul_zalogowany_w_sieci) {
 140:main.c        ****     utoa(poziom_sieci_gsm * 100 / 31, ptr, 10);
 141:main.c        ****     ptr += strlen(ptr);
 142:main.c        ****     *ptr++ = '%';
 143:main.c        ****   } else {
 144:main.c        ****     *ptr++ = '-';
 145:main.c        ****     *ptr++ = '-';
 146:main.c        ****     *ptr++ = '-';
 147:main.c        ****   }
 148:main.c        ****   *ptr = 0;
 149:main.c        ****   *buf_sms = ptr;
 150:main.c        **** }
 151:main.c        **** 
 152:main.c        **** void generuj_raport_uzytkownikow_1(uchar **buf_sms) {
 153:main.c        ****   static const char tekst_gsm[] PROGMEM = "Uzytkownicy ";
 154:main.c        ****   uchar *ptr = *buf_sms;
 155:main.c        **** 
 156:main.c        ****   memcpy_R(ptr, tekst_gsm);
 157:main.c        ****   ptr += sizeof tekst_gsm - 1;
 158:main.c        ****   uint aktywne_numery = 0;
 159:main.c        ****   uint wolne_numery = 0;
 160:main.c        ****   // for (uchar nr_uzyt_clip = 0; nr_uzyt_clip <
 161:main.c        ****   // MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip)
 162:main.c        ****   for (uint nr_uzyt_clip = 0; nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 163:main.c        ****        ++nr_uzyt_clip) {
 164:main.c        ****     if (czy_aktywny_numer_telefonu_brama(nr_uzyt_clip))
 165:main.c        ****       ++aktywne_numery;
 166:main.c        ****     else
 167:main.c        ****       ++wolne_numery;
 168:main.c        ****   }
 169:main.c        **** 
 170:main.c        ****   utoa(aktywne_numery, ptr, 10);
 171:main.c        ****   ptr += strlen(ptr);
 172:main.c        ****   *ptr++ = '/';
 173:main.c        ****   utoa(wolne_numery, ptr, 10);
 174:main.c        ****   ptr += strlen(ptr);
 175:main.c        ****   *buf_sms = ptr;
 176:main.c        **** }
 177:main.c        **** 
 178:main.c        **** void generuj_raport_uzytkownikow(uchar **buf_sms) {
 179:main.c        ****   static const char tekst_gsm[] PROGMEM = "Uzytkownicy ";
 180:main.c        ****   uchar *ptr = *buf_sms;
 181:main.c        **** 
 182:main.c        ****   memcpy_R(ptr, tekst_gsm);
 183:main.c        ****   ptr += sizeof tekst_gsm - 1;
 184:main.c        ****   uchar aktywne_numery = 0;
 185:main.c        ****   uchar wolne_numery = 0;
 186:main.c        ****   for (uint nr_uzyt_clip = 0; nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 187:main.c        ****        ++nr_uzyt_clip) {
 188:main.c        ****     if (czy_aktywny_numer_telefonu_brama(nr_uzyt_clip))
 189:main.c        ****       ++aktywne_numery;
 190:main.c        ****     else
 191:main.c        ****       ++wolne_numery;
 192:main.c        ****   }
 193:main.c        ****   utoa(aktywne_numery, ptr, 10);
 194:main.c        ****   ptr += strlen(ptr);
 195:main.c        ****   *ptr++ = '/';
 196:main.c        ****   utoa(wolne_numery, ptr, 10);
 197:main.c        ****   ptr += strlen(ptr);
 198:main.c        ****   *buf_sms = ptr;
 199:main.c        **** }
 200:main.c        **** 
 201:main.c        **** uchar blokada_systemu = FALSE; // Nowa zmienna globalna
 202:main.c        **** uchar tryb_pracy = 1;          // 0=Prywatny, 1=Publiczny (domyślnie Publiczny)
 203:main.c        **** 
 204:main.c        **** void generuj_raport_stanu_urzadzenia(void) {
 205:main.c        ****   uchar *sms = (char *)tekst_wysylanego_smsa;
 206:main.c        ****   *sms++ = '*';
 207:main.c        ****   *sms++ = '\n';
 208:main.c        ****   generuj_raport_sieci(&sms);
 209:main.c        ****   *sms++ = '\n';
 210:main.c        ****   generuj_raport_uzytkownikow_1(&sms);
 211:main.c        ****   *sms++ = '\n';
 212:main.c        **** 
 213:main.c        ****   // Status sterownika (START/STOP)
 214:main.c        ****   if (blokada_systemu) {
 215:main.c        ****     strcpy_P((char *)sms, PSTR("Status: Zablokowany"));
 216:main.c        ****   } else {
 217:main.c        ****     strcpy_P((char *)sms, PSTR("Status: Aktywny"));
 218:main.c        ****   }
 219:main.c        ****   sms += strlen((char *)sms);
 220:main.c        ****   *sms++ = '\n';
 221:main.c        **** 
 222:main.c        ****   // Tryb pracy (OPEN/CLOSE)
 223:main.c        ****   if (tryb_pracy == 0) {
 224:main.c        ****     strcpy_P((char *)sms, PSTR("Tryb: Prywatny"));
 225:main.c        ****   } else {
 226:main.c        ****     strcpy_P((char *)sms, PSTR("Tryb: Publiczny"));
 227:main.c        ****   }
 228:main.c        ****   sms += strlen((char *)sms);
 229:main.c        **** 
 230:main.c        ****   if (tryb_clip) {
 231:main.c        ****     strcpy_P((char *)sms, PSTR(" CLIP"));
 232:main.c        ****   } else {
 233:main.c        ****     strcpy_P((char *)sms, PSTR(" DTMF"));
 234:main.c        ****   }
 235:main.c        ****   sms += strlen((char *)sms);
 236:main.c        ****   *sms++ = '\n';
 237:main.c        **** 
 238:main.c        ****   if (czas_start_h == 0xFF) {
 239:main.c        ****     strcpy_P((char *)sms, PSTR("Harmonogram: Wylaczony"));
 240:main.c        ****   } else {
 241:main.c        ****     sprintf((char *)sms, "Harmonogram: %02d:%02d %02d:%02d", (int)czas_start_h,
 242:main.c        ****             (int)czas_start_m, (int)czas_stop_h, (int)czas_stop_m);
 243:main.c        ****   }
 244:main.c        ****   sms += strlen((char *)sms);
 245:main.c        ****   *sms++ = '\n';
 246:main.c        **** 
 247:main.c        ****   if (skryba_wlaczona) {
 248:main.c        ****     uint aktywne_numery = 0;
 249:main.c        ****     for (uint nr_uzyt_clip = 0;
 250:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 251:main.c        ****       if (czy_aktywny_numer_telefonu_brama(nr_uzyt_clip))
 252:main.c        ****         ++aktywne_numery;
 253:main.c        ****     }
 254:main.c        ****     int pozostalo = (int)skryba_limit - (int)aktywne_numery;
 255:main.c        ****     if (pozostalo < 0)
 256:main.c        ****       pozostalo = 0;
 257:main.c        ****     sprintf((char *)sms, "Skryba: Limit %d", pozostalo);
 258:main.c        ****   } else {
 259:main.c        ****     strcpy_P((char *)sms, PSTR("Skryba: Wylaczony"));
 260:main.c        ****   }
 261:main.c        ****   sms += strlen((char *)sms);
 262:main.c        ****   *sms++ = '\n';
 263:main.c        **** 
 264:main.c        ****   static const char tekst_demo[] PROGMEM = INFORMACJA_W_RAPORCIE;
 265:main.c        ****   strcpy_P((char *)sms, tekst_demo);
 266:main.c        **** }
 267:main.c        **** 
 268:main.c        **** void ustaw_wyjscie_clip(void) {
 269:main.c        ****   stan_wyjscie[0] = TRUE;
 270:main.c        ****   licznik_przelacznik_wyjscia[0] = 2 * 10ul; // 2 sekundy
 271:main.c        **** }
 272:main.c        **** 
 273:main.c        **** uchar kod_modulu[LICZBA_BAJTOW_KODU_DOSTEPU];
 274:main.c        **** 
 275:main.c        **** uchar nie_wysylaj_echa_z_powodu_nietypowego_smsa;
 276:main.c        **** 
 277:main.c        **** uchar numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama;
 278:main.c        **** uchar numer_telefonu_skryba[20];
 279:main.c        **** 
 280:main.c        **** // Blokada komend REPORT/USER - maksymalnie 8 w ciągu 30 sekund
 281:main.c        **** static uchar licznik_report_user = 0;
 282:main.c        **** static uint timer_report_user_100ms = 0;
 283:main.c        **** #define MAX_LICZBA_KOMEND_REPORT_USER_W_OKNIE 8
 284:main.c        **** #define OKNO_CZASOWE_REPORT_USER_100MS (30 * 10) // 30 sekund
 285:main.c        **** 
 286:main.c        **** // Mechanizm wykrywania zablokowanej kolejki i czyszczenia
 287:main.c        **** static komenda_typ ostatnia_pierwsza_komenda = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 288:main.c        **** static uint licznik_kolejka_stoi_100ms = 0;
 289:main.c        **** #define MAX_CZAS_KOLEJKA_STOI_100MS                                            \
 290:main.c        ****   (15 * 10) // 15 sekund - jesli kolejka stoi tyle czasu, wyczysc
 291:main.c        **** 
 292:main.c        **** static uint licznik_usunietych_sms_przez_limit = 0;
 293:main.c        **** static uint licznik_awaryjnych_resetow_kolejki = 0;
 294:main.c        **** 
 295:main.c        **** #define WATCHDOG_WYSYLANIA_SMS_100MS (30 * 10) // 30 sekund
 296:main.c        **** static uint licznik_watchdog_wysylanie_smsa_100ms = 0;
 297:main.c        **** static uchar liczba_kolejnych_watchdogow_wysylania = 0;
 298:main.c        **** #define WATCHDOG_SMS_TIMEOUT_100MS (10 * 10) // 10 sekund
 299:main.c        **** #define WATCHDOG_SMS_SAFE_MODE_100MS                                           \
 300:main.c        ****   (5 * 10) // 5 sekund po resecie - nie przyjmuj SMS
 301:main.c        **** 
 302:main.c        **** static inline void watchdog_sms_arm(void) {
 303:main.c        ****   watchdog_sms_aktywny = TRUE;
 304:main.c        ****   watchdog_sms_licznik_100ms = 0;
 305:main.c        **** }
 306:main.c        **** 
 307:main.c        **** static inline void watchdog_sms_disarm(void) {
  15               		.loc 1 307 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 308:main.c        ****   watchdog_sms_aktywny = FALSE;
  21               		.loc 1 308 0
  22 0000 1092 0000 		sts watchdog_sms_aktywny,__zero_reg__
 309:main.c        ****   watchdog_sms_licznik_100ms = 0;
  23               		.loc 1 309 0
  24 0004 1092 0000 		sts watchdog_sms_licznik_100ms+1,__zero_reg__
  25 0008 1092 0000 		sts watchdog_sms_licznik_100ms,__zero_reg__
  26               	/* epilogue start */
 310:main.c        **** }
  27               		.loc 1 310 0
  28 000c 0895      		ret
  29               		.cfi_endproc
  30               	.LFE33:
  33               	czy_numer_istnieje:
  34               	.LFB57:
 311:main.c        **** 
 312:main.c        **** static inline void sygnalizuj_pelny_system(void) {
 313:main.c        ****   // 10 szybkich blyskow informuje, ze kolejka/limit SMS jest zapelniony
 314:main.c        ****   zapal_diode_led_blyski(10);
 315:main.c        **** }
 316:main.c        **** 
 317:main.c        **** // Funkcja usuwania zablokowanego SMS z modulu SIM900
 318:main.c        **** static void usun_zablokowany_sms(void) {
 319:main.c        ****   // Usun SMS z modulu SIM900 (numer jest w aktualnie_wysylane_polecenie_SIM900)
 320:main.c        ****   // Sprawdzamy czy to byla komenda odczytu SMS
 321:main.c        ****   if (aktualnie_wysylane_polecenie_SIM900 >= KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 322:main.c        ****       aktualnie_wysylane_polecenie_SIM900 <= KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 323:main.c        ****     const uchar nr_smsa =
 324:main.c        ****         aktualnie_wysylane_polecenie_SIM900 - KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1;
 325:main.c        ****     // Uzywamy filtruj_i_dodaj_komende zamiast dodaj_komende
 326:main.c        ****     filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_USUN_SMSA_1 + nr_smsa);
 327:main.c        ****   } else {
 328:main.c        ****     // Fallback: Usun wszystkie
 329:main.c        ****     filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 330:main.c        ****   }
 331:main.c        **** }
 332:main.c        **** 
 333:main.c        **** static void zareaguj_na_usuniety_sms_z_powodu_limitu(void) {
 334:main.c        ****   if (licznik_usunietych_sms_przez_limit < 0xFFFF)
 335:main.c        ****     ++licznik_usunietych_sms_przez_limit;
 336:main.c        ****   sygnalizuj_pelny_system();
 337:main.c        ****   watchdog_sms_disarm();
 338:main.c        ****   // Uzywamy filtruj_i_dodaj
 339:main.c        ****   filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 340:main.c        **** }
 341:main.c        **** 
 342:main.c        **** // Funkcja zapisu znacznikow debugowania do EEPROM
 343:main.c        **** static void zapisz_debug_do_eeprom(uchar komenda, uchar akcja) {
 344:main.c        ****   if (!czy_wolny_eeprom())
 345:main.c        ****     return;
 346:main.c        **** 
 347:main.c        ****   uchar buf[8];
 348:main.c        ****   buf[0] = licznik_report_user;
 349:main.c        ****   buf[1] = (uchar)(timer_report_user_100ms & 0xFF);
 350:main.c        ****   buf[2] = (uchar)((timer_report_user_100ms >> 8) & 0xFF);
 351:main.c        ****   buf[3] = (uchar)flaga_wysylanie_smsa;
 352:main.c        **** 
 353:main.c        ****   uchar liczba_sms_w_kolejce = 0;
 354:main.c        ****   for (uchar i = 0; i < LICZBA_KOMEND; ++i) {
 355:main.c        ****     if (komendy_kolejka[i] >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
 356:main.c        ****         komendy_kolejka[i] <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
 357:main.c        ****       ++liczba_sms_w_kolejce;
 358:main.c        ****   }
 359:main.c        ****   buf[4] = liczba_sms_w_kolejce;
 360:main.c        ****   buf[5] = komenda;
 361:main.c        ****   buf[6] = akcja;
 362:main.c        **** 
 363:main.c        ****   zapisz_znaki_w_eeprom(buf, EEPROM_DEBUG_START, 7);
 364:main.c        **** }
 365:main.c        **** 
 366:main.c        **** void wykonanie_polecenia_sms(void) {
 367:main.c        ****   tekst_odebranego_smsa[MAX_LICZBA_ZNAKOW_SMS] = 0; // (1) dla pewnoci
 368:main.c        ****   uchar komenda = interpretuj_wiadomosc_sms(tekst_odebranego_smsa);
 369:main.c        **** 
 370:main.c        ****   // --- BLOKADA SYSTEMU (START/STOP) ---
 371:main.c        ****   if (blokada_systemu) {
 372:main.c        ****     // Gdy zablokowany, akceptuj tylko START i REPORT
 373:main.c        ****     if (komenda != INTERPRETACJA_SMS_POPRAWNY && // START/STOP zwracaja POPRAWNY
 374:main.c        ****         komenda != INTERPRETACJA_SMS_RAPORT) {
 375:main.c        ****       // Sprawdz czy to byla komenda START (ktora wlasnie odblokowala system)
 376:main.c        ****       // Jesli system nadal jest zablokowany (czyli to nie byl START), to
 377:main.c        ****       // ignoruj
 378:main.c        ****       if (eeprom_read_byte((const uint8_t *)ADRES_EEPROM_BLOKADA_SYSTEMU) ==
 379:main.c        ****           1) {
 380:main.c        ****         zapisz_debug_do_eeprom(1, 2); // Debug: Odrzucono przez blokade
 381:main.c        ****         usun_zablokowany_sms();
 382:main.c        ****         return;
 383:main.c        ****       }
 384:main.c        ****     }
 385:main.c        ****   }
 386:main.c        **** 
 387:main.c        ****   // --- WARSTWA 1: Limit czasowy (Rate Limiting) - V7 style ---
 388:main.c        ****   if (komenda == INTERPRETACJA_SMS_RAPORT ||
 389:main.c        ****       komenda == INTERPRETACJA_SMS_USER) {
 390:main.c        ****     if (licznik_report_user >= MAX_LICZBA_KOMEND_REPORT_USER_W_OKNIE) {
 391:main.c        ****       zapisz_debug_do_eeprom(1, 1);
 392:main.c        ****       usun_zablokowany_sms();
 393:main.c        ****       zareaguj_na_usuniety_sms_z_powodu_limitu();
 394:main.c        ****       watchdog_sms_disarm();
 395:main.c        ****       return;
 396:main.c        ****     }
 397:main.c        ****   }
 398:main.c        **** 
 399:main.c        ****   // --- WARSTWA 2: Sprawdzenie zajętości modemu (Busy Check) ---
 400:main.c        ****   if (flaga_wysylanie_smsa) {
 401:main.c        ****     // Same number check
 402:main.c        ****     if (strcmp((char *)numer_telefonu_odebranego_smsa,
 403:main.c        ****                (char *)numer_telefonu_wysylanego_smsa) == 0) {
 404:main.c        ****       zapisz_debug_do_eeprom(1, 1);
 405:main.c        ****       usun_zablokowany_sms();
 406:main.c        ****       zareaguj_na_usuniety_sms_z_powodu_limitu();
 407:main.c        ****       watchdog_sms_disarm();
 408:main.c        ****       return;
 409:main.c        ****     }
 410:main.c        ****     // Different number but busy
 411:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 412:main.c        ****     usun_zablokowany_sms();
 413:main.c        ****     zareaguj_na_usuniety_sms_z_powodu_limitu();
 414:main.c        ****     watchdog_sms_disarm();
 415:main.c        ****     return;
 416:main.c        ****   }
 417:main.c        **** 
 418:main.c        ****   // --- WARSTWA 3 i 4: Ochrona kolejki ---
 419:main.c        ****   uchar liczba_sms_w_kolejce = 0;
 420:main.c        ****   uchar liczba_wszystkich_komend = 0;
 421:main.c        ****   for (uchar i = 0; i < LICZBA_KOMEND; ++i) {
 422:main.c        ****     if (komendy_kolejka[i] != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 423:main.c        ****       ++liczba_wszystkich_komend;
 424:main.c        ****       if (komendy_kolejka[i] >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
 425:main.c        ****           komendy_kolejka[i] <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
 426:main.c        ****         ++liczba_sms_w_kolejce;
 427:main.c        ****     }
 428:main.c        ****   }
 429:main.c        **** 
 430:main.c        ****   if (liczba_wszystkich_komend >= 35) {
 431:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 432:main.c        ****     usun_zablokowany_sms();
 433:main.c        ****     zareaguj_na_usuniety_sms_z_powodu_limitu();
 434:main.c        ****     watchdog_sms_disarm();
 435:main.c        ****     return;
 436:main.c        ****   }
 437:main.c        **** 
 438:main.c        ****   if (liczba_sms_w_kolejce >= 6) {
 439:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 440:main.c        ****     usun_zablokowany_sms();
 441:main.c        ****     zareaguj_na_usuniety_sms_z_powodu_limitu();
 442:main.c        ****     watchdog_sms_disarm();
 443:main.c        ****     return;
 444:main.c        ****   }
 445:main.c        **** 
 446:main.c        ****   switch (komenda) {
 447:main.c        ****   case INTERPRETACJA_SMS_POPRAWNY:
 448:main.c        ****     zapal_diode_led_blyski(2); // Odbior poprawnej komendy - 2 blyski
 449:main.c        ****     break;
 450:main.c        ****   case INTERPRETACJA_SMS_BRAK_KODU: {
 451:main.c        ****     zapal_diode_led_blyski(1); // Odbior zwyklego SMS (bez kodu) - 1 blysk
 452:main.c        ****     zapisz_debug_do_eeprom(0, 3);
 453:main.c        ****     break;
 454:main.c        ****   }
 455:main.c        ****   case INTERPRETACJA_SMS_RAPORT: {
 456:main.c        ****     ++licznik_report_user;
 457:main.c        ****     timer_report_user_100ms = OKNO_CZASOWE_REPORT_USER_100MS;
 458:main.c        **** 
 459:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 460:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 461:main.c        ****     generuj_raport_stanu_urzadzenia();
 462:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 463:main.c        ****     zapal_diode_led_blyski(2); // Komenda REPORT - 2 blyski
 464:main.c        ****     zapisz_debug_do_eeprom(1, 0);
 465:main.c        ****     break;
 466:main.c        ****   }
 467:main.c        ****   case INTERPRETACJA_SMS_DEBUG: {
 468:main.c        ****     // DEBUG - wyślij flagi debug dla SKRYBA i USER
 469:main.c        ****     strcpy_P((char *)tekst_wysylanego_smsa, PSTR("DEBUG\n"));
 470:main.c        ****     uchar *sms = tekst_wysylanego_smsa + strlen((char *)tekst_wysylanego_smsa);
 471:main.c        **** 
 472:main.c        ****     // SKRYBA DEBUG
 473:main.c        ****     strcpy_P((char *)sms, PSTR("SKRYBA:"));
 474:main.c        ****     sms += strlen((char *)sms);
 475:main.c        ****     *sms++ =
 476:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_2);
 477:main.c        ****     *sms++ =
 478:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_3);
 479:main.c        ****     *sms++ =
 480:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_4);
 481:main.c        ****     *sms++ =
 482:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_5);
 483:main.c        ****     *sms++ = '\n';
 484:main.c        **** 
 485:main.c        ****     // USER DEBUG - wyświetl jako liczby dziesiętne
 486:main.c        ****     strcpy_P((char *)sms, PSTR("U1="));
 487:main.c        ****     sms += strlen((char *)sms);
 488:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_1), sms, 10);
 489:main.c        ****     sms += strlen((char *)sms);
 490:main.c        **** 
 491:main.c        ****     strcpy_P((char *)sms, PSTR(" U2="));
 492:main.c        ****     sms += strlen((char *)sms);
 493:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_2), sms, 10);
 494:main.c        ****     sms += strlen((char *)sms);
 495:main.c        **** 
 496:main.c        ****     strcpy_P((char *)sms, PSTR(" U3="));
 497:main.c        ****     sms += strlen((char *)sms);
 498:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_3), sms, 10);
 499:main.c        ****     sms += strlen((char *)sms);
 500:main.c        ****     *sms++ = '\n';
 501:main.c        **** 
 502:main.c        ****     strcpy_P((char *)sms, PSTR("U4="));
 503:main.c        ****     sms += strlen((char *)sms);
 504:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_4), sms, 10);
 505:main.c        ****     sms += strlen((char *)sms);
 506:main.c        **** 
 507:main.c        ****     strcpy_P((char *)sms, PSTR(" U5="));
 508:main.c        ****     sms += strlen((char *)sms);
 509:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_5), sms, 10);
 510:main.c        ****     sms += strlen((char *)sms);
 511:main.c        **** 
 512:main.c        ****     strcpy_P((char *)sms, PSTR(" U6="));
 513:main.c        ****     sms += strlen((char *)sms);
 514:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_6), sms, 10);
 515:main.c        ****     sms += strlen((char *)sms);
 516:main.c        **** 
 517:main.c        ****     strcpy_P((char *)sms, PSTR(" U7="));
 518:main.c        ****     sms += strlen((char *)sms);
 519:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_7), sms, 10);
 520:main.c        ****     sms += strlen((char *)sms);
 521:main.c        ****     *sms++ = '\n';
 522:main.c        **** 
 523:main.c        ****     strcpy_P((char *)sms, PSTR("1=RCV 2=BSY 3=CNT 4=QSM 5=QAL 6=FND 7=ADD"));
 524:main.c        **** 
 525:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 526:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 527:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 528:main.c        ****     zapal_diode_led_blyski(2);
 529:main.c        ****     break;
 530:main.c        ****   }
 531:main.c        ****   case INTERPRETACJA_SMS_USER: {
 532:main.c        ****     ++licznik_report_user;
 533:main.c        ****     timer_report_user_100ms = OKNO_CZASOWE_REPORT_USER_100MS;
 534:main.c        **** 
 535:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 536:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 537:main.c        **** 
 538:main.c        ****     // Uzyj lokalnego bufora aby uniknac konfliktow z EEPROM
 539:main.c        ****     uchar temp_buf[10];
 540:main.c        **** 
 541:main.c        ****     // Konwertuj numer na format EEPROM
 542:main.c        ****     konwertuj_telefon_na_blok_eeprom(
 543:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
 544:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[strlen(
 545:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
 546:main.c        ****         temp_buf);
 547:main.c        **** 
 548:main.c        ****     // Sprawdz czy numer jest na liscie
 549:main.c        ****     uchar znaleziono = FALSE;
 550:main.c        ****     for (uint nr_uzyt_clip = 0;
 551:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 552:main.c        ****       if (porownaj_numer_telefonu_blok(
 553:main.c        ****               temp_buf, (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
 554:main.c        ****         znaleziono = TRUE;
 555:main.c        ****         break;
 556:main.c        ****       }
 557:main.c        ****     }
 558:main.c        **** 
 559:main.c        ****     // Przygotuj odpowiedz z numerem telefonu i statusem
 560:main.c        ****     strcpy((char *)tekst_wysylanego_smsa,
 561:main.c        ****            (char *)numer_telefonu_do_ktorego_dzwonic);
 562:main.c        ****     strcat((char *)tekst_wysylanego_smsa, ": ");
 563:main.c        ****     if (znaleziono) {
 564:main.c        ****       strcat((char *)tekst_wysylanego_smsa, "OK");
 565:main.c        ****     } else {
 566:main.c        ****       strcat((char *)tekst_wysylanego_smsa, "Brak takiego numeru w systemie");
 567:main.c        ****     }
 568:main.c        **** 
 569:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 570:main.c        **** 
 571:main.c        ****     zapal_diode_led_blyski(2); // Komenda USER - 2 blyski
 572:main.c        **** 
 573:main.c        ****     // Zapisz debug tylko na koncu (bezpiecznie)
 574:main.c        ****     // U1=1 (USER), U6=znaleziono
 575:main.c        ****     if (czy_wolny_eeprom()) {
 576:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 577:main.c        ****       // Ale poniewaz zapisz_znak_w_eeprom uzywa przerwan, nie mozemy wolac go
 578:main.c        ****       // od razu drugi raz Mozemy zapisac skondensowana informacje lub uzyc
 579:main.c        ****       // bufora Dla bezpieczenstwa zapiszmy tylko jeden bajt statusu Bit 0:
 580:main.c        ****       // znaleziono, Bit 1: USER wykonany zapisz_znak_w_eeprom(znaleziono |
 581:main.c        ****       // 0x02, ADRES_EEPROM_DEBUG_USER_6);
 582:main.c        ****     }
 583:main.c        ****     zapisz_debug_do_eeprom(2, znaleziono); // 2 = USER
 584:main.c        ****     break;
 585:main.c        ****   }
 586:main.c        ****   case INTERPRETACJA_SMS_USER_BEZ_NUMERU: {
 587:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 588:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 589:main.c        ****     strcpy((char *)tekst_wysylanego_smsa,
 590:main.c        ****            "Wpisz numer jaki sprawdzasz, np: USER 793557357");
 591:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 592:main.c        ****     zapal_diode_led_blyski(2);
 593:main.c        ****     break;
 594:main.c        ****   }
 595:main.c        ****   case INTERPRETACJA_SMS_USER_LIST: {
 596:main.c        ****     strcpy((char *)numer_telefonu_wysylanego_smsa,
 597:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 598:main.c        ****     numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama = 0;
 599:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW);
 600:main.c        ****     zapal_diode_led_blyski(2);
 601:main.c        ****     break;
 602:main.c        ****   }
 603:main.c        ****   case INTERPRETACJA_SMS_RESET_WSZYSTKICH_USTAWIEN: {
 604:main.c        ****     if (not czy_sa_komendy_z_przedzialu(
 605:main.c        ****             KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 606:main.c        ****             KOMENDA_KOLEJKI_RESET_USTAWIEN_INICJALIZACJA)) {
 607:main.c        ****       zapal_diode_led_blyski(25);
 608:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
 609:main.c        ****     }
 610:main.c        ****     break;
 611:main.c        ****   }
 612:main.c        ****   default:
 613:main.c        ****     break;
 614:main.c        ****   }
 615:main.c        ****   watchdog_sms_disarm();
 616:main.c        **** }
 617:main.c        **** 
 618:main.c        **** void steruj_wejsciem_reset_100ms(void) {
 619:main.c        ****   static uchar licznik_reset;
 620:main.c        ****   if (CZY_AKTUALNY_STAN_LOGICZNY_ON(0)) {
 621:main.c        ****     if (licznik_reset < 20 * 10)
 622:main.c        ****       ++licznik_reset;
 623:main.c        ****   } else {
 624:main.c        ****     if (licznik_reset >= 20 * 10) {
 625:main.c        ****       if (not czy_sa_komendy_z_przedzialu(
 626:main.c        ****               KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 627:main.c        ****               KOMENDA_KOLEJKI_RESET_USTAWIEN_INICJALIZACJA))
 628:main.c        ****         dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
 629:main.c        ****     } else if (licznik_reset >= 5 * 10) {
 630:main.c        ****       if (not czy_sa_komendy_z_przedzialu(
 631:main.c        ****               KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 632:main.c        ****               KOMENDA_KOLEJKI_RESET_USTAWIEN_INICJALIZACJA))
 633:main.c        ****         dodaj_komende(KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU);
 634:main.c        ****     }
 635:main.c        ****     licznik_reset = 0;
 636:main.c        ****   }
 637:main.c        **** }
 638:main.c        **** 
 639:main.c        **** uchar sprawdz_przychodzaca_rozmowe(void) // wysya TRUE, gdy naley odebra
 640:main.c        **** {
 641:main.c        ****   if (blokada_systemu) {
 642:main.c        ****     return FALSE; // Ignoruj rozmowy gdy system zablokowany
 643:main.c        ****   }
 644:main.c        **** 
 645:main.c        ****   // W trybie DTMF:
 646:main.c        ****   if (!tryb_clip) {
 647:main.c        ****     if (numer_telefonu_ktory_dzwoni[0] != 0)
 648:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA);
 649:main.c        **** 
 650:main.c        ****     // Publiczny: odbierz wszystkie
 651:main.c        ****     if (tryb_pracy == 1)
 652:main.c        ****       return TRUE;
 653:main.c        **** 
 654:main.c        ****     // Prywatny: sprawdź autoryzację SYNCHRONICZNIE
 655:main.c        ****     // Konwertuj numer na format EEPROM
 656:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_ktory_dzwoni[0],
 657:main.c        ****                                      &numer_telefonu_ktory_dzwoni[strlen(
 658:main.c        ****                                          (char *)numer_telefonu_ktory_dzwoni)],
 659:main.c        ****                                      &bufor_eeprom[0]);
 660:main.c        **** 
 661:main.c        ****     // Sprawdź listę autoryzowanych numerów
 662:main.c        ****     for (uint nr_uzyt = 0; nr_uzyt < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 663:main.c        ****          ++nr_uzyt) {
 664:main.c        ****       if (porownaj_numer_telefonu_blok(
 665:main.c        ****               &bufor_eeprom[0], (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt))) {
 666:main.c        ****         return TRUE; // Numer autoryzowany - odbierz
 667:main.c        ****       }
 668:main.c        ****     }
 669:main.c        ****     return FALSE; // Numer nieautoryzowany - odrzuć
 670:main.c        ****   }
 671:main.c        **** 
 672:main.c        ****   // W trybie CLIP:
 673:main.c        ****   if (numer_telefonu_ktory_dzwoni[0] != 0)
 674:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA);
 675:main.c        **** 
 676:main.c        ****   // Publiczny: włącz wyjście dla wszystkich
 677:main.c        ****   if (tryb_pracy == 1)
 678:main.c        ****     return TRUE;
 679:main.c        **** 
 680:main.c        ****   // Prywatny: sprawdź autoryzację
 681:main.c        ****   return FALSE; // Autoryzacja przez SPRAWDZ_UZYTKOWNIKOW_BRAMA
 682:main.c        **** }
 683:main.c        **** 
 684:main.c        **** uchar wysylanie_echa_przez_pdu = FALSE;
 685:main.c        **** 
 686:main.c        **** uchar *ptr_start_pdu_z_wiadomoscia; // pierwszy znak
 687:main.c        **** 
 688:main.c        **** #define WYSYLANIE_SMSA_CLIPA_BRAK 0
 689:main.c        **** #define WYSYLANIE_SMSA_WYSYLANIE 1
 690:main.c        **** #define WYSYLANIE_SMSA_POWTARZANIE 2
 691:main.c        **** #define WYSYLANIE_CLIPA_WYSYLANIE 4
 692:main.c        **** #define WYSYLANIE_CLIPA_KONCZENIE 5
 693:main.c        **** 
 694:main.c        **** uchar wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
 695:main.c        **** 
 696:main.c        **** enum PowodZakonczeniaRozmowyTelefonicznej {
 697:main.c        ****   powod_zakonczenia_rozmowy_odrzucenie,
 698:main.c        ****   powod_zakonczenia_rozmowy_zakonczenie,
 699:main.c        ****   powod_zakonczenia_rozmowy_przekroczony_czas,
 700:main.c        ****   powod_zakonczenia_rozmowy_otrzymana_wiadomosc
 701:main.c        **** };
 702:main.c        **** 
 703:main.c        **** void zakonczono_rozmowe_telefoniczna(
 704:main.c        ****     const enum PowodZakonczeniaRozmowyTelefonicznej powod) {
 705:main.c        ****   POMOC_DODAJ2('#', 'a');
 706:main.c        ****   opoznienie_SIM900_100MS = 60; // byo 60
 707:main.c        ****   licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 708:main.c        ****   ustaw_maksymalny_czas_dzwonienia = 0;
 709:main.c        ****   maksymalny_czas_dzwonienia = 0;
 710:main.c        ****   blokada_clip = FALSE;
 711:main.c        **** }
 712:main.c        **** 
 713:main.c        **** enum PowodZakonczeniaWysylaniaSMS {
 714:main.c        ****   zakonczenie_wysylania_sms_ok,
 715:main.c        ****   zakonczenie_wysylania_sms_blad_powtarzanie,
 716:main.c        ****   zakonczenie_wysylania_sms_blad_zakonczenie,
 717:main.c        ****   zakonczenie_wysylania_sms_blad_powtorz_sms,
 718:main.c        **** };
 719:main.c        **** 
 720:main.c        **** void zakonczono_wysylanie_smsa(const enum PowodZakonczeniaWysylaniaSMS powod) {
 721:main.c        ****   POMOC_DODAJ2('#', 'A');
 722:main.c        ****   opoznienie_SIM900_100MS = 60;
 723:main.c        **** 
 724:main.c        ****   wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
 725:main.c        **** }
 726:main.c        **** 
 727:main.c        **** void problem_z_wyslaniem_powiadomienia(void) {
 728:main.c        ****   wykonywanie_rozmowy_telefonicznej = FALSE;
 729:main.c        ****   licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 730:main.c        ****   wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 731:main.c        ****   czekanie_na_odebranie_zachety = FALSE;
 732:main.c        ****   opoznienie_SIM900_100MS = 60;
 733:main.c        ****   flaga_wysylanie_smsa = 0;
 734:main.c        **** }
 735:main.c        **** 
 736:main.c        **** #define JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ()                             \
 737:main.c        ****   if (!czy_mozna_wysylac_dane_do_SIM900) {                                     \
 738:main.c        ****     dodaj_komende(wykonywana_komenda);                                         \
 739:main.c        ****     break;                                                                     \
 740:main.c        ****   }                                                                            \
 741:main.c        ****   wysylane_polecenie_SIM900 = wykonywana_komenda;
 742:main.c        **** 
 743:main.c        **** #define POWTORZ_JESLI(WAR)                                                     \
 744:main.c        ****   {                                                                            \
 745:main.c        ****     if (WAR) {                                                                 \
 746:main.c        ****       dodaj_komende(wykonywana_komenda);                                       \
 747:main.c        ****       break;                                                                   \
 748:main.c        ****     }                                                                          \
 749:main.c        ****   }
 750:main.c        **** 
 751:main.c        **** #define JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ() POWTORZ_JESLI(!czy_wolny_eeprom())
 752:main.c        **** 
 753:main.c        **** #define JESLI_SIM900_ZAJETY_WYKONAJ_POZNIEJ() POWTORZ_JESLI(czy_gsm_zajety)
 754:main.c        **** 
 755:main.c        **** #include "main_sim900.h"
 756:main.c        **** 
 757:main.c        **** #define aktualnie_wykonywana_komenda wykonywana_komenda
 758:main.c        **** 
 759:main.c        **** void inicjalizuj_parametry_modulu(void);
 760:main.c        **** 
 761:main.c        **** #define MAX_LICZBA_KOMEND_DLA_ALARMOW (LICZBA_KOMEND / 4)
 762:main.c        **** 
 763:main.c        **** // Funkcja pomocnicza: Wyciąga ostatnie N cyfr z numeru telefonu
 764:main.c        **** // max_digits: maksimum cyfr (9)
 765:main.c        **** static void wyciagnij_ostatnie_cyfry(const uchar *numer_pelny,
 766:main.c        ****                                      uchar *numer_skrocony, uchar max_digits) {
 767:main.c        ****   uchar len = strlen((char *)numer_pelny);
 768:main.c        **** 
 769:main.c        ****   if (len > max_digits) {
 770:main.c        ****     // Take last max_digits
 771:main.c        ****     strcpy((char *)numer_skrocony, (char *)numer_pelny + (len - max_digits));
 772:main.c        ****   } else {
 773:main.c        ****     // Take all
 774:main.c        ****     strcpy((char *)numer_skrocony, (char *)numer_pelny);
 775:main.c        ****   }
 776:main.c        **** }
 777:main.c        **** 
 778:main.c        **** // Helper function to check if a number exists in EEPROM
 779:main.c        **** // Uses bufor_eeprom as temporary storage for comparison
 780:main.c        **** static uchar czy_numer_istnieje(const uchar *numer_telefonu) {
  35               		.loc 1 780 0
  36               		.cfi_startproc
  37               	.LVL0:
  38 000e CF93      		push r28
  39               	.LCFI0:
  40               		.cfi_def_cfa_offset 3
  41               		.cfi_offset 28, -2
  42 0010 DF93      		push r29
  43               	.LCFI1:
  44               		.cfi_def_cfa_offset 4
  45               		.cfi_offset 29, -3
  46               	/* prologue: function */
  47               	/* frame size = 0 */
  48               	/* stack size = 2 */
  49               	.L__stack_usage = 2
 781:main.c        ****   // Convert number to EEPROM block format
 782:main.c        ****   // We use a local buffer to avoid corrupting global buffers if possible,
 783:main.c        ****   // but porownaj_numer_telefonu_blok expects a block.
 784:main.c        ****   // Let's use bufor_eeprom as it is standard for this operation in this
 785:main.c        ****   // codebase.
 786:main.c        ****   konwertuj_telefon_na_blok_eeprom(
 787:main.c        ****       numer_telefonu, numer_telefonu + strlen((char *)numer_telefonu),
  50               		.loc 1 787 0
  51 0012 FC01      		movw r30,r24
  52               		0:
  53 0014 0190      		ld __tmp_reg__,Z+
  54 0016 0020      		tst __tmp_reg__
  55 0018 01F4      		brne 0b
  56 001a BF01      		movw r22,r30
 786:main.c        ****       numer_telefonu, numer_telefonu + strlen((char *)numer_telefonu),
  57               		.loc 1 786 0
  58 001c 6150      		subi r22,1
  59 001e 7109      		sbc r23,__zero_reg__
  60 0020 40E0      		ldi r20,lo8(bufor_eeprom)
  61 0022 50E0      		ldi r21,hi8(bufor_eeprom)
  62 0024 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
  63               	.LVL1:
  64 0028 C8E0      		ldi r28,lo8(8)
  65 002a D0E0      		ldi r29,0
  66               	.LVL2:
  67               	.L4:
  68               	.LBB355:
 788:main.c        ****       bufor_eeprom);
 789:main.c        **** 
 790:main.c        ****   for (uint nr_uzyt_clip = 0; nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 791:main.c        ****        ++nr_uzyt_clip) {
 792:main.c        ****     if (porownaj_numer_telefonu_blok(
  69               		.loc 1 792 0
  70 002c BE01      		movw r22,r28
  71 002e 80E0      		ldi r24,lo8(bufor_eeprom)
  72 0030 90E0      		ldi r25,hi8(bufor_eeprom)
  73 0032 0E94 0000 		call porownaj_numer_telefonu_blok
  74               	.LVL3:
  75 0036 8111      		cpse r24,__zero_reg__
  76 0038 00C0      		rjmp .L5
  77 003a 2596      		adiw r28,5
 790:main.c        ****        ++nr_uzyt_clip) {
  78               		.loc 1 790 0
  79 003c C83A      		cpi r28,-88
  80 003e FFE0      		ldi r31,15
  81 0040 DF07      		cpc r29,r31
  82 0042 01F4      		brne .L4
  83               	.L2:
  84               	/* epilogue start */
  85               	.LBE355:
 793:main.c        ****             bufor_eeprom, (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
 794:main.c        ****       return TRUE;
 795:main.c        ****     }
 796:main.c        ****   }
 797:main.c        ****   return FALSE;
 798:main.c        **** }
  86               		.loc 1 798 0
  87 0044 DF91      		pop r29
  88 0046 CF91      		pop r28
  89 0048 0895      		ret
  90               	.L5:
  91               	.LBB356:
 794:main.c        ****     }
  92               		.loc 1 794 0
  93 004a 8FEF      		ldi r24,lo8(-1)
  94 004c 00C0      		rjmp .L2
  95               	.LBE356:
  96               		.cfi_endproc
  97               	.LFE57:
 100               	usun_zablokowany_sms:
 101               	.LFB35:
 318:main.c        ****   // Usun SMS z modulu SIM900 (numer jest w aktualnie_wysylane_polecenie_SIM900)
 102               		.loc 1 318 0
 103               		.cfi_startproc
 104               	/* prologue: function */
 105               	/* frame size = 0 */
 106               	/* stack size = 0 */
 107               	.L__stack_usage = 0
 321:main.c        ****       aktualnie_wysylane_polecenie_SIM900 <= KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 108               		.loc 1 321 0
 109 004e 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 110 0052 97E5      		ldi r25,lo8(87)
 111 0054 980F      		add r25,r24
 112               	.LBB357:
 326:main.c        ****   } else {
 113               		.loc 1 326 0
 114 0056 8C5E      		subi r24,lo8(-(20))
 115               	.LBE357:
 321:main.c        ****       aktualnie_wysylane_polecenie_SIM900 <= KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 116               		.loc 1 321 0
 117 0058 9431      		cpi r25,lo8(20)
 118 005a 00F0      		brlo .L9
 329:main.c        ****   }
 119               		.loc 1 329 0
 120 005c 81E9      		ldi r24,lo8(-111)
 121               	.L9:
 122 005e 0C94 0000 		jmp filtruj_i_dodaj_komende
 123               	.LVL4:
 124               		.cfi_endproc
 125               	.LFE35:
 128               	zareaguj_na_usuniety_sms_z_powodu_limitu:
 129               	.LFB36:
 333:main.c        ****   if (licznik_usunietych_sms_przez_limit < 0xFFFF)
 130               		.loc 1 333 0
 131               		.cfi_startproc
 132               	/* prologue: function */
 133               	/* frame size = 0 */
 134               	/* stack size = 0 */
 135               	.L__stack_usage = 0
 334:main.c        ****     ++licznik_usunietych_sms_przez_limit;
 136               		.loc 1 334 0
 137 0062 8091 0000 		lds r24,licznik_usunietych_sms_przez_limit
 138 0066 9091 0000 		lds r25,licznik_usunietych_sms_przez_limit+1
 139 006a 8F3F      		cpi r24,-1
 140 006c 9807      		cpc r25,r24
 141 006e 01F0      		breq .L11
 335:main.c        ****   sygnalizuj_pelny_system();
 142               		.loc 1 335 0
 143 0070 0196      		adiw r24,1
 144 0072 9093 0000 		sts licznik_usunietych_sms_przez_limit+1,r25
 145 0076 8093 0000 		sts licznik_usunietych_sms_przez_limit,r24
 146               	.L11:
 147               	.LBB360:
 148               	.LBB361:
 314:main.c        **** }
 149               		.loc 1 314 0
 150 007a 8AE0      		ldi r24,lo8(10)
 151 007c 8093 0000 		sts liczba_blyskow_led,r24
 152 0080 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 153               	.LBE361:
 154               	.LBE360:
 337:main.c        ****   // Uzywamy filtruj_i_dodaj
 155               		.loc 1 337 0
 156 0084 0E94 0000 		call watchdog_sms_disarm
 157               	.LVL5:
 339:main.c        **** }
 158               		.loc 1 339 0
 159 0088 81E9      		ldi r24,lo8(-111)
 160 008a 0C94 0000 		jmp filtruj_i_dodaj_komende
 161               	.LVL6:
 162               		.cfi_endproc
 163               	.LFE36:
 166               	polozenie_polecenia_SIM900:
 167               	.LFB47:
 168               		.file 2 "main_sim900.h"
   1:main_sim900.h **** 
   2:main_sim900.h **** #ifdef MAIN_SIM900_H
   3:main_sim900.h **** #error Dwa razy wlaczany plik
   4:main_sim900.h **** #endif
   5:main_sim900.h **** 
   6:main_sim900.h **** void wyzerowanie_danych_SIM900(void) {
   7:main_sim900.h ****   POMOC_DODAJ2('*', 't');
   8:main_sim900.h ****   problem_z_wyslaniem_powiadomienia();
   9:main_sim900.h ****   licznik_wysylane_polecenie_SIM900 = 0;
  10:main_sim900.h ****   aktualnie_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
  11:main_sim900.h ****   liczba_komend_w_kolejce_SIM900 = 0;
  12:main_sim900.h ****   licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow = 0;
  13:main_sim900.h ****   czekanie_na_odebranie_zachety = FALSE;
  14:main_sim900.h ****   flaga_odebrany_znak_zachety = FALSE;
  15:main_sim900.h ****   trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
  16:main_sim900.h ****   wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
  17:main_sim900.h ****   flaga_odczytywanie_smsa = FALSE;
  18:main_sim900.h **** }
  19:main_sim900.h **** 
  20:main_sim900.h **** void reset_modulu_SIM900(void) {
  21:main_sim900.h ****   wyzerowanie_danych_SIM900();
  22:main_sim900.h ****   POMOC_DODAJ2('*', 'm');
  23:main_sim900.h ****   HARDRESET_SIM900();
  24:main_sim900.h ****   podlaczony_modul_gsm_SIM900 = FALSE;
  25:main_sim900.h ****   podlaczona_karta_SIM_SIM900 = FALSE;
  26:main_sim900.h ****   licznik_blad_stanu_karty_SIM = 0;
  27:main_sim900.h ****   licznik_blad_zalogowania_u_operatora = 0;
  28:main_sim900.h ****   nazwa_operatora[0] = '\0';
  29:main_sim900.h ****   licznik_ogolny_blad_zalogowania = 0;
  30:main_sim900.h ****   blokada_clip = FALSE;
  31:main_sim900.h ****   nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
  32:main_sim900.h ****   poziom_sieci_gsm = POZIOM_SIECI_BLAD;
  33:main_sim900.h ****   filtruj_komendy_z_przedzialu(KOMENDA_KOLEJKI_USUN_SMSA_1,
  34:main_sim900.h ****                                KOMENDA_KOLEJKI_USUN_SMSA_20);
  35:main_sim900.h ****   filtruj_komendy_z_przedzialu(
  36:main_sim900.h ****       KOMENDA_KOLEJKI_KOMENDA_SIM900,
  37:main_sim900.h ****       KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE);
  38:main_sim900.h ****   filtruj_komendy_z_przedzialu(
  39:main_sim900.h ****       KOMENDA_KOLEJKI_SPRAWDZ_PIN,
  40:main_sim900.h ****       KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ);
  41:main_sim900.h ****   filtruj_komendy_z_przedzialu(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT,
  42:main_sim900.h ****                                KOMENDA_KOLEJKI_WYSLIJ_PDU);
  43:main_sim900.h ****   modul_zalogowany_w_sieci = FALSE;
  44:main_sim900.h **** }
  45:main_sim900.h **** 
  46:main_sim900.h **** static uchar czy_polecenie_SIM900(PGM_P polecenie, const uchar liczba_znakow) {
  47:main_sim900.h ****   return strncmp_P(odebrany_blok_SIM900 + 2, polecenie, liczba_znakow) == 0;
  48:main_sim900.h **** }
  49:main_sim900.h **** 
  50:main_sim900.h **** static uchar *polozenie_polecenia_SIM900(PGM_P polecenie) {
 169               		.loc 2 50 0
 170               		.cfi_startproc
 171               	.LVL7:
 172               	/* prologue: function */
 173               	/* frame size = 0 */
 174               	/* stack size = 0 */
 175               	.L__stack_usage = 0
  51:main_sim900.h ****   return strstr_P(odebrany_blok_SIM900, polecenie);
 176               		.loc 2 51 0
 177 008e BC01      		movw r22,r24
 178 0090 80E0      		ldi r24,lo8(odebrany_blok_SIM900)
 179 0092 90E0      		ldi r25,hi8(odebrany_blok_SIM900)
 180               	.LVL8:
 181 0094 0C94 0000 		jmp strstr_P
 182               	.LVL9:
 183               		.cfi_endproc
 184               	.LFE47:
 187               	opoznienie_startowe:
 188               	.LFB69:
 799:main.c        **** 
 800:main.c        **** uchar wykonanie_komend_ukladow(void) {
 801:main.c        ****   const komenda_typ aktualnie_wykonywana_komenda = komendy_kolejka[0];
 802:main.c        **** 
 803:main.c        ****   switch (aktualnie_wykonywana_komenda) {
 804:main.c        ****   case KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU: {
 805:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 806:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 807:main.c        ****     kod_modulu[1] = bufor_eeprom[1] = 'B';
 808:main.c        ****     kod_modulu[2] = bufor_eeprom[2] = 'C';
 809:main.c        ****     kod_modulu[3] = bufor_eeprom[3] = 'D';
 810:main.c        ****     zapisz_znaki_w_eeprom_bez_kopiowania(ADRES_EEPROM_KOD_DOSTEPU,
 811:main.c        ****                                          LICZBA_BAJTOW_KODU_DOSTEPU);
 812:main.c        ****     zapal_diode_led(50);
 813:main.c        ****     break;
 814:main.c        ****   }
 815:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_0:
 816:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_1:
 817:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_2:
 818:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_3:
 819:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_4:
 820:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_5:
 821:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_6:
 822:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_7:
 823:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_8:
 824:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_9:
 825:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_10:
 826:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_11:
 827:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_12:
 828:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_13:
 829:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_14:
 830:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_15:
 831:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_16:
 832:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_17:
 833:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_18:
 834:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_19:
 835:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_20:
 836:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_21:
 837:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_22:
 838:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_23:
 839:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_24:
 840:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_25:
 841:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_26:
 842:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_27:
 843:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_28:
 844:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_29:
 845:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_30:
 846:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_31:
 847:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_32:
 848:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_33:
 849:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_34:
 850:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_35:
 851:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_36:
 852:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_37:
 853:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_38:
 854:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_39:
 855:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_40:
 856:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_41:
 857:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_42:
 858:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_43:
 859:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_44:
 860:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_45:
 861:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_46:
 862:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_47:
 863:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_48:
 864:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_49:
 865:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_50:
 866:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_51:
 867:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_52:
 868:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_53:
 869:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_54:
 870:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_55:
 871:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_56:
 872:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_57:
 873:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_58:
 874:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_59:
 875:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_60:
 876:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_61:
 877:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_62:
 878:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_63:
 879:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_64:
 880:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_65:
 881:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_66:
 882:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_67:
 883:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_68:
 884:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_69:
 885:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_70:
 886:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_71:
 887:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_72:
 888:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_73:
 889:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_74:
 890:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_75:
 891:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_76:
 892:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_77:
 893:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_78:
 894:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_79:
 895:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_80:
 896:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_81:
 897:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_82:
 898:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_83:
 899:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_84:
 900:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_85:
 901:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_86:
 902:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_87:
 903:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_88:
 904:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_89:
 905:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_90:
 906:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_91:
 907:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_92:
 908:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_93:
 909:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_94:
 910:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_95:
 911:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_96:
 912:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_97:
 913:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_98:
 914:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_99:
 915:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_100:
 916:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_101:
 917:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_102:
 918:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_103:
 919:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_104:
 920:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_105:
 921:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_106:
 922:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_107:
 923:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_108:
 924:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_109:
 925:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_110:
 926:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_111:
 927:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_112:
 928:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_113:
 929:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_114:
 930:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_115:
 931:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_116:
 932:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_117:
 933:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_118:
 934:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_119:
 935:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_120:
 936:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_121:
 937:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_122:
 938:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_123:
 939:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_124:
 940:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_125:
 941:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_126:
 942:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_127: {
 943:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 944:main.c        ****     const uchar nr_bloku =
 945:main.c        ****         aktualnie_wykonywana_komenda - KOMENDA_KOLEJKI_RESET_USTAWIEN_0;
 946:main.c        **** #define LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE 32
 947:main.c        ****     memset(bufor_eeprom, 0xff, LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE);
 948:main.c        ****     if (nr_bloku == 0) {
 949:main.c        ****       kod_modulu[0] = bufor_eeprom[1] = 'A';
 950:main.c        ****       kod_modulu[1] = bufor_eeprom[2] = 'B';
 951:main.c        ****       kod_modulu[2] = bufor_eeprom[3] = 'C';
 952:main.c        ****       kod_modulu[3] = bufor_eeprom[4] = 'D';
 953:main.c        ****       bufor_eeprom[5] = 0;
 954:main.c        ****       stan_wyjscie[0] = 0;
 955:main.c        ****       licznik_przelacznik_wyjscia[0] = 0;
 956:main.c        ****     }
 957:main.c        ****     zapisz_znaki_w_eeprom_bez_kopiowania(
 958:main.c        ****         nr_bloku * LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE,
 959:main.c        ****         LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE);
 960:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0 + nr_bloku + 1);
 961:main.c        ****     zapal_diode_led(50);
 962:main.c        ****     break;
 963:main.c        ****   }
 964:main.c        ****   case KOMENDA_KOLEJKI_RESET_USTAWIEN_INICJALIZACJA: {
 965:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 966:main.c        ****     uchar bledny_zapis = FALSE;
 967:main.c        ****     static const uchar tab_eeprom_fabryczny[6] PROGMEM = {
 968:main.c        ****         0xff, 'A', 'B', 'C', 'D', 0x00,
 969:main.c        ****     };
 970:main.c        ****     for (uint i = 0; i < 6; ++i) {
 971:main.c        ****       if (eeprom_read_byte((void *)i) !=
 972:main.c        ****           pgm_read_byte(tab_eeprom_fabryczny + i))
 973:main.c        ****         bledny_zapis = TRUE;
 974:main.c        ****     }
 975:main.c        ****     for (uint i = EEPROM_NUMER_TELEFONU_BRAMA_0;
 976:main.c        ****          i < EEPROM_NUMER_TELEFONU_BRAMA_0 +
 977:main.c        ****                  MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA *
 978:main.c        ****                      LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM;
 979:main.c        ****          ++i) {
 980:main.c        ****       if (eeprom_read_byte((void *)i) != 0xff) {
 981:main.c        ****         bledny_zapis = TRUE;
 982:main.c        ****         break;
 983:main.c        ****       }
 984:main.c        ****     }
 985:main.c        ****     if (bledny_zapis) {
 986:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
 987:main.c        ****       break;
 988:main.c        ****     }
 989:main.c        ****     inicjalizuj_parametry_modulu();
 990:main.c        ****     ustaw_stan_led(FALSE); // Wylacz diode po zakonczeniu resetu
 991:main.c        ****     break;
 992:main.c        ****   }
 993:main.c        ****   case KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA: {
 994:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 995:main.c        **** 
 996:main.c        ****     if (blokada_sterowania_czasowa) {
 997:main.c        ****       // Poza dozwolonym czasem - ignoruj
 998:main.c        ****       break;
 999:main.c        ****     }
1000:main.c        **** 
1001:main.c        ****     // Make a local copy of the phone number to prevent corruption
1002:main.c        ****     // if the global buffer changes during processing (e.g. new CLIP)
1003:main.c        ****     uchar numer_lokalny[MAX_LICZBA_ZNAKOW_TELEFON + 1];
1004:main.c        ****     strcpy((char *)numer_lokalny, (char *)numer_telefonu_ktory_dzwoni);
1005:main.c        **** 
1006:main.c        ****     // Konwertuj numer dla późniejszego użycia
1007:main.c        ****     konwertuj_telefon_na_blok_eeprom(
1008:main.c        ****         &numer_lokalny[0], &numer_lokalny[strlen((char *)numer_lokalny)],
1009:main.c        ****         &bufor_eeprom[0]);
1010:main.c        **** 
1011:main.c        ****     // Sprawdź czy numer jest na liście (PEŁNY NUMER)
1012:main.c        ****     uchar znaleziono = FALSE;
1013:main.c        ****     if (tryb_pracy != 1) {
1014:main.c        ****       // Tylko w trybie prywatnym sprawdzamy listę
1015:main.c        ****       for (uint nr_uzyt_clip = 0;
1016:main.c        ****            nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
1017:main.c        ****         if (porownaj_numer_telefonu_blok(
1018:main.c        ****                 &bufor_eeprom[0],
1019:main.c        ****                 (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
1020:main.c        ****           znaleziono = TRUE;
1021:main.c        ****           break;
1022:main.c        ****         }
1023:main.c        ****       }
1024:main.c        ****     }
1025:main.c        **** 
1026:main.c        ****     // SKRYBA: Jeśli nie znaleziono pełnego, sprawdź skrócony (ostatnie 9 cyfr)
1027:main.c        ****     uchar numer_skrocony[20]; // Increased buffer size
1028:main.c        ****     if (skryba_wlaczona && !znaleziono) {
1029:main.c        ****       wyciagnij_ostatnie_cyfry(numer_lokalny, numer_skrocony, 9);
1030:main.c        **** 
1031:main.c        ****       // Konwertuj skrócony numer do bufor_eeprom dla porównania
1032:main.c        ****       konwertuj_telefon_na_blok_eeprom(
1033:main.c        ****           &numer_skrocony[0], &numer_skrocony[strlen((char *)numer_skrocony)],
1034:main.c        ****           &bufor_eeprom[0]);
1035:main.c        **** 
1036:main.c        ****       if (tryb_pracy != 1) {
1037:main.c        ****         for (uint nr_uzyt_clip = 0;
1038:main.c        ****              nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
1039:main.c        ****              ++nr_uzyt_clip) {
1040:main.c        ****           if (porownaj_numer_telefonu_blok(
1041:main.c        ****                   &bufor_eeprom[0],
1042:main.c        ****                   (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
1043:main.c        ****             znaleziono = TRUE;
1044:main.c        ****             break;
1045:main.c        ****           }
1046:main.c        ****         }
1047:main.c        ****       }
1048:main.c        ****     }
1049:main.c        **** 
1050:main.c        ****     // SKRYBA: Auto-save numer jesli wlaczona i nie znaleziono
1051:main.c        ****     zapisz_znak_w_eeprom(skryba_wlaczona ? 1 : 0,
1052:main.c        ****                          ADRES_EEPROM_DEBUG_SKRYBA_2); // DEBUG
1053:main.c        ****     zapisz_znak_w_eeprom(znaleziono ? 0 : 1,
1054:main.c        ****                          ADRES_EEPROM_DEBUG_SKRYBA_3); // DEBUG
1055:main.c        **** 
1056:main.c        ****     if (skryba_wlaczona && !znaleziono) {
1057:main.c        ****       uchar len_full = strlen((char *)numer_lokalny);
1058:main.c        **** 
1059:main.c        ****       // DEBUG: Zapisz dlugosc numeru
1060:main.c        ****       zapisz_znak_w_eeprom(len_full, ADRES_EEPROM_DEBUG_SKRYBA_5);
1061:main.c        **** 
1062:main.c        ****       if (len_full >= 3) {
1063:main.c        ****         // Skopiuj skrócony numer do numer_telefonu_skryba
1064:main.c        ****         strcpy((char *)numer_telefonu_skryba, (char *)numer_skrocony);
1065:main.c        **** 
1066:main.c        ****         // Extra check: ensure extracted number is also >= 3 chars
1067:main.c        ****         if (strlen((char *)numer_telefonu_skryba) >= 3) {
1068:main.c        ****           zapisz_znak_w_eeprom(
1069:main.c        ****               1, ADRES_EEPROM_DEBUG_SKRYBA_4); // DEBUG: komenda dodana
1070:main.c        **** 
1071:main.c        ****           // Dodaj komende dodania uzytkownika Skryba
1072:main.c        ****           dodaj_komende(KOMENDA_KOLEJKI_DODAJ_UZYTKOWNIKA_SKRYBA);
1073:main.c        ****         }
1074:main.c        ****       }
1075:main.c        ****     }
1076:main.c        **** 
1077:main.c        ****     // Teraz sprawdź tryb i otwórz bramę (TYLKO W TRYBIE CLIP!)
1078:main.c        ****     if (tryb_clip) {
1079:main.c        ****       if (tryb_pracy == 1) {
1080:main.c        ****         // Tryb publiczny - otwórz dla każdego
1081:main.c        ****         ustaw_wyjscie_clip();
1082:main.c        ****       } else if (znaleziono) {
1083:main.c        ****         // Tryb prywatny - otwórz tylko dla znalezionych
1084:main.c        ****         ustaw_wyjscie_clip();
1085:main.c        ****       }
1086:main.c        ****     }
1087:main.c        ****     // W trybie DTMF NIE włączamy wyjścia - czekamy na klawisz '1'
1088:main.c        **** 
1089:main.c        ****     break;
1090:main.c        ****   }
1091:main.c        ****   case KOMENDA_KOLEJKI_DODAJ_UZYTKOWNIKA_BRAMA: {
1092:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1093:main.c        **** 
1094:main.c        ****     // Check for duplicates using the helper function
1095:main.c        ****     if (czy_numer_istnieje(numer_telefonu_do_ktorego_dzwonic)) {
1096:main.c        ****       return TRUE; // Duplicate found, abort
1097:main.c        ****     }
1098:main.c        **** 
1099:main.c        ****     // Re-convert because czy_numer_istnieje uses bufor_eeprom which might be
1100:main.c        ****     // modified (though in this implementation it sets it correctly for writing
1101:main.c        ****     // too) But to be safe and consistent with original logic:
1102:main.c        ****     konwertuj_telefon_na_blok_eeprom(
1103:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
1104:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[strlen(
1105:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
1106:main.c        ****         &bufor_eeprom[0]);
1107:main.c        **** 
1108:main.c        ****     uchar dodano = FALSE;
1109:main.c        ****     for (uint nr_uzyt_clip = 0;
1110:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
1111:main.c        ****       if (not czy_aktywny_numer_telefonu_brama(nr_uzyt_clip)) {
1112:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
1113:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
1114:main.c        ****             LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1115:main.c        ****         dodano = TRUE;
1116:main.c        ****         break;
1117:main.c        ****       }
1118:main.c        ****     }
1119:main.c        **** 
1120:main.c        ****     // Jesli dodano numer i Skryba jest wlaczona, sprawdz czy osiagnieto limit
1121:main.c        ****     if (dodano && skryba_wlaczona) {
1122:main.c        ****       // Policz aktywnych uzytkownikow
1123:main.c        ****       uint aktywne_numery = 0;
1124:main.c        ****       for (uint i = 0; i < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++i) {
1125:main.c        ****         if (czy_aktywny_numer_telefonu_brama(i)) {
1126:main.c        ****           ++aktywne_numery;
1127:main.c        ****         }
1128:main.c        ****       }
1129:main.c        **** 
1130:main.c        ****       // Jesli osiagnieto limit, wylacz Skrybe
1131:main.c        ****       if (aktywne_numery >= skryba_limit) {
1132:main.c        ****         skryba_wlaczona = FALSE;
1133:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_SKRYBA);
1134:main.c        **** 
1135:main.c        ****         tryb_pracy = 0; // Prywatny
1136:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_TRYB_PRACY);
1137:main.c        ****       }
1138:main.c        ****     }
1139:main.c        ****     break;
1140:main.c        ****   }
1141:main.c        ****   case KOMENDA_KOLEJKI_DODAJ_UZYTKOWNIKA_SKRYBA: {
1142:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1143:main.c        **** 
1144:main.c        ****     // Use a LOCAL buffer for Skryba to avoid corruption by czy_numer_istnieje
1145:main.c        ****     uchar bufor_skryba[LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM];
1146:main.c        **** 
1147:main.c        ****     // Convert Skryba number to EEPROM format FIRST, before duplicate check
1148:main.c        ****     konwertuj_telefon_na_blok_eeprom(
1149:main.c        ****         &numer_telefonu_skryba[0],
1150:main.c        ****         &numer_telefonu_skryba[strlen((char *)numer_telefonu_skryba)],
1151:main.c        ****         bufor_skryba);
1152:main.c        **** 
1153:main.c        ****     // Check for duplicates using the helper function
1154:main.c        ****     // (This will use bufor_eeprom internally, but we have our number safe in
1155:main.c        ****     // bufor_skryba)
1156:main.c        ****     if (czy_numer_istnieje(numer_telefonu_skryba)) {
1157:main.c        ****       return TRUE; // Duplicate found, abort
1158:main.c        ****     }
1159:main.c        **** 
1160:main.c        ****     // Copy our safe buffer to bufor_eeprom for writing
1161:main.c        ****     memcpy(bufor_eeprom, bufor_skryba, LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1162:main.c        **** 
1163:main.c        ****     uchar dodano = FALSE;
1164:main.c        ****     for (uint nr_uzyt_clip = 0;
1165:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
1166:main.c        ****       if (not czy_aktywny_numer_telefonu_brama(nr_uzyt_clip)) {
1167:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
1168:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
1169:main.c        ****             LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1170:main.c        **** 
1171:main.c        ****         dodano = TRUE;
1172:main.c        ****         break;
1173:main.c        ****       }
1174:main.c        ****     }
1175:main.c        **** 
1176:main.c        ****     // Jesli dodano numer i Skryba jest wlaczona, sprawdz czy osiagnieto limit
1177:main.c        ****     if (dodano && skryba_wlaczona) {
1178:main.c        ****       // Policz aktywnych uzytkownikow
1179:main.c        ****       uint aktywne_numery = 0;
1180:main.c        ****       for (uint i = 0; i < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++i) {
1181:main.c        ****         if (czy_aktywny_numer_telefonu_brama(i)) {
1182:main.c        ****           ++aktywne_numery;
1183:main.c        ****         }
1184:main.c        ****       }
1185:main.c        **** 
1186:main.c        ****       // Jesli osiagnieto limit, wylacz Skrybe
1187:main.c        ****       if (aktywne_numery >= skryba_limit) {
1188:main.c        ****         skryba_wlaczona = FALSE;
1189:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_SKRYBA);
1190:main.c        **** 
1191:main.c        ****         tryb_pracy = 0; // Prywatny
1192:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_TRYB_PRACY);
1193:main.c        ****       }
1194:main.c        ****     }
1195:main.c        ****   } break;
1196:main.c        ****   case KOMENDA_KOLEJKI_USUN_UZYTKOWNIKA_BRAMA: {
1197:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1198:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
1199:main.c        ****                                      &numer_telefonu_do_ktorego_dzwonic[strlen(
1200:main.c        ****                                          numer_telefonu_do_ktorego_dzwonic)],
1201:main.c        ****                                      &bufor_eeprom[0]);
1202:main.c        ****     // for (uchar nr_uzyt_clip = 0; nr_uzyt_clip <
1203:main.c        ****     // MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip)
1204:main.c        ****     for (uint nr_uzyt_clip = 0;
1205:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
1206:main.c        ****       if (porownaj_numer_telefonu_blok(
1207:main.c        ****               &bufor_eeprom[0], // 1 porwnanie zajmuje ~10us, czyli 170 numerw ~
1208:main.c        ****                                 // 2ms
1209:main.c        ****               (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
1210:main.c        ****         numer_telefonu_do_ktorego_dzwonic[0] = '\0';
1211:main.c        ****         konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
1212:main.c        ****                                          &numer_telefonu_do_ktorego_dzwonic[1],
1213:main.c        ****                                          &bufor_eeprom[0]);
1214:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
1215:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
1216:main.c        ****             LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
1217:main.c        ****         break;
1218:main.c        ****       }
1219:main.c        ****     }
1220:main.c        ****     break;
1221:main.c        ****   }
1222:main.c        ****   default:
1223:main.c        ****     return FALSE;
1224:main.c        ****   }
1225:main.c        ****   return TRUE;
1226:main.c        **** }
1227:main.c        **** 
1228:main.c        **** uchar wykonanie_komend_powiadomien(void) {
1229:main.c        ****   const komenda_typ aktualnie_wykonywana_komenda = komendy_kolejka[0];
1230:main.c        **** 
1231:main.c        ****   const uchar czy_gsm_zajety =
1232:main.c        ****       flaga_odczytywanie_smsa || flaga_wysylanie_smsa ||
1233:main.c        ****       wykonywanie_rozmowy_telefonicznej ||
1234:main.c        ****       trwa_rozmowa_przychodzaca_od_uzytkownika ||
1235:main.c        ****       aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
1236:main.c        ****       opoznienie_SIM900_100MS || czekanie_na_odebranie_zachety;
1237:main.c        **** 
1238:main.c        ****   const uchar czy_mozna_wysylac_dane_do_SIM900 =
1239:main.c        ****       !czy_gsm_zajety && CZY_MOZNA_WYSYLAC_DANE_SIM900() &&
1240:main.c        ****       czy_jest_bezczynny_SIM900();
1241:main.c        **** 
1242:main.c        ****   switch (aktualnie_wykonywana_komenda) {
1243:main.c        ****   case KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW: {
1244:main.c        ****     if (not czy_mozna_wysylac_dane_do_SIM900 ||
1245:main.c        ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1246:main.c        ****       dodaj_komende(aktualnie_wykonywana_komenda);
1247:main.c        ****       break;
1248:main.c        ****     }
1249:main.c        ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1250:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
1251:main.c        ****     *sms++ = '*';
1252:main.c        ****     for (;;) {
1253:main.c        ****       if (czy_aktywny_numer_telefonu_brama(
1254:main.c        ****               numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama)) {
1255:main.c        ****         sms += kopiuj_blok_eeprom_na_telefon(
1256:main.c        ****             (void *)EEPROM_NUMER_TELEFONU_BRAMA(
1257:main.c        ****                 numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama),
1258:main.c        ****             sms, MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER);
1259:main.c        ****         *sms++ = '#';
1260:main.c        ****         *sms++ = '\n';
1261:main.c        ****         ++numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama;
1262:main.c        ****         if ((sms + MAX_LICZBA_ZNAKOW_TELEFON + 1 >=
1263:main.c        ****              &tekst_wysylanego_smsa[MAX_LICZBA_ZNAKOW_SMS]) ||
1264:main.c        ****             (numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama >=
1265:main.c        ****              MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER)) {
1266:main.c        ****           if ((numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama <
1267:main.c        ****                MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER))
1268:main.c        ****             dodaj_komende(aktualnie_wykonywana_komenda);
1269:main.c        ****           *sms = '\0';
1270:main.c        ****           dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
1271:main.c        ****           wysylanie_smsa_clipa = WYSYLANIE_SMSA_WYSYLANIE;
1272:main.c        ****           break;
1273:main.c        ****         }
1274:main.c        ****       } else {
1275:main.c        ****         if (++numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama >=
1276:main.c        ****             MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER) {
1277:main.c        ****           if (sms != &tekst_wysylanego_smsa[0]) {
1278:main.c        ****             *sms = '\0';
1279:main.c        ****             dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
1280:main.c        ****             wysylanie_smsa_clipa = WYSYLANIE_SMSA_WYSYLANIE;
1281:main.c        ****           }
1282:main.c        ****           break;
1283:main.c        ****         }
1284:main.c        ****       }
1285:main.c        ****     }
1286:main.c        ****     break;
1287:main.c        ****   }
1288:main.c        ****   default:
1289:main.c        ****     return FALSE;
1290:main.c        ****   }
1291:main.c        ****   return TRUE;
1292:main.c        **** }
1293:main.c        **** 
1294:main.c        **** void wykonanie_komend(void) {
1295:main.c        ****   if (wykonanie_komend_SIM900())
1296:main.c        ****     ;
1297:main.c        ****   else if (wykonanie_komend_ukladow())
1298:main.c        ****     ;
1299:main.c        ****   else if (wykonanie_komend_powiadomien())
1300:main.c        ****     ;
1301:main.c        ****   else
1302:main.c        ****     ;
1303:main.c        ****   usun_komende();
1304:main.c        **** }
1305:main.c        **** 
1306:main.c        **** void test_sms_clip_100ms(void) {
1307:main.c        ****   // static ulong licznik_sms;
1308:main.c        ****   // if ( ++licznik_sms > 60 * 10 )
1309:main.c        ****   //{
1310:main.c        ****   //	licznik_sms = 0;
1311:main.c        **** 
1312:main.c        ****   // tekst_wysylanego_smsa[0] = 'A';
1313:main.c        ****   // tekst_wysylanego_smsa[1] = 'B';
1314:main.c        ****   // tekst_wysylanego_smsa[2] = 'C';
1315:main.c        ****   // tekst_wysylanego_smsa[3] = 'D';
1316:main.c        ****   // tekst_wysylanego_smsa[4] = 0;
1317:main.c        ****   // static const char tel[] PROGMEM = "731314727";
1318:main.c        ****   ////static const char tel[] PROGMEM = "505691117";
1319:main.c        ****   // memcpy_R(numer_telefonu_wysylanego_smsa, tel);
1320:main.c        ****   // dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
1321:main.c        **** 
1322:main.c        ****   // memcpy_R(numer_telefonu_do_ktorego_dzwonic, tel);
1323:main.c        ****   // dodaj_komende(KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE);
1324:main.c        ****   //}
1325:main.c        **** }
1326:main.c        **** 
1327:main.c        **** void steruj_wejscia_wyjscia_100ms(void) {
1328:main.c        ****   aktualizuj_stan_wyzwolenia_wejsc_100ms();
1329:main.c        ****   steruj_wejsciem_reset_100ms();
1330:main.c        ****   steruj_wyjscia_100ms();
1331:main.c        **** }
1332:main.c        **** 
1333:main.c        **** void zapis_w_eeprom_stanu_wyjsc(void) {
1334:main.c        ****   if (not czy_wolny_eeprom())
1335:main.c        ****     return;
1336:main.c        ****   uchar par = 0;
1337:main.c        ****   if ((stan_wyjscie[0] != 0) ^ (licznik_przelacznik_wyjscia[0] != 0))
1338:main.c        ****     par |= BIT(0);
1339:main.c        ****   if (par != eeprom_read_byte((void *)EEPROM_USTAWIENIE_STANOW_WYJSC))
1340:main.c        ****     zapisz_znaki_w_eeprom(&par, (uint)EEPROM_USTAWIENIE_STANOW_WYJSC, 1);
1341:main.c        **** }
1342:main.c        **** 
1343:main.c        **** // void test_clip_na_101(void)
1344:main.c        **** //{
1345:main.c        **** //	if ( not modul_zalogowany_w_sieci )
1346:main.c        **** //		return;
1347:main.c        **** //	static uint licznik_101;
1348:main.c        **** //	if ( ++licznik_101 < 2 * 60 * 10 )
1349:main.c        **** //		return;
1350:main.c        **** //	licznik_101 = 0;
1351:main.c        **** //	static const char doladowanie[] PROGMEM = "*101#";
1352:main.c        **** //	strcpy_P(numer_telefonu_do_ktorego_dzwonic, doladowanie);
1353:main.c        **** //	dodaj_komende(KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE);
1354:main.c        **** // }
1355:main.c        **** 
1356:main.c        **** void steruj_urzadzeniem_100MS(void) {
1357:main.c        ****   steruj_wejscia_wyjscia_100ms();
1358:main.c        ****   steruj_SIM900_100MS();
1359:main.c        ****   if (licznik_100ms_dioda_led) {
1360:main.c        ****     if (--licznik_100ms_dioda_led == 0)
1361:main.c        ****       ustaw_stan_led(FALSE);
1362:main.c        ****     else
1363:main.c        ****       ustaw_stan_led(TRUE);
1364:main.c        ****   }
1365:main.c        **** 
1366:main.c        ****   // Aktualizacja timera blokady komend REPORT/USER
1367:main.c        ****   if (timer_report_user_100ms > 0) {
1368:main.c        ****     --timer_report_user_100ms;
1369:main.c        ****     if (timer_report_user_100ms == 0) {
1370:main.c        ****       // Okno czasowe minelo - resetuj licznik
1371:main.c        ****       licznik_report_user = 0;
1372:main.c        ****     }
1373:main.c        ****   } else {
1374:main.c        ****     // Timer jest 0 - upewnij sie ze licznik tez jest 0 (ochrona przed
1375:main.c        ****     // bledami)
1376:main.c        ****     licznik_report_user = 0;
1377:main.c        ****   }
1378:main.c        **** 
1379:main.c        ****   // Mechanizm wykrywania zablokowanej kolejki i czyszczenia starych komend
1380:main.c        ****   // SMS
1381:main.c        ****   const komenda_typ pierwsza_komenda = komendy_kolejka[0];
1382:main.c        ****   if (pierwsza_komenda != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
1383:main.c        ****     // Sprawdz czy pierwsza komenda to SMS - jesli tak i stoi zbyt dlugo,
1384:main.c        ****     // wyczysc
1385:main.c        ****     if (pierwsza_komenda >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
1386:main.c        ****         pierwsza_komenda <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU) {
1387:main.c        ****       // To jest komenda SMS - sprawdz czy stoi zbyt dlugo
1388:main.c        ****       if (pierwsza_komenda == ostatnia_pierwsza_komenda) {
1389:main.c        ****         // Ta sama komenda SMS jest na poczatku kolejki - kolejka moze stac
1390:main.c        ****         if (licznik_kolejka_stoi_100ms < MAX_CZAS_KOLEJKA_STOI_100MS)
1391:main.c        ****           ++licznik_kolejka_stoi_100ms;
1392:main.c        ****         else {
1393:main.c        ****           // Komenda SMS stoi juz 30 sekund - wyczysc wszystkie komendy SMS i
1394:main.c        ****           // wznow dzialanie
1395:main.c        ****           filtruj_komendy_z_przedzialu(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT,
1396:main.c        ****                                        KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
1397:main.c        ****           if (licznik_awaryjnych_resetow_kolejki < 0xFFFF)
1398:main.c        ****             ++licznik_awaryjnych_resetow_kolejki;
1399:main.c        **** 
1400:main.c        ****           filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
1401:main.c        **** 
1402:main.c        ****           // Resetuj blokade komend REPORT/USER aby wznowic dzialanie
1403:main.c        ****           licznik_report_user = 0;
1404:main.c        ****           timer_report_user_100ms = 0;
1405:main.c        **** 
1406:main.c        ****           // Resetuj liczniki kolejki
1407:main.c        ****           licznik_kolejka_stoi_100ms = 0;
1408:main.c        ****           ostatnia_pierwsza_komenda = KOMENDA_KOLEJKI_BRAK_KOMENDY;
1409:main.c        **** 
1410:main.c        ****           // Resetuj flage wysylania SMS (na wypadek zablokowania)
1411:main.c        ****           flaga_wysylanie_smsa = 0;
1412:main.c        ****         }
1413:main.c        ****       } else {
1414:main.c        ****         // Pierwsza komenda SMS sie zmienila - kolejka dziala
1415:main.c        ****         ostatnia_pierwsza_komenda = pierwsza_komenda;
1416:main.c        ****         licznik_kolejka_stoi_100ms = 0;
1417:main.c        ****       }
1418:main.c        ****     } else {
1419:main.c        ****       // To nie jest komenda SMS - resetuj licznik (nie interesuje nas)
1420:main.c        ****       ostatnia_pierwsza_komenda = pierwsza_komenda;
1421:main.c        ****       licznik_kolejka_stoi_100ms = 0;
1422:main.c        ****     }
1423:main.c        ****   } else {
1424:main.c        ****     // Kolejka jest pusta
1425:main.c        ****     ostatnia_pierwsza_komenda = KOMENDA_KOLEJKI_BRAK_KOMENDY;
1426:main.c        ****     licznik_kolejka_stoi_100ms = 0;
1427:main.c        ****   }
1428:main.c        **** 
1429:main.c        ****   // Watchdog pilnujacy zakleszczonego wysylania SMS
1430:main.c        ****   if (flaga_wysylanie_smsa) {
1431:main.c        ****     if (licznik_watchdog_wysylanie_smsa_100ms < WATCHDOG_WYSYLANIA_SMS_100MS) {
1432:main.c        ****       ++licznik_watchdog_wysylanie_smsa_100ms;
1433:main.c        ****     } else {
1434:main.c        ****       licznik_watchdog_wysylanie_smsa_100ms = 0;
1435:main.c        ****       // Awaryjne odblokowanie
1436:main.c        ****       watchdog_sms_disarm();
1437:main.c        ****       flaga_wysylanie_smsa = 0;
1438:main.c        ****       liczba_prob_wyslania_smsa = 0;
1439:main.c        ****       czekanie_na_odebranie_zachety = FALSE;
1440:main.c        ****       wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
1441:main.c        **** 
1442:main.c        ****       if (liczba_kolejnych_watchdogow_wysylania < 255)
1443:main.c        ****         ++liczba_kolejnych_watchdogow_wysylania;
1444:main.c        ****       if (liczba_kolejnych_watchdogow_wysylania >= 3) {
1445:main.c        ****         liczba_kolejnych_watchdogow_wysylania = 0;
1446:main.c        ****         reset_modulu_SIM900();
1447:main.c        ****       }
1448:main.c        ****     }
1449:main.c        ****   } else {
1450:main.c        ****     licznik_watchdog_wysylanie_smsa_100ms = 0;
1451:main.c        ****     liczba_kolejnych_watchdogow_wysylania = 0;
1452:main.c        ****   }
1453:main.c        **** 
1454:main.c        ****   if (watchdog_sms_aktywny) {
1455:main.c        ****     if (watchdog_sms_licznik_100ms < WATCHDOG_SMS_TIMEOUT_100MS)
1456:main.c        ****       ++watchdog_sms_licznik_100ms;
1457:main.c        ****     else {
1458:main.c        ****       watchdog_sms_trwa_reset = TRUE;
1459:main.c        ****       cli();
1460:main.c        ****       wdt_enable(WDTO_15MS);
1461:main.c        ****       while (1)
1462:main.c        ****         ;
1463:main.c        ****     }
1464:main.c        ****   } else if (watchdog_sms_safe_mode_100ms) {
1465:main.c        ****     --watchdog_sms_safe_mode_100ms;
1466:main.c        ****   }
1467:main.c        **** 
1468:main.c        ****   // Obsluga szybkich blyskow LED
1469:main.c        ****   if (liczba_blyskow_led > 0) {
1470:main.c        ****     ++stan_cyklu_blysku;
1471:main.c        ****     if (stan_cyklu_blysku >= 6) {
1472:main.c        ****       stan_cyklu_blysku = 0;
1473:main.c        ****       --liczba_blyskow_led;
1474:main.c        ****     }
1475:main.c        ****     ustaw_stan_led(stan_cyklu_blysku < 2);
1476:main.c        ****     return;
1477:main.c        ****   }
1478:main.c        **** 
1479:main.c        ****   // LED: ON gdy nie zalogowany, OFF gdy zalogowany (z mruganiem przy dobrym
1480:main.c        ****   // sygnale)
1481:main.c        ****   if (!modul_zalogowany_w_sieci) {
1482:main.c        ****     // Nie zalogowany - dioda swiecei ciagle
1483:main.c        ****     ustaw_stan_led(TRUE);
1484:main.c        ****   } else {
1485:main.c        ****     // Zalogowany - dioda zgaszona lub mruga w zaleznosci od sygnalu
1486:main.c        ****     if (licznik_100ms_dioda_led) {
1487:main.c        ****       // Mrugniecie (SMS, etc.)
1488:main.c        ****       ustaw_stan_led(TRUE);
1489:main.c        ****     } else {
1490:main.c        ****       // Normalne dzialanie - mrugaj w zaleznosci od poziomu sygnalu
1491:main.c        ****       static uchar licznik_dioda_led_poziom_sieci;
1492:main.c        ****       if (poziom_sieci_gsm < 16) {
1493:main.c        ****         if (++licznik_dioda_led_poziom_sieci >= 50)
1494:main.c        ****           licznik_dioda_led_poziom_sieci = 1;
1495:main.c        ****       } else
1496:main.c        ****         licznik_dioda_led_poziom_sieci = 0;
1497:main.c        **** 
1498:main.c        ****       ustaw_stan_led(licznik_dioda_led_poziom_sieci == 40 ||
1499:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
1500:main.c        ****                      (licznik_dioda_led_poziom_sieci >= 46 &&
1501:main.c        ****                       licznik_dioda_led_poziom_sieci <= 49));
1502:main.c        ****     }
1503:main.c        ****   }
1504:main.c        ****   zapis_w_eeprom_stanu_wyjsc();
1505:main.c        **** }
1506:main.c        **** 
1507:main.c        **** void steruj_urzadzeniem_10MS(void) {
1508:main.c        ****   steruj_wejscia_10ms();
1509:main.c        ****   steruj_SIM900_10MS();
1510:main.c        ****   zapisz_bajt_w_EEPROM();
1511:main.c        ****   // test_dioda_wyjscia();
1512:main.c        ****   // test_wejscie();
1513:main.c        **** }
1514:main.c        **** 
1515:main.c        **** void wolne_zdarzenie_timer(void) {
1516:main.c        ****   WYKONAJ_CLI_SEI(WYLACZ_PRZERWANIE_TIMER());
1517:main.c        ****   if (!CZY_WYKONAC_ZDARZENIE_TIMER()) {
1518:main.c        ****     WYKONAJ_CLI_SEI(WLACZ_PRZERWANIE_TIMER());
1519:main.c        ****     return;
1520:main.c        ****   }
1521:main.c        ****   wykonaj_zdarzenie_timer = FALSE;
1522:main.c        ****   if (wykonac_watki_10MS) {
1523:main.c        ****     wykonac_watki = WYKONAJ_WATKI_10MS;
1524:main.c        ****     wykonac_watki_10MS = FALSE;
1525:main.c        ****   }
1526:main.c        ****   WYKONAJ_CLI_SEI(WLACZ_PRZERWANIE_TIMER());
1527:main.c        ****   if (CZY_WYKONAC_WATKI_10MS()) {
1528:main.c        ****     static uchar licznik_wybuc_watki_100MS = 0;
1529:main.c        **** #define OPOZNIENIE_100_MS 10
1530:main.c        ****     if (++licznik_wybuc_watki_100MS == OPOZNIENIE_100_MS) {
1531:main.c        ****       licznik_wybuc_watki_100MS = 0;
1532:main.c        ****       wykonac_watki = WYKONAJ_WATKI_100MS | WYKONAJ_WATKI_10MS;
1533:main.c        ****     }
1534:main.c        ****     NOP();
1535:main.c        ****     cli();
1536:main.c        ****     if (CZY_ODBIERANIE_DANYCH_SIM900()) {
1537:main.c        ****       WYLACZ_PRZERWANIE_ODBIORU_DANYCH_SIM900();
1538:main.c        ****       sei();
1539:main.c        ****       if (liczba_odebranych_znakow_SIM900 != 0 &&
1540:main.c        ****           ++licznik_opoznienie_oczekiwania_na_bajt_SIM900 >
1541:main.c        ****               MAX_OPOZNIENIE_OCZEKIWANIA_NA_BAJT_SIM900_500_MS) {
1542:main.c        ****         resetuj_odbior_SIM900_po_bledzie();
1543:main.c        ****       } else {
1544:main.c        ****         WYKONAJ_CLI_SEI(WLACZ_PRZERWANIE_ODBIORU_DANYCH_SIM900());
1545:main.c        ****       }
1546:main.c        ****     }
1547:main.c        ****     sei();
1548:main.c        ****   }
1549:main.c        **** }
1550:main.c        **** 
1551:main.c        **** void ustaw_parametry_dla_bezpieczenstwa(void) {
1552:main.c        ****   wdt_reset();
1553:main.c        ****   ustaw_parametry_dla_bezpieczenstwa_rejestry();
1554:main.c        ****   set_sleep_mode(SLEEP_MODE_IDLE);
1555:main.c        **** }
1556:main.c        **** 
1557:main.c        **** void inicjalizuj_parametry_modulu(void) {
1558:main.c        ****   memcpy_E(kod_modulu, ADRES_EEPROM_KOD_DOSTEPU, LICZBA_BAJTOW_KODU_DOSTEPU);
1559:main.c        **** 
1560:main.c        ****   // Auto-naprawa: Jeśli kod jest pusty (FF) lub zerowy, ustaw ABCD
1561:main.c        ****   if (kod_modulu[0] == 0xFF || kod_modulu[0] == 0x00) {
1562:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
1563:main.c        ****     kod_modulu[1] = bufor_eeprom[1] = 'B';
1564:main.c        ****     kod_modulu[2] = bufor_eeprom[2] = 'C';
1565:main.c        ****     kod_modulu[3] = bufor_eeprom[3] = 'D';
1566:main.c        ****     // Zapisz do EEPROM natychmiast (BLOCKING)
1567:main.c        ****     while (!eeprom_is_ready())
1568:main.c        ****       ;
1569:main.c        ****     eeprom_update_block(kod_modulu, (void *)ADRES_EEPROM_KOD_DOSTEPU,
1570:main.c        ****                         LICZBA_BAJTOW_KODU_DOSTEPU);
1571:main.c        ****   }
1572:main.c        **** 
1573:main.c        ****   // Auto-naprawa: Jeśli tryb pracy jest nieokreślony (0xFF), ustaw Publiczny
1574:main.c        ****   // (1)
1575:main.c        ****   tryb_pracy = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_TRYB_PRACY);
1576:main.c        ****   if (tryb_pracy == 0xFF) {
1577:main.c        ****     tryb_pracy = 1; // Domyślnie Publiczny
1578:main.c        ****     while (!eeprom_is_ready())
1579:main.c        ****       ;
1580:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_TRYB_PRACY, 1);
1581:main.c        ****   }
1582:main.c        **** 
1583:main.c        ****   // --- Inicjalizacja trybu CLIP/DTMF ---
1584:main.c        ****   tryb_clip = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_TRYB_CLIP_DTMF);
1585:main.c        ****   if (tryb_clip == 0xFF) {
1586:main.c        ****     tryb_clip = 1; // Domyślnie CLIP (1)
1587:main.c        ****     while (!eeprom_is_ready())
1588:main.c        ****       ;
1589:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_TRYB_CLIP_DTMF, 1);
1590:main.c        ****   }
1591:main.c        **** 
1592:main.c        ****   // Inicjalizacja parametrow czasowych
1593:main.c        ****   czas_start_h = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_START_H);
1594:main.c        ****   czas_start_m = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_START_M);
1595:main.c        ****   czas_stop_h = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_STOP_H);
1596:main.c        ****   czas_stop_m = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_STOP_M);
1597:main.c        **** 
1598:main.c        ****   // Inicjalizacja SKRYBA
1599:main.c        ****   skryba_wlaczona = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA);
1600:main.c        ****   if (skryba_wlaczona == 0xFF)
1601:main.c        ****     skryba_wlaczona = FALSE;
1602:main.c        **** 
1603:main.c        ****   // Odczyt limitu Skryby z EEPROM
1604:main.c        ****   uchar limit_l =
1605:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA_LIMIT_L);
1606:main.c        ****   uchar limit_h =
1607:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA_LIMIT_H);
1608:main.c        ****   if (limit_l == 0xFF && limit_h == 0xFF) {
1609:main.c        ****     // Nie ustawiono - domyslnie 800
1610:main.c        ****     skryba_limit = 800;
1611:main.c        ****   } else {
1612:main.c        ****     skryba_limit = limit_l | (limit_h << 8);
1613:main.c        ****     // Walidacja zakresu
1614:main.c        ****     if (skryba_limit < 1 || skryba_limit > MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA) {
1615:main.c        ****       skryba_limit = 800;
1616:main.c        ****     }
1617:main.c        ****   }
1618:main.c        ****   // Debug initialization
1619:main.c        ****   zapisz_debug_do_eeprom(skryba_wlaczona ? 1 : 0, (uchar)(skryba_limit & 0xFF));
1620:main.c        **** 
1621:main.c        ****   // Auto-naprawa Harmonogramu: Jeśli wartości są nieprawidłowe (ale nie
1622:main.c        ****   // 0xFF), ustaw na OFF
1623:main.c        ****   if ((czas_start_h > 23 && czas_start_h != 0xFF) ||
1624:main.c        ****       (czas_start_m > 59 && czas_start_m != 0xFF) ||
1625:main.c        ****       (czas_stop_h > 23 && czas_stop_h != 0xFF) ||
1626:main.c        ****       (czas_stop_m > 59 && czas_stop_m != 0xFF)) {
1627:main.c        ****     // Zapisz wartosci wylaczajace (0xFF) - BLOCKING
1628:main.c        ****     while (!eeprom_is_ready())
1629:main.c        ****       ;
1630:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_CZAS_START_H, 0xFF);
1631:main.c        ****     while (!eeprom_is_ready())
1632:main.c        ****       ;
1633:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_CZAS_START_M, 0xFF);
1634:main.c        ****     while (!eeprom_is_ready())
1635:main.c        ****       ;
1636:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_CZAS_STOP_H, 0xFF);
1637:main.c        ****     while (!eeprom_is_ready())
1638:main.c        ****       ;
1639:main.c        ****     eeprom_update_byte((uint8_t *)ADRES_EEPROM_CZAS_STOP_M, 0xFF);
1640:main.c        **** 
1641:main.c        ****     czas_start_h = 0xFF;
1642:main.c        ****     czas_start_m = 0xFF;
1643:main.c        ****     czas_stop_h = 0xFF;
1644:main.c        ****     czas_stop_m = 0xFF;
1645:main.c        ****   }
1646:main.c        **** 
1647:main.c        ****   blokada_sterowania_czasowa =
1648:main.c        ****       FALSE; // Domyślnie odblokowane, zaktualizuje sie przy odczycie czasu
1649:main.c        **** 
1650:main.c        ****   // Inicjalizacja blokady systemu (START/STOP)
1651:main.c        ****   blokada_systemu =
1652:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_BLOKADA_SYSTEMU);
1653:main.c        ****   if (blokada_systemu == 0xFF) {
1654:main.c        ****     blokada_systemu = FALSE; // Domyślnie odblokowany
1655:main.c        ****   }
1656:main.c        **** 
1657:main.c        ****   // Inicjalizacja zmiennych debug SKRYBA (jesli 0xFF to wyczysc)
1658:main.c        ****   for (uint16_t addr = ADRES_EEPROM_DEBUG_SKRYBA_1;
1659:main.c        ****        addr <= ADRES_EEPROM_DEBUG_SKRYBA_5; ++addr) {
1660:main.c        ****     if (eeprom_read_byte((const uint8_t *)addr) == 0xFF) {
1661:main.c        ****       while (!eeprom_is_ready())
1662:main.c        ****         ;
1663:main.c        ****       eeprom_update_byte((uint8_t *)addr, 0);
1664:main.c        ****     }
1665:main.c        ****   }
1666:main.c        **** 
1667:main.c        ****   // Inicjalizacja zmiennych debug USER (jesli 0xFF to wyczysc)
1668:main.c        ****   for (uint16_t addr = ADRES_EEPROM_DEBUG_USER_1;
1669:main.c        ****        addr <= ADRES_EEPROM_DEBUG_USER_7; ++addr) {
1670:main.c        ****     if (eeprom_read_byte((const uint8_t *)addr) == 0xFF) {
1671:main.c        ****       while (!eeprom_is_ready())
1672:main.c        ****         ;
1673:main.c        ****       eeprom_update_byte((uint8_t *)addr, 0);
1674:main.c        ****     }
1675:main.c        ****   }
1676:main.c        **** 
1677:main.c        ****   // --- NOWE Z V7 (Ported) ---
1678:main.c        ****   // Reset blokady komend REPORT/USER po inicjalizacji/resecie
1679:main.c        ****   licznik_report_user = 0;
1680:main.c        ****   timer_report_user_100ms = 0;
1681:main.c        **** 
1682:main.c        ****   // Reset flagi wysylania SMS po resecie
1683:main.c        ****   flaga_wysylanie_smsa = 0;
1684:main.c        **** 
1685:main.c        ****   // Zwieksz licznik resetow i zapisz debug
1686:main.c        ****   static uchar licznik_resetow = 0;
1687:main.c        ****   if (licznik_resetow < 255)
1688:main.c        ****     ++licznik_resetow;
1689:main.c        ****   while (!eeprom_is_ready())
1690:main.c        ****     ;
1691:main.c        ****   eeprom_update_byte((void *)EEPROM_DEBUG_LICZNIK_RESETOW, licznik_resetow);
1692:main.c        ****   while (!eeprom_is_ready())
1693:main.c        ****     ;
1694:main.c        ****   zapisz_debug_do_eeprom(0, 2); // Reset (komenda=0 oznacza reset)
1695:main.c        **** }
1696:main.c        **** 
1697:main.c        **** static void opoznienie_startowe(void) {
 189               		.loc 1 1697 0
 190               		.cfi_startproc
 191               	/* prologue: function */
 192               	/* frame size = 0 */
 193               	/* stack size = 0 */
 194               	.L__stack_usage = 0
 195               	.LVL10:
 196               	.LBB362:
 197               	.LBB363:
 198               	.LBB364:
 199               		.file 3 "/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h"
   1:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
   6:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
   9:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  12:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      distribution.
  16:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  17:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  21:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  33:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  35:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  38:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #  endif
  42:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  44:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  48:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /** \file */
  49:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \code
  51:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \endcode
  55:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  56:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     used.
  60:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  61:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  70:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  79:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  83:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** */
  84:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  85:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif
  89:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  90:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
  97:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 103:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****     integer value.
 107:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****  */
 108:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif
 110:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 111:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif
 114:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 115:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #endif
 120:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 121:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** /**
 122:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 124:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 126:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 129:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 131:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 137:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 142:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 147:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    respectively.
 151:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 152:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    \note
 153:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 154:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 164:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****  */
 165:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** void
 166:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** {
 168:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 176:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 179:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 182:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	#else
 183:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	#endif
 186:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 
 187:/usr/local/avr8-gnu-toolchain/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 200               		.loc 3 187 0
 201 0098 8FEF      		ldi r24,lo8(-28673)
 202 009a 9FE8      		ldi r25,hi8(-28673)
 203 009c 0197      	1:	sbiw r24,1
 204 009e 01F4      		brne 1b
 205 00a0 00C0      		rjmp .
 206 00a2 0000      		nop
 207               	.LVL11:
 208 00a4 8FEF      		ldi r24,lo8(-28673)
 209 00a6 9FE8      		ldi r25,hi8(-28673)
 210 00a8 0197      	1:	sbiw r24,1
 211 00aa 01F4      		brne 1b
 212 00ac 00C0      		rjmp .
 213 00ae 0000      		nop
 214               	.LVL12:
 215 00b0 8FEF      		ldi r24,lo8(-28673)
 216 00b2 9FE8      		ldi r25,hi8(-28673)
 217 00b4 0197      	1:	sbiw r24,1
 218 00b6 01F4      		brne 1b
 219 00b8 00C0      		rjmp .
 220 00ba 0000      		nop
 221               	.LVL13:
 222 00bc 8FEF      		ldi r24,lo8(-28673)
 223 00be 9FE8      		ldi r25,hi8(-28673)
 224 00c0 0197      	1:	sbiw r24,1
 225 00c2 01F4      		brne 1b
 226 00c4 00C0      		rjmp .
 227 00c6 0000      		nop
 228               	.LVL14:
 229 00c8 8FEF      		ldi r24,lo8(-28673)
 230 00ca 9FE8      		ldi r25,hi8(-28673)
 231 00cc 0197      	1:	sbiw r24,1
 232 00ce 01F4      		brne 1b
 233 00d0 00C0      		rjmp .
 234 00d2 0000      		nop
 235               	.LVL15:
 236               	.LBE364:
 237               	.LBE363:
 238               	.LBE362:
1698:main.c        ****   for (uchar i = 0; i < 5; ++i)
1699:main.c        ****     _delay_ms(20);
1700:main.c        ****   wdt_reset();
 239               		.loc 1 1700 0
 240               	/* #APP */
 241               	 ;  1700 "main.c" 1
 242 00d4 A895      		wdr
 243               	 ;  0 "" 2
 244               	/* epilogue start */
1701:main.c        **** }
 245               		.loc 1 1701 0
 246               	/* #NOAPP */
 247 00d6 0895      		ret
 248               		.cfi_endproc
 249               	.LFE69:
 252               	zapisz_debug_do_eeprom:
 253               	.LFB37:
 343:main.c        ****   if (!czy_wolny_eeprom())
 254               		.loc 1 343 0
 255               		.cfi_startproc
 256               	.LVL16:
 257 00d8 CF93      		push r28
 258               	.LCFI2:
 259               		.cfi_def_cfa_offset 3
 260               		.cfi_offset 28, -2
 261 00da DF93      		push r29
 262               	.LCFI3:
 263               		.cfi_def_cfa_offset 4
 264               		.cfi_offset 29, -3
 265 00dc CDB7      		in r28,__SP_L__
 266 00de DEB7      		in r29,__SP_H__
 267               	.LCFI4:
 268               		.cfi_def_cfa_register 28
 269 00e0 2897      		sbiw r28,8
 270               	.LCFI5:
 271               		.cfi_def_cfa_offset 12
 272 00e2 0FB6      		in __tmp_reg__,__SREG__
 273 00e4 F894      		cli
 274 00e6 DEBF      		out __SP_H__,r29
 275 00e8 0FBE      		out __SREG__,__tmp_reg__
 276 00ea CDBF      		out __SP_L__,r28
 277               	/* prologue: function */
 278               	/* frame size = 8 */
 279               	/* stack size = 10 */
 280               	.L__stack_usage = 10
 344:main.c        ****     return;
 281               		.loc 1 344 0
 282 00ec 9091 0000 		lds r25,bufor_pomoc_liczba_znakow_do_zapisu
 283 00f0 9111      		cpse r25,__zero_reg__
 284 00f2 00C0      		rjmp .L17
 344:main.c        ****     return;
 285               		.loc 1 344 0 is_stmt 0 discriminator 1
 286 00f4 9091 0000 		lds r25,liczba_znakow_do_zapisu
 287 00f8 9111      		cpse r25,__zero_reg__
 288 00fa 00C0      		rjmp .L17
 344:main.c        ****     return;
 289               		.loc 1 344 0 discriminator 2
 290 00fc 9091 0000 		lds r25,czy_zajety_bufor_eeprom
 291 0100 9111      		cpse r25,__zero_reg__
 292 0102 00C0      		rjmp .L17
 344:main.c        ****     return;
 293               		.loc 1 344 0 discriminator 3
 294 0104 F999      		sbic 0x1f,1
 295 0106 00C0      		rjmp .L17
 296               	.LVL17:
 297               	.LBB368:
 298               	.LBB369:
 348:main.c        ****   buf[1] = (uchar)(timer_report_user_100ms & 0xFF);
 299               		.loc 1 348 0 is_stmt 1
 300 0108 2091 0000 		lds r18,licznik_report_user
 301 010c 2983      		std Y+1,r18
 349:main.c        ****   buf[2] = (uchar)((timer_report_user_100ms >> 8) & 0xFF);
 302               		.loc 1 349 0
 303 010e 3091 0000 		lds r19,timer_report_user_100ms
 304 0112 2091 0000 		lds r18,timer_report_user_100ms+1
 305 0116 3A83      		std Y+2,r19
 350:main.c        ****   buf[3] = (uchar)flaga_wysylanie_smsa;
 306               		.loc 1 350 0
 307 0118 2B83      		std Y+3,r18
 351:main.c        **** 
 308               		.loc 1 351 0
 309 011a 2091 0000 		lds r18,flaga_wysylanie_smsa
 310 011e 2C83      		std Y+4,r18
 311               	.LVL18:
 312 0120 E0E0      		ldi r30,lo8(komendy_kolejka)
 313 0122 F0E0      		ldi r31,hi8(komendy_kolejka)
 314               	.LVL19:
 315               	.L20:
 316               	.LBB370:
 355:main.c        ****         komendy_kolejka[i] <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
 317               		.loc 1 355 0
 318 0124 2191      		ld r18,Z+
 319               	.LVL20:
 320 0126 225D      		subi r18,lo8(-(46))
 321 0128 2230      		cpi r18,lo8(2)
 322 012a 00F4      		brsh .L19
 357:main.c        ****   }
 323               		.loc 1 357 0
 324 012c 9F5F      		subi r25,lo8(-(1))
 325               	.LVL21:
 326               	.L19:
 354:main.c        ****     if (komendy_kolejka[i] >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
 327               		.loc 1 354 0
 328 012e 20E0      		ldi r18,hi8(komendy_kolejka+30)
 329 0130 E030      		cpi r30,lo8(komendy_kolejka+30)
 330 0132 F207      		cpc r31,r18
 331 0134 01F4      		brne .L20
 332               	.LBE370:
 359:main.c        ****   buf[5] = komenda;
 333               		.loc 1 359 0
 334 0136 9D83      		std Y+5,r25
 360:main.c        ****   buf[6] = akcja;
 335               		.loc 1 360 0
 336 0138 8E83      		std Y+6,r24
 361:main.c        **** 
 337               		.loc 1 361 0
 338 013a 6F83      		std Y+7,r22
 363:main.c        **** }
 339               		.loc 1 363 0
 340 013c 47E0      		ldi r20,lo8(7)
 341 013e 62ED      		ldi r22,lo8(-46)
 342 0140 7FE0      		ldi r23,lo8(15)
 343               	.LVL22:
 344 0142 CE01      		movw r24,r28
 345               	.LVL23:
 346 0144 0196      		adiw r24,1
 347 0146 0E94 0000 		call zapisz_znaki_w_eeprom
 348               	.LVL24:
 349               	.L17:
 350               	/* epilogue start */
 351               	.LBE369:
 352               	.LBE368:
 364:main.c        **** 
 353               		.loc 1 364 0
 354 014a 2896      		adiw r28,8
 355 014c 0FB6      		in __tmp_reg__,__SREG__
 356 014e F894      		cli
 357 0150 DEBF      		out __SP_H__,r29
 358 0152 0FBE      		out __SREG__,__tmp_reg__
 359 0154 CDBF      		out __SP_L__,r28
 360 0156 DF91      		pop r29
 361 0158 CF91      		pop r28
 362 015a 0895      		ret
 363               		.cfi_endproc
 364               	.LFE37:
 366               	.global	test_dioda_wyjscia
 368               	test_dioda_wyjscia:
 369               	.LFB24:
 370               		.file 4 "test_pcb.h"
   1:test_pcb.h    **** void test_dioda_wyjscia(void)
   2:test_pcb.h    **** {
 371               		.loc 4 2 0
 372               		.cfi_startproc
 373               	/* prologue: function */
 374               	/* frame size = 0 */
 375               	/* stack size = 0 */
 376               	.L__stack_usage = 0
   3:test_pcb.h    **** 	static uchar opoznienie_1s;
   4:test_pcb.h    **** 	if ( ++opoznienie_1s < 100 )
 377               		.loc 4 4 0
 378 015c 8091 0000 		lds r24,opoznienie_1s.2964
 379 0160 8F5F      		subi r24,lo8(-(1))
 380 0162 8436      		cpi r24,lo8(100)
 381 0164 00F4      		brsh .L23
 382 0166 8093 0000 		sts opoznienie_1s.2964,r24
 383 016a 0895      		ret
 384               	.L23:
   5:test_pcb.h    **** 		return;
   6:test_pcb.h    **** 	opoznienie_1s = 0;
 385               		.loc 4 6 0
 386 016c 1092 0000 		sts opoznienie_1s.2964,__zero_reg__
   7:test_pcb.h    **** 	static uchar stan;
   8:test_pcb.h    **** 	stan = not stan;
 387               		.loc 4 8 0
 388 0170 8091 0000 		lds r24,stan.2965
 389 0174 91E0      		ldi r25,lo8(1)
 390 0176 8111      		cpse r24,__zero_reg__
 391 0178 90E0      		ldi r25,0
 392               	.L25:
 393 017a 9093 0000 		sts stan.2965,r25
   9:test_pcb.h    **** 	if ( stan )
 394               		.loc 4 9 0
 395 017e 8111      		cpse r24,__zero_reg__
 396 0180 00C0      		rjmp .L26
  10:test_pcb.h    **** 	{
  11:test_pcb.h    **** 		ustaw_stan_led(TRUE);
 397               		.loc 4 11 0 discriminator 2
 398 0182 4098      		cbi 0x8,0
 399 0184 0895      		ret
 400               	.L26:
  12:test_pcb.h    **** 	}
  13:test_pcb.h    **** 	else
  14:test_pcb.h    **** 	{
  15:test_pcb.h    **** 		ustaw_stan_led(FALSE);
 401               		.loc 4 15 0 discriminator 1
 402 0186 409A      		sbi 0x8,0
 403               	/* epilogue start */
  16:test_pcb.h    **** 	}
  17:test_pcb.h    **** }
 404               		.loc 4 17 0 discriminator 1
 405 0188 0895      		ret
 406               		.cfi_endproc
 407               	.LFE24:
 409               	.global	test_wejscie
 411               	test_wejscie:
 412               	.LFB25:
  18:test_pcb.h    **** 
  19:test_pcb.h    **** void test_wejscie(void)
  20:test_pcb.h    **** {
 413               		.loc 4 20 0
 414               		.cfi_startproc
 415               	/* prologue: function */
 416               	/* frame size = 0 */
 417               	/* stack size = 0 */
 418               	.L__stack_usage = 0
 419               	.LBB371:
 420               	.LBB372:
 421               		.file 5 "wewy.h"
   1:wewy.h        **** 
   2:wewy.h        **** #include <avr/io.h>
   3:wewy.h        **** #include "narzedzia.h"
   4:wewy.h        **** #include "konfiguracja_eeprom.h"
   5:wewy.h        **** 
   6:wewy.h        **** #define LICZBA_WEJSC	1
   7:wewy.h        **** extern uchar licznik_wejscie[LICZBA_WEJSC];
   8:wewy.h        **** 
   9:wewy.h        **** extern uchar parametry_wejscia[LICZBA_WEJSC];
  10:wewy.h        **** void kopiuj_parametry_we_wy_z_eeprom(void);
  11:wewy.h        **** 
  12:wewy.h        **** extern ulong czas_trwania_impulsu_na_wejsciu[LICZBA_WEJSC];
  13:wewy.h        **** extern ulong czas_trwania_impulsu_off_na_wejsciu[LICZBA_WEJSC];
  14:wewy.h        **** 
  15:wewy.h        **** #define STAN_LOGICZNY_NA_WEJSCIU_WYZWOLENIE	0x02
  16:wewy.h        **** #define STAN_LOGICZNY_NA_WEJSCIU_ON					0x01
  17:wewy.h        **** #define STAN_LOGICZNY_NA_WEJSCIU_OFF				0x00
  18:wewy.h        **** #define CZY_WYZWOLENIE_NA_WEJSCIU(NR_WEJ)	(stan_logiczny_na_wejsciu[NR_WEJ] & STAN_LOGICZNY_NA_WEJS
  19:wewy.h        **** #define CZY_AKTUALNY_STAN_LOGICZNY_ON(NR_WEJ)	(stan_logiczny_na_wejsciu[NR_WEJ] & STAN_LOGICZNY_NA_
  20:wewy.h        **** #define CZY_AKTUALNY_STAN_LOGICZNY_OFF(NR_WEJ)	(!CZY_AKTUALNY_STAN_LOGICZNY_ON(NR_WEJ))
  21:wewy.h        **** 
  22:wewy.h        **** extern uchar stan_logiczny_na_wejsciu[LICZBA_WEJSC];
  23:wewy.h        **** 
  24:wewy.h        **** void steruj_wejscia_10ms(void);
  25:wewy.h        **** void aktualizuj_stan_wyzwolenia_wejsc_100ms(void);
  26:wewy.h        **** void inicjalizuj_parametry_we_wy(void);
  27:wewy.h        **** 
  28:wewy.h        **** static uchar stan_wejscia(const uchar nr_wejscia) __attribute__((unused));
  29:wewy.h        **** 
  30:wewy.h        **** static uchar stan_wejscia(const uchar nr_wejscia)
  31:wewy.h        **** {
  32:wewy.h        **** 	return licznik_wejscie[nr_wejscia] & 0xf0;
 422               		.loc 5 32 0
 423 018a 8091 0000 		lds r24,licznik_wejscie
 424 018e 807F      		andi r24,lo8(-16)
 425               	.LBE372:
 426               	.LBE371:
  21:test_pcb.h    **** 	ustaw_stan_led(stan_wejscia(0));
 427               		.loc 4 21 0
 428 0190 01F4      		brne .L31
 429               		.loc 4 21 0 is_stmt 0 discriminator 1
 430 0192 409A      		sbi 0x8,0
 431 0194 0895      		ret
 432               	.L31:
 433               		.loc 4 21 0 discriminator 2
 434 0196 4098      		cbi 0x8,0
 435               	/* epilogue start */
  22:test_pcb.h    **** }
 436               		.loc 4 22 0 is_stmt 1 discriminator 2
 437 0198 0895      		ret
 438               		.cfi_endproc
 439               	.LFE25:
 441               	.global	__vector_16
 443               	__vector_16:
 444               	.LFB26:
  74:main.c        ****   if (++licznik_wybudz_watki_10MS >= OPOZNIENIE_TIMERA_0) {
 445               		.loc 1 74 0
 446               		.cfi_startproc
 447 019a 7894      		sei
 448 019c 1F92      		push r1
 449               	.LCFI6:
 450               		.cfi_def_cfa_offset 3
 451               		.cfi_offset 1, -2
 452 019e 0F92      		push r0
 453               	.LCFI7:
 454               		.cfi_def_cfa_offset 4
 455               		.cfi_offset 0, -3
 456 01a0 0FB6      		in r0,__SREG__
 457 01a2 0F92      		push r0
 458 01a4 1124      		clr __zero_reg__
 459 01a6 0BB6      		in r0,__RAMPZ__
 460 01a8 0F92      		push r0
 461 01aa 2F93      		push r18
 462               	.LCFI8:
 463               		.cfi_def_cfa_offset 5
 464               		.cfi_offset 18, -4
 465 01ac 8F93      		push r24
 466               	.LCFI9:
 467               		.cfi_def_cfa_offset 6
 468               		.cfi_offset 24, -5
 469 01ae 9F93      		push r25
 470               	.LCFI10:
 471               		.cfi_def_cfa_offset 7
 472               		.cfi_offset 25, -6
 473 01b0 EF93      		push r30
 474               	.LCFI11:
 475               		.cfi_def_cfa_offset 8
 476               		.cfi_offset 30, -7
 477 01b2 FF93      		push r31
 478               	.LCFI12:
 479               		.cfi_def_cfa_offset 9
 480               		.cfi_offset 31, -8
 481               	/* prologue: Interrupt */
 482               	/* frame size = 0 */
 483               	/* stack size = 9 */
 484               	.L__stack_usage = 9
  75:main.c        ****     licznik_wybudz_watki_10MS = 0;
 485               		.loc 1 75 0
 486 01b4 8091 0000 		lds r24,licznik_wybudz_watki_10MS
 487 01b8 8F5F      		subi r24,lo8(-(1))
 488 01ba 8093 0000 		sts licznik_wybudz_watki_10MS,r24
 489 01be 8231      		cpi r24,lo8(18)
 490 01c0 00F0      		brlo .L34
  76:main.c        ****     wykonac_watki_10MS = TRUE;
 491               		.loc 1 76 0
 492 01c2 1092 0000 		sts licznik_wybudz_watki_10MS,__zero_reg__
  77:main.c        ****   }
 493               		.loc 1 77 0
 494 01c6 8FEF      		ldi r24,lo8(-1)
 495 01c8 8093 0000 		sts wykonac_watki_10MS,r24
 496               	.L34:
  80:main.c        ****     if (!CZY_ODBIERANIE_DANYCH_SIM900() && czy_jest_bezczynny_SIM900()) {
 497               		.loc 1 80 0
 498 01cc 4F9B      		sbis 0x9,7
 499 01ce 00C0      		rjmp .L35
  81:main.c        ****       ustaw_odbior_SIM900();
 500               		.loc 1 81 0
 501 01d0 00B6      		in __tmp_reg__,0x30
 502 01d2 01FC      		sbrc __tmp_reg__,1
 503 01d4 00C0      		rjmp .L36
  81:main.c        ****       ustaw_odbior_SIM900();
 504               		.loc 1 81 0 is_stmt 0 discriminator 1
 505 01d6 8091 0000 		lds r24,komenda_SIM900
 506 01da 8111      		cpse r24,__zero_reg__
 507 01dc 00C0      		rjmp .L36
  82:main.c        ****     }
 508               		.loc 1 82 0 is_stmt 1
 509 01de 1092 0000 		sts liczba_odebranych_znakow_SIM900+1,__zero_reg__
 510 01e2 1092 0000 		sts liczba_odebranych_znakow_SIM900,__zero_reg__
 511 01e6 1092 0000 		sts licznik_opoznienie_oczekiwania_na_bajt_SIM900,__zero_reg__
 512 01ea 80B7      		in r24,0x30
 513 01ec 8260      		ori r24,lo8(2)
 514 01ee 80BF      		out 0x30,r24
 515               	/* #APP */
 516               	 ;  82 "main.c" 1
 517 01f0 F894      		cli
 518               	 ;  0 "" 2
 519               	/* #NOAPP */
 520 01f2 8091 C100 		lds r24,193
 521 01f6 8068      		ori r24,lo8(-128)
 522 01f8 8093 C100 		sts 193,r24
 523               	/* #APP */
 524               	 ;  82 "main.c" 1
 525 01fc 7894      		sei
 526               	 ;  0 "" 2
 527               	 ;  82 "main.c" 1
 528 01fe 0000      		nop
 529               	 ;  0 "" 2
 530               	/* #NOAPP */
 531 0200 4598      		cbi 0x8,5
 532               	.L36:
  84:main.c        ****       cli();
 533               		.loc 1 84 0
 534 0202 3499      		sbic 0x6,4
 535 0204 00C0      		rjmp .L37
  85:main.c        ****       if (CZY_WYSYLANIE_DANYCH_SIM900()) {
 536               		.loc 1 85 0
 537               	/* #APP */
 538               	 ;  85 "main.c" 1
 539 0206 F894      		cli
 540               	 ;  0 "" 2
  86:main.c        ****         WYLACZ_PRZERWANIE_WYSYLANIA_DANYCH_SIM900();
 541               		.loc 1 86 0
 542               	/* #NOAPP */
 543 0208 8091 C100 		lds r24,193
 544 020c 86FF      		sbrs r24,6
 545 020e 00C0      		rjmp .L38
 546               	.LBB373:
  87:main.c        ****         sei();
 547               		.loc 1 87 0
 548 0210 8091 C100 		lds r24,193
 549 0214 8F7B      		andi r24,lo8(-65)
 550 0216 8093 C100 		sts 193,r24
  88:main.c        ****         uchar p = sprawdzaj_wejscie_CTS_SIM900;
 551               		.loc 1 88 0
 552               	/* #APP */
 553               	 ;  88 "main.c" 1
 554 021a 7894      		sei
 555               	 ;  0 "" 2
  89:main.c        ****         if (p && (podlaczony_modul_gsm_SIM900 ||
 556               		.loc 1 89 0
 557               	/* #NOAPP */
 558 021c 8091 0000 		lds r24,sprawdzaj_wejscie_CTS_SIM900
 559               	.LVL25:
  90:main.c        ****                   aktualnie_wysylane_polecenie_SIM900 ==
 560               		.loc 1 90 0
 561 0220 8823      		tst r24
 562 0222 01F0      		breq .L39
  90:main.c        ****                   aktualnie_wysylane_polecenie_SIM900 ==
 563               		.loc 1 90 0 is_stmt 0 discriminator 1
 564 0224 8091 0000 		lds r24,podlaczony_modul_gsm_SIM900
 565               	.LVL26:
 566 0228 8111      		cpse r24,__zero_reg__
 567 022a 00C0      		rjmp .L40
  90:main.c        ****                   aktualnie_wysylane_polecenie_SIM900 ==
 568               		.loc 1 90 0 discriminator 2
 569 022c 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 570 0230 8B38      		cpi r24,lo8(-117)
 571 0232 01F4      		brne .L39
 572               	.L40:
 573               	.LVL27:
  94:main.c        ****           WSTAW_ZNAK_DO_BUFORA_SIM900();
 574               		.loc 1 94 0 is_stmt 1
 575 0234 1092 0000 		sts sprawdzaj_wejscie_CTS_SIM900,__zero_reg__
 576               	.LBB374:
  95:main.c        ****         }
 577               		.loc 1 95 0
 578 0238 8091 0000 		lds r24,nr_wyslanego_znaku_SIM900
 579 023c 9091 0000 		lds r25,nr_wyslanego_znaku_SIM900+1
 580               	.LVL28:
 581 0240 FC01      		movw r30,r24
 582 0242 E050      		subi r30,lo8(-(wysylany_blok_SIM900))
 583 0244 F040      		sbci r31,hi8(-(wysylany_blok_SIM900))
 584 0246 2081      		ld r18,Z
 585               	.LVL29:
 586 0248 0196      		adiw r24,1
 587               	.LVL30:
 588 024a 9093 0000 		sts nr_wyslanego_znaku_SIM900+1,r25
 589 024e 8093 0000 		sts nr_wyslanego_znaku_SIM900,r24
 590 0252 2093 C600 		sts 198,r18
 591               	.LVL31:
 592               	.L39:
 593               	.LBE374:
  97:main.c        ****         WLACZ_PRZERWANIE_WYSYLANIA_DANYCH_SIM900();
 594               		.loc 1 97 0
 595               	/* #APP */
 596               	 ;  97 "main.c" 1
 597 0256 F894      		cli
 598               	 ;  0 "" 2
  98:main.c        ****       }
 599               		.loc 1 98 0
 600               	/* #NOAPP */
 601 0258 8091 C100 		lds r24,193
 602 025c 8064      		ori r24,lo8(64)
 603 025e 8093 C100 		sts 193,r24
 604               	.L38:
 605               	.LBE373:
 100:main.c        ****     }
 606               		.loc 1 100 0
 607               	/* #APP */
 608               	 ;  100 "main.c" 1
 609 0262 7894      		sei
 610               	 ;  0 "" 2
 611               	/* #NOAPP */
 612               	.L37:
 106:main.c        ****       TRUE; // uruchamia zdarzenie_timer, ktra korzysta z pozostaych zmiennych
 613               		.loc 1 106 0
 614 0264 8FEF      		ldi r24,lo8(-1)
 615 0266 8093 0000 		sts wykonaj_zdarzenie_timer,r24
 616               	/* epilogue start */
 108:main.c        **** 
 617               		.loc 1 108 0
 618 026a FF91      		pop r31
 619 026c EF91      		pop r30
 620 026e 9F91      		pop r25
 621 0270 8F91      		pop r24
 622 0272 2F91      		pop r18
 623 0274 0F90      		pop r0
 624 0276 0BBE      		out __RAMPZ__,r0
 625 0278 0F90      		pop r0
 626 027a 0FBE      		out __SREG__,r0
 627 027c 0F90      		pop r0
 628 027e 1F90      		pop r1
 629 0280 1895      		reti
 630               	.L35:
 103:main.c        ****   }
 631               		.loc 1 103 0
 632 0282 459A      		sbi 0x8,5
 633               	/* #APP */
 634               	 ;  103 "main.c" 1
 635 0284 F894      		cli
 636               	 ;  0 "" 2
 637               	/* #NOAPP */
 638 0286 8091 C100 		lds r24,193
 639 028a 8F73      		andi r24,lo8(63)
 640 028c 8093 C100 		sts 193,r24
 641 0290 80B7      		in r24,0x30
 642 0292 8D7F      		andi r24,lo8(-3)
 643 0294 80BF      		out 0x30,r24
 644               	/* #APP */
 645               	 ;  103 "main.c" 1
 646 0296 7894      		sei
 647               	 ;  0 "" 2
 648               	 ;  103 "main.c" 1
 649 0298 0000      		nop
 650               	 ;  0 "" 2
 651               	/* #NOAPP */
 652 029a 00C0      		rjmp .L37
 653               		.cfi_endproc
 654               	.LFE26:
 656               	.global	generuj_raport_sieci
 658               	generuj_raport_sieci:
 659               	.LFB27:
 121:main.c        ****   static const char tekst_gsm[] PROGMEM = "AC800-TS";
 660               		.loc 1 121 0
 661               		.cfi_startproc
 662               	.LVL32:
 663 029c DF92      		push r13
 664               	.LCFI13:
 665               		.cfi_def_cfa_offset 3
 666               		.cfi_offset 13, -2
 667 029e EF92      		push r14
 668               	.LCFI14:
 669               		.cfi_def_cfa_offset 4
 670               		.cfi_offset 14, -3
 671 02a0 FF92      		push r15
 672               	.LCFI15:
 673               		.cfi_def_cfa_offset 5
 674               		.cfi_offset 15, -4
 675 02a2 0F93      		push r16
 676               	.LCFI16:
 677               		.cfi_def_cfa_offset 6
 678               		.cfi_offset 16, -5
 679 02a4 1F93      		push r17
 680               	.LCFI17:
 681               		.cfi_def_cfa_offset 7
 682               		.cfi_offset 17, -6
 683 02a6 CF93      		push r28
 684               	.LCFI18:
 685               		.cfi_def_cfa_offset 8
 686               		.cfi_offset 28, -7
 687 02a8 DF93      		push r29
 688               	.LCFI19:
 689               		.cfi_def_cfa_offset 9
 690               		.cfi_offset 29, -8
 691               	/* prologue: function */
 692               	/* frame size = 0 */
 693               	/* stack size = 7 */
 694               	.L__stack_usage = 7
 695 02aa 8C01      		movw r16,r24
 123:main.c        **** 
 696               		.loc 1 123 0
 697 02ac DC01      		movw r26,r24
 698 02ae ED90      		ld r14,X+
 699 02b0 FC90      		ld r15,X
 700               	.LVL33:
 125:main.c        ****   ptr += sizeof tekst_gsm - 1;
 701               		.loc 1 125 0
 702 02b2 48E0      		ldi r20,lo8(8)
 703 02b4 50E0      		ldi r21,0
 704 02b6 60E0      		ldi r22,lo8(tekst_gsm.2996)
 705 02b8 70E0      		ldi r23,hi8(tekst_gsm.2996)
 706 02ba C701      		movw r24,r14
 707               	.LVL34:
 708 02bc 0E94 0000 		call memcpy_P
 709               	.LVL35:
 127:main.c        **** 
 710               		.loc 1 127 0
 711 02c0 E701      		movw r28,r14
 712 02c2 2996      		adiw r28,9
 713               	.LVL36:
 714 02c4 8AE0      		ldi r24,lo8(10)
 715 02c6 D82E      		mov r13,r24
 716 02c8 F701      		movw r30,r14
 717 02ca D086      		std Z+8,r13
 129:main.c        ****   ptr += strlen((char *)ptr);
 718               		.loc 1 129 0
 719 02cc 60E0      		ldi r22,lo8(__c.2998)
 720 02ce 70E0      		ldi r23,hi8(__c.2998)
 721 02d0 CE01      		movw r24,r28
 722 02d2 0E94 0000 		call strcpy_P
 723               	.LVL37:
 130:main.c        ****   strcat((char *)ptr, rtc_czas);
 724               		.loc 1 130 0
 725               		0:
 726 02d6 0990      		ld __tmp_reg__,Y+
 727 02d8 0020      		tst __tmp_reg__
 728 02da 01F4      		brne 0b
 729               	.LVL38:
 730 02dc 2197      		sbiw r28,1
 731               	.LVL39:
 131:main.c        ****   ptr += strlen((char *)ptr);
 732               		.loc 1 131 0
 733 02de 60E0      		ldi r22,lo8(rtc_czas)
 734 02e0 70E0      		ldi r23,hi8(rtc_czas)
 735 02e2 CE01      		movw r24,r28
 736 02e4 0E94 0000 		call strcat
 737               	.LVL40:
 132:main.c        ****   *ptr++ = '\n';
 738               		.loc 1 132 0
 739               		0:
 740 02e8 0990      		ld __tmp_reg__,Y+
 741 02ea 0020      		tst __tmp_reg__
 742 02ec 01F4      		brne 0b
 743               	.LVL41:
 744 02ee 2197      		sbiw r28,1
 745               	.LVL42:
 133:main.c        **** 
 746               		.loc 1 133 0
 747 02f0 DE01      		movw r26,r28
 748 02f2 DD92      		st X+,r13
 749               	.LVL43:
 750 02f4 CD01      		movw r24,r26
 136:main.c        ****   ptr += sizeof text_sygnal - 1;
 751               		.loc 1 136 0
 752 02f6 4BE0      		ldi r20,lo8(11)
 753 02f8 50E0      		ldi r21,0
 754 02fa 60E0      		ldi r22,lo8(text_sygnal.3000)
 755 02fc 70E0      		ldi r23,hi8(text_sygnal.3000)
 756 02fe 0E94 0000 		call memcpy_P
 757               	.LVL44:
 139:main.c        ****     utoa(poziom_sieci_gsm * 100 / 31, ptr, 10);
 758               		.loc 1 139 0
 759 0302 8091 0000 		lds r24,poziom_sieci_gsm
 760 0306 8032      		cpi r24,lo8(32)
 761 0308 00F4      		brsh .L48
 139:main.c        ****     utoa(poziom_sieci_gsm * 100 / 31, ptr, 10);
 762               		.loc 1 139 0 is_stmt 0 discriminator 1
 763 030a 9091 0000 		lds r25,modul_zalogowany_w_sieci
 764 030e 9923      		tst r25
 765 0310 01F0      		breq .L48
 137:main.c        **** 
 766               		.loc 1 137 0 is_stmt 1
 767 0312 2C96      		adiw r28,12
 768               	.LVL45:
 140:main.c        ****     ptr += strlen(ptr);
 769               		.loc 1 140 0
 770 0314 B4E6      		ldi r27,lo8(100)
 771 0316 8B9F      		mul r24,r27
 772 0318 C001      		movw r24,r0
 773 031a 1124      		clr __zero_reg__
 774               	.LVL46:
 775 031c 6FE1      		ldi r22,lo8(31)
 776 031e 70E0      		ldi r23,0
 777 0320 0E94 0000 		call __divmodhi4
 778 0324 CB01      		movw r24,r22
 779               	.LBB375:
 780               	.LBB376:
 781               		.file 6 "/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h"
   1:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Copyright (c) 2004,2007 Joerg Wunsch
   3:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
   4:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Portions of documentation Copyright (c) 1990, 1991, 1993, 1994
   5:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The Regents of the University of California.
   6:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
   7:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    All rights reserved.
   8:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
   9:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Redistribution and use in source and binary forms, with or without
  10:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    modification, are permitted provided that the following conditions are met:
  11:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  12:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    * Redistributions of source code must retain the above copyright
  13:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer.
  14:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  15:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    * Redistributions in binary form must reproduce the above copyright
  16:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      notice, this list of conditions and the following disclaimer in
  17:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      the documentation and/or other materials provided with the
  18:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      distribution.
  19:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  20:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    * Neither the name of the copyright holders nor the names of
  21:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      contributors may be used to endorse or promote products derived
  22:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      from this software without specific prior written permission.
  23:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  24:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  28:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  34:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   POSSIBILITY OF SUCH DAMAGE.
  35:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  36:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****   $Id$
  37:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
  38:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  39:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef _STDLIB_H_
  40:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define	_STDLIB_H_ 1
  41:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  42:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ASSEMBLER__
  43:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  44:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __DOXYGEN__
  45:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define __need_NULL
  46:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define __need_size_t
  47:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define __need_wchar_t
  48:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #include <stddef.h>
  49:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  50:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ptr_t
  51:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define __ptr_t void *
  52:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  53:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif	/* !__DOXYGEN__ */
  54:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  55:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifdef __cplusplus
  56:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern "C" {
  57:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  58:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  59:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** \file */
  60:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  61:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** \defgroup avr_stdlib <stdlib.h>: General utilities
  62:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \code #include <stdlib.h> \endcode
  63:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  64:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     This file declares some basic C macros and functions as
  65:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     defined by the ISO standard, plus some AVR-specific extensions.
  66:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
  67:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  68:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /*@{*/
  69:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** Result type for function div(). */
  70:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** typedef struct {
  71:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	int quot;                   /**< The Quotient. */
  72:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	int rem;                    /**< The Remainder. */
  73:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** } div_t;
  74:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  75:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** Result type for function ldiv(). */
  76:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** typedef struct {
  77:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	long quot;                  /**< The Quotient. */
  78:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	long rem;                   /**< The Remainder. */
  79:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** } ldiv_t;
  80:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  81:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** Comparision function type for qsort(), just for convenience. */
  82:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** typedef int (*__compar_fn_t)(const void *, const void *);
  83:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  84:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __DOXYGEN__
  85:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  86:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ATTR_CONST__
  87:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # define __ATTR_CONST__ __attribute__((__const__))
  88:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  89:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  90:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ATTR_MALLOC__
  91:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # define __ATTR_MALLOC__ __attribute__((__malloc__))
  92:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  93:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  94:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ATTR_NORETURN__
  95:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # define __ATTR_NORETURN__ __attribute__((__noreturn__))
  96:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
  97:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
  98:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __ATTR_PURE__
  99:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # define __ATTR_PURE__ __attribute__((__pure__))
 100:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 101:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 102:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef	__ATTR_GNU_INLINE__
 103:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # ifdef  __GNUC_STDC_INLINE__
 104:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__   __attribute__((__gnu_inline__))
 105:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # else
 106:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #  define __ATTR_GNU_INLINE__
 107:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** # endif
 108:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 109:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 110:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 111:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 112:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** The abort() function causes abnormal program termination to occur.
 113:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     This realization disables interrupts and jumps to _exit() function
 114:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     with argument equal to 1. In the limited AVR environment, execution is
 115:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     effectively halted by entering an infinite loop. */
 116:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void abort(void) __ATTR_NORETURN__;
 117:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 118:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** The abs() function computes the absolute value of the integer \c i.
 119:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 120:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 121:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern int abs(int __i) __ATTR_CONST__;
 122:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 123:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define	abs(__i) __builtin_abs(__i)
 124:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 125:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 126:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** The labs() function computes the absolute value of the long integer
 127:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c i.
 128:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The abs() and labs() functions are builtins of gcc.
 129:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 130:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern long labs(long __i) __ATTR_CONST__;
 131:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifndef __DOXYGEN__
 132:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define labs(__i) __builtin_labs(__i)
 133:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 134:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 135:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 136:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The bsearch() function searches an array of \c nmemb objects, the
 137:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      initial member of which is pointed to by \c base, for a member
 138:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      that matches the object pointed to by \c key.  The size of each
 139:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      member of the array is specified by \c size.
 140:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 141:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The contents of the array should be in ascending sorted order
 142:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      according to the comparison function referenced by \c compar.
 143:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The \c compar routine is expected to have two arguments which
 144:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      point to the key object and to an array member, in that order,
 145:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      and should return an integer less than, equal to, or greater than
 146:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      zero if the key object is found, respectively, to be less than,
 147:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      to match, or be greater than the array member.
 148:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 149:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The bsearch() function returns a pointer to a matching member of
 150:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      the array, or a null pointer if no match is found.  If two
 151:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      members compare as equal, which member is matched is unspecified.
 152:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 153:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void *bsearch(const void *__key, const void *__base, size_t __nmemb,
 154:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 		     size_t __size, int (*__compar)(const void *, const void *));
 155:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 156:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /* __divmodhi4 and __divmodsi4 from libgcc.a */
 157:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 158:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The div() function computes the value \c num/denom and returns
 159:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c div_t that
 160:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      contains two int members named \c quot and \c rem.
 161:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 162:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern div_t div(int __num, int __denom) __asm__("__divmodhi4") __ATTR_CONST__;
 163:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 164:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The ldiv() function computes the value \c num/denom and returns
 165:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      the quotient and remainder in a structure named \c ldiv_t that
 166:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      contains two long integer members named \c quot and \c rem.
 167:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 168:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern ldiv_t ldiv(long __num, long __denom) __asm__("__divmodsi4") __ATTR_CONST__;
 169:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 170:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 171:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The qsort() function is a modified partition-exchange sort, or
 172:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      quicksort.
 173:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 174:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The qsort() function sorts an array of \c nmemb objects, the
 175:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      initial member of which is pointed to by \c base.  The size of
 176:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      each object is specified by \c size.  The contents of the array
 177:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      base are sorted in ascending order according to a comparison
 178:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      function pointed to by \c compar, which requires two arguments
 179:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      pointing to the objects being compared.
 180:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 181:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The comparison function must return an integer less than, equal
 182:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      to, or greater than zero if the first argument is considered to
 183:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      be respectively less than, equal to, or greater than the second.
 184:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 185:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void qsort(void *__base, size_t __nmemb, size_t __size,
 186:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 		  __compar_fn_t __compar);
 187:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 188:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 189:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The strtol() function converts the string in \c nptr to a long
 190:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     value.  The conversion is done according to the given base, which
 191:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     must be between 2 and 36 inclusive, or be the special value 0.
 192:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 193:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 194:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 195:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 196:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 197:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 198:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 199:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 200:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The remainder of the string is converted to a long value in the
 201:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     obvious manner, stopping at the first character which is not a
 202:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     valid digit in the given base.  (In bases above 10, the letter \c 'A'
 203:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     in either upper or lower case represents 10, \c 'B' represents 11,
 204:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     and so forth, with \c 'Z' representing 35.)
 205:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 206:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     If \c endptr is not NULL, strtol() stores the address of the first
 207:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 208:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     however, strtol() stores the original value of \c nptr in \c
 209:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 210:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     on return, the entire string was valid.)
 211:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 212:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The strtol() function returns the result of the conversion, unless
 213:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     the value would underflow or overflow.  If no conversion could be
 214:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     performed, 0 is returned.  If an overflow or underflow occurs, \c
 215:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE" and the function return value
 216:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     is clamped to \c LONG_MIN or \c LONG_MAX, respectively.
 217:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 218:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern long strtol(const char *__nptr, char **__endptr, int __base);
 219:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 220:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 221:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The strtoul() function converts the string in \c nptr to an
 222:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     unsigned long value.  The conversion is done according to the
 223:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     given base, which must be between 2 and 36 inclusive, or be the
 224:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     special value 0.
 225:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 226:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The string may begin with an arbitrary amount of white space (as
 227:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     determined by isspace()) followed by a single optional \c '+' or \c '-'
 228:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     sign.  If \c base is zero or 16, the string may then include a
 229:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c "0x" prefix, and the number will be read in base 16; otherwise,
 230:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     a zero base is taken as 10 (decimal) unless the next character is
 231:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \c '0', in which case it is taken as 8 (octal).
 232:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 233:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The remainder of the string is converted to an unsigned long value
 234:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     in the obvious manner, stopping at the first character which is
 235:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     not a valid digit in the given base.  (In bases above 10, the
 236:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     letter \c 'A' in either upper or lower case represents 10, \c 'B'
 237:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     represents 11, and so forth, with \c 'Z' representing 35.)
 238:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 239:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     If \c endptr is not NULL, strtoul() stores the address of the first
 240:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     invalid character in \c *endptr.  If there were no digits at all,
 241:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     however, strtoul() stores the original value of \c nptr in \c
 242:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     *endptr.  (Thus, if \c *nptr is not \c '\\0' but \c **endptr is \c '\\0'
 243:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     on return, the entire string was valid.)
 244:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 245:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The strtoul() function return either the result of the conversion
 246:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     or, if there was a leading minus sign, the negation of the result
 247:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     of the conversion, unless the original (non-negated) value would
 248:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     overflow; in the latter case, strtoul() returns ULONG_MAX, and \c
 249:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     errno is set to \ref avr_errno "ERANGE".  If no conversion could 
 250:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     be performed, 0 is returned.
 251:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 252:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern unsigned long strtoul(const char *__nptr, char **__endptr, int __base);
 253:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 254:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 255:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The atol() function converts the initial portion of the string
 256:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     pointed to by \p s to long integer representation. In contrast to
 257:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 258:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****         \code strtol(s, (char **)NULL, 10); \endcode
 259:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 260:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 261:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 262:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     stack) and works more quickly.
 263:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 264:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern long atol(const char *__s) __ATTR_PURE__;
 265:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 266:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 267:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The atoi() function converts the initial portion of the string
 268:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     pointed to by \p s to integer representation. In contrast to
 269:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 270:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****         \code (int)strtol(s, (char **)NULL, 10); \endcode
 271:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 272:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     this function does not detect overflow (\c errno is not changed and
 273:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     the result value is not predictable), uses smaller memory (flash and
 274:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     stack) and works more quickly.
 275:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 276:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern int atoi(const char *__s) __ATTR_PURE__;
 277:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 278:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 279:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The exit() function terminates the application.  Since there is no
 280:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    environment to return to, \c status is ignored, and code execution
 281:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    will eventually reach an infinite loop, thereby effectively halting
 282:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    all code processing.  Before entering the infinite loop, interrupts
 283:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    are globally disabled.
 284:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 285:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    In a C++ context, global destructors will be called before halting
 286:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    execution.
 287:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 288:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void exit(int __status) __ATTR_NORETURN__;
 289:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 290:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 291:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The malloc() function allocates \c size bytes of memory.
 292:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    If malloc() fails, a NULL pointer is returned.
 293:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 294:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Note that malloc() does \e not initialize the returned memory to
 295:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    zero bytes.
 296:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 297:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    See the chapter about \ref malloc "malloc() usage" for implementation
 298:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    details.
 299:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 300:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void *malloc(size_t __size) __ATTR_MALLOC__;
 301:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 302:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 303:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The free() function causes the allocated memory referenced by \c
 304:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    ptr to be made available for future allocations.  If \c ptr is
 305:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    NULL, no action occurs.
 306:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 307:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void free(void *__ptr);
 308:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 309:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 310:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 311:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 312:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern size_t __malloc_margin;
 313:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 314:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 315:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 316:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 317:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *__malloc_heap_start;
 318:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 319:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 320:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c malloc() \ref malloc_tunables "tunable".
 321:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 322:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *__malloc_heap_end;
 323:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 324:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 325:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Allocate \c nele elements of \c size each.  Identical to calling
 326:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c malloc() using <tt>nele * size</tt> as argument, except the
 327:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    allocated memory will be cleared to zero.
 328:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 329:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void *calloc(size_t __nele, size_t __size) __ATTR_MALLOC__;
 330:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 331:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 332:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The realloc() function tries to change the size of the region
 333:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    allocated at \c ptr to the new \c size value.  It returns a
 334:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    pointer to the new region.  The returned pointer might be the
 335:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    same as the old pointer, or a pointer to a completely different
 336:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    region.
 337:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 338:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The contents of the returned region up to either the old or the new
 339:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    size value (whatever is less) will be identical to the contents of
 340:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    the old region, even in case a new region had to be allocated.
 341:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 342:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    It is acceptable to pass \c ptr as NULL, in which case realloc()
 343:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    will behave identical to malloc().
 344:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 345:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    If the new memory cannot be allocated, realloc() returns NULL, and
 346:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    the region at \c ptr will not be changed.
 347:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 348:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void *realloc(void *__ptr, size_t __size) __ATTR_MALLOC__;
 349:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 350:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern double strtod(const char *__nptr, char **__endptr);
 351:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 352:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** \ingroup avr_stdlib
 353:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     \fn  double atof (const char *nptr)
 354:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 355:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     The atof() function converts the initial portion of the string pointed
 356:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     to by \a nptr to double representation.
 357:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 358:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     It is equivalent to calling
 359:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	\code strtod(nptr, (char **)0); \endcode
 360:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  */
 361:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern double atof(const char *__nptr);
 362:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 363:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** Highest number that can be generated by rand(). */
 364:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #define	RAND_MAX 0x7FFF
 365:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 366:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 367:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The rand() function computes a sequence of pseudo-random integers in the
 368:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      range of 0 to \c RAND_MAX (as defined by the header file <stdlib.h>).
 369:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 370:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      The srand() function sets its argument \c seed as the seed for a new
 371:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      sequence of pseudo-random numbers to be returned by rand().  These
 372:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      sequences are repeatable by calling srand() with the same seed value.
 373:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 374:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      If no seed value is provided, the functions are automatically seeded with
 375:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      a value of 1.
 376:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 377:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      In compliance with the C standard, these functions operate on
 378:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      \c int arguments.  Since the underlying algorithm already uses
 379:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      32-bit calculations, this causes a loss of precision.  See
 380:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      \c random() for an alternate set of functions that retains full
 381:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****      32-bit precision.
 382:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 383:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern int rand(void);
 384:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 385:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Pseudo-random number generator seeding; see rand().
 386:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 387:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern void srand(unsigned int __seed);
 388:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 389:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 390:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Variant of rand() that stores the context in the user-supplied
 391:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    variable located at \c ctx instead of a static library variable
 392:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    so the function becomes re-entrant.
 393:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 394:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern int rand_r(unsigned long *__ctx);
 395:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /*@}*/
 396:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 397:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /*@{*/
 398:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /** \name Non-standard (i.e. non-ISO C) functions.
 399:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  \ingroup avr_stdlib
 400:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 401:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 402:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \brief Convert an integer to a string.
 403:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 404:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The function itoa() converts the integer value from \c val into an
 405:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 406:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 407:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 408:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 409:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 410:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (int) + 1 characters, i.e. one
 411:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 412:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 413:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 414:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 415:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 416:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 417:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 418:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 419:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c 'a'.
 420:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     
 421:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     If radix is 10 and val is negative, a minus sign will be prepended.
 422:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 423:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The itoa() function returns the pointer passed as \c s.
 424:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 425:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 426:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *itoa(int val, char *s, int radix);
 427:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #else
 428:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 429:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** char *itoa (int __val, char *__s, int __radix)
 430:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** {
 431:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 432:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__itoa (int, char *, int);
 433:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __itoa (__val, __s, __radix);
 434:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 435:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	*__s = 0;
 436:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __s;
 437:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else {
 438:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__itoa_ncheck (int, char *, unsigned char);
 439:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __itoa_ncheck (__val, __s, __radix);
 440:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     }
 441:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** }
 442:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 443:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 444:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 445:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  \ingroup avr_stdlib
 446:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  
 447:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \brief Convert a long integer to a string.
 448:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 449:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The function ltoa() converts the long integer value from \c val into an
 450:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 451:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 452:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 453:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 454:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 455:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (long int) + 1 characters, i.e. one
 456:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 457:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 458:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 459:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 460:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 461:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 462:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 463:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 464:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c 'a'.
 465:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 466:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    If radix is 10 and val is negative, a minus sign will be prepended.
 467:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 468:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The ltoa() function returns the pointer passed as \c s.
 469:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 470:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 471:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *ltoa(long val, char *s, int radix);
 472:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #else
 473:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 474:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** char *ltoa (long __val, char *__s, int __radix)
 475:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** {
 476:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 477:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__ltoa (long, char *, int);
 478:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __ltoa (__val, __s, __radix);
 479:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 480:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	*__s = 0;
 481:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __s;
 482:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else {
 483:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__ltoa_ncheck (long, char *, unsigned char);
 484:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __ltoa_ncheck (__val, __s, __radix);
 485:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     }
 486:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** }
 487:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #endif
 488:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 489:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** /**
 490:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****  \ingroup avr_stdlib
 491:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 492:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \brief Convert an unsigned integer to a string.
 493:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 494:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The function utoa() converts the unsigned integer value from \c val into an
 495:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    ASCII representation that will be stored under \c s.  The caller
 496:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is responsible for providing sufficient storage in \c s.
 497:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 498:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \note The minimal size of the buffer \c s depends on the choice of
 499:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix. For example, if the radix is 2 (binary), you need to supply a buffer
 500:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    with a minimal length of 8 * sizeof (unsigned int) + 1 characters, i.e. one
 501:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    character for each bit plus one for the string terminator. Using a larger
 502:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    radix will require a smaller minimal buffer size.
 503:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 504:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \warning If the buffer is too small, you risk a buffer overflow.
 505:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 506:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    Conversion is done using the \c radix as base, which may be a
 507:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    number between 2 (binary conversion) and up to 36.  If \c radix
 508:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    is greater than 10, the next digit after \c '9' will be the letter
 509:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    \c 'a'.
 510:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 
 511:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****    The utoa() function returns the pointer passed as \c s.
 512:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** */
 513:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #ifdef  __DOXYGEN__
 514:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern char *utoa(unsigned int val, char *s, int radix);
 515:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** #else
 516:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** extern __inline__ __ATTR_GNU_INLINE__
 517:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** char *utoa (unsigned int __val, char *__s, int __radix)
 518:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** {
 519:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     if (!__builtin_constant_p (__radix)) {
 520:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__utoa (unsigned int, char *, int);
 521:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __utoa (__val, __s, __radix);
 522:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else if (__radix < 2 || __radix > 36) {
 523:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	*__s = 0;
 524:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __s;
 525:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h ****     } else {
 526:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	extern char *__utoa_ncheck (unsigned int, char *, unsigned char);
 527:/usr/local/avr8-gnu-toolchain/avr/include/stdlib.h **** 	return __utoa_ncheck (__val, __s, __radix);
 782               		.loc 6 527 0
 783 0326 4AE0      		ldi r20,lo8(10)
 784 0328 BE01      		movw r22,r28
 785 032a 0E94 0000 		call __utoa_ncheck
 786               	.LVL47:
 787               	.LBE376:
 788               	.LBE375:
 141:main.c        ****     *ptr++ = '%';
 789               		.loc 1 141 0
 790               		0:
 791 032e 0990      		ld __tmp_reg__,Y+
 792 0330 0020      		tst __tmp_reg__
 793 0332 01F4      		brne 0b
 794               	.LVL48:
 795 0334 2197      		sbiw r28,1
 796               	.LVL49:
 142:main.c        ****   } else {
 797               		.loc 1 142 0
 798 0336 FE01      		movw r30,r28
 799 0338 3196      		adiw r30,1
 800               	.LVL50:
 801 033a 85E2      		ldi r24,lo8(37)
 802 033c 8883      		st Y,r24
 803               	.L49:
 148:main.c        ****   *buf_sms = ptr;
 804               		.loc 1 148 0
 805 033e 1082      		st Z,__zero_reg__
 149:main.c        **** }
 806               		.loc 1 149 0
 807 0340 D801      		movw r26,r16
 808 0342 ED93      		st X+,r30
 809 0344 FC93      		st X,r31
 810               	/* epilogue start */
 150:main.c        **** 
 811               		.loc 1 150 0
 812 0346 DF91      		pop r29
 813 0348 CF91      		pop r28
 814 034a 1F91      		pop r17
 815 034c 0F91      		pop r16
 816               	.LVL51:
 817 034e FF90      		pop r15
 818 0350 EF90      		pop r14
 819 0352 DF90      		pop r13
 820 0354 0895      		ret
 821               	.LVL52:
 822               	.L48:
 144:main.c        ****     *ptr++ = '-';
 823               		.loc 1 144 0
 824 0356 8DE2      		ldi r24,lo8(45)
 825 0358 8C87      		std Y+12,r24
 826               	.LVL53:
 145:main.c        ****     *ptr++ = '-';
 827               		.loc 1 145 0
 828 035a 8D87      		std Y+13,r24
 146:main.c        ****   }
 829               		.loc 1 146 0
 830 035c FE01      		movw r30,r28
 831 035e 3F96      		adiw r30,15
 832               	.LVL54:
 833 0360 8E87      		std Y+14,r24
 834 0362 00C0      		rjmp .L49
 835               		.cfi_endproc
 836               	.LFE27:
 838               	.global	generuj_raport_uzytkownikow_1
 840               	generuj_raport_uzytkownikow_1:
 841               	.LFB28:
 152:main.c        ****   static const char tekst_gsm[] PROGMEM = "Uzytkownicy ";
 842               		.loc 1 152 0
 843               		.cfi_startproc
 844               	.LVL55:
 845 0364 AF92      		push r10
 846               	.LCFI20:
 847               		.cfi_def_cfa_offset 3
 848               		.cfi_offset 10, -2
 849 0366 BF92      		push r11
 850               	.LCFI21:
 851               		.cfi_def_cfa_offset 4
 852               		.cfi_offset 11, -3
 853 0368 CF92      		push r12
 854               	.LCFI22:
 855               		.cfi_def_cfa_offset 5
 856               		.cfi_offset 12, -4
 857 036a DF92      		push r13
 858               	.LCFI23:
 859               		.cfi_def_cfa_offset 6
 860               		.cfi_offset 13, -5
 861 036c EF92      		push r14
 862               	.LCFI24:
 863               		.cfi_def_cfa_offset 7
 864               		.cfi_offset 14, -6
 865 036e FF92      		push r15
 866               	.LCFI25:
 867               		.cfi_def_cfa_offset 8
 868               		.cfi_offset 15, -7
 869 0370 0F93      		push r16
 870               	.LCFI26:
 871               		.cfi_def_cfa_offset 9
 872               		.cfi_offset 16, -8
 873 0372 1F93      		push r17
 874               	.LCFI27:
 875               		.cfi_def_cfa_offset 10
 876               		.cfi_offset 17, -9
 877 0374 CF93      		push r28
 878               	.LCFI28:
 879               		.cfi_def_cfa_offset 11
 880               		.cfi_offset 28, -10
 881 0376 DF93      		push r29
 882               	.LCFI29:
 883               		.cfi_def_cfa_offset 12
 884               		.cfi_offset 29, -11
 885               	/* prologue: function */
 886               	/* frame size = 0 */
 887               	/* stack size = 10 */
 888               	.L__stack_usage = 10
 889 0378 8C01      		movw r16,r24
 154:main.c        **** 
 890               		.loc 1 154 0
 891 037a FC01      		movw r30,r24
 892 037c C081      		ld r28,Z
 893 037e D181      		ldd r29,Z+1
 894               	.LVL56:
 156:main.c        ****   ptr += sizeof tekst_gsm - 1;
 895               		.loc 1 156 0
 896 0380 4CE0      		ldi r20,lo8(12)
 897 0382 50E0      		ldi r21,0
 898 0384 60E0      		ldi r22,lo8(tekst_gsm.3004)
 899 0386 70E0      		ldi r23,hi8(tekst_gsm.3004)
 900 0388 CE01      		movw r24,r28
 901               	.LVL57:
 902 038a 0E94 0000 		call memcpy_P
 903               	.LVL58:
 157:main.c        ****   uint aktywne_numery = 0;
 904               		.loc 1 157 0
 905 038e 2C96      		adiw r28,12
 906               	.LVL59:
 907 0390 88E0      		ldi r24,lo8(8)
 908 0392 C82E      		mov r12,r24
 909 0394 D12C      		mov r13,__zero_reg__
 159:main.c        ****   // for (uchar nr_uzyt_clip = 0; nr_uzyt_clip <
 910               		.loc 1 159 0
 911 0396 F12C      		mov r15,__zero_reg__
 912 0398 E12C      		mov r14,__zero_reg__
 158:main.c        ****   uint wolne_numery = 0;
 913               		.loc 1 158 0
 914 039a B12C      		mov r11,__zero_reg__
 915 039c A12C      		mov r10,__zero_reg__
 916               	.LVL60:
 917               	.L56:
 918               	.LBB377:
 164:main.c        ****       ++aktywne_numery;
 919               		.loc 1 164 0
 920 039e C601      		movw r24,r12
 921 03a0 0E94 0000 		call eeprom_read_byte
 922               	.LVL61:
 923 03a4 8F3F      		cpi r24,lo8(-1)
 924 03a6 01F0      		breq .L54
 165:main.c        ****     else
 925               		.loc 1 165 0
 926 03a8 FFEF      		ldi r31,-1
 927 03aa AF1A      		sub r10,r31
 928 03ac BF0A      		sbc r11,r31
 929               	.LVL62:
 930               	.L55:
 931 03ae E5E0      		ldi r30,5
 932 03b0 CE0E      		add r12,r30
 933 03b2 D11C      		adc r13,__zero_reg__
 162:main.c        ****        ++nr_uzyt_clip) {
 934               		.loc 1 162 0
 935 03b4 F8EA      		ldi r31,-88
 936 03b6 CF16      		cp r12,r31
 937 03b8 FFE0      		ldi r31,15
 938 03ba DF06      		cpc r13,r31
 939 03bc 01F4      		brne .L56
 940               	.LVL63:
 941               	.LBE377:
 942               	.LBB378:
 943               	.LBB379:
 944               		.loc 6 527 0
 945 03be 4AE0      		ldi r20,lo8(10)
 946 03c0 BE01      		movw r22,r28
 947 03c2 C501      		movw r24,r10
 948 03c4 0E94 0000 		call __utoa_ncheck
 949               	.LVL64:
 950               	.LBE379:
 951               	.LBE378:
 171:main.c        ****   *ptr++ = '/';
 952               		.loc 1 171 0
 953               		0:
 954 03c8 0990      		ld __tmp_reg__,Y+
 955 03ca 0020      		tst __tmp_reg__
 956 03cc 01F4      		brne 0b
 957               	.LVL65:
 958 03ce 2197      		sbiw r28,1
 959               	.LVL66:
 172:main.c        ****   utoa(wolne_numery, ptr, 10);
 960               		.loc 1 172 0
 961 03d0 6E01      		movw r12,r28
 962 03d2 8FEF      		ldi r24,-1
 963 03d4 C81A      		sub r12,r24
 964 03d6 D80A      		sbc r13,r24
 965               	.LVL67:
 966 03d8 8FE2      		ldi r24,lo8(47)
 967 03da 8883      		st Y,r24
 968               	.LVL68:
 969               	.LBB380:
 970               	.LBB381:
 971               		.loc 6 527 0
 972 03dc 4AE0      		ldi r20,lo8(10)
 973 03de B601      		movw r22,r12
 974 03e0 C701      		movw r24,r14
 975 03e2 0E94 0000 		call __utoa_ncheck
 976               	.LVL69:
 977               	.LBE381:
 978               	.LBE380:
 174:main.c        ****   *buf_sms = ptr;
 979               		.loc 1 174 0
 980 03e6 F601      		movw r30,r12
 981               		0:
 982 03e8 0190      		ld __tmp_reg__,Z+
 983 03ea 0020      		tst __tmp_reg__
 984 03ec 01F4      		brne 0b
 985 03ee CF01      		movw r24,r30
 986               	.LVL70:
 987 03f0 0197      		sbiw r24,1
 988               	.LVL71:
 175:main.c        **** }
 989               		.loc 1 175 0
 990 03f2 F801      		movw r30,r16
 991               	.LVL72:
 992 03f4 9183      		std Z+1,r25
 993 03f6 8083      		st Z,r24
 994               	/* epilogue start */
 176:main.c        **** 
 995               		.loc 1 176 0
 996 03f8 DF91      		pop r29
 997 03fa CF91      		pop r28
 998 03fc 1F91      		pop r17
 999 03fe 0F91      		pop r16
 1000               	.LVL73:
 1001 0400 FF90      		pop r15
 1002 0402 EF90      		pop r14
 1003               	.LVL74:
 1004 0404 DF90      		pop r13
 1005 0406 CF90      		pop r12
 1006               	.LVL75:
 1007 0408 BF90      		pop r11
 1008 040a AF90      		pop r10
 1009               	.LVL76:
 1010 040c 0895      		ret
 1011               	.LVL77:
 1012               	.L54:
 1013               	.LBB382:
 167:main.c        ****   }
 1014               		.loc 1 167 0
 1015 040e 8FEF      		ldi r24,-1
 1016 0410 E81A      		sub r14,r24
 1017 0412 F80A      		sbc r15,r24
 1018               	.LVL78:
 1019 0414 00C0      		rjmp .L55
 1020               	.LBE382:
 1021               		.cfi_endproc
 1022               	.LFE28:
 1024               	.global	generuj_raport_uzytkownikow
 1026               	generuj_raport_uzytkownikow:
 1027               	.LFB29:
 178:main.c        ****   static const char tekst_gsm[] PROGMEM = "Uzytkownicy ";
 1028               		.loc 1 178 0
 1029               		.cfi_startproc
 1030               	.LVL79:
 1031 0416 CF92      		push r12
 1032               	.LCFI30:
 1033               		.cfi_def_cfa_offset 3
 1034               		.cfi_offset 12, -2
 1035 0418 DF92      		push r13
 1036               	.LCFI31:
 1037               		.cfi_def_cfa_offset 4
 1038               		.cfi_offset 13, -3
 1039 041a EF92      		push r14
 1040               	.LCFI32:
 1041               		.cfi_def_cfa_offset 5
 1042               		.cfi_offset 14, -4
 1043 041c FF92      		push r15
 1044               	.LCFI33:
 1045               		.cfi_def_cfa_offset 6
 1046               		.cfi_offset 15, -5
 1047 041e 0F93      		push r16
 1048               	.LCFI34:
 1049               		.cfi_def_cfa_offset 7
 1050               		.cfi_offset 16, -6
 1051 0420 1F93      		push r17
 1052               	.LCFI35:
 1053               		.cfi_def_cfa_offset 8
 1054               		.cfi_offset 17, -7
 1055 0422 CF93      		push r28
 1056               	.LCFI36:
 1057               		.cfi_def_cfa_offset 9
 1058               		.cfi_offset 28, -8
 1059 0424 DF93      		push r29
 1060               	.LCFI37:
 1061               		.cfi_def_cfa_offset 10
 1062               		.cfi_offset 29, -9
 1063               	/* prologue: function */
 1064               	/* frame size = 0 */
 1065               	/* stack size = 8 */
 1066               	.L__stack_usage = 8
 1067 0426 8C01      		movw r16,r24
 180:main.c        **** 
 1068               		.loc 1 180 0
 1069 0428 FC01      		movw r30,r24
 1070 042a C081      		ld r28,Z
 1071 042c D181      		ldd r29,Z+1
 1072               	.LVL80:
 182:main.c        ****   ptr += sizeof tekst_gsm - 1;
 1073               		.loc 1 182 0
 1074 042e 4CE0      		ldi r20,lo8(12)
 1075 0430 50E0      		ldi r21,0
 1076 0432 60E0      		ldi r22,lo8(tekst_gsm.3015)
 1077 0434 70E0      		ldi r23,hi8(tekst_gsm.3015)
 1078 0436 CE01      		movw r24,r28
 1079               	.LVL81:
 1080 0438 0E94 0000 		call memcpy_P
 1081               	.LVL82:
 183:main.c        ****   uchar aktywne_numery = 0;
 1082               		.loc 1 183 0
 1083 043c 2C96      		adiw r28,12
 1084               	.LVL83:
 1085 043e 88E0      		ldi r24,lo8(8)
 1086 0440 E82E      		mov r14,r24
 1087 0442 F12C      		mov r15,__zero_reg__
 185:main.c        ****   for (uint nr_uzyt_clip = 0; nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 1088               		.loc 1 185 0
 1089 0444 D12C      		mov r13,__zero_reg__
 184:main.c        ****   uchar wolne_numery = 0;
 1090               		.loc 1 184 0
 1091 0446 C12C      		mov r12,__zero_reg__
 1092               	.LVL84:
 1093               	.L61:
 1094               	.LBB383:
 188:main.c        ****       ++aktywne_numery;
 1095               		.loc 1 188 0
 1096 0448 C701      		movw r24,r14
 1097 044a 0E94 0000 		call eeprom_read_byte
 1098               	.LVL85:
 1099 044e 8F3F      		cpi r24,lo8(-1)
 1100 0450 01F0      		breq .L59
 189:main.c        ****     else
 1101               		.loc 1 189 0
 1102 0452 C394      		inc r12
 1103               	.LVL86:
 1104               	.L60:
 1105 0454 F5E0      		ldi r31,5
 1106 0456 EF0E      		add r14,r31
 1107 0458 F11C      		adc r15,__zero_reg__
 186:main.c        ****        ++nr_uzyt_clip) {
 1108               		.loc 1 186 0
 1109 045a 88EA      		ldi r24,-88
 1110 045c E816      		cp r14,r24
 1111 045e 8FE0      		ldi r24,15
 1112 0460 F806      		cpc r15,r24
 1113 0462 01F4      		brne .L61
 1114               	.LVL87:
 1115               	.LBE383:
 1116               	.LBB384:
 1117               	.LBB385:
 1118               		.loc 6 527 0
 1119 0464 4AE0      		ldi r20,lo8(10)
 1120 0466 BE01      		movw r22,r28
 1121 0468 8C2D      		mov r24,r12
 1122 046a 90E0      		ldi r25,0
 1123 046c 0E94 0000 		call __utoa_ncheck
 1124               	.LVL88:
 1125               	.LBE385:
 1126               	.LBE384:
 194:main.c        ****   *ptr++ = '/';
 1127               		.loc 1 194 0
 1128               		0:
 1129 0470 0990      		ld __tmp_reg__,Y+
 1130 0472 0020      		tst __tmp_reg__
 1131 0474 01F4      		brne 0b
 1132               	.LVL89:
 1133 0476 2197      		sbiw r28,1
 1134               	.LVL90:
 195:main.c        ****   utoa(wolne_numery, ptr, 10);
 1135               		.loc 1 195 0
 1136 0478 7E01      		movw r14,r28
 1137 047a EFEF      		ldi r30,-1
 1138 047c EE1A      		sub r14,r30
 1139 047e FE0A      		sbc r15,r30
 1140               	.LVL91:
 1141 0480 8FE2      		ldi r24,lo8(47)
 1142 0482 8883      		st Y,r24
 1143               	.LVL92:
 1144               	.LBB386:
 1145               	.LBB387:
 1146               		.loc 6 527 0
 1147 0484 4AE0      		ldi r20,lo8(10)
 1148 0486 B701      		movw r22,r14
 1149 0488 8D2D      		mov r24,r13
 1150 048a 90E0      		ldi r25,0
 1151 048c 0E94 0000 		call __utoa_ncheck
 1152               	.LVL93:
 1153               	.LBE387:
 1154               	.LBE386:
 197:main.c        ****   *buf_sms = ptr;
 1155               		.loc 1 197 0
 1156 0490 F701      		movw r30,r14
 1157               		0:
 1158 0492 0190      		ld __tmp_reg__,Z+
 1159 0494 0020      		tst __tmp_reg__
 1160 0496 01F4      		brne 0b
 1161 0498 CF01      		movw r24,r30
 1162               	.LVL94:
 1163 049a 0197      		sbiw r24,1
 1164               	.LVL95:
 198:main.c        **** }
 1165               		.loc 1 198 0
 1166 049c F801      		movw r30,r16
 1167               	.LVL96:
 1168 049e 9183      		std Z+1,r25
 1169 04a0 8083      		st Z,r24
 1170               	/* epilogue start */
 199:main.c        **** 
 1171               		.loc 1 199 0
 1172 04a2 DF91      		pop r29
 1173 04a4 CF91      		pop r28
 1174 04a6 1F91      		pop r17
 1175 04a8 0F91      		pop r16
 1176               	.LVL97:
 1177 04aa FF90      		pop r15
 1178 04ac EF90      		pop r14
 1179               	.LVL98:
 1180 04ae DF90      		pop r13
 1181               	.LVL99:
 1182 04b0 CF90      		pop r12
 1183               	.LVL100:
 1184 04b2 0895      		ret
 1185               	.LVL101:
 1186               	.L59:
 1187               	.LBB388:
 191:main.c        ****   }
 1188               		.loc 1 191 0
 1189 04b4 D394      		inc r13
 1190               	.LVL102:
 1191 04b6 00C0      		rjmp .L60
 1192               	.LBE388:
 1193               		.cfi_endproc
 1194               	.LFE29:
 1196               		.section	.rodata.str1.1,"aMS",@progbits,1
 1197               	.LC0:
 1198 0000 4861 726D 		.string	"Harmonogram: %02d:%02d %02d:%02d"
 1198      6F6E 6F67 
 1198      7261 6D3A 
 1198      2025 3032 
 1198      643A 2530 
 1199               	.LC1:
 1200 0021 536B 7279 		.string	"Skryba: Limit %d"
 1200      6261 3A20 
 1200      4C69 6D69 
 1200      7420 2564 
 1200      00
 1201               		.text
 1202               	.global	generuj_raport_stanu_urzadzenia
 1204               	generuj_raport_stanu_urzadzenia:
 1205               	.LFB30:
 204:main.c        ****   uchar *sms = (char *)tekst_wysylanego_smsa;
 1206               		.loc 1 204 0
 1207               		.cfi_startproc
 1208 04b8 EF92      		push r14
 1209               	.LCFI38:
 1210               		.cfi_def_cfa_offset 3
 1211               		.cfi_offset 14, -2
 1212 04ba FF92      		push r15
 1213               	.LCFI39:
 1214               		.cfi_def_cfa_offset 4
 1215               		.cfi_offset 15, -3
 1216 04bc 0F93      		push r16
 1217               	.LCFI40:
 1218               		.cfi_def_cfa_offset 5
 1219               		.cfi_offset 16, -4
 1220 04be 1F93      		push r17
 1221               	.LCFI41:
 1222               		.cfi_def_cfa_offset 6
 1223               		.cfi_offset 17, -5
 1224 04c0 CF93      		push r28
 1225               	.LCFI42:
 1226               		.cfi_def_cfa_offset 7
 1227               		.cfi_offset 28, -6
 1228 04c2 DF93      		push r29
 1229               	.LCFI43:
 1230               		.cfi_def_cfa_offset 8
 1231               		.cfi_offset 29, -7
 1232 04c4 00D0      		rcall .
 1233               	.LCFI44:
 1234               		.cfi_def_cfa_offset 10
 1235 04c6 CDB7      		in r28,__SP_L__
 1236 04c8 DEB7      		in r29,__SP_H__
 1237               	.LCFI45:
 1238               		.cfi_def_cfa_register 28
 1239               	/* prologue: function */
 1240               	/* frame size = 2 */
 1241               	/* stack size = 8 */
 1242               	.L__stack_usage = 8
 206:main.c        ****   *sms++ = '\n';
 1243               		.loc 1 206 0
 1244 04ca 8AE2      		ldi r24,lo8(42)
 1245 04cc 8093 0000 		sts tekst_wysylanego_smsa,r24
 207:main.c        ****   generuj_raport_sieci(&sms);
 1246               		.loc 1 207 0
 1247 04d0 80E0      		ldi r24,lo8(tekst_wysylanego_smsa+2)
 1248 04d2 90E0      		ldi r25,hi8(tekst_wysylanego_smsa+2)
 1249 04d4 9A83      		std Y+2,r25
 1250 04d6 8983      		std Y+1,r24
 1251 04d8 1AE0      		ldi r17,lo8(10)
 1252 04da 1093 0000 		sts tekst_wysylanego_smsa+1,r17
 208:main.c        ****   *sms++ = '\n';
 1253               		.loc 1 208 0
 1254 04de CE01      		movw r24,r28
 1255 04e0 0196      		adiw r24,1
 1256 04e2 0E94 0000 		call generuj_raport_sieci
 1257               	.LVL103:
 209:main.c        ****   generuj_raport_uzytkownikow_1(&sms);
 1258               		.loc 1 209 0
 1259 04e6 E981      		ldd r30,Y+1
 1260 04e8 FA81      		ldd r31,Y+2
 1261 04ea CF01      		movw r24,r30
 1262 04ec 0196      		adiw r24,1
 1263 04ee 9A83      		std Y+2,r25
 1264 04f0 8983      		std Y+1,r24
 1265 04f2 1083      		st Z,r17
 210:main.c        ****   *sms++ = '\n';
 1266               		.loc 1 210 0
 1267 04f4 CE01      		movw r24,r28
 1268 04f6 0196      		adiw r24,1
 1269 04f8 0E94 0000 		call generuj_raport_uzytkownikow_1
 1270               	.LVL104:
 211:main.c        **** 
 1271               		.loc 1 211 0
 1272 04fc E981      		ldd r30,Y+1
 1273 04fe FA81      		ldd r31,Y+2
 1274 0500 CF01      		movw r24,r30
 1275 0502 0196      		adiw r24,1
 1276 0504 9A83      		std Y+2,r25
 1277 0506 8983      		std Y+1,r24
 1278 0508 1083      		st Z,r17
 214:main.c        ****     strcpy_P((char *)sms, PSTR("Status: Zablokowany"));
 1279               		.loc 1 214 0
 1280 050a 2091 0000 		lds r18,blokada_systemu
 1281 050e 8981      		ldd r24,Y+1
 1282 0510 9A81      		ldd r25,Y+2
 215:main.c        ****   } else {
 1283               		.loc 1 215 0
 1284 0512 60E0      		ldi r22,lo8(__c.3029)
 1285 0514 70E0      		ldi r23,hi8(__c.3029)
 214:main.c        ****     strcpy_P((char *)sms, PSTR("Status: Zablokowany"));
 1286               		.loc 1 214 0
 1287 0516 2111      		cpse r18,__zero_reg__
 1288 0518 00C0      		rjmp .L81
 217:main.c        ****   }
 1289               		.loc 1 217 0
 1290 051a 60E0      		ldi r22,lo8(__c.3031)
 1291 051c 70E0      		ldi r23,hi8(__c.3031)
 1292               	.L81:
 1293 051e 0E94 0000 		call strcpy_P
 1294               	.LVL105:
 219:main.c        ****   *sms++ = '\n';
 1295               		.loc 1 219 0
 1296 0522 E981      		ldd r30,Y+1
 1297 0524 FA81      		ldd r31,Y+2
 1298               		0:
 1299 0526 0190      		ld __tmp_reg__,Z+
 1300 0528 0020      		tst __tmp_reg__
 1301 052a 01F4      		brne 0b
 220:main.c        **** 
 1302               		.loc 1 220 0
 1303 052c DF01      		movw r26,r30
 1304 052e 1197      		sbiw r26,1
 1305 0530 FA83      		std Y+2,r31
 1306 0532 E983      		std Y+1,r30
 1307 0534 8AE0      		ldi r24,lo8(10)
 1308 0536 8C93      		st X,r24
 223:main.c        ****     strcpy_P((char *)sms, PSTR("Tryb: Prywatny"));
 1309               		.loc 1 223 0
 1310 0538 2091 0000 		lds r18,tryb_pracy
 1311 053c 8981      		ldd r24,Y+1
 1312 053e 9A81      		ldd r25,Y+2
 224:main.c        ****   } else {
 1313               		.loc 1 224 0
 1314 0540 60E0      		ldi r22,lo8(__c.3033)
 1315 0542 70E0      		ldi r23,hi8(__c.3033)
 223:main.c        ****     strcpy_P((char *)sms, PSTR("Tryb: Prywatny"));
 1316               		.loc 1 223 0
 1317 0544 2223      		tst r18
 1318 0546 01F0      		breq .L82
 226:main.c        ****   }
 1319               		.loc 1 226 0
 1320 0548 60E0      		ldi r22,lo8(__c.3035)
 1321 054a 70E0      		ldi r23,hi8(__c.3035)
 1322               	.L82:
 1323 054c 0E94 0000 		call strcpy_P
 1324               	.LVL106:
 228:main.c        **** 
 1325               		.loc 1 228 0
 1326 0550 8981      		ldd r24,Y+1
 1327 0552 9A81      		ldd r25,Y+2
 1328 0554 FC01      		movw r30,r24
 1329               		0:
 1330 0556 0190      		ld __tmp_reg__,Z+
 1331 0558 0020      		tst __tmp_reg__
 1332 055a 01F4      		brne 0b
 1333 055c CF01      		movw r24,r30
 1334 055e 0197      		sbiw r24,1
 1335 0560 9A83      		std Y+2,r25
 1336 0562 8983      		std Y+1,r24
 230:main.c        ****     strcpy_P((char *)sms, PSTR(" CLIP"));
 1337               		.loc 1 230 0
 1338 0564 2091 0000 		lds r18,tryb_clip
 231:main.c        ****   } else {
 1339               		.loc 1 231 0
 1340 0568 60E0      		ldi r22,lo8(__c.3037)
 1341 056a 70E0      		ldi r23,hi8(__c.3037)
 230:main.c        ****     strcpy_P((char *)sms, PSTR(" CLIP"));
 1342               		.loc 1 230 0
 1343 056c 2111      		cpse r18,__zero_reg__
 1344 056e 00C0      		rjmp .L83
 233:main.c        ****   }
 1345               		.loc 1 233 0
 1346 0570 60E0      		ldi r22,lo8(__c.3039)
 1347 0572 70E0      		ldi r23,hi8(__c.3039)
 1348               	.L83:
 1349 0574 0E94 0000 		call strcpy_P
 1350               	.LVL107:
 235:main.c        ****   *sms++ = '\n';
 1351               		.loc 1 235 0
 1352 0578 E981      		ldd r30,Y+1
 1353 057a FA81      		ldd r31,Y+2
 1354               		0:
 1355 057c 0190      		ld __tmp_reg__,Z+
 1356 057e 0020      		tst __tmp_reg__
 1357 0580 01F4      		brne 0b
 236:main.c        **** 
 1358               		.loc 1 236 0
 1359 0582 DF01      		movw r26,r30
 1360 0584 1197      		sbiw r26,1
 1361 0586 FA83      		std Y+2,r31
 1362 0588 E983      		std Y+1,r30
 1363 058a 8AE0      		ldi r24,lo8(10)
 1364 058c 8C93      		st X,r24
 238:main.c        ****     strcpy_P((char *)sms, PSTR("Harmonogram: Wylaczony"));
 1365               		.loc 1 238 0
 1366 058e 8091 0000 		lds r24,czas_start_h
 1367 0592 8F3F      		cpi r24,lo8(-1)
 1368 0594 01F0      		breq .+2
 1369 0596 00C0      		rjmp .L70
 239:main.c        ****   } else {
 1370               		.loc 1 239 0
 1371 0598 60E0      		ldi r22,lo8(__c.3041)
 1372 059a 70E0      		ldi r23,hi8(__c.3041)
 1373 059c 8981      		ldd r24,Y+1
 1374 059e 9A81      		ldd r25,Y+2
 1375 05a0 0E94 0000 		call strcpy_P
 1376               	.LVL108:
 1377               	.L71:
 244:main.c        ****   *sms++ = '\n';
 1378               		.loc 1 244 0
 1379 05a4 E981      		ldd r30,Y+1
 1380 05a6 FA81      		ldd r31,Y+2
 1381               		0:
 1382 05a8 0190      		ld __tmp_reg__,Z+
 1383 05aa 0020      		tst __tmp_reg__
 1384 05ac 01F4      		brne 0b
 245:main.c        **** 
 1385               		.loc 1 245 0
 1386 05ae DF01      		movw r26,r30
 1387 05b0 1197      		sbiw r26,1
 1388 05b2 FA83      		std Y+2,r31
 1389 05b4 E983      		std Y+1,r30
 1390 05b6 8AE0      		ldi r24,lo8(10)
 1391 05b8 8C93      		st X,r24
 247:main.c        ****     uint aktywne_numery = 0;
 1392               		.loc 1 247 0
 1393 05ba 8091 0000 		lds r24,skryba_wlaczona
 1394 05be 8823      		tst r24
 1395 05c0 01F4      		brne .+2
 1396 05c2 00C0      		rjmp .L72
 1397 05c4 08E0      		ldi r16,lo8(8)
 1398 05c6 10E0      		ldi r17,0
 1399               	.LBB389:
 248:main.c        ****     for (uint nr_uzyt_clip = 0;
 1400               		.loc 1 248 0
 1401 05c8 F12C      		mov r15,__zero_reg__
 1402 05ca E12C      		mov r14,__zero_reg__
 1403               	.L74:
 1404               	.LVL109:
 1405               	.LBB390:
 251:main.c        ****         ++aktywne_numery;
 1406               		.loc 1 251 0
 1407 05cc C801      		movw r24,r16
 1408 05ce 0E94 0000 		call eeprom_read_byte
 1409               	.LVL110:
 1410 05d2 8F3F      		cpi r24,lo8(-1)
 1411 05d4 01F0      		breq .L73
 252:main.c        ****     }
 1412               		.loc 1 252 0
 1413 05d6 9FEF      		ldi r25,-1
 1414 05d8 E91A      		sub r14,r25
 1415 05da F90A      		sbc r15,r25
 1416               	.LVL111:
 1417               	.L73:
 1418 05dc 0B5F      		subi r16,-5
 1419 05de 1F4F      		sbci r17,-1
 249:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 1420               		.loc 1 249 0
 1421 05e0 083A      		cpi r16,-88
 1422 05e2 EFE0      		ldi r30,15
 1423 05e4 1E07      		cpc r17,r30
 1424 05e6 01F4      		brne .L74
 1425               	.LBE390:
 254:main.c        ****     if (pozostalo < 0)
 1426               		.loc 1 254 0
 1427 05e8 8091 0000 		lds r24,skryba_limit
 1428 05ec 9091 0000 		lds r25,skryba_limit+1
 1429               	.LVL112:
 257:main.c        ****   } else {
 1430               		.loc 1 257 0
 1431 05f0 8E19      		sub r24,r14
 1432 05f2 9F09      		sbc r25,r15
 1433               	.LVL113:
 1434 05f4 97FF      		sbrs r25,7
 1435 05f6 00C0      		rjmp .L75
 1436 05f8 90E0      		ldi r25,0
 1437 05fa 80E0      		ldi r24,0
 1438               	.LVL114:
 1439               	.L75:
 1440 05fc 9F93      		push r25
 1441 05fe 8F93      		push r24
 1442 0600 80E0      		ldi r24,lo8(.LC1)
 1443 0602 90E0      		ldi r25,hi8(.LC1)
 1444 0604 9F93      		push r25
 1445 0606 8F93      		push r24
 1446 0608 8A81      		ldd r24,Y+2
 1447 060a 8F93      		push r24
 1448 060c 8981      		ldd r24,Y+1
 1449 060e 8F93      		push r24
 1450 0610 0E94 0000 		call sprintf
 1451               	.LVL115:
 1452               	.LBE389:
 1453 0614 0F90      		pop __tmp_reg__
 1454 0616 0F90      		pop __tmp_reg__
 1455 0618 0F90      		pop __tmp_reg__
 1456 061a 0F90      		pop __tmp_reg__
 1457 061c 0F90      		pop __tmp_reg__
 1458 061e 0F90      		pop __tmp_reg__
 1459               	.LVL116:
 1460               	.L76:
 261:main.c        ****   *sms++ = '\n';
 1461               		.loc 1 261 0
 1462 0620 E981      		ldd r30,Y+1
 1463 0622 FA81      		ldd r31,Y+2
 1464               		0:
 1465 0624 0190      		ld __tmp_reg__,Z+
 1466 0626 0020      		tst __tmp_reg__
 1467 0628 01F4      		brne 0b
 262:main.c        **** 
 1468               		.loc 1 262 0
 1469 062a DF01      		movw r26,r30
 1470 062c 1197      		sbiw r26,1
 1471 062e FA83      		std Y+2,r31
 1472 0630 E983      		std Y+1,r30
 1473 0632 8AE0      		ldi r24,lo8(10)
 1474 0634 8C93      		st X,r24
 265:main.c        **** }
 1475               		.loc 1 265 0
 1476 0636 60E0      		ldi r22,lo8(tekst_demo.3051)
 1477 0638 70E0      		ldi r23,hi8(tekst_demo.3051)
 1478 063a 8981      		ldd r24,Y+1
 1479 063c 9A81      		ldd r25,Y+2
 1480 063e 0E94 0000 		call strcpy_P
 1481               	.LVL117:
 1482               	/* epilogue start */
 266:main.c        **** 
 1483               		.loc 1 266 0
 1484 0642 0F90      		pop __tmp_reg__
 1485 0644 0F90      		pop __tmp_reg__
 1486 0646 DF91      		pop r29
 1487 0648 CF91      		pop r28
 1488 064a 1F91      		pop r17
 1489 064c 0F91      		pop r16
 1490 064e FF90      		pop r15
 1491 0650 EF90      		pop r14
 1492 0652 0895      		ret
 1493               	.L70:
 241:main.c        ****             (int)czas_start_m, (int)czas_stop_h, (int)czas_stop_m);
 1494               		.loc 1 241 0
 1495 0654 9091 0000 		lds r25,czas_stop_m
 1496 0658 1F92      		push __zero_reg__
 1497 065a 9F93      		push r25
 1498 065c 9091 0000 		lds r25,czas_stop_h
 1499 0660 1F92      		push __zero_reg__
 1500 0662 9F93      		push r25
 1501 0664 9091 0000 		lds r25,czas_start_m
 1502 0668 1F92      		push __zero_reg__
 1503 066a 9F93      		push r25
 1504 066c 1F92      		push __zero_reg__
 1505 066e 8F93      		push r24
 1506 0670 80E0      		ldi r24,lo8(.LC0)
 1507 0672 90E0      		ldi r25,hi8(.LC0)
 1508 0674 9F93      		push r25
 1509 0676 8F93      		push r24
 1510 0678 8A81      		ldd r24,Y+2
 1511 067a 8F93      		push r24
 1512 067c 8981      		ldd r24,Y+1
 1513 067e 8F93      		push r24
 1514 0680 0E94 0000 		call sprintf
 1515               	.LVL118:
 1516 0684 0FB6      		in __tmp_reg__,__SREG__
 1517 0686 F894      		cli
 1518 0688 DEBF      		out __SP_H__,r29
 1519 068a 0FBE      		out __SREG__,__tmp_reg__
 1520 068c CDBF      		out __SP_L__,r28
 1521 068e 00C0      		rjmp .L71
 1522               	.L72:
 259:main.c        ****   }
 1523               		.loc 1 259 0
 1524 0690 60E0      		ldi r22,lo8(__c.3049)
 1525 0692 70E0      		ldi r23,hi8(__c.3049)
 1526 0694 8981      		ldd r24,Y+1
 1527 0696 9A81      		ldd r25,Y+2
 1528 0698 0E94 0000 		call strcpy_P
 1529               	.LVL119:
 1530 069c 00C0      		rjmp .L76
 1531               		.cfi_endproc
 1532               	.LFE30:
 1534               	.global	ustaw_wyjscie_clip
 1536               	ustaw_wyjscie_clip:
 1537               	.LFB31:
 268:main.c        ****   stan_wyjscie[0] = TRUE;
 1538               		.loc 1 268 0
 1539               		.cfi_startproc
 1540               	/* prologue: function */
 1541               	/* frame size = 0 */
 1542               	/* stack size = 0 */
 1543               	.L__stack_usage = 0
 269:main.c        ****   licznik_przelacznik_wyjscia[0] = 2 * 10ul; // 2 sekundy
 1544               		.loc 1 269 0
 1545 069e 8FEF      		ldi r24,lo8(-1)
 1546 06a0 8093 0000 		sts stan_wyjscie,r24
 270:main.c        **** }
 1547               		.loc 1 270 0
 1548 06a4 84E1      		ldi r24,lo8(20)
 1549 06a6 90E0      		ldi r25,0
 1550 06a8 A0E0      		ldi r26,0
 1551 06aa B0E0      		ldi r27,0
 1552 06ac 8093 0000 		sts licznik_przelacznik_wyjscia,r24
 1553 06b0 9093 0000 		sts licznik_przelacznik_wyjscia+1,r25
 1554 06b4 A093 0000 		sts licznik_przelacznik_wyjscia+2,r26
 1555 06b8 B093 0000 		sts licznik_przelacznik_wyjscia+3,r27
 1556               	/* epilogue start */
 271:main.c        **** 
 1557               		.loc 1 271 0
 1558 06bc 0895      		ret
 1559               		.cfi_endproc
 1560               	.LFE31:
 1562               		.section	.rodata.str1.1
 1563               	.LC2:
 1564 0032 3A20 00   		.string	": "
 1565               	.LC3:
 1566 0035 4F4B 00   		.string	"OK"
 1567               	.LC4:
 1568 0038 4272 616B 		.string	"Brak takiego numeru w systemie"
 1568      2074 616B 
 1568      6965 676F 
 1568      206E 756D 
 1568      6572 7520 
 1569               	.LC5:
 1570 0057 5770 6973 		.string	"Wpisz numer jaki sprawdzasz, np: USER 793557357"
 1570      7A20 6E75 
 1570      6D65 7220 
 1570      6A61 6B69 
 1570      2073 7072 
 1571               		.text
 1572               	.global	wykonanie_polecenia_sms
 1574               	wykonanie_polecenia_sms:
 1575               	.LFB38:
 366:main.c        ****   tekst_odebranego_smsa[MAX_LICZBA_ZNAKOW_SMS] = 0; // (1) dla pewnoci
 1576               		.loc 1 366 0
 1577               		.cfi_startproc
 1578 06be CF92      		push r12
 1579               	.LCFI46:
 1580               		.cfi_def_cfa_offset 3
 1581               		.cfi_offset 12, -2
 1582 06c0 DF92      		push r13
 1583               	.LCFI47:
 1584               		.cfi_def_cfa_offset 4
 1585               		.cfi_offset 13, -3
 1586 06c2 FF92      		push r15
 1587               	.LCFI48:
 1588               		.cfi_def_cfa_offset 5
 1589               		.cfi_offset 15, -4
 1590 06c4 0F93      		push r16
 1591               	.LCFI49:
 1592               		.cfi_def_cfa_offset 6
 1593               		.cfi_offset 16, -5
 1594 06c6 1F93      		push r17
 1595               	.LCFI50:
 1596               		.cfi_def_cfa_offset 7
 1597               		.cfi_offset 17, -6
 1598 06c8 CF93      		push r28
 1599               	.LCFI51:
 1600               		.cfi_def_cfa_offset 8
 1601               		.cfi_offset 28, -7
 1602 06ca DF93      		push r29
 1603               	.LCFI52:
 1604               		.cfi_def_cfa_offset 9
 1605               		.cfi_offset 29, -8
 1606 06cc CDB7      		in r28,__SP_L__
 1607 06ce DEB7      		in r29,__SP_H__
 1608               	.LCFI53:
 1609               		.cfi_def_cfa_register 28
 1610 06d0 2A97      		sbiw r28,10
 1611               	.LCFI54:
 1612               		.cfi_def_cfa_offset 19
 1613 06d2 0FB6      		in __tmp_reg__,__SREG__
 1614 06d4 F894      		cli
 1615 06d6 DEBF      		out __SP_H__,r29
 1616 06d8 0FBE      		out __SREG__,__tmp_reg__
 1617 06da CDBF      		out __SP_L__,r28
 1618               	/* prologue: function */
 1619               	/* frame size = 10 */
 1620               	/* stack size = 17 */
 1621               	.L__stack_usage = 17
 367:main.c        ****   uchar komenda = interpretuj_wiadomosc_sms(tekst_odebranego_smsa);
 1622               		.loc 1 367 0
 1623 06dc 1092 0000 		sts wysylany_blok_SIM900+399,__zero_reg__
 368:main.c        **** 
 1624               		.loc 1 368 0
 1625 06e0 80E0      		ldi r24,lo8(wysylany_blok_SIM900+239)
 1626 06e2 90E0      		ldi r25,hi8(wysylany_blok_SIM900+239)
 1627 06e4 0E94 0000 		call interpretuj_wiadomosc_sms
 1628               	.LVL120:
 1629 06e8 182F      		mov r17,r24
 1630               	.LVL121:
 371:main.c        ****     // Gdy zablokowany, akceptuj tylko START i REPORT
 1631               		.loc 1 371 0
 1632 06ea 8091 0000 		lds r24,blokada_systemu
 1633 06ee 8823      		tst r24
 1634 06f0 01F0      		breq .L86
 373:main.c        ****         komenda != INTERPRETACJA_SMS_RAPORT) {
 1635               		.loc 1 373 0
 1636 06f2 8DEF      		ldi r24,lo8(-3)
 1637 06f4 810F      		add r24,r17
 1638 06f6 8230      		cpi r24,lo8(2)
 1639 06f8 00F0      		brlo .L86
 378:main.c        ****           1) {
 1640               		.loc 1 378 0
 1641 06fa 87EF      		ldi r24,lo8(-9)
 1642 06fc 9FE0      		ldi r25,lo8(15)
 1643 06fe 0E94 0000 		call eeprom_read_byte
 1644               	.LVL122:
 1645 0702 8130      		cpi r24,lo8(1)
 1646 0704 01F4      		brne .L86
 380:main.c        ****         usun_zablokowany_sms();
 1647               		.loc 1 380 0
 1648 0706 62E0      		ldi r22,lo8(2)
 1649 0708 0E94 0000 		call zapisz_debug_do_eeprom
 1650               	.LVL123:
 381:main.c        ****         return;
 1651               		.loc 1 381 0
 1652 070c 0E94 0000 		call usun_zablokowany_sms
 1653               	.LVL124:
 1654               	.L85:
 1655               	/* epilogue start */
 616:main.c        **** 
 1656               		.loc 1 616 0
 1657 0710 2A96      		adiw r28,10
 1658 0712 0FB6      		in __tmp_reg__,__SREG__
 1659 0714 F894      		cli
 1660 0716 DEBF      		out __SP_H__,r29
 1661 0718 0FBE      		out __SREG__,__tmp_reg__
 1662 071a CDBF      		out __SP_L__,r28
 1663 071c DF91      		pop r29
 1664 071e CF91      		pop r28
 1665 0720 1F91      		pop r17
 1666 0722 0F91      		pop r16
 1667 0724 FF90      		pop r15
 1668 0726 DF90      		pop r13
 1669 0728 CF90      		pop r12
 1670 072a 0895      		ret
 1671               	.LVL125:
 1672               	.L86:
 388:main.c        ****       komenda == INTERPRETACJA_SMS_USER) {
 1673               		.loc 1 388 0
 1674 072c 8CEF      		ldi r24,lo8(-4)
 1675 072e 810F      		add r24,r17
 1676 0730 8230      		cpi r24,lo8(2)
 1677 0732 00F4      		brsh .L88
 390:main.c        ****       zapisz_debug_do_eeprom(1, 1);
 1678               		.loc 1 390 0
 1679 0734 8091 0000 		lds r24,licznik_report_user
 1680 0738 8830      		cpi r24,lo8(8)
 1681 073a 00F0      		brlo .L88
 1682               	.L89:
 391:main.c        ****       usun_zablokowany_sms();
 1683               		.loc 1 391 0
 1684 073c 61E0      		ldi r22,lo8(1)
 1685 073e 81E0      		ldi r24,lo8(1)
 1686 0740 0E94 0000 		call zapisz_debug_do_eeprom
 1687               	.LVL126:
 392:main.c        ****       zareaguj_na_usuniety_sms_z_powodu_limitu();
 1688               		.loc 1 392 0
 1689 0744 0E94 0000 		call usun_zablokowany_sms
 1690               	.LVL127:
 393:main.c        ****       watchdog_sms_disarm();
 1691               		.loc 1 393 0
 1692 0748 0E94 0000 		call zareaguj_na_usuniety_sms_z_powodu_limitu
 1693               	.LVL128:
 1694               	.L92:
 615:main.c        **** }
 1695               		.loc 1 615 0
 1696 074c 0E94 0000 		call watchdog_sms_disarm
 1697               	.LVL129:
 1698 0750 00C0      		rjmp .L85
 1699               	.LVL130:
 1700               	.L88:
 400:main.c        ****     // Same number check
 1701               		.loc 1 400 0
 1702 0752 8091 0000 		lds r24,flaga_wysylanie_smsa
 1703 0756 8111      		cpse r24,__zero_reg__
 1704 0758 00C0      		rjmp .L89
 1705 075a E0E0      		ldi r30,lo8(komendy_kolejka)
 1706 075c F0E0      		ldi r31,hi8(komendy_kolejka)
 420:main.c        ****   for (uchar i = 0; i < LICZBA_KOMEND; ++i) {
 1707               		.loc 1 420 0
 1708 075e 20E0      		ldi r18,0
 419:main.c        ****   uchar liczba_wszystkich_komend = 0;
 1709               		.loc 1 419 0
 1710 0760 90E0      		ldi r25,0
 1711               	.L91:
 1712               	.LVL131:
 1713               	.LBB391:
 422:main.c        ****       ++liczba_wszystkich_komend;
 1714               		.loc 1 422 0
 1715 0762 8191      		ld r24,Z+
 1716               	.LVL132:
 1717 0764 8823      		tst r24
 1718 0766 01F0      		breq .L90
 423:main.c        ****       if (komendy_kolejka[i] >= KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT &&
 1719               		.loc 1 423 0
 1720 0768 2F5F      		subi r18,lo8(-(1))
 1721               	.LVL133:
 424:main.c        ****           komendy_kolejka[i] <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
 1722               		.loc 1 424 0
 1723 076a 825D      		subi r24,lo8(-(46))
 1724 076c 8230      		cpi r24,lo8(2)
 1725 076e 00F4      		brsh .L90
 426:main.c        ****     }
 1726               		.loc 1 426 0
 1727 0770 9F5F      		subi r25,lo8(-(1))
 1728               	.LVL134:
 1729               	.L90:
 421:main.c        ****     if (komendy_kolejka[i] != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 1730               		.loc 1 421 0 discriminator 2
 1731 0772 80E0      		ldi r24,hi8(komendy_kolejka+30)
 1732 0774 E030      		cpi r30,lo8(komendy_kolejka+30)
 1733 0776 F807      		cpc r31,r24
 1734 0778 01F4      		brne .L91
 1735               	.LBE391:
 430:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 1736               		.loc 1 430 0
 1737 077a 2332      		cpi r18,lo8(35)
 1738 077c 00F4      		brsh .L89
 438:main.c        ****     zapisz_debug_do_eeprom(1, 1);
 1739               		.loc 1 438 0
 1740 077e 9630      		cpi r25,lo8(6)
 1741 0780 00F4      		brsh .L89
 446:main.c        ****   case INTERPRETACJA_SMS_POPRAWNY:
 1742               		.loc 1 446 0
 1743 0782 1C30      		cpi r17,lo8(12)
 1744 0784 00F4      		brsh .L92
 1745 0786 E12F      		mov r30,r17
 1746               	.LVL135:
 1747 0788 F0E0      		ldi r31,0
 1748 078a E050      		subi r30,lo8(-(gs(.L94)))
 1749 078c F040      		sbci r31,hi8(-(gs(.L94)))
 1750 078e 0C94 0000 		jmp __tablejump2__
 1751               		.p2align	1
 1752               	.L94:
 1753 0792 0000      		.word gs(.L93)
 1754 0794 0000      		.word gs(.L92)
 1755 0796 0000      		.word gs(.L92)
 1756 0798 0000      		.word gs(.L117)
 1757 079a 0000      		.word gs(.L96)
 1758 079c 0000      		.word gs(.L97)
 1759 079e 0000      		.word gs(.L98)
 1760 07a0 0000      		.word gs(.L99)
 1761 07a2 0000      		.word gs(.L100)
 1762 07a4 0000      		.word gs(.L92)
 1763 07a6 0000      		.word gs(.L92)
 1764 07a8 0000      		.word gs(.L101)
 1765               	.L93:
 451:main.c        ****     zapisz_debug_do_eeprom(0, 3);
 1766               		.loc 1 451 0
 1767 07aa 81E0      		ldi r24,lo8(1)
 1768 07ac 8093 0000 		sts liczba_blyskow_led,r24
 1769 07b0 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 452:main.c        ****     break;
 1770               		.loc 1 452 0
 1771 07b4 63E0      		ldi r22,lo8(3)
 1772 07b6 80E0      		ldi r24,0
 1773               	.LVL136:
 1774               	.L119:
 464:main.c        ****     break;
 1775               		.loc 1 464 0
 1776 07b8 0E94 0000 		call zapisz_debug_do_eeprom
 1777               	.LVL137:
 465:main.c        ****   }
 1778               		.loc 1 465 0
 1779 07bc 00C0      		rjmp .L92
 1780               	.LVL138:
 1781               	.L96:
 456:main.c        ****     timer_report_user_100ms = OKNO_CZASOWE_REPORT_USER_100MS;
 1782               		.loc 1 456 0
 1783 07be 8091 0000 		lds r24,licznik_report_user
 1784 07c2 8F5F      		subi r24,lo8(-(1))
 1785 07c4 8093 0000 		sts licznik_report_user,r24
 457:main.c        **** 
 1786               		.loc 1 457 0
 1787 07c8 8CE2      		ldi r24,lo8(44)
 1788 07ca 91E0      		ldi r25,lo8(1)
 1789 07cc 9093 0000 		sts timer_report_user_100ms+1,r25
 1790 07d0 8093 0000 		sts timer_report_user_100ms,r24
 459:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 1791               		.loc 1 459 0
 1792 07d4 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 1793 07d6 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 1794 07d8 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 1795 07da 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 1796 07dc 0E94 0000 		call strcpy
 1797               	.LVL139:
 461:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 1798               		.loc 1 461 0
 1799 07e0 0E94 0000 		call generuj_raport_stanu_urzadzenia
 1800               	.LVL140:
 462:main.c        ****     zapal_diode_led_blyski(2); // Komenda REPORT - 2 blyski
 1801               		.loc 1 462 0
 1802 07e4 82ED      		ldi r24,lo8(-46)
 1803 07e6 0E94 0000 		call dodaj_komende
 1804               	.LVL141:
 463:main.c        ****     zapisz_debug_do_eeprom(1, 0);
 1805               		.loc 1 463 0
 1806 07ea 82E0      		ldi r24,lo8(2)
 1807 07ec 8093 0000 		sts liczba_blyskow_led,r24
 1808 07f0 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 464:main.c        ****     break;
 1809               		.loc 1 464 0
 1810 07f4 60E0      		ldi r22,0
 1811 07f6 81E0      		ldi r24,lo8(1)
 1812 07f8 00C0      		rjmp .L119
 1813               	.LVL142:
 1814               	.L100:
 1815               	.LBB392:
 469:main.c        ****     uchar *sms = tekst_wysylanego_smsa + strlen((char *)tekst_wysylanego_smsa);
 1816               		.loc 1 469 0
 1817 07fa 60E0      		ldi r22,lo8(__c.3108)
 1818 07fc 70E0      		ldi r23,hi8(__c.3108)
 1819 07fe 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 1820 0800 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 1821 0802 0E94 0000 		call strcpy_P
 1822               	.LVL143:
 470:main.c        **** 
 1823               		.loc 1 470 0
 1824 0806 00E0      		ldi r16,lo8(tekst_wysylanego_smsa)
 1825 0808 10E0      		ldi r17,hi8(tekst_wysylanego_smsa)
 1826 080a F801      		movw r30,r16
 1827               		0:
 1828 080c 0190      		ld __tmp_reg__,Z+
 1829 080e 0020      		tst __tmp_reg__
 1830 0810 01F4      		brne 0b
 1831 0812 8F01      		movw r16,r30
 1832 0814 0150      		subi r16,1
 1833 0816 1109      		sbc r17,__zero_reg__
 1834               	.LVL144:
 473:main.c        ****     sms += strlen((char *)sms);
 1835               		.loc 1 473 0
 1836 0818 60E0      		ldi r22,lo8(__c.3111)
 1837 081a 70E0      		ldi r23,hi8(__c.3111)
 1838 081c C801      		movw r24,r16
 1839 081e 0E94 0000 		call strcpy_P
 1840               	.LVL145:
 474:main.c        ****     *sms++ =
 1841               		.loc 1 474 0
 1842 0822 F801      		movw r30,r16
 1843               		0:
 1844 0824 0190      		ld __tmp_reg__,Z+
 1845 0826 0020      		tst __tmp_reg__
 1846 0828 01F4      		brne 0b
 1847 082a CF01      		movw r24,r30
 1848 082c 0197      		sbiw r24,1
 1849 082e 6C01      		movw r12,r24
 1850               	.LVL146:
 476:main.c        ****     *sms++ =
 1851               		.loc 1 476 0
 1852 0830 81EF      		ldi r24,lo8(-15)
 1853 0832 9FE0      		ldi r25,lo8(15)
 1854 0834 0E94 0000 		call eeprom_read_byte
 1855               	.LVL147:
 1856 0838 805D      		subi r24,lo8(-(48))
 475:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_2);
 1857               		.loc 1 475 0
 1858 083a F601      		movw r30,r12
 1859 083c 8083      		st Z,r24
 478:main.c        ****     *sms++ =
 1860               		.loc 1 478 0
 1861 083e 82EF      		ldi r24,lo8(-14)
 1862 0840 9FE0      		ldi r25,lo8(15)
 1863 0842 0E94 0000 		call eeprom_read_byte
 1864               	.LVL148:
 1865 0846 805D      		subi r24,lo8(-(48))
 477:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_3);
 1866               		.loc 1 477 0
 1867 0848 F601      		movw r30,r12
 1868 084a 8183      		std Z+1,r24
 480:main.c        ****     *sms++ =
 1869               		.loc 1 480 0
 1870 084c 83EF      		ldi r24,lo8(-13)
 1871 084e 9FE0      		ldi r25,lo8(15)
 1872 0850 0E94 0000 		call eeprom_read_byte
 1873               	.LVL149:
 1874 0854 805D      		subi r24,lo8(-(48))
 479:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_4);
 1875               		.loc 1 479 0
 1876 0856 F601      		movw r30,r12
 1877 0858 8283      		std Z+2,r24
 482:main.c        ****     *sms++ = '\n';
 1878               		.loc 1 482 0
 1879 085a 84EF      		ldi r24,lo8(-12)
 1880 085c 9FE0      		ldi r25,lo8(15)
 1881 085e 0E94 0000 		call eeprom_read_byte
 1882               	.LVL150:
 1883 0862 805D      		subi r24,lo8(-(48))
 481:main.c        ****         '0' + eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_SKRYBA_5);
 1884               		.loc 1 481 0
 1885 0864 F601      		movw r30,r12
 1886 0866 8383      		std Z+3,r24
 483:main.c        **** 
 1887               		.loc 1 483 0
 1888 0868 8601      		movw r16,r12
 1889 086a 0B5F      		subi r16,-5
 1890 086c 1F4F      		sbci r17,-1
 1891               	.LVL151:
 1892 086e 9AE0      		ldi r25,lo8(10)
 1893 0870 F92E      		mov r15,r25
 1894 0872 F482      		std Z+4,r15
 486:main.c        ****     sms += strlen((char *)sms);
 1895               		.loc 1 486 0
 1896 0874 60E0      		ldi r22,lo8(__c.3113)
 1897 0876 70E0      		ldi r23,hi8(__c.3113)
 1898 0878 C801      		movw r24,r16
 1899 087a 0E94 0000 		call strcpy_P
 1900               	.LVL152:
 487:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_1), sms, 10);
 1901               		.loc 1 487 0
 1902 087e F801      		movw r30,r16
 1903               		0:
 1904 0880 0190      		ld __tmp_reg__,Z+
 1905 0882 0020      		tst __tmp_reg__
 1906 0884 01F4      		brne 0b
 1907 0886 8F01      		movw r16,r30
 1908               	.LVL153:
 1909 0888 0150      		subi r16,1
 1910 088a 1109      		sbc r17,__zero_reg__
 1911               	.LVL154:
 488:main.c        ****     sms += strlen((char *)sms);
 1912               		.loc 1 488 0
 1913 088c 86EE      		ldi r24,lo8(-26)
 1914 088e 9FE0      		ldi r25,lo8(15)
 1915 0890 0E94 0000 		call eeprom_read_byte
 1916               	.LVL155:
 1917               	.LBB393:
 1918               	.LBB394:
 1919               		.loc 6 527 0
 1920 0894 4AE0      		ldi r20,lo8(10)
 1921 0896 B801      		movw r22,r16
 1922 0898 90E0      		ldi r25,0
 1923 089a 0E94 0000 		call __utoa_ncheck
 1924               	.LVL156:
 1925               	.LBE394:
 1926               	.LBE393:
 489:main.c        **** 
 1927               		.loc 1 489 0
 1928 089e F801      		movw r30,r16
 1929               		0:
 1930 08a0 0190      		ld __tmp_reg__,Z+
 1931 08a2 0020      		tst __tmp_reg__
 1932 08a4 01F4      		brne 0b
 1933 08a6 8F01      		movw r16,r30
 1934               	.LVL157:
 1935 08a8 0150      		subi r16,1
 1936 08aa 1109      		sbc r17,__zero_reg__
 1937               	.LVL158:
 491:main.c        ****     sms += strlen((char *)sms);
 1938               		.loc 1 491 0
 1939 08ac 60E0      		ldi r22,lo8(__c.3115)
 1940 08ae 70E0      		ldi r23,hi8(__c.3115)
 1941 08b0 C801      		movw r24,r16
 1942 08b2 0E94 0000 		call strcpy_P
 1943               	.LVL159:
 492:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_2), sms, 10);
 1944               		.loc 1 492 0
 1945 08b6 F801      		movw r30,r16
 1946               		0:
 1947 08b8 0190      		ld __tmp_reg__,Z+
 1948 08ba 0020      		tst __tmp_reg__
 1949 08bc 01F4      		brne 0b
 1950 08be 8F01      		movw r16,r30
 1951               	.LVL160:
 1952 08c0 0150      		subi r16,1
 1953 08c2 1109      		sbc r17,__zero_reg__
 1954               	.LVL161:
 493:main.c        ****     sms += strlen((char *)sms);
 1955               		.loc 1 493 0
 1956 08c4 87EE      		ldi r24,lo8(-25)
 1957 08c6 9FE0      		ldi r25,lo8(15)
 1958 08c8 0E94 0000 		call eeprom_read_byte
 1959               	.LVL162:
 1960               	.LBB395:
 1961               	.LBB396:
 1962               		.loc 6 527 0
 1963 08cc 4AE0      		ldi r20,lo8(10)
 1964 08ce B801      		movw r22,r16
 1965 08d0 90E0      		ldi r25,0
 1966 08d2 0E94 0000 		call __utoa_ncheck
 1967               	.LVL163:
 1968               	.LBE396:
 1969               	.LBE395:
 494:main.c        **** 
 1970               		.loc 1 494 0
 1971 08d6 F801      		movw r30,r16
 1972               		0:
 1973 08d8 0190      		ld __tmp_reg__,Z+
 1974 08da 0020      		tst __tmp_reg__
 1975 08dc 01F4      		brne 0b
 1976 08de 8F01      		movw r16,r30
 1977               	.LVL164:
 1978 08e0 0150      		subi r16,1
 1979 08e2 1109      		sbc r17,__zero_reg__
 1980               	.LVL165:
 496:main.c        ****     sms += strlen((char *)sms);
 1981               		.loc 1 496 0
 1982 08e4 60E0      		ldi r22,lo8(__c.3117)
 1983 08e6 70E0      		ldi r23,hi8(__c.3117)
 1984 08e8 C801      		movw r24,r16
 1985 08ea 0E94 0000 		call strcpy_P
 1986               	.LVL166:
 497:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_3), sms, 10);
 1987               		.loc 1 497 0
 1988 08ee F801      		movw r30,r16
 1989               		0:
 1990 08f0 0190      		ld __tmp_reg__,Z+
 1991 08f2 0020      		tst __tmp_reg__
 1992 08f4 01F4      		brne 0b
 1993 08f6 8F01      		movw r16,r30
 1994               	.LVL167:
 1995 08f8 0150      		subi r16,1
 1996 08fa 1109      		sbc r17,__zero_reg__
 1997               	.LVL168:
 498:main.c        ****     sms += strlen((char *)sms);
 1998               		.loc 1 498 0
 1999 08fc 88EE      		ldi r24,lo8(-24)
 2000 08fe 9FE0      		ldi r25,lo8(15)
 2001 0900 0E94 0000 		call eeprom_read_byte
 2002               	.LVL169:
 2003               	.LBB397:
 2004               	.LBB398:
 2005               		.loc 6 527 0
 2006 0904 4AE0      		ldi r20,lo8(10)
 2007 0906 B801      		movw r22,r16
 2008 0908 90E0      		ldi r25,0
 2009 090a 0E94 0000 		call __utoa_ncheck
 2010               	.LVL170:
 2011               	.LBE398:
 2012               	.LBE397:
 499:main.c        ****     *sms++ = '\n';
 2013               		.loc 1 499 0
 2014 090e F801      		movw r30,r16
 2015               		0:
 2016 0910 0190      		ld __tmp_reg__,Z+
 2017 0912 0020      		tst __tmp_reg__
 2018 0914 01F4      		brne 0b
 2019 0916 3197      		sbiw r30,1
 2020               	.LVL171:
 500:main.c        **** 
 2021               		.loc 1 500 0
 2022 0918 8F01      		movw r16,r30
 2023 091a 0F5F      		subi r16,-1
 2024 091c 1F4F      		sbci r17,-1
 2025               	.LVL172:
 2026 091e F082      		st Z,r15
 502:main.c        ****     sms += strlen((char *)sms);
 2027               		.loc 1 502 0
 2028 0920 60E0      		ldi r22,lo8(__c.3119)
 2029 0922 70E0      		ldi r23,hi8(__c.3119)
 2030 0924 C801      		movw r24,r16
 2031 0926 0E94 0000 		call strcpy_P
 2032               	.LVL173:
 503:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_4), sms, 10);
 2033               		.loc 1 503 0
 2034 092a F801      		movw r30,r16
 2035               		0:
 2036 092c 0190      		ld __tmp_reg__,Z+
 2037 092e 0020      		tst __tmp_reg__
 2038 0930 01F4      		brne 0b
 2039 0932 8F01      		movw r16,r30
 2040               	.LVL174:
 2041 0934 0150      		subi r16,1
 2042 0936 1109      		sbc r17,__zero_reg__
 2043               	.LVL175:
 504:main.c        ****     sms += strlen((char *)sms);
 2044               		.loc 1 504 0
 2045 0938 89EE      		ldi r24,lo8(-23)
 2046 093a 9FE0      		ldi r25,lo8(15)
 2047 093c 0E94 0000 		call eeprom_read_byte
 2048               	.LVL176:
 2049               	.LBB399:
 2050               	.LBB400:
 2051               		.loc 6 527 0
 2052 0940 4AE0      		ldi r20,lo8(10)
 2053 0942 B801      		movw r22,r16
 2054 0944 90E0      		ldi r25,0
 2055 0946 0E94 0000 		call __utoa_ncheck
 2056               	.LVL177:
 2057               	.LBE400:
 2058               	.LBE399:
 505:main.c        **** 
 2059               		.loc 1 505 0
 2060 094a F801      		movw r30,r16
 2061               		0:
 2062 094c 0190      		ld __tmp_reg__,Z+
 2063 094e 0020      		tst __tmp_reg__
 2064 0950 01F4      		brne 0b
 2065 0952 8F01      		movw r16,r30
 2066               	.LVL178:
 2067 0954 0150      		subi r16,1
 2068 0956 1109      		sbc r17,__zero_reg__
 2069               	.LVL179:
 507:main.c        ****     sms += strlen((char *)sms);
 2070               		.loc 1 507 0
 2071 0958 60E0      		ldi r22,lo8(__c.3121)
 2072 095a 70E0      		ldi r23,hi8(__c.3121)
 2073 095c C801      		movw r24,r16
 2074 095e 0E94 0000 		call strcpy_P
 2075               	.LVL180:
 508:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_5), sms, 10);
 2076               		.loc 1 508 0
 2077 0962 F801      		movw r30,r16
 2078               		0:
 2079 0964 0190      		ld __tmp_reg__,Z+
 2080 0966 0020      		tst __tmp_reg__
 2081 0968 01F4      		brne 0b
 2082 096a 8F01      		movw r16,r30
 2083               	.LVL181:
 2084 096c 0150      		subi r16,1
 2085 096e 1109      		sbc r17,__zero_reg__
 2086               	.LVL182:
 509:main.c        ****     sms += strlen((char *)sms);
 2087               		.loc 1 509 0
 2088 0970 8AEE      		ldi r24,lo8(-22)
 2089 0972 9FE0      		ldi r25,lo8(15)
 2090 0974 0E94 0000 		call eeprom_read_byte
 2091               	.LVL183:
 2092               	.LBB401:
 2093               	.LBB402:
 2094               		.loc 6 527 0
 2095 0978 4AE0      		ldi r20,lo8(10)
 2096 097a B801      		movw r22,r16
 2097 097c 90E0      		ldi r25,0
 2098 097e 0E94 0000 		call __utoa_ncheck
 2099               	.LVL184:
 2100               	.LBE402:
 2101               	.LBE401:
 510:main.c        **** 
 2102               		.loc 1 510 0
 2103 0982 F801      		movw r30,r16
 2104               		0:
 2105 0984 0190      		ld __tmp_reg__,Z+
 2106 0986 0020      		tst __tmp_reg__
 2107 0988 01F4      		brne 0b
 2108 098a 8F01      		movw r16,r30
 2109               	.LVL185:
 2110 098c 0150      		subi r16,1
 2111 098e 1109      		sbc r17,__zero_reg__
 2112               	.LVL186:
 512:main.c        ****     sms += strlen((char *)sms);
 2113               		.loc 1 512 0
 2114 0990 60E0      		ldi r22,lo8(__c.3123)
 2115 0992 70E0      		ldi r23,hi8(__c.3123)
 2116 0994 C801      		movw r24,r16
 2117 0996 0E94 0000 		call strcpy_P
 2118               	.LVL187:
 513:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_6), sms, 10);
 2119               		.loc 1 513 0
 2120 099a F801      		movw r30,r16
 2121               		0:
 2122 099c 0190      		ld __tmp_reg__,Z+
 2123 099e 0020      		tst __tmp_reg__
 2124 09a0 01F4      		brne 0b
 2125 09a2 8F01      		movw r16,r30
 2126               	.LVL188:
 2127 09a4 0150      		subi r16,1
 2128 09a6 1109      		sbc r17,__zero_reg__
 2129               	.LVL189:
 514:main.c        ****     sms += strlen((char *)sms);
 2130               		.loc 1 514 0
 2131 09a8 8BEE      		ldi r24,lo8(-21)
 2132 09aa 9FE0      		ldi r25,lo8(15)
 2133 09ac 0E94 0000 		call eeprom_read_byte
 2134               	.LVL190:
 2135               	.LBB403:
 2136               	.LBB404:
 2137               		.loc 6 527 0
 2138 09b0 4AE0      		ldi r20,lo8(10)
 2139 09b2 B801      		movw r22,r16
 2140 09b4 90E0      		ldi r25,0
 2141 09b6 0E94 0000 		call __utoa_ncheck
 2142               	.LVL191:
 2143               	.LBE404:
 2144               	.LBE403:
 515:main.c        **** 
 2145               		.loc 1 515 0
 2146 09ba F801      		movw r30,r16
 2147               		0:
 2148 09bc 0190      		ld __tmp_reg__,Z+
 2149 09be 0020      		tst __tmp_reg__
 2150 09c0 01F4      		brne 0b
 2151 09c2 8F01      		movw r16,r30
 2152               	.LVL192:
 2153 09c4 0150      		subi r16,1
 2154 09c6 1109      		sbc r17,__zero_reg__
 2155               	.LVL193:
 517:main.c        ****     sms += strlen((char *)sms);
 2156               		.loc 1 517 0
 2157 09c8 60E0      		ldi r22,lo8(__c.3125)
 2158 09ca 70E0      		ldi r23,hi8(__c.3125)
 2159 09cc C801      		movw r24,r16
 2160 09ce 0E94 0000 		call strcpy_P
 2161               	.LVL194:
 518:main.c        ****     utoa(eeprom_read_byte((const uint8_t *)ADRES_EEPROM_DEBUG_USER_7), sms, 10);
 2162               		.loc 1 518 0
 2163 09d2 F801      		movw r30,r16
 2164               		0:
 2165 09d4 0190      		ld __tmp_reg__,Z+
 2166 09d6 0020      		tst __tmp_reg__
 2167 09d8 01F4      		brne 0b
 2168 09da 8F01      		movw r16,r30
 2169               	.LVL195:
 2170 09dc 0150      		subi r16,1
 2171 09de 1109      		sbc r17,__zero_reg__
 2172               	.LVL196:
 519:main.c        ****     sms += strlen((char *)sms);
 2173               		.loc 1 519 0
 2174 09e0 8CEE      		ldi r24,lo8(-20)
 2175 09e2 9FE0      		ldi r25,lo8(15)
 2176 09e4 0E94 0000 		call eeprom_read_byte
 2177               	.LVL197:
 2178               	.LBB405:
 2179               	.LBB406:
 2180               		.loc 6 527 0
 2181 09e8 4AE0      		ldi r20,lo8(10)
 2182 09ea B801      		movw r22,r16
 2183 09ec 90E0      		ldi r25,0
 2184 09ee 0E94 0000 		call __utoa_ncheck
 2185               	.LVL198:
 2186               	.LBE406:
 2187               	.LBE405:
 520:main.c        ****     *sms++ = '\n';
 2188               		.loc 1 520 0
 2189 09f2 F801      		movw r30,r16
 2190               		0:
 2191 09f4 0190      		ld __tmp_reg__,Z+
 2192 09f6 0020      		tst __tmp_reg__
 2193 09f8 01F4      		brne 0b
 2194 09fa CF01      		movw r24,r30
 2195               	.LVL199:
 521:main.c        **** 
 2196               		.loc 1 521 0
 2197 09fc 0197      		sbiw r24,1
 2198               	.LVL200:
 2199 09fe FC01      		movw r30,r24
 2200               	.LVL201:
 2201 0a00 F192      		st Z+,r15
 2202 0a02 CF01      		movw r24,r30
 2203               	.LVL202:
 523:main.c        **** 
 2204               		.loc 1 523 0
 2205 0a04 60E0      		ldi r22,lo8(__c.3127)
 2206 0a06 70E0      		ldi r23,hi8(__c.3127)
 2207 0a08 0E94 0000 		call strcpy_P
 2208               	.LVL203:
 525:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 2209               		.loc 1 525 0
 2210 0a0c 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 2211 0a0e 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 2212 0a10 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 2213 0a12 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 2214               	.L120:
 2215 0a14 0E94 0000 		call strcpy
 2216               	.LVL204:
 527:main.c        ****     zapal_diode_led_blyski(2);
 2217               		.loc 1 527 0
 2218 0a18 82ED      		ldi r24,lo8(-46)
 2219               	.L118:
 2220 0a1a 0E94 0000 		call dodaj_komende
 2221               	.LVL205:
 2222               	.L117:
 528:main.c        ****     break;
 2223               		.loc 1 528 0
 2224 0a1e 82E0      		ldi r24,lo8(2)
 2225 0a20 8093 0000 		sts liczba_blyskow_led,r24
 2226 0a24 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 529:main.c        ****   }
 2227               		.loc 1 529 0
 2228 0a28 00C0      		rjmp .L92
 2229               	.LVL206:
 2230               	.L97:
 2231               	.LBE392:
 2232               	.LBB407:
 532:main.c        ****     timer_report_user_100ms = OKNO_CZASOWE_REPORT_USER_100MS;
 2233               		.loc 1 532 0
 2234 0a2a 8091 0000 		lds r24,licznik_report_user
 2235 0a2e 8F5F      		subi r24,lo8(-(1))
 2236 0a30 8093 0000 		sts licznik_report_user,r24
 533:main.c        **** 
 2237               		.loc 1 533 0
 2238 0a34 8CE2      		ldi r24,lo8(44)
 2239 0a36 91E0      		ldi r25,lo8(1)
 2240 0a38 9093 0000 		sts timer_report_user_100ms+1,r25
 2241 0a3c 8093 0000 		sts timer_report_user_100ms,r24
 535:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 2242               		.loc 1 535 0
 2243 0a40 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 2244 0a42 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 2245 0a44 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 2246 0a46 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 2247 0a48 0E94 0000 		call strcpy
 2248               	.LVL207:
 544:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
 2249               		.loc 1 544 0
 2250 0a4c 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 2251 0a4e 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 2252 0a50 FB01      		movw r30,r22
 2253               		0:
 2254 0a52 0190      		ld __tmp_reg__,Z+
 2255 0a54 0020      		tst __tmp_reg__
 2256 0a56 01F4      		brne 0b
 2257 0a58 BF01      		movw r22,r30
 2258 0a5a 6150      		subi r22,1
 2259 0a5c 7109      		sbc r23,__zero_reg__
 542:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
 2260               		.loc 1 542 0
 2261 0a5e AE01      		movw r20,r28
 2262 0a60 4F5F      		subi r20,-1
 2263 0a62 5F4F      		sbci r21,-1
 2264 0a64 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 2265 0a66 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 2266 0a68 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 2267               	.LVL208:
 2268 0a6c 88E0      		ldi r24,lo8(8)
 2269 0a6e C82E      		mov r12,r24
 2270 0a70 D12C      		mov r13,__zero_reg__
 2271               	.LVL209:
 2272               	.L103:
 2273               	.LBB408:
 552:main.c        ****               temp_buf, (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip))) {
 2274               		.loc 1 552 0
 2275 0a72 B601      		movw r22,r12
 2276 0a74 CE01      		movw r24,r28
 2277 0a76 0196      		adiw r24,1
 2278 0a78 0E94 0000 		call porownaj_numer_telefonu_blok
 2279               	.LVL210:
 2280 0a7c 182F      		mov r17,r24
 2281 0a7e 8111      		cpse r24,__zero_reg__
 2282 0a80 00C0      		rjmp .L107
 2283 0a82 F5E0      		ldi r31,5
 2284 0a84 CF0E      		add r12,r31
 2285 0a86 D11C      		adc r13,__zero_reg__
 550:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 2286               		.loc 1 550 0
 2287 0a88 88EA      		ldi r24,-88
 2288 0a8a C816      		cp r12,r24
 2289 0a8c 8FE0      		ldi r24,15
 2290 0a8e D806      		cpc r13,r24
 2291 0a90 01F4      		brne .L103
 2292               	.L102:
 2293               	.LVL211:
 2294               	.LBE408:
 560:main.c        ****            (char *)numer_telefonu_do_ktorego_dzwonic);
 2295               		.loc 1 560 0
 2296 0a92 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 2297 0a94 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 2298 0a96 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 2299 0a98 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 2300 0a9a 0E94 0000 		call strcpy
 2301               	.LVL212:
 562:main.c        ****     if (znaleziono) {
 2302               		.loc 1 562 0
 2303 0a9e 60E0      		ldi r22,lo8(.LC2)
 2304 0aa0 70E0      		ldi r23,hi8(.LC2)
 2305 0aa2 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 2306 0aa4 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 2307 0aa6 0E94 0000 		call strcat
 2308               	.LVL213:
 564:main.c        ****     } else {
 2309               		.loc 1 564 0
 2310 0aaa 60E0      		ldi r22,lo8(.LC3)
 2311 0aac 70E0      		ldi r23,hi8(.LC3)
 563:main.c        ****       strcat((char *)tekst_wysylanego_smsa, "OK");
 2312               		.loc 1 563 0
 2313 0aae 1111      		cpse r17,__zero_reg__
 2314 0ab0 00C0      		rjmp .L116
 2315               	.LVL214:
 566:main.c        ****     }
 2316               		.loc 1 566 0
 2317 0ab2 60E0      		ldi r22,lo8(.LC4)
 2318 0ab4 70E0      		ldi r23,hi8(.LC4)
 2319               	.LVL215:
 2320               	.L116:
 2321 0ab6 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 2322 0ab8 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 2323 0aba 0E94 0000 		call strcat
 2324               	.LVL216:
 569:main.c        **** 
 2325               		.loc 1 569 0
 2326 0abe 82ED      		ldi r24,lo8(-46)
 2327 0ac0 0E94 0000 		call dodaj_komende
 2328               	.LVL217:
 571:main.c        **** 
 2329               		.loc 1 571 0
 2330 0ac4 82E0      		ldi r24,lo8(2)
 2331 0ac6 8093 0000 		sts liczba_blyskow_led,r24
 2332 0aca 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 575:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 2333               		.loc 1 575 0
 2334 0ace 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 2335 0ad2 8111      		cpse r24,__zero_reg__
 2336 0ad4 00C0      		rjmp .L106
 575:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 2337               		.loc 1 575 0 is_stmt 0 discriminator 1
 2338 0ad6 8091 0000 		lds r24,liczba_znakow_do_zapisu
 2339 0ada 8111      		cpse r24,__zero_reg__
 2340 0adc 00C0      		rjmp .L106
 575:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 2341               		.loc 1 575 0 discriminator 2
 2342 0ade 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 2343 0ae2 8111      		cpse r24,__zero_reg__
 2344 0ae4 00C0      		rjmp .L106
 575:main.c        ****       // Czekamy na zakonczenie poprzedniego zapisu w tle
 2345               		.loc 1 575 0 discriminator 3
 2346 0ae6 8FB3      		in r24,0x1f
 2347               	.L106:
 583:main.c        ****     break;
 2348               		.loc 1 583 0 is_stmt 1
 2349 0ae8 612F      		mov r22,r17
 2350 0aea 82E0      		ldi r24,lo8(2)
 2351 0aec 00C0      		rjmp .L119
 2352               	.LVL218:
 2353               	.L107:
 2354               	.LBB409:
 554:main.c        ****         break;
 2355               		.loc 1 554 0
 2356 0aee 1FEF      		ldi r17,lo8(-1)
 2357 0af0 00C0      		rjmp .L102
 2358               	.LVL219:
 2359               	.L98:
 2360               	.LBE409:
 2361               	.LBE407:
 587:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 2362               		.loc 1 587 0
 2363 0af2 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 2364 0af4 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 2365 0af6 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 2366 0af8 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 2367 0afa 0E94 0000 		call strcpy
 2368               	.LVL220:
 589:main.c        ****            "Wpisz numer jaki sprawdzasz, np: USER 793557357");
 2369               		.loc 1 589 0
 2370 0afe 60E0      		ldi r22,lo8(.LC5)
 2371 0b00 70E0      		ldi r23,hi8(.LC5)
 2372 0b02 80E0      		ldi r24,lo8(tekst_wysylanego_smsa)
 2373 0b04 90E0      		ldi r25,hi8(tekst_wysylanego_smsa)
 2374 0b06 00C0      		rjmp .L120
 2375               	.LVL221:
 2376               	.L99:
 596:main.c        ****            (char *)numer_telefonu_odebranego_smsa);
 2377               		.loc 1 596 0
 2378 0b08 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 2379 0b0a 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 2380 0b0c 80E0      		ldi r24,lo8(numer_telefonu_wysylanego_smsa)
 2381 0b0e 90E0      		ldi r25,hi8(numer_telefonu_wysylanego_smsa)
 2382 0b10 0E94 0000 		call strcpy
 2383               	.LVL222:
 598:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW);
 2384               		.loc 1 598 0
 2385 0b14 1092 0000 		sts numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama,__zero_reg__
 599:main.c        ****     zapal_diode_led_blyski(2);
 2386               		.loc 1 599 0
 2387 0b18 88E8      		ldi r24,lo8(-120)
 2388 0b1a 00C0      		rjmp .L118
 2389               	.LVL223:
 2390               	.L101:
 604:main.c        ****             KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 2391               		.loc 1 604 0
 2392 0b1c 63E8      		ldi r22,lo8(-125)
 2393 0b1e 82E0      		ldi r24,lo8(2)
 2394 0b20 0E94 0000 		call czy_sa_komendy_z_przedzialu
 2395               	.LVL224:
 2396 0b24 8111      		cpse r24,__zero_reg__
 2397 0b26 00C0      		rjmp .L92
 607:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
 2398               		.loc 1 607 0
 2399 0b28 89E1      		ldi r24,lo8(25)
 2400 0b2a 8093 0000 		sts liczba_blyskow_led,r24
 2401 0b2e 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 608:main.c        ****     }
 2402               		.loc 1 608 0
 2403 0b32 83E0      		ldi r24,lo8(3)
 2404 0b34 0E94 0000 		call dodaj_komende
 2405               	.LVL225:
 2406 0b38 00C0      		rjmp .L92
 2407               		.cfi_endproc
 2408               	.LFE38:
 2410               	.global	steruj_wejsciem_reset_100ms
 2412               	steruj_wejsciem_reset_100ms:
 2413               	.LFB39:
 618:main.c        ****   static uchar licznik_reset;
 2414               		.loc 1 618 0
 2415               		.cfi_startproc
 2416               	/* prologue: function */
 2417               	/* frame size = 0 */
 2418               	/* stack size = 0 */
 2419               	.L__stack_usage = 0
 2420 0b3a 8091 0000 		lds r24,licznik_reset.3143
 620:main.c        ****     if (licznik_reset < 20 * 10)
 2421               		.loc 1 620 0
 2422 0b3e 9091 0000 		lds r25,stan_logiczny_na_wejsciu
 2423 0b42 90FF      		sbrs r25,0
 2424 0b44 00C0      		rjmp .L122
 621:main.c        ****       ++licznik_reset;
 2425               		.loc 1 621 0
 2426 0b46 883C      		cpi r24,lo8(-56)
 2427 0b48 00F4      		brsh .L121
 622:main.c        ****   } else {
 2428               		.loc 1 622 0
 2429 0b4a 8F5F      		subi r24,lo8(-(1))
 2430 0b4c 8093 0000 		sts licznik_reset.3143,r24
 2431 0b50 0895      		ret
 2432               	.L122:
 2433               	.LBB412:
 2434               	.LBB413:
 624:main.c        ****       if (not czy_sa_komendy_z_przedzialu(
 2435               		.loc 1 624 0
 2436 0b52 883C      		cpi r24,lo8(-56)
 2437 0b54 00F0      		brlo .L124
 625:main.c        ****               KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 2438               		.loc 1 625 0
 2439 0b56 63E8      		ldi r22,lo8(-125)
 2440 0b58 82E0      		ldi r24,lo8(2)
 2441 0b5a 0E94 0000 		call czy_sa_komendy_z_przedzialu
 2442               	.LVL226:
 2443 0b5e 8111      		cpse r24,__zero_reg__
 2444 0b60 00C0      		rjmp .L126
 628:main.c        ****     } else if (licznik_reset >= 5 * 10) {
 2445               		.loc 1 628 0
 2446 0b62 83E0      		ldi r24,lo8(3)
 2447               	.L128:
 633:main.c        ****     }
 2448               		.loc 1 633 0
 2449 0b64 0E94 0000 		call dodaj_komende
 2450               	.LVL227:
 2451               	.L126:
 635:main.c        ****   }
 2452               		.loc 1 635 0
 2453 0b68 1092 0000 		sts licznik_reset.3143,__zero_reg__
 2454               	.L121:
 2455               	/* epilogue start */
 2456               	.LBE413:
 2457               	.LBE412:
 637:main.c        **** 
 2458               		.loc 1 637 0
 2459 0b6c 0895      		ret
 2460               	.L124:
 2461               	.LBB415:
 2462               	.LBB414:
 629:main.c        ****       if (not czy_sa_komendy_z_przedzialu(
 2463               		.loc 1 629 0
 2464 0b6e 8233      		cpi r24,lo8(50)
 2465 0b70 00F0      		brlo .L126
 630:main.c        ****               KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU,
 2466               		.loc 1 630 0
 2467 0b72 63E8      		ldi r22,lo8(-125)
 2468 0b74 82E0      		ldi r24,lo8(2)
 2469 0b76 0E94 0000 		call czy_sa_komendy_z_przedzialu
 2470               	.LVL228:
 2471 0b7a 8111      		cpse r24,__zero_reg__
 2472 0b7c 00C0      		rjmp .L126
 633:main.c        ****     }
 2473               		.loc 1 633 0
 2474 0b7e 82E0      		ldi r24,lo8(2)
 2475 0b80 00C0      		rjmp .L128
 2476               	.LBE414:
 2477               	.LBE415:
 2478               		.cfi_endproc
 2479               	.LFE39:
 2481               	.global	sprawdz_przychodzaca_rozmowe
 2483               	sprawdz_przychodzaca_rozmowe:
 2484               	.LFB40:
 640:main.c        ****   if (blokada_systemu) {
 2485               		.loc 1 640 0
 2486               		.cfi_startproc
 2487 0b82 CF93      		push r28
 2488               	.LCFI55:
 2489               		.cfi_def_cfa_offset 3
 2490               		.cfi_offset 28, -2
 2491 0b84 DF93      		push r29
 2492               	.LCFI56:
 2493               		.cfi_def_cfa_offset 4
 2494               		.cfi_offset 29, -3
 2495               	/* prologue: function */
 2496               	/* frame size = 0 */
 2497               	/* stack size = 2 */
 2498               	.L__stack_usage = 2
 641:main.c        ****     return FALSE; // Ignoruj rozmowy gdy system zablokowany
 2499               		.loc 1 641 0
 2500 0b86 8091 0000 		lds r24,blokada_systemu
 2501 0b8a 8823      		tst r24
 2502 0b8c 01F0      		breq .L130
 2503               	.L137:
 642:main.c        ****   }
 2504               		.loc 1 642 0
 2505 0b8e 80E0      		ldi r24,0
 2506               	.L129:
 2507               	/* epilogue start */
 682:main.c        **** 
 2508               		.loc 1 682 0
 2509 0b90 DF91      		pop r29
 2510 0b92 CF91      		pop r28
 2511 0b94 0895      		ret
 2512               	.L130:
 2513 0b96 8091 0000 		lds r24,numer_telefonu_ktory_dzwoni
 646:main.c        ****     if (numer_telefonu_ktory_dzwoni[0] != 0)
 2514               		.loc 1 646 0
 2515 0b9a 9091 0000 		lds r25,tryb_clip
 2516 0b9e 9111      		cpse r25,__zero_reg__
 2517 0ba0 00C0      		rjmp .L132
 647:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA);
 2518               		.loc 1 647 0
 2519 0ba2 8823      		tst r24
 2520 0ba4 01F0      		breq .L133
 648:main.c        **** 
 2521               		.loc 1 648 0
 2522 0ba6 84E8      		ldi r24,lo8(-124)
 2523 0ba8 0E94 0000 		call dodaj_komende
 2524               	.LVL229:
 2525               	.L133:
 651:main.c        ****       return TRUE;
 2526               		.loc 1 651 0
 2527 0bac 8091 0000 		lds r24,tryb_pracy
 2528 0bb0 8130      		cpi r24,lo8(1)
 2529 0bb2 01F4      		brne .L134
 2530               	.L135:
 652:main.c        **** 
 2531               		.loc 1 652 0
 2532 0bb4 8FEF      		ldi r24,lo8(-1)
 2533 0bb6 00C0      		rjmp .L129
 2534               	.L134:
 2535               	.LBB419:
 2536               	.LBB420:
 657:main.c        ****                                          (char *)numer_telefonu_ktory_dzwoni)],
 2537               		.loc 1 657 0
 2538 0bb8 60E0      		ldi r22,lo8(numer_telefonu_ktory_dzwoni)
 2539 0bba 70E0      		ldi r23,hi8(numer_telefonu_ktory_dzwoni)
 2540 0bbc FB01      		movw r30,r22
 2541               		0:
 2542 0bbe 0190      		ld __tmp_reg__,Z+
 2543 0bc0 0020      		tst __tmp_reg__
 2544 0bc2 01F4      		brne 0b
 2545 0bc4 BF01      		movw r22,r30
 2546 0bc6 6150      		subi r22,1
 2547 0bc8 7109      		sbc r23,__zero_reg__
 656:main.c        ****                                      &numer_telefonu_ktory_dzwoni[strlen(
 2548               		.loc 1 656 0
 2549 0bca 40E0      		ldi r20,lo8(bufor_eeprom)
 2550 0bcc 50E0      		ldi r21,hi8(bufor_eeprom)
 2551 0bce 80E0      		ldi r24,lo8(numer_telefonu_ktory_dzwoni)
 2552 0bd0 90E0      		ldi r25,hi8(numer_telefonu_ktory_dzwoni)
 2553 0bd2 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 2554               	.LVL230:
 2555 0bd6 C8E0      		ldi r28,lo8(8)
 2556 0bd8 D0E0      		ldi r29,0
 2557               	.LVL231:
 2558               	.L136:
 2559               	.LBB421:
 664:main.c        ****               &bufor_eeprom[0], (void *)EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt))) {
 2560               		.loc 1 664 0
 2561 0bda BE01      		movw r22,r28
 2562 0bdc 80E0      		ldi r24,lo8(bufor_eeprom)
 2563 0bde 90E0      		ldi r25,hi8(bufor_eeprom)
 2564 0be0 0E94 0000 		call porownaj_numer_telefonu_blok
 2565               	.LVL232:
 2566 0be4 8111      		cpse r24,__zero_reg__
 2567 0be6 00C0      		rjmp .L135
 2568 0be8 2596      		adiw r28,5
 662:main.c        ****          ++nr_uzyt) {
 2569               		.loc 1 662 0
 2570 0bea C83A      		cpi r28,-88
 2571 0bec FFE0      		ldi r31,15
 2572 0bee DF07      		cpc r29,r31
 2573 0bf0 01F4      		brne .L136
 2574 0bf2 00C0      		rjmp .L137
 2575               	.L132:
 2576               	.LBE421:
 2577               	.LBE420:
 2578               	.LBE419:
 673:main.c        ****     dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_UZYTKOWNIKOW_BRAMA);
 2579               		.loc 1 673 0
 2580 0bf4 8823      		tst r24
 2581 0bf6 01F0      		breq .L138
 674:main.c        **** 
 2582               		.loc 1 674 0
 2583 0bf8 84E8      		ldi r24,lo8(-124)
 2584 0bfa 0E94 0000 		call dodaj_komende
 2585               	.LVL233:
 2586               	.L138:
 677:main.c        ****     return TRUE;
 2587               		.loc 1 677 0
 2588 0bfe 81E0      		ldi r24,lo8(1)
 2589 0c00 9091 0000 		lds r25,tryb_pracy
 2590 0c04 9130      		cpi r25,lo8(1)
 2591 0c06 01F0      		breq .L139
 2592 0c08 80E0      		ldi r24,0
 2593               	.L139:
 2594 0c0a 8195      		neg r24
 2595 0c0c 00C0      		rjmp .L129
 2596               		.cfi_endproc
 2597               	.LFE40:
 2599               	.global	zakonczono_rozmowe_telefoniczna
 2601               	zakonczono_rozmowe_telefoniczna:
 2602               	.LFB41:
 704:main.c        ****   POMOC_DODAJ2('#', 'a');
 2603               		.loc 1 704 0
 2604               		.cfi_startproc
 2605               	.LVL234:
 2606               	/* prologue: function */
 2607               	/* frame size = 0 */
 2608               	/* stack size = 0 */
 2609               	.L__stack_usage = 0
 706:main.c        ****   licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 2610               		.loc 1 706 0
 2611 0c0e 8CE3      		ldi r24,lo8(60)
 2612               	.LVL235:
 2613 0c10 8093 0000 		sts opoznienie_SIM900_100MS,r24
 707:main.c        ****   ustaw_maksymalny_czas_dzwonienia = 0;
 2614               		.loc 1 707 0
 2615 0c14 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 2616 0c18 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 708:main.c        ****   maksymalny_czas_dzwonienia = 0;
 2617               		.loc 1 708 0
 2618 0c1c 1092 0000 		sts ustaw_maksymalny_czas_dzwonienia,__zero_reg__
 709:main.c        ****   blokada_clip = FALSE;
 2619               		.loc 1 709 0
 2620 0c20 1092 0000 		sts maksymalny_czas_dzwonienia,__zero_reg__
 710:main.c        **** }
 2621               		.loc 1 710 0
 2622 0c24 1092 0000 		sts blokada_clip,__zero_reg__
 2623               	/* epilogue start */
 711:main.c        **** 
 2624               		.loc 1 711 0
 2625 0c28 0895      		ret
 2626               		.cfi_endproc
 2627               	.LFE41:
 2629               	.global	zakonczono_wysylanie_smsa
 2631               	zakonczono_wysylanie_smsa:
 2632               	.LFB42:
 720:main.c        ****   POMOC_DODAJ2('#', 'A');
 2633               		.loc 1 720 0
 2634               		.cfi_startproc
 2635               	.LVL236:
 2636               	/* prologue: function */
 2637               	/* frame size = 0 */
 2638               	/* stack size = 0 */
 2639               	.L__stack_usage = 0
 722:main.c        **** 
 2640               		.loc 1 722 0
 2641 0c2a 8CE3      		ldi r24,lo8(60)
 2642               	.LVL237:
 2643 0c2c 8093 0000 		sts opoznienie_SIM900_100MS,r24
 724:main.c        **** }
 2644               		.loc 1 724 0
 2645 0c30 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 2646               	/* epilogue start */
 725:main.c        **** 
 2647               		.loc 1 725 0
 2648 0c34 0895      		ret
 2649               		.cfi_endproc
 2650               	.LFE42:
 2652               	.global	problem_z_wyslaniem_powiadomienia
 2654               	problem_z_wyslaniem_powiadomienia:
 2655               	.LFB43:
 727:main.c        ****   wykonywanie_rozmowy_telefonicznej = FALSE;
 2656               		.loc 1 727 0
 2657               		.cfi_startproc
 2658               	/* prologue: function */
 2659               	/* frame size = 0 */
 2660               	/* stack size = 0 */
 2661               	.L__stack_usage = 0
 728:main.c        ****   licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 2662               		.loc 1 728 0
 2663 0c36 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 729:main.c        ****   wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 2664               		.loc 1 729 0
 2665 0c3a 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 2666 0c3e 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 730:main.c        ****   czekanie_na_odebranie_zachety = FALSE;
 2667               		.loc 1 730 0
 2668 0c42 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 2669 0c46 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 2670 0c4a 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
 731:main.c        ****   opoznienie_SIM900_100MS = 60;
 2671               		.loc 1 731 0
 2672 0c4e 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
 732:main.c        ****   flaga_wysylanie_smsa = 0;
 2673               		.loc 1 732 0
 2674 0c52 8CE3      		ldi r24,lo8(60)
 2675 0c54 8093 0000 		sts opoznienie_SIM900_100MS,r24
 733:main.c        **** }
 2676               		.loc 1 733 0
 2677 0c58 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
 2678               	/* epilogue start */
 734:main.c        **** 
 2679               		.loc 1 734 0
 2680 0c5c 0895      		ret
 2681               		.cfi_endproc
 2682               	.LFE43:
 2684               	.global	wyzerowanie_danych_SIM900
 2686               	wyzerowanie_danych_SIM900:
 2687               	.LFB44:
   6:main_sim900.h ****   POMOC_DODAJ2('*', 't');
 2688               		.loc 2 6 0
 2689               		.cfi_startproc
 2690               	/* prologue: function */
 2691               	/* frame size = 0 */
 2692               	/* stack size = 0 */
 2693               	.L__stack_usage = 0
 2694               	.LVL238:
   8:main_sim900.h ****   licznik_wysylane_polecenie_SIM900 = 0;
 2695               		.loc 2 8 0
 2696 0c5e 0E94 0000 		call problem_z_wyslaniem_powiadomienia
 2697               	.LVL239:
   9:main_sim900.h ****   aktualnie_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 2698               		.loc 2 9 0
 2699 0c62 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 2700 0c66 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
  10:main_sim900.h ****   liczba_komend_w_kolejce_SIM900 = 0;
 2701               		.loc 2 10 0
 2702 0c6a 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
  11:main_sim900.h ****   licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow = 0;
 2703               		.loc 2 11 0
 2704 0c6e 1092 0000 		sts liczba_komend_w_kolejce_SIM900,__zero_reg__
  12:main_sim900.h ****   czekanie_na_odebranie_zachety = FALSE;
 2705               		.loc 2 12 0
 2706 0c72 1092 0000 		sts licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow,__zero_reg__
  13:main_sim900.h ****   flaga_odebrany_znak_zachety = FALSE;
 2707               		.loc 2 13 0
 2708 0c76 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
  14:main_sim900.h ****   trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 2709               		.loc 2 14 0
 2710 0c7a 1092 0000 		sts flaga_odebrany_znak_zachety,__zero_reg__
  15:main_sim900.h ****   wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
 2711               		.loc 2 15 0
 2712 0c7e 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
  16:main_sim900.h ****   flaga_odczytywanie_smsa = FALSE;
 2713               		.loc 2 16 0
 2714 0c82 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
  17:main_sim900.h **** }
 2715               		.loc 2 17 0
 2716 0c86 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 2717               	/* epilogue start */
  18:main_sim900.h **** 
 2718               		.loc 2 18 0
 2719 0c8a 0895      		ret
 2720               		.cfi_endproc
 2721               	.LFE44:
 2723               	.global	reset_modulu_SIM900
 2725               	reset_modulu_SIM900:
 2726               	.LFB45:
  20:main_sim900.h ****   wyzerowanie_danych_SIM900();
 2727               		.loc 2 20 0
 2728               		.cfi_startproc
 2729               	/* prologue: function */
 2730               	/* frame size = 0 */
 2731               	/* stack size = 0 */
 2732               	.L__stack_usage = 0
  21:main_sim900.h ****   POMOC_DODAJ2('*', 'm');
 2733               		.loc 2 21 0
 2734 0c8c 0E94 0000 		call wyzerowanie_danych_SIM900
 2735               	.LVL240:
  23:main_sim900.h ****   podlaczony_modul_gsm_SIM900 = FALSE;
 2736               		.loc 2 23 0
 2737 0c90 86E9      		ldi r24,lo8(-106)
 2738 0c92 8093 0000 		sts licznik_100ms_procedura_inicjalizacyjna_SIM900,r24
  24:main_sim900.h ****   podlaczona_karta_SIM_SIM900 = FALSE;
 2739               		.loc 2 24 0
 2740 0c96 1092 0000 		sts podlaczony_modul_gsm_SIM900,__zero_reg__
  25:main_sim900.h ****   licznik_blad_stanu_karty_SIM = 0;
 2741               		.loc 2 25 0
 2742 0c9a 1092 0000 		sts podlaczona_karta_SIM_SIM900,__zero_reg__
  26:main_sim900.h ****   licznik_blad_zalogowania_u_operatora = 0;
 2743               		.loc 2 26 0
 2744 0c9e 1092 0000 		sts licznik_blad_stanu_karty_SIM,__zero_reg__
  27:main_sim900.h ****   nazwa_operatora[0] = '\0';
 2745               		.loc 2 27 0
 2746 0ca2 1092 0000 		sts licznik_blad_zalogowania_u_operatora,__zero_reg__
  28:main_sim900.h ****   licznik_ogolny_blad_zalogowania = 0;
 2747               		.loc 2 28 0
 2748 0ca6 1092 0000 		sts nazwa_operatora,__zero_reg__
  29:main_sim900.h ****   blokada_clip = FALSE;
 2749               		.loc 2 29 0
 2750 0caa 1092 0000 		sts licznik_ogolny_blad_zalogowania+1,__zero_reg__
 2751 0cae 1092 0000 		sts licznik_ogolny_blad_zalogowania,__zero_reg__
  30:main_sim900.h ****   nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 2752               		.loc 2 30 0
 2753 0cb2 1092 0000 		sts blokada_clip,__zero_reg__
  31:main_sim900.h ****   poziom_sieci_gsm = POZIOM_SIECI_BLAD;
 2754               		.loc 2 31 0
 2755 0cb6 1092 0000 		sts nastepne_wysylane_polecenie_SIM900,__zero_reg__
  32:main_sim900.h ****   filtruj_komendy_z_przedzialu(KOMENDA_KOLEJKI_USUN_SMSA_1,
 2756               		.loc 2 32 0
 2757 0cba 83E6      		ldi r24,lo8(99)
 2758 0cbc 8093 0000 		sts poziom_sieci_gsm,r24
  33:main_sim900.h ****                                KOMENDA_KOLEJKI_USUN_SMSA_20);
 2759               		.loc 2 33 0
 2760 0cc0 60ED      		ldi r22,lo8(-48)
 2761 0cc2 8DEB      		ldi r24,lo8(-67)
 2762 0cc4 0E94 0000 		call filtruj_komendy_z_przedzialu
 2763               	.LVL241:
  35:main_sim900.h ****       KOMENDA_KOLEJKI_KOMENDA_SIM900,
 2764               		.loc 2 35 0
 2765 0cc8 6DE9      		ldi r22,lo8(-99)
 2766 0cca 89E8      		ldi r24,lo8(-119)
 2767 0ccc 0E94 0000 		call filtruj_komendy_z_przedzialu
 2768               	.LVL242:
  38:main_sim900.h ****       KOMENDA_KOLEJKI_SPRAWDZ_PIN,
 2769               		.loc 2 38 0
 2770 0cd0 67EA      		ldi r22,lo8(-89)
 2771 0cd2 8EE9      		ldi r24,lo8(-98)
 2772 0cd4 0E94 0000 		call filtruj_komendy_z_przedzialu
 2773               	.LVL243:
  41:main_sim900.h ****                                KOMENDA_KOLEJKI_WYSLIJ_PDU);
 2774               		.loc 2 41 0
 2775 0cd8 64ED      		ldi r22,lo8(-44)
 2776 0cda 82ED      		ldi r24,lo8(-46)
 2777 0cdc 0E94 0000 		call filtruj_komendy_z_przedzialu
 2778               	.LVL244:
  43:main_sim900.h **** }
 2779               		.loc 2 43 0
 2780 0ce0 1092 0000 		sts modul_zalogowany_w_sieci,__zero_reg__
 2781               	/* epilogue start */
  44:main_sim900.h **** 
 2782               		.loc 2 44 0
 2783 0ce4 0895      		ret
 2784               		.cfi_endproc
 2785               	.LFE45:
 2787               	.global	obsluga_wysylania_sms
 2789               	obsluga_wysylania_sms:
 2790               	.LFB48:
  52:main_sim900.h **** }
  53:main_sim900.h **** 
  54:main_sim900.h **** void obsluga_wysylania_sms(void) {
 2791               		.loc 2 54 0
 2792               		.cfi_startproc
 2793               	/* prologue: function */
 2794               	/* frame size = 0 */
 2795               	/* stack size = 0 */
 2796               	.L__stack_usage = 0
 2797               	.LVL245:
  55:main_sim900.h ****   POMOC_DODAJ2('#', 'M');
  56:main_sim900.h ****   if (czy_jest_komenda_wyslano_sms()) {
 2798               		.loc 2 56 0
 2799 0ce6 8091 0000 		lds r24,komenda_SIM900
 2800 0cea 8D30      		cpi r24,lo8(13)
 2801 0cec 01F4      		brne .L156
 2802               	.LVL246:
  57:main_sim900.h ****     POMOC_DODAJ2('#', 'T');
  58:main_sim900.h ****     liczba_prob_wyslania_smsa = 0;
 2803               		.loc 2 58 0
 2804 0cee 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
 2805               	.LVL247:
 2806               	.LBB442:
 2807               	.LBB443:
 724:main.c        **** }
 2808               		.loc 1 724 0
 2809 0cf2 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 2810               	.LBE443:
 2811               	.LBE442:
  59:main_sim900.h ****     zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_ok);
  60:main_sim900.h ****     flaga_wysylanie_smsa = 0;
 2812               		.loc 2 60 0
 2813 0cf6 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
  61:main_sim900.h ****     opoznienie_SIM900_100MS = 70;
 2814               		.loc 2 61 0
 2815 0cfa 86E4      		ldi r24,lo8(70)
 2816 0cfc 8093 0000 		sts opoznienie_SIM900_100MS,r24
  62:main_sim900.h ****     return;
 2817               		.loc 2 62 0
 2818 0d00 0895      		ret
 2819               	.LVL248:
 2820               	.L156:
  63:main_sim900.h ****   } else if (
  64:main_sim900.h ****       czy_jest_komenda_blad_CMS()) // spawdzi
 2821               		.loc 2 64 0
 2822 0d02 8091 0000 		lds r24,komenda_SIM900
  63:main_sim900.h ****   } else if (
 2823               		.loc 2 63 0
 2824 0d06 8630      		cpi r24,lo8(6)
 2825 0d08 01F4      		brne .L158
  65:main_sim900.h ****                                    // czy_modul_byl_polaczony_z_internetem
  66:main_sim900.h ****   {
  67:main_sim900.h ****     ++liczba_prob_wyslania_smsa;
 2826               		.loc 2 67 0
 2827 0d0a 2091 0000 		lds r18,liczba_prob_wyslania_smsa
 2828 0d0e 2F5F      		subi r18,lo8(-(1))
 2829 0d10 2093 0000 		sts liczba_prob_wyslania_smsa,r18
  68:main_sim900.h ****     if (numer_bledu_cms == CMS_SM_BL_NOT_READY ||
 2830               		.loc 2 68 0
 2831 0d14 8091 0000 		lds r24,numer_bledu_cms
 2832 0d18 9091 0000 		lds r25,numer_bledu_cms+1
 2833 0d1c 8530      		cpi r24,5
 2834 0d1e 32E0      		ldi r19,2
 2835 0d20 9307      		cpc r25,r19
 2836 0d22 01F0      		breq .L159
 2837               		.loc 2 68 0 is_stmt 0 discriminator 1
 2838 0d24 8A33      		cpi r24,58
 2839 0d26 31E0      		ldi r19,1
 2840 0d28 9307      		cpc r25,r19
 2841 0d2a 01F0      		breq .L159
  69:main_sim900.h ****         numer_bledu_cms == CMS_SIM_BUSY ||
 2842               		.loc 2 69 0 is_stmt 1
 2843 0d2c 8330      		cpi r24,3
 2844 0d2e 32E0      		ldi r19,2
 2845 0d30 9307      		cpc r25,r19
 2846 0d32 01F0      		breq .L159
  70:main_sim900.h ****         numer_bledu_cms == CMS_PC_BUSY // powinien by reset
  71:main_sim900.h ****         || numer_bledu_cms == CMS_INVALID_CHARS_IN_PDU ||
 2847               		.loc 2 71 0
 2848 0d34 8051      		subi r24,16
 2849 0d36 9240      		sbci r25,2
 2850 0d38 0297      		sbiw r24,2
 2851 0d3a 00F4      		brsh .L160
 2852               	.L159:
  72:main_sim900.h ****         numer_bledu_cms == CMS_INCORECT_PDU_LENGTH) {
  73:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 2853               		.loc 2 73 0
 2854 0d3c 8CE3      		ldi r24,lo8(60)
 2855 0d3e 8093 0000 		sts opoznienie_SIM900_100MS,r24
  74:main_sim900.h ****       if (liczba_prob_wyslania_smsa < max_liczba_prob_wyslania_smsa) {
  75:main_sim900.h ****         POMOC_DODAJ2('#', 'C');
  76:main_sim900.h ****         POMOC_DODAJ_HEX(numer_bledu_cms >> 8);
  77:main_sim900.h ****         POMOC_DODAJ_HEX(numer_bledu_cms & 0xff);
  78:main_sim900.h ****         dodaj_komende(flaga_wysylanie_smsa);
 2856               		.loc 2 78 0
 2857 0d42 8091 0000 		lds r24,flaga_wysylanie_smsa
  74:main_sim900.h ****       if (liczba_prob_wyslania_smsa < max_liczba_prob_wyslania_smsa) {
 2858               		.loc 2 74 0
 2859 0d46 2230      		cpi r18,lo8(2)
 2860 0d48 00F0      		brlo .L184
 2861               	.LVL249:
 2862               	.L185:
  79:main_sim900.h ****       } else {
  80:main_sim900.h ****         POMOC_DODAJ2('#', 'D');
  81:main_sim900.h ****         POMOC_DODAJ_HEX(numer_bledu_cms >> 8);
  82:main_sim900.h ****         POMOC_DODAJ_HEX(numer_bledu_cms & 0xff);
  83:main_sim900.h ****         liczba_prob_wyslania_smsa = 0;
  84:main_sim900.h ****         zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
  85:main_sim900.h ****       }
  86:main_sim900.h ****     } else {
  87:main_sim900.h ****       POMOC_DODAJ2('#', 'F');
  88:main_sim900.h ****       POMOC_DODAJ_HEX(numer_bledu_cms >> 8);
  89:main_sim900.h ****       POMOC_DODAJ_HEX(numer_bledu_cms & 0xff);
  90:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
  91:main_sim900.h ****       liczba_prob_wyslania_smsa = 0;
 2863               		.loc 2 91 0
 2864 0d4a 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
 2865               	.LVL250:
 2866               	.LBB444:
 2867               	.LBB445:
 724:main.c        **** }
 2868               		.loc 1 724 0
 2869 0d4e 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 2870               	.LVL251:
 2871               	.L162:
 2872               	.LBE445:
 2873               	.LBE444:
  92:main_sim900.h ****       zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
  93:main_sim900.h ****     }
  94:main_sim900.h ****     flaga_wysylanie_smsa = 0;
 2874               		.loc 2 94 0
 2875 0d52 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
 2876 0d56 0895      		ret
 2877               	.LVL252:
 2878               	.L160:
  90:main_sim900.h ****       liczba_prob_wyslania_smsa = 0;
 2879               		.loc 2 90 0
 2880 0d58 8CE3      		ldi r24,lo8(60)
 2881 0d5a 8093 0000 		sts opoznienie_SIM900_100MS,r24
 2882 0d5e 00C0      		rjmp .L185
 2883               	.LVL253:
 2884               	.L158:
 2885               	.LBB446:
 2886               	.LBB447:
  95:main_sim900.h ****   } else if (czy_jest_komenda_ERROR()) {
 2887               		.loc 2 95 0
 2888 0d60 8091 0000 		lds r24,komenda_SIM900
 2889 0d64 8430      		cpi r24,lo8(4)
 2890 0d66 01F4      		brne .L163
 2891               	.LVL254:
  96:main_sim900.h ****     POMOC_DODAJ2('#', 'G');
  97:main_sim900.h ****     opoznienie_SIM900_100MS = 60;
 2892               		.loc 2 97 0
 2893 0d68 8CE3      		ldi r24,lo8(60)
 2894 0d6a 8093 0000 		sts opoznienie_SIM900_100MS,r24
  98:main_sim900.h ****     czekanie_na_odebranie_zachety = FALSE;
 2895               		.loc 2 98 0
 2896 0d6e 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
  99:main_sim900.h ****     if ((odebrany_blok_SIM900[2] == '>' &&
 2897               		.loc 2 99 0
 2898 0d72 8091 0000 		lds r24,odebrany_blok_SIM900+2
 2899 0d76 8E33      		cpi r24,lo8(62)
 2900 0d78 01F4      		brne .L164
 100:main_sim900.h ****          liczba_odebranych_znakow_SIM900 < 10) ||
 2901               		.loc 2 100 0
 2902 0d7a 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 2903 0d7e 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
  99:main_sim900.h ****     if ((odebrany_blok_SIM900[2] == '>' &&
 2904               		.loc 2 99 0
 2905 0d82 0A97      		sbiw r24,10
 2906 0d84 00F0      		brlo .L165
 2907               	.L164:
 101:main_sim900.h ****         flaga_wysylanie_smsa == 0) // SIM900 nie odpowiada
 2908               		.loc 2 101 0
 2909 0d86 8091 0000 		lds r24,flaga_wysylanie_smsa
 100:main_sim900.h ****          liczba_odebranych_znakow_SIM900 < 10) ||
 2910               		.loc 2 100 0
 2911 0d8a 8111      		cpse r24,__zero_reg__
 2912 0d8c 00C0      		rjmp .L166
 2913               	.L165:
 2914               	.LVL255:
 102:main_sim900.h ****     {
 103:main_sim900.h ****       POMOC_DODAJ2('#', 'H');
 104:main_sim900.h ****       liczba_prob_wyslania_smsa = 0;
 2915               		.loc 2 104 0
 2916 0d8e 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
 2917               	.LVL256:
 2918               	.LBB448:
 2919               	.LBB449:
 724:main.c        **** }
 2920               		.loc 1 724 0
 2921 0d92 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 2922               	.LBE449:
 2923               	.LBE448:
 105:main_sim900.h ****       zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
 106:main_sim900.h ****       reset_modulu_SIM900();
 2924               		.loc 2 106 0
 2925 0d96 0E94 0000 		call reset_modulu_SIM900
 2926               	.LVL257:
 2927 0d9a 00C0      		rjmp .L162
 2928               	.LVL258:
 2929               	.L166:
 107:main_sim900.h ****     } else {
 108:main_sim900.h ****       POMOC_DODAJ2('#', 'I');
 109:main_sim900.h ****       if (++liczba_prob_wyslania_smsa <
 2930               		.loc 2 109 0
 2931 0d9c 9091 0000 		lds r25,liczba_prob_wyslania_smsa
 2932 0da0 9F5F      		subi r25,lo8(-(1))
 2933 0da2 9093 0000 		sts liczba_prob_wyslania_smsa,r25
 2934 0da6 9230      		cpi r25,lo8(2)
 2935 0da8 00F4      		brsh .L185
 2936               	.LVL259:
 2937               	.L184:
 110:main_sim900.h ****           max_liczba_prob_wyslania_smsa) // musi by sta wartoci
 111:main_sim900.h ****         dodaj_komende(flaga_wysylanie_smsa);
 2938               		.loc 2 111 0
 2939 0daa 0E94 0000 		call dodaj_komende
 2940               	.LVL260:
 2941 0dae 00C0      		rjmp .L162
 2942               	.LVL261:
 2943               	.L163:
 112:main_sim900.h ****       else {
 113:main_sim900.h ****         liczba_prob_wyslania_smsa = 0;
 114:main_sim900.h ****         zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
 115:main_sim900.h ****       }
 116:main_sim900.h ****     }
 117:main_sim900.h ****     flaga_wysylanie_smsa = 0;
 118:main_sim900.h ****   } else if (czy_jest_komenda_blad_CME()) {
 2944               		.loc 2 118 0
 2945 0db0 8091 0000 		lds r24,komenda_SIM900
 2946 0db4 8530      		cpi r24,lo8(5)
 2947 0db6 01F4      		brne .L167
 2948               	.LVL262:
 119:main_sim900.h ****     POMOC_DODAJ2('#', 'J');
 120:main_sim900.h ****     POMOC_DODAJ_HEX(numer_bledu_cme >> 8);
 2949               		.loc 2 120 0
 2950 0db8 8091 0000 		lds r24,numer_bledu_cme
 2951 0dbc 9091 0000 		lds r25,numer_bledu_cme+1
 2952               	.LVL263:
 121:main_sim900.h ****     POMOC_DODAJ_HEX(numer_bledu_cme & 0xff);
 122:main_sim900.h ****     if (numer_bledu_cme == CME_SIM_NOT_INSERTED ||
 2953               		.loc 2 122 0
 2954 0dc0 8A30      		cpi r24,10
 2955 0dc2 9105      		cpc r25,__zero_reg__
 2956 0dc4 01F0      		breq .L168
 2957 0dc6 9C01      		movw r18,r24
 2958 0dc8 2D7F      		andi r18,253
 2959 0dca 2D30      		cpi r18,13
 2960 0dcc 3105      		cpc r19,__zero_reg__
 2961 0dce 01F0      		breq .L168
 123:main_sim900.h ****         numer_bledu_cme == CME_SIM_FAILURE ||
 124:main_sim900.h ****         numer_bledu_cme == CME_SIM_WRONG ||
 2962               		.loc 2 124 0
 2963 0dd0 4E97      		sbiw r24,30
 2964 0dd2 01F4      		brne .L155
 2965               	.L168:
 2966               	.LVL264:
 125:main_sim900.h ****         numer_bledu_cme == CME_NO_NETWORK_SERVICE) {
 126:main_sim900.h ****       POMOC_DODAJ2('#', 'K');
 127:main_sim900.h ****       liczba_prob_wyslania_smsa = 0;
 2967               		.loc 2 127 0
 2968 0dd4 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
 2969               	.LVL265:
 2970               	.LBB450:
 2971               	.LBB451:
 722:main.c        **** 
 2972               		.loc 1 722 0
 2973 0dd8 8CE3      		ldi r24,lo8(60)
 2974               	.LVL266:
 2975 0dda 8093 0000 		sts opoznienie_SIM900_100MS,r24
 724:main.c        **** }
 2976               		.loc 1 724 0
 2977 0dde 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
 2978               	.LBE451:
 2979               	.LBE450:
 128:main_sim900.h ****       zakonczono_wysylanie_smsa(zakonczenie_wysylania_sms_blad_zakonczenie);
 129:main_sim900.h ****       reset_modulu_SIM900();
 2980               		.loc 2 129 0
 2981 0de2 0C94 0000 		jmp reset_modulu_SIM900
 2982               	.LVL267:
 2983               	.L167:
 130:main_sim900.h ****     }
 131:main_sim900.h ****   } else {
 132:main_sim900.h ****     POMOC_DODAJ2('#', 'L');
 133:main_sim900.h ****     POMOC_DODAJ_HEX(komenda_SIM900 >> 8);
 2984               		.loc 2 133 0
 2985 0de6 8091 0000 		lds r24,komenda_SIM900
 2986               	.LVL268:
 134:main_sim900.h ****     POMOC_DODAJ_HEX(komenda_SIM900 & 0xff);
 2987               		.loc 2 134 0
 2988 0dea 8091 0000 		lds r24,komenda_SIM900
 2989               	.LVL269:
 2990               	.L155:
 2991               	/* epilogue start */
 2992               	.LBE447:
 2993               	.LBE446:
 135:main_sim900.h ****   }
 136:main_sim900.h **** }
 2994               		.loc 2 136 0
 2995 0dee 0895      		ret
 2996               		.cfi_endproc
 2997               	.LFE48:
 2999               	.global	odpowiedz_na_polecenie
 3001               	odpowiedz_na_polecenie:
 3002               	.LFB49:
 137:main_sim900.h **** 
 138:main_sim900.h **** void odpowiedz_na_polecenie(void) {
 3003               		.loc 2 138 0
 3004               		.cfi_startproc
 3005 0df0 0F93      		push r16
 3006               	.LCFI57:
 3007               		.cfi_def_cfa_offset 3
 3008               		.cfi_offset 16, -2
 3009 0df2 1F93      		push r17
 3010               	.LCFI58:
 3011               		.cfi_def_cfa_offset 4
 3012               		.cfi_offset 17, -3
 3013 0df4 CF93      		push r28
 3014               	.LCFI59:
 3015               		.cfi_def_cfa_offset 5
 3016               		.cfi_offset 28, -4
 3017 0df6 DF93      		push r29
 3018               	.LCFI60:
 3019               		.cfi_def_cfa_offset 6
 3020               		.cfi_offset 29, -5
 3021               	/* prologue: function */
 3022               	/* frame size = 0 */
 3023               	/* stack size = 4 */
 3024               	.L__stack_usage = 4
 139:main_sim900.h **** #define czy_polecenie_sim(POL) czy_polecenie_SIM900(POL, sizeof POL - 1)
 140:main_sim900.h ****   const uchar kom = komenda_SIM900;
 3025               		.loc 2 140 0
 3026 0df8 D091 0000 		lds r29,komenda_SIM900
 3027               	.LVL270:
 141:main_sim900.h **** 
 142:main_sim900.h ****   switch (aktualnie_wysylane_polecenie_SIM900) {
 3028               		.loc 2 142 0
 3029 0dfc C091 0000 		lds r28,aktualnie_wysylane_polecenie_SIM900
 3030 0e00 CD39      		cpi r28,lo8(-99)
 3031 0e02 01F4      		brne .+2
 3032 0e04 00C0      		rjmp .L188
 3033 0e06 00F0      		brlo .+2
 3034 0e08 00C0      		rjmp .L189
 3035 0e0a C439      		cpi r28,lo8(-108)
 3036 0e0c 01F4      		brne .+2
 3037 0e0e 00C0      		rjmp .L190
 3038 0e10 00F4      		brsh .L191
 3039 0e12 CE38      		cpi r28,lo8(-114)
 3040 0e14 01F4      		brne .+2
 3041 0e16 00C0      		rjmp .L192
 3042 0e18 00F4      		brsh .L193
 3043 0e1a CB38      		cpi r28,lo8(-117)
 3044 0e1c 01F4      		brne .+2
 3045 0e1e 00C0      		rjmp .L194
 3046 0e20 CD38      		cpi r28,lo8(-115)
 3047 0e22 01F4      		brne .+2
 3048 0e24 00C0      		rjmp .L195
 3049               	.L187:
 143:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 144:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_ODEBRANO_POLECENIE_ROZPOCZYNAJACE);
 145:main_sim900.h ****     max_oczekiwanie_na_odpowiedz_at = 0;
 146:main_sim900.h ****     break;
 147:main_sim900.h ****   }
 148:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE: {
 149:main_sim900.h ****     static const char polecenie_zegar[] PROGMEM = "+CCLK:";
 150:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 && czy_polecenie_sim(polecenie_zegar)) {
 151:main_sim900.h ****       const uchar *p1 =
 152:main_sim900.h ****           strchr(polozenie_polecenia_SIM900(polecenie_zegar), '\"');
 153:main_sim900.h ****       if (p1++ != NULL) {
 154:main_sim900.h ****         const uchar *p2 = strchr(p1, '\"');
 155:main_sim900.h ****         const uchar *p3 = strchr(p1, ',');
 156:main_sim900.h ****         if (p2 != NULL && p3++ != NULL && p2 > p3) {
 157:main_sim900.h ****           // const uchar g = atoi(p3);
 158:main_sim900.h ****           if ((p3 = strchr(p3, ':')) != NULL && p2 > p3++) {
 159:main_sim900.h ****             // Pobierz czas z odpowiedzi +CCLK: "yy/MM/dd,hh:mm:ss+zz"
 160:main_sim900.h ****             // p3 wskazuje na minuty po pierwszym ':'
 161:main_sim900.h ****             // cofnijmy si do pocztku godziny (p3 wskazuje na mm, wic -3 to hh)
 162:main_sim900.h ****             // ale w kodzie powyej p3 byo przesuwane.
 163:main_sim900.h **** 
 164:main_sim900.h ****             // Restart parsowania dla pewnoci:
 165:main_sim900.h ****             // "24/01/01,12:34:56+00"
 166:main_sim900.h ****             const char *ptr_time = strchr(p1, ',');
 167:main_sim900.h ****             if (ptr_time) {
 168:main_sim900.h ****               ptr_time++; // skip comma
 169:main_sim900.h ****               if (strlen(ptr_time) >= 8) {
 170:main_sim900.h ****                 memcpy(rtc_czas, ptr_time, 8);
 171:main_sim900.h ****                 rtc_czas[8] = '\0';
 172:main_sim900.h **** 
 173:main_sim900.h ****                 // Aktualizacja blokady czasowej
 174:main_sim900.h ****                 if (czas_start_h == 0xFF) {
 175:main_sim900.h ****                   blokada_sterowania_czasowa = FALSE;
 176:main_sim900.h ****                 } else {
 177:main_sim900.h ****                   // Parsowanie aktualnego czasu
 178:main_sim900.h ****                   int curr_h = (rtc_czas[0] - '0') * 10 + (rtc_czas[1] - '0');
 179:main_sim900.h ****                   int curr_m = (rtc_czas[3] - '0') * 10 + (rtc_czas[4] - '0');
 180:main_sim900.h ****                   int curr_time = curr_h * 60 + curr_m;
 181:main_sim900.h **** 
 182:main_sim900.h ****                   int start_time = czas_start_h * 60 + czas_start_m;
 183:main_sim900.h ****                   int stop_time = czas_stop_h * 60 + czas_stop_m;
 184:main_sim900.h **** 
 185:main_sim900.h ****                   if (start_time <= stop_time) {
 186:main_sim900.h ****                     // Normalny przedzial (np. 08:00 - 16:00)
 187:main_sim900.h ****                     if (curr_time >= start_time && curr_time <= stop_time)
 188:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 189:main_sim900.h ****                     else
 190:main_sim900.h ****                       blokada_sterowania_czasowa = TRUE;
 191:main_sim900.h ****                   } else {
 192:main_sim900.h ****                     // Przejscie przez polnoc (np. 22:00 - 06:00)
 193:main_sim900.h ****                     if (curr_time >= start_time || curr_time <= stop_time)
 194:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 195:main_sim900.h ****                     else
 196:main_sim900.h ****                       blokada_sterowania_czasowa = TRUE;
 197:main_sim900.h ****                   }
 198:main_sim900.h ****                 }
 199:main_sim900.h ****               }
 200:main_sim900.h ****             }
 201:main_sim900.h ****           }
 202:main_sim900.h ****         }
 203:main_sim900.h ****       }
 204:main_sim900.h ****     }
 205:main_sim900.h ****     break;
 206:main_sim900.h ****   }
 207:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_PIN: {
 208:main_sim900.h ****     static const char polecenie_pin_ready[] PROGMEM = "+CPIN: READY";
 209:main_sim900.h ****     static uchar nr_zapytania_o_pin;
 210:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 211:main_sim900.h ****       if (polozenie_polecenia_SIM900(polecenie_pin_ready) != NULL) {
 212:main_sim900.h ****         podlaczona_karta_SIM_SIM900 = TRUE;
 213:main_sim900.h ****         bledny_PIN = FALSE;
 214:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 215:main_sim900.h ****       } else
 216:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_PODAJ_PIN);
 217:main_sim900.h ****       nr_zapytania_o_pin = 0;
 218:main_sim900.h ****     } else if (kom == CME_ERROR_KOMENDA_SIM900 &&
 219:main_sim900.h ****                numer_bledu_cme == CME_SIM_BUSY)
 220:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 221:main_sim900.h ****     else if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900()) {
 222:main_sim900.h ****       if (++nr_zapytania_o_pin >= 20) {
 223:main_sim900.h ****         reset_modulu_SIM900();
 224:main_sim900.h ****         nr_zapytania_o_pin = 0;
 225:main_sim900.h ****       } else {
 226:main_sim900.h ****         opoznienie_SIM900_100MS = 20;
 227:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 228:main_sim900.h ****       }
 229:main_sim900.h ****     } else
 230:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 231:main_sim900.h ****     break;
 232:main_sim900.h ****   }
 233:main_sim900.h ****   case KOMENDA_KOLEJKI_PODAJ_PIN: {
 234:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 235:main_sim900.h ****       podlaczona_karta_SIM_SIM900 = TRUE;
 236:main_sim900.h ****       bledny_PIN = FALSE;
 237:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 238:main_sim900.h ****       opoznienie_SIM900_100MS = 50;
 239:main_sim900.h ****     } else if (kom == CME_ERROR_KOMENDA_SIM900 &&
 240:main_sim900.h ****                numer_bledu_cme == CME_SIM_INCORECT_PASWORD)
 241:main_sim900.h ****       bledny_PIN = TRUE;
 242:main_sim900.h ****     else if (kom == CME_ERROR_KOMENDA_SIM900 && numer_bledu_cme == CME_SIM_BUSY)
 243:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 244:main_sim900.h ****     else if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900())
 245:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 246:main_sim900.h ****     else
 247:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 248:main_sim900.h ****     break;
 249:main_sim900.h ****   }
 250:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY: {
 251:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900)
 252:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW);
 253:main_sim900.h ****     else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 254:main_sim900.h ****       if (numer_bledu_cms == CMS_SIM_BUSY ||
 255:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 256:main_sim900.h ****         opoznienie_SIM900_100MS = 60;
 257:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 258:main_sim900.h ****       }
 259:main_sim900.h ****     } else if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900())
 260:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 261:main_sim900.h ****     break;
 262:main_sim900.h ****   }
 263:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW: {
 264:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900)
 265:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW);
 266:main_sim900.h ****     else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 267:main_sim900.h ****       if (numer_bledu_cms == CMS_SIM_BUSY ||
 268:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 269:main_sim900.h ****         opoznienie_SIM900_100MS = 20;
 270:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 271:main_sim900.h ****       }
 272:main_sim900.h ****     } else {
 273:main_sim900.h ****       opoznienie_SIM900_100MS = 10;
 274:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 275:main_sim900.h ****     }
 276:main_sim900.h ****     break;
 277:main_sim900.h ****   }
 278:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_WYSYLANIE_INFO_O_DZWONIACYM: {
 279:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 ||
 280:main_sim900.h ****         (kom == CME_ERROR_KOMENDA_SIM900 &&
 281:main_sim900.h ****          (numer_bledu_cme == CME_OPERATION_NOT_ALLOWED ||
 282:main_sim900.h ****           numer_bledu_cme == CME_OPERATION_NOT_SUPPORTED))) {
 283:main_sim900.h ****       dodaj_komende(nastepne_wysylane_polecenie_SIM900);
 284:main_sim900.h ****       nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 285:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 286:main_sim900.h ****     } else if (kom != OK_KOMENDA_SIM900 &&
 287:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 288:main_sim900.h ****                    MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 289:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 290:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 291:main_sim900.h ****     break;
 292:main_sim900.h ****   }
 293:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_POZIOM_SIECI: {
 294:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 295:main_sim900.h ****       static const uchar urc[] PROGMEM = "+CSQ:";
 296:main_sim900.h ****       const uchar *p1 = polozenie_polecenia_SIM900(urc);
 297:main_sim900.h ****       if (p1 != NULL) {
 298:main_sim900.h ****         p1 += strlen_R(urc) + 1;
 299:main_sim900.h ****         poziom_sieci_gsm = strtol(p1, NULL, 10);
 300:main_sim900.h ****         // if ( poziom_sieci_gsm != POZIOM_SIECI_BLAD )
 301:main_sim900.h ****         //	POMOC_DODAJ2('*', '0' + poziom_sieci_gsm / 4);
 302:main_sim900.h ****         // else
 303:main_sim900.h ****         //{
 304:main_sim900.h ****         //	POMOC_DODAJ2('*', 'c');
 305:main_sim900.h ****         // }
 306:main_sim900.h ****       }
 307:main_sim900.h ****     } else
 308:main_sim900.h ****       poziom_sieci_gsm = POZIOM_SIECI_BLAD;
 309:main_sim900.h ****     break;
 310:main_sim900.h ****   }
 311:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_ZAREJESTROWANIE: {
 312:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 313:main_sim900.h ****       static const uchar urc[] PROGMEM = "+CREG:";
 314:main_sim900.h ****       const uchar *p1 = polozenie_polecenia_SIM900(urc);
 315:main_sim900.h ****       if (p1 != NULL) {
 316:main_sim900.h ****         p1 += strlen_R(urc) + 1;
 317:main_sim900.h ****         if (*p1 != ',')
 318:main_sim900.h ****           ++p1;
 319:main_sim900.h ****         if (*p1 != ',')
 320:main_sim900.h ****           ++p1;
 321:main_sim900.h ****         if (*p1 != ',')
 322:main_sim900.h ****           ++p1;
 323:main_sim900.h ****         ++p1;
 324:main_sim900.h ****         uchar stan_zarejestrowania = (uchar)strtol(p1, NULL, 10);
 325:main_sim900.h ****         if (stan_zarejestrowania == 0 || stan_zarejestrowania == 3 ||
 326:main_sim900.h ****             stan_zarejestrowania == 4) {
 327:main_sim900.h ****           reset_modulu_SIM900();
 328:main_sim900.h ****         } else if (stan_zarejestrowania == 1 || stan_zarejestrowania == 5) {
 329:main_sim900.h ****           modul_zalogowany_w_sieci = TRUE;
 330:main_sim900.h ****         }
 331:main_sim900.h ****       }
 332:main_sim900.h ****     }
 333:main_sim900.h ****     break;
 334:main_sim900.h ****   }
 335:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_STAN_KARTY_SIM: {
 336:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 || (kom == CME_ERROR_KOMENDA_SIM900 &&
 337:main_sim900.h ****                                      (numer_bledu_cme == CME_INVALID_INDEX ||
 338:main_sim900.h ****                                       numer_bledu_cme == CME_NOT_FOUND))) {
 339:main_sim900.h ****       licznik_blad_stanu_karty_SIM = 0;
 340:main_sim900.h ****     } else {
 341:main_sim900.h ****       ++licznik_blad_stanu_karty_SIM;
 342:main_sim900.h ****     }
 343:main_sim900.h ****     break;
 344:main_sim900.h ****   }
 345:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_ZALOGOWANIE_U_OPERATORA: {
 346:main_sim900.h ****     static const char polecenie_operator[] PROGMEM = "+COPS:";
 347:main_sim900.h ****     uchar w = FALSE;
 348:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 && czy_polecenie_sim(polecenie_operator)) {
 349:main_sim900.h ****       const uchar *p1 =
 350:main_sim900.h ****           strchr(polozenie_polecenia_SIM900(polecenie_operator), ',');
 351:main_sim900.h ****       if (p1 != NULL) {
 352:main_sim900.h ****         p1 = strchr(p1, ',');
 353:main_sim900.h ****         if (p1 != NULL) {
 354:main_sim900.h ****           p1 = strchr(p1, '\"');
 355:main_sim900.h ****           if (p1++ != NULL) {
 356:main_sim900.h ****             const uchar *p2 = strchr(p1, '\"');
 357:main_sim900.h ****             if (p2 != NULL && p1 != p2) {
 358:main_sim900.h ****               const uchar m = min(p2 - p1, ROZMIAR_NAZWA_OPERATORA);
 359:main_sim900.h ****               memcpy(nazwa_operatora, p1, m);
 360:main_sim900.h ****               nazwa_operatora[m] = '\0';
 361:main_sim900.h ****               w = TRUE;
 362:main_sim900.h ****             }
 363:main_sim900.h ****           }
 364:main_sim900.h ****         }
 365:main_sim900.h ****       }
 366:main_sim900.h ****     }
 367:main_sim900.h ****     if (w)
 368:main_sim900.h ****       licznik_blad_zalogowania_u_operatora = 0;
 369:main_sim900.h ****     else {
 370:main_sim900.h ****       ++licznik_blad_zalogowania_u_operatora;
 371:main_sim900.h ****     }
 372:main_sim900.h ****     // POMOC_DODAJ2('*', w ? '+' : '-');
 373:main_sim900.h ****     break;
 374:main_sim900.h ****   }
 375:main_sim900.h ****   case KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS: {
 376:main_sim900.h ****     if (kom ==
 377:main_sim900.h ****         CMS_ERROR_KOMENDA_SIM900 /*&& numer_bledu_cms == CMS_SMS_ME_RESERVED*/) // co le interpretu
 378:main_sim900.h ****       ; // nic nie robi
 379:main_sim900.h ****     else if (kom != OK_KOMENDA_SIM900)
 380:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 381:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 382:main_sim900.h ****     break;
 383:main_sim900.h ****   }
 384:main_sim900.h ****   case KOMENDA_KOLEJKI_ODBIERZ_ROZMOWE: {
 385:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900 ||
 386:main_sim900.h ****         czy_jest_komenda_uzytkownik_odebral_rozmowe()) {
 387:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = TRUE;
 388:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 389:main_sim900.h **** 
 390:main_sim900.h ****       // DTMF START
 391:main_sim900.h ****       if (!tryb_clip) {
 392:main_sim900.h ****         licznik_timeout_rozmowy_100ms = MAX_LICZNIK_TIMEOUT_ROZMOWY_100MS;
 393:main_sim900.h ****         opoznienie_SIM900_100MS =
 394:main_sim900.h ****             20; // 2 sekundy opoznienia przed wyslaniem tonu
 395:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_TON_DTMF); // Beep potwierdzenia
 396:main_sim900.h ****       }
 397:main_sim900.h ****     } else if ((kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900()) &&
 398:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 399:main_sim900.h ****                    MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 400:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 401:main_sim900.h ****     else if (kom == NO_CARRIER_KOMENDA_SIM900) {
 402:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 403:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 404:main_sim900.h ****     } else
 405:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 406:main_sim900.h ****     break;
 407:main_sim900.h ****   }
 408:main_sim900.h ****   case KOMENDA_KOLEJKI_ODRZUC_ROZMOWE: {
 409:main_sim900.h ****     if (kom != OK_KOMENDA_SIM900)
 410:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 411:main_sim900.h ****     else {
 412:main_sim900.h ****       zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_zakonczenie);
 413:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 414:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 415:main_sim900.h ****     }
 416:main_sim900.h ****     break;
 417:main_sim900.h ****   }
 418:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1:
 419:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_2:
 420:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_3:
 421:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_4:
 422:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_5:
 423:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_6:
 424:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_7:
 425:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_8:
 426:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_9:
 427:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_10:
 428:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_11:
 429:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_12:
 430:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_13:
 431:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_14:
 432:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_15:
 433:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_16:
 434:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_17:
 435:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_18:
 436:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_19:
 437:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20: {
 438:main_sim900.h ****     if (kom == OK_KOMENDA_SIM900) {
 439:main_sim900.h ****       // odczytany sms
 440:main_sim900.h ****       const uchar *ptr = polozenie_polecenia_SIM900(PSTR("+CMGR:")); // (1)
 441:main_sim900.h ****       ptr = strchr(ptr, ZNAK_KONCA_ODBIERANIA_ZNAKOW_LF);            // (1)
 442:main_sim900.h ****       // const uchar* ptr = strchr(&odebrany_blok_SIM900[7],
 443:main_sim900.h ****       // ZNAK_KONCA_ODBIERANIA_ZNAKOW_LF);
 444:main_sim900.h ****       if (ptr != NULL) {
 445:main_sim900.h ****         ++ptr;
 446:main_sim900.h ****         const uchar *ptr2 = strchr(ptr, ZNAK_KONCA_WYSYLANIA_ZNAKOW_CR);
 447:main_sim900.h ****         if (ptr2 != NULL) {
 448:main_sim900.h ****           dlugosc_pdu = (ptr2 - ptr) / 2;
 449:main_sim900.h ****           if (dlugosc_pdu > MAX_DLUGOSC_PDU)
 450:main_sim900.h ****             dlugosc_pdu = MAX_DLUGOSC_PDU;
 451:main_sim900.h ****           konwertuj_blok_dwa_znaki_na_znak_pdu(ptr, dlugosc_pdu, bufor_pdu);
 452:main_sim900.h ****           dodaj_komende(KOMENDA_KOLEJKI_INTERPRETUJ_PDU);
 453:main_sim900.h ****           const uchar nr_smsa = aktualnie_wysylane_polecenie_SIM900 -
 454:main_sim900.h ****                                 KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1;
 455:main_sim900.h ****           dodaj_komende(KOMENDA_KOLEJKI_USUN_SMSA_1 + nr_smsa);
 456:main_sim900.h ****           flaga_odczytywanie_smsa = TRUE;
 457:main_sim900.h ****           POMOC_DODAJ2('#', 'O');
 458:main_sim900.h ****         } else
 459:main_sim900.h ****           flaga_odczytywanie_smsa = FALSE;
 460:main_sim900.h ****       } else
 461:main_sim900.h ****         flaga_odczytywanie_smsa = FALSE;
 462:main_sim900.h ****     } else if (kom == CME_ERROR_KOMENDA_SIM900) {
 463:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 464:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 465:main_sim900.h ****     } else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 466:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 467:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 468:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 469:main_sim900.h ****       POMOC_DODAJ2('#', 'P');
 470:main_sim900.h ****       POMOC_DODAJ_HEX(numer_bledu_cms >> 8);
 471:main_sim900.h ****       POMOC_DODAJ_HEX(numer_bledu_cms & 0xff);
 472:main_sim900.h ****     } else {
 473:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 474:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 475:main_sim900.h ****     }
 476:main_sim900.h ****     break;
 477:main_sim900.h ****   }
 478:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_1:
 479:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_2:
 480:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_3:
 481:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_4:
 482:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_5:
 483:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_6:
 484:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_7:
 485:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_8:
 486:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_9:
 487:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_10:
 488:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_11:
 489:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_12:
 490:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_13:
 491:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_14:
 492:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_15:
 493:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_16:
 494:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_17:
 495:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_18:
 496:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_19:
 497:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_20: {
 498:main_sim900.h ****     if (kom == CMS_ERROR_KOMENDA_SIM900 &&
 499:main_sim900.h ****         numer_bledu_cms != CMS_INVALID_MEMORY_INDEX) {
 500:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 501:main_sim900.h ****     } else if (kom == ERROR_KOMENDA_SIM900)
 502:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 503:main_sim900.h ****     else if (czy_jest_blad_SIM900())
 504:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 505:main_sim900.h ****     POMOC_DODAJ2('#', 'Q');
 506:main_sim900.h ****     opoznienie_SIM900_100MS = 25;
 507:main_sim900.h ****     break;
 508:main_sim900.h ****   }
 509:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT: {
 510:main_sim900.h ****     // czekanie_na_odebranie_zachety = FALSE; byo
 511:main_sim900.h ****     break;
 512:main_sim900.h ****   }
 513:main_sim900.h ****   case KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE: {
 514:main_sim900.h ****     if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900()) {
 515:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 516:main_sim900.h ****       if (++liczba_wykonanych_komend_identycznego_polecenia <
 517:main_sim900.h ****           MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 518:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 519:main_sim900.h ****       else {
 520:main_sim900.h ****         liczba_wykonanych_komend_identycznego_polecenia = 0;
 521:main_sim900.h ****         zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 522:main_sim900.h ****         trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 523:main_sim900.h ****         wykonywanie_rozmowy_telefonicznej = FALSE;
 524:main_sim900.h ****         licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 525:main_sim900.h ****       }
 526:main_sim900.h ****     } else
 527:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 528:main_sim900.h ****     break;
 529:main_sim900.h ****   }
 530:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW:
 531:main_sim900.h ****     if (kom != OK_KOMENDA_SIM900) {
 532:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 533:main_sim900.h ****       opoznienie_SIM900_100MS = 20;
 534:main_sim900.h ****       break;
 535:main_sim900.h ****     } // bez break
 536:main_sim900.h ****     goto obsluga_standardowej_instrukcji_at;
 537:main_sim900.h ****   case KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1: {
 538:main_sim900.h ****     if (polozenie_polecenia_SIM900(PSTR(">")) != 0) {
 539:main_sim900.h ****       reset_modulu_SIM900();
 540:main_sim900.h ****       break;
 541:main_sim900.h ****     }
 542:main_sim900.h ****   }
 543:main_sim900.h ****   case KOMENDA_KOLEJKI_WSTAWIENIE_MORING_GDY_DZWONI:
 544:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_WZMOCNIENIE_MIKROFONU:
 545:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_CICHY_TRYB:
 546:main_sim900.h ****   case KOMENDA_KOLEJKI_WYCISZ_DZWONKI:
 547:main_sim900.h ****   case KOMENDA_KOLEJKI_ODBIERAJ_SMS_FLASH:
 548:main_sim900.h ****   case KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ:
 549:main_sim900.h ****   case KOMENDA_KOLEJKI_WLACZ_CZAS_Z_SIECI: {
 550:main_sim900.h ****   obsluga_standardowej_instrukcji_at:
 551:main_sim900.h ****     if (kom != OK_KOMENDA_SIM900 &&
 552:main_sim900.h ****         ++liczba_wykonanych_komend_identycznego_polecenia <
 553:main_sim900.h ****             MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 554:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 555:main_sim900.h ****     else {
 556:main_sim900.h ****       dodaj_komende(nastepne_wysylane_polecenie_SIM900);
 557:main_sim900.h ****       if (nastepne_wysylane_polecenie_SIM900 >=
 558:main_sim900.h ****               KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 559:main_sim900.h ****           nastepne_wysylane_polecenie_SIM900 <=
 560:main_sim900.h ****               KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 561:main_sim900.h ****         flaga_odczytywanie_smsa = FALSE;
 562:main_sim900.h ****       }
 563:main_sim900.h ****       nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 564:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 565:main_sim900.h ****     }
 566:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 567:main_sim900.h ****     break;
 568:main_sim900.h ****   }
 569:main_sim900.h ****   }
 570:main_sim900.h **** #undef czy_polecenie_sim
 571:main_sim900.h ****   wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 3050               		.loc 2 571 0
 3051 0e26 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 3052 0e2a 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 3053 0e2e 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
 3054               	/* epilogue start */
 572:main_sim900.h **** }
 3055               		.loc 2 572 0
 3056 0e32 DF91      		pop r29
 3057               	.LVL271:
 3058 0e34 CF91      		pop r28
 3059 0e36 1F91      		pop r17
 3060 0e38 0F91      		pop r16
 3061 0e3a 0895      		ret
 3062               	.LVL272:
 3063               	.L193:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3064               		.loc 2 142 0
 3065 0e3c C139      		cpi r28,lo8(-111)
 3066 0e3e 01F4      		brne .+2
 3067 0e40 00C0      		rjmp .L196
 3068 0e42 C339      		cpi r28,lo8(-109)
 3069 0e44 01F4      		brne .L187
 3070               	.L197:
 551:main_sim900.h ****         ++liczba_wykonanych_komend_identycznego_polecenia <
 3071               		.loc 2 551 0
 3072 0e46 D130      		cpi r29,lo8(1)
 3073 0e48 01F4      		brne .+2
 3074 0e4a 00C0      		rjmp .L274
 552:main_sim900.h ****             MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 3075               		.loc 2 552 0 discriminator 1
 3076 0e4c 8091 0000 		lds r24,liczba_wykonanych_komend_identycznego_polecenia
 3077 0e50 8F5F      		subi r24,lo8(-(1))
 551:main_sim900.h ****         ++liczba_wykonanych_komend_identycznego_polecenia <
 3078               		.loc 2 551 0 discriminator 1
 3079 0e52 8093 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,r24
 3080 0e56 8330      		cpi r24,lo8(3)
 3081 0e58 00F0      		brlo .+2
 3082 0e5a 00C0      		rjmp .L274
 554:main_sim900.h ****     else {
 3083               		.loc 2 554 0
 3084 0e5c 8C2F      		mov r24,r28
 3085 0e5e 00C0      		rjmp .L378
 3086               	.L191:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3087               		.loc 2 142 0
 3088 0e60 C839      		cpi r28,lo8(-104)
 3089 0e62 01F4      		brne .+2
 3090 0e64 00C0      		rjmp .L198
 3091 0e66 00F4      		brsh .L199
 3092 0e68 C539      		cpi r28,lo8(-107)
 3093 0e6a 01F4      		brne .+2
 3094 0e6c 00C0      		rjmp .L200
 3095 0e6e C639      		cpi r28,lo8(-106)
 3096 0e70 01F4      		brne .L187
 410:main_sim900.h ****     else {
 3097               		.loc 2 410 0
 3098 0e72 86E9      		ldi r24,lo8(-106)
 409:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3099               		.loc 2 409 0
 3100 0e74 D130      		cpi r29,lo8(1)
 3101 0e76 01F0      		breq .+2
 3102 0e78 00C0      		rjmp .L383
 412:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 3103               		.loc 2 412 0
 3104 0e7a 81E0      		ldi r24,lo8(1)
 3105 0e7c 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 3106               	.LVL273:
 413:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 3107               		.loc 2 413 0
 3108 0e80 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 414:main_sim900.h ****     }
 3109               		.loc 2 414 0
 3110 0e84 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 3111 0e88 00C0      		rjmp .L187
 3112               	.L199:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3113               		.loc 2 142 0
 3114 0e8a CA39      		cpi r28,lo8(-102)
 3115 0e8c 01F4      		brne .+2
 3116 0e8e 00C0      		rjmp .L202
 3117 0e90 00F4      		brsh .+2
 3118 0e92 00C0      		rjmp .L203
 3119 0e94 CC39      		cpi r28,lo8(-100)
 3120 0e96 01F4      		brne .L187
 312:main_sim900.h ****       static const uchar urc[] PROGMEM = "+CREG:";
 3121               		.loc 2 312 0
 3122 0e98 D130      		cpi r29,lo8(1)
 3123 0e9a 01F4      		brne .L187
 3124               	.LBB474:
 314:main_sim900.h ****       if (p1 != NULL) {
 3125               		.loc 2 314 0
 3126 0e9c 80E0      		ldi r24,lo8(urc.3217)
 3127 0e9e 90E0      		ldi r25,hi8(urc.3217)
 3128 0ea0 0E94 0000 		call polozenie_polecenia_SIM900
 3129               	.LVL274:
 3130 0ea4 FC01      		movw r30,r24
 3131               	.LVL275:
 315:main_sim900.h ****         p1 += strlen_R(urc) + 1;
 3132               		.loc 2 315 0
 3133 0ea6 892B      		or r24,r25
 3134 0ea8 01F4      		brne .+2
 3135 0eaa 00C0      		rjmp .L187
 3136               	.LVL276:
 3137               	.LBB475:
 317:main_sim900.h ****           ++p1;
 3138               		.loc 2 317 0
 3139 0eac 2781      		ldd r18,Z+7
 3140 0eae 2C32      		cpi r18,lo8(44)
 3141 0eb0 01F0      		breq .+2
 3142 0eb2 00C0      		rjmp .L246
 316:main_sim900.h ****         if (*p1 != ',')
 3143               		.loc 2 316 0
 3144 0eb4 3796      		adiw r30,7
 3145               	.LVL277:
 3146               	.L247:
 319:main_sim900.h ****           ++p1;
 3147               		.loc 2 319 0
 3148 0eb6 8081      		ld r24,Z
 3149 0eb8 8C32      		cpi r24,lo8(44)
 3150 0eba 01F0      		breq .L248
 3151 0ebc 3196      		adiw r30,1
 3152               	.LVL278:
 3153               	.L248:
 321:main_sim900.h ****           ++p1;
 3154               		.loc 2 321 0
 3155 0ebe 8081      		ld r24,Z
 3156 0ec0 8C32      		cpi r24,lo8(44)
 3157 0ec2 01F0      		breq .L249
 3158 0ec4 3196      		adiw r30,1
 3159               	.LVL279:
 3160               	.L249:
 324:main_sim900.h ****         if (stan_zarejestrowania == 0 || stan_zarejestrowania == 3 ||
 3161               		.loc 2 324 0
 3162 0ec6 4AE0      		ldi r20,lo8(10)
 3163 0ec8 50E0      		ldi r21,0
 3164 0eca 70E0      		ldi r23,0
 3165 0ecc 60E0      		ldi r22,0
 3166 0ece CF01      		movw r24,r30
 3167 0ed0 0196      		adiw r24,1
 3168               	.LVL280:
 3169 0ed2 0E94 0000 		call strtol
 3170               	.LVL281:
 325:main_sim900.h ****             stan_zarejestrowania == 4) {
 3171               		.loc 2 325 0
 3172 0ed6 6623      		tst r22
 3173 0ed8 01F0      		breq .L250
 325:main_sim900.h ****             stan_zarejestrowania == 4) {
 3174               		.loc 2 325 0 is_stmt 0 discriminator 1
 3175 0eda 8DEF      		ldi r24,lo8(-3)
 3176 0edc 860F      		add r24,r22
 3177 0ede 8230      		cpi r24,lo8(2)
 3178 0ee0 00F0      		brlo .+2
 3179 0ee2 00C0      		rjmp .L251
 3180               	.LVL282:
 3181               	.L250:
 327:main_sim900.h ****         } else if (stan_zarejestrowania == 1 || stan_zarejestrowania == 5) {
 3182               		.loc 2 327 0 is_stmt 1
 3183 0ee4 0E94 0000 		call reset_modulu_SIM900
 3184               	.LVL283:
 3185 0ee8 00C0      		rjmp .L187
 3186               	.L189:
 3187               	.LBE475:
 3188               	.LBE474:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3189               		.loc 2 142 0
 3190 0eea C93A      		cpi r28,lo8(-87)
 3191 0eec 00F4      		brsh .L205
 3192 0eee C53A      		cpi r28,lo8(-91)
 3193 0ef0 00F0      		brlo .+2
 3194 0ef2 00C0      		rjmp .L197
 3195 0ef4 C03A      		cpi r28,lo8(-96)
 3196 0ef6 01F4      		brne .+2
 3197 0ef8 00C0      		rjmp .L197
 3198 0efa 00F4      		brsh .L206
 3199 0efc CE39      		cpi r28,lo8(-98)
 3200 0efe 01F4      		brne .+2
 3201 0f00 00C0      		rjmp .L207
 3202 0f02 CF39      		cpi r28,lo8(-97)
 3203 0f04 01F0      		breq .+2
 3204 0f06 00C0      		rjmp .L187
 264:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW);
 3205               		.loc 2 264 0
 3206 0f08 D130      		cpi r29,lo8(1)
 3207 0f0a 01F0      		breq .+2
 3208 0f0c 00C0      		rjmp .L238
 265:main_sim900.h ****     else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 3209               		.loc 2 265 0
 3210 0f0e 8EE8      		ldi r24,lo8(-114)
 3211 0f10 00C0      		rjmp .L383
 3212               	.L206:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3213               		.loc 2 142 0
 3214 0f12 C13A      		cpi r28,lo8(-95)
 3215 0f14 01F4      		brne .+2
 3216 0f16 00C0      		rjmp .L209
 3217 0f18 C33A      		cpi r28,lo8(-93)
 3218 0f1a 01F4      		brne .+2
 3219 0f1c 00C0      		rjmp .L197
 3220 0f1e 00C0      		rjmp .L187
 3221               	.L205:
 3222 0f20 C13D      		cpi r28,lo8(-47)
 3223 0f22 00F4      		brsh .L210
 3224 0f24 CD3B      		cpi r28,lo8(-67)
 3225 0f26 00F4      		brsh .+2
 3226 0f28 00C0      		rjmp .L375
 498:main_sim900.h ****         numer_bledu_cms != CMS_INVALID_MEMORY_INDEX) {
 3227               		.loc 2 498 0
 3228 0f2a D630      		cpi r29,lo8(6)
 3229 0f2c 01F0      		breq .+2
 3230 0f2e 00C0      		rjmp .L269
 498:main_sim900.h ****         numer_bledu_cms != CMS_INVALID_MEMORY_INDEX) {
 3231               		.loc 2 498 0 is_stmt 0 discriminator 1
 3232 0f30 8091 0000 		lds r24,numer_bledu_cms
 3233 0f34 9091 0000 		lds r25,numer_bledu_cms+1
 3234 0f38 8134      		cpi r24,65
 3235 0f3a 9140      		sbci r25,1
 3236 0f3c 01F4      		brne .+2
 3237 0f3e 00C0      		rjmp .L270
 3238               	.L380:
 504:main_sim900.h ****     POMOC_DODAJ2('#', 'Q');
 3239               		.loc 2 504 0 is_stmt 1
 3240 0f40 8C2F      		mov r24,r28
 3241 0f42 0E94 0000 		call dodaj_komende
 3242               	.LVL284:
 3243 0f46 00C0      		rjmp .L271
 3244               	.L210:
 142:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: {
 3245               		.loc 2 142 0
 3246 0f48 C53D      		cpi r28,lo8(-43)
 3247 0f4a 01F4      		brne .+2
 3248 0f4c 00C0      		rjmp .L213
 3249 0f4e CC3F      		cpi r28,lo8(-4)
 3250 0f50 01F0      		breq .+2
 3251 0f52 00C0      		rjmp .L187
 538:main_sim900.h ****       reset_modulu_SIM900();
 3252               		.loc 2 538 0
 3253 0f54 80E0      		ldi r24,lo8(__c.3280)
 3254 0f56 90E0      		ldi r25,hi8(__c.3280)
 3255 0f58 0E94 0000 		call polozenie_polecenia_SIM900
 3256               	.LVL285:
 3257 0f5c 892B      		or r24,r25
 3258 0f5e 01F4      		brne .+2
 3259 0f60 00C0      		rjmp .L197
 3260 0f62 00C0      		rjmp .L250
 3261               	.L194:
 144:main_sim900.h ****     max_oczekiwanie_na_odpowiedz_at = 0;
 3262               		.loc 2 144 0
 3263 0f64 8CE8      		ldi r24,lo8(-116)
 3264 0f66 0E94 0000 		call dodaj_komende
 3265               	.LVL286:
 145:main_sim900.h ****     break;
 3266               		.loc 2 145 0
 3267 0f6a 1092 0000 		sts max_oczekiwanie_na_odpowiedz_at,__zero_reg__
 146:main_sim900.h ****   }
 3268               		.loc 2 146 0
 3269 0f6e 00C0      		rjmp .L187
 3270               	.L188:
 3271               	.LBB477:
 150:main_sim900.h ****       const uchar *p1 =
 3272               		.loc 2 150 0
 3273 0f70 D130      		cpi r29,lo8(1)
 3274 0f72 01F0      		breq .+2
 3275 0f74 00C0      		rjmp .L187
 3276               	.LVL287:
 3277               	.LBB478:
 3278               	.LBB479:
  47:main_sim900.h **** }
 3279               		.loc 2 47 0
 3280 0f76 46E0      		ldi r20,lo8(6)
 3281 0f78 50E0      		ldi r21,0
 3282 0f7a 60E0      		ldi r22,lo8(polecenie_zegar.3196)
 3283 0f7c 70E0      		ldi r23,hi8(polecenie_zegar.3196)
 3284 0f7e 80E0      		ldi r24,lo8(odebrany_blok_SIM900+2)
 3285 0f80 90E0      		ldi r25,hi8(odebrany_blok_SIM900+2)
 3286 0f82 0E94 0000 		call strncmp_P
 3287               	.LVL288:
 3288               	.LBE479:
 3289               	.LBE478:
 150:main_sim900.h ****       const uchar *p1 =
 3290               		.loc 2 150 0
 3291 0f86 892B      		or r24,r25
 3292 0f88 01F0      		breq .+2
 3293 0f8a 00C0      		rjmp .L187
 3294               	.LBB480:
 152:main_sim900.h ****       if (p1++ != NULL) {
 3295               		.loc 2 152 0
 3296 0f8c 80E0      		ldi r24,lo8(polecenie_zegar.3196)
 3297 0f8e 90E0      		ldi r25,hi8(polecenie_zegar.3196)
 3298 0f90 0E94 0000 		call polozenie_polecenia_SIM900
 3299               	.LVL289:
 151:main_sim900.h ****           strchr(polozenie_polecenia_SIM900(polecenie_zegar), '\"');
 3300               		.loc 2 151 0
 3301 0f94 62E2      		ldi r22,lo8(34)
 3302 0f96 70E0      		ldi r23,0
 3303 0f98 0E94 0000 		call strchr
 3304               	.LVL290:
 153:main_sim900.h ****         const uchar *p2 = strchr(p1, '\"');
 3305               		.loc 2 153 0
 3306 0f9c 0097      		sbiw r24,0
 3307 0f9e 01F4      		brne .+2
 3308 0fa0 00C0      		rjmp .L187
 3309 0fa2 EC01      		movw r28,r24
 3310 0fa4 2196      		adiw r28,1
 3311               	.LVL291:
 3312               	.LBB481:
 154:main_sim900.h ****         const uchar *p3 = strchr(p1, ',');
 3313               		.loc 2 154 0
 3314 0fa6 62E2      		ldi r22,lo8(34)
 3315 0fa8 70E0      		ldi r23,0
 3316 0faa CE01      		movw r24,r28
 3317 0fac 0E94 0000 		call strchr
 3318               	.LVL292:
 3319 0fb0 8C01      		movw r16,r24
 3320               	.LVL293:
 155:main_sim900.h ****         if (p2 != NULL && p3++ != NULL && p2 > p3) {
 3321               		.loc 2 155 0
 3322 0fb2 6CE2      		ldi r22,lo8(44)
 3323 0fb4 70E0      		ldi r23,0
 3324 0fb6 CE01      		movw r24,r28
 3325 0fb8 0E94 0000 		call strchr
 3326               	.LVL294:
 156:main_sim900.h ****           // const uchar g = atoi(p3);
 3327               		.loc 2 156 0
 3328 0fbc 0115      		cp r16,__zero_reg__
 3329 0fbe 1105      		cpc r17,__zero_reg__
 3330 0fc0 01F4      		brne .+2
 3331 0fc2 00C0      		rjmp .L187
 3332               	.LVL295:
 156:main_sim900.h ****           // const uchar g = atoi(p3);
 3333               		.loc 2 156 0 is_stmt 0 discriminator 1
 3334 0fc4 0097      		sbiw r24,0
 3335 0fc6 01F4      		brne .+2
 3336 0fc8 00C0      		rjmp .L187
 156:main_sim900.h ****           // const uchar g = atoi(p3);
 3337               		.loc 2 156 0 discriminator 2
 3338 0fca EC01      		movw r28,r24
 3339               	.LVL296:
 3340 0fcc 2196      		adiw r28,1
 3341               	.LVL297:
 3342 0fce C017      		cp r28,r16
 3343 0fd0 D107      		cpc r29,r17
 3344 0fd2 00F0      		brlo .+2
 3345 0fd4 00C0      		rjmp .L187
 158:main_sim900.h ****             // Pobierz czas z odpowiedzi +CCLK: "yy/MM/dd,hh:mm:ss+zz"
 3346               		.loc 2 158 0 is_stmt 1
 3347 0fd6 6AE3      		ldi r22,lo8(58)
 3348 0fd8 70E0      		ldi r23,0
 3349 0fda CE01      		movw r24,r28
 3350 0fdc 0E94 0000 		call strchr
 3351               	.LVL298:
 3352 0fe0 0097      		sbiw r24,0
 3353 0fe2 01F4      		brne .+2
 3354 0fe4 00C0      		rjmp .L187
 3355               	.LVL299:
 158:main_sim900.h ****             // Pobierz czas z odpowiedzi +CCLK: "yy/MM/dd,hh:mm:ss+zz"
 3356               		.loc 2 158 0 is_stmt 0 discriminator 1
 3357 0fe6 8017      		cp r24,r16
 3358 0fe8 9107      		cpc r25,r17
 3359 0fea 00F0      		brlo .+2
 3360 0fec 00C0      		rjmp .L187
 3361               	.LVL300:
 3362               	.LBB482:
 169:main_sim900.h ****                 memcpy(rtc_czas, ptr_time, 8);
 3363               		.loc 2 169 0 is_stmt 1
 3364 0fee FE01      		movw r30,r28
 3365               		0:
 3366 0ff0 0190      		ld __tmp_reg__,Z+
 3367 0ff2 0020      		tst __tmp_reg__
 3368 0ff4 01F4      		brne 0b
 3369 0ff6 3197      		sbiw r30,1
 3370 0ff8 EC1B      		sub r30,r28
 3371 0ffa FD0B      		sbc r31,r29
 3372 0ffc 3897      		sbiw r30,8
 3373 0ffe 00F4      		brsh .+2
 3374 1000 00C0      		rjmp .L187
 170:main_sim900.h ****                 rtc_czas[8] = '\0';
 3375               		.loc 2 170 0
 3376 1002 88E0      		ldi r24,lo8(8)
 3377               	.LVL301:
 3378 1004 FE01      		movw r30,r28
 3379 1006 A0E0      		ldi r26,lo8(rtc_czas)
 3380 1008 B0E0      		ldi r27,hi8(rtc_czas)
 3381               		0:
 3382 100a 0190      		ld r0,Z+
 3383 100c 0D92      		st X+,r0
 3384 100e 8A95      		dec r24
 3385 1010 01F4      		brne 0b
 171:main_sim900.h **** 
 3386               		.loc 2 171 0
 3387 1012 1092 0000 		sts rtc_czas+8,__zero_reg__
 174:main_sim900.h ****                   blokada_sterowania_czasowa = FALSE;
 3388               		.loc 2 174 0
 3389 1016 7091 0000 		lds r23,czas_start_h
 3390 101a 7F3F      		cpi r23,lo8(-1)
 3391 101c 01F4      		brne .L217
 3392               	.L220:
 175:main_sim900.h ****                 } else {
 3393               		.loc 2 175 0
 3394 101e 1092 0000 		sts blokada_sterowania_czasowa,__zero_reg__
 3395 1022 00C0      		rjmp .L187
 3396               	.L217:
 3397               	.LVL302:
 3398               	.LBB483:
 178:main_sim900.h ****                   int curr_m = (rtc_czas[3] - '0') * 10 + (rtc_czas[4] - '0');
 3399               		.loc 2 178 0
 3400 1024 2091 0000 		lds r18,rtc_czas
 3401 1028 2053      		subi r18,48
 3402 102a 330B      		sbc r19,r19
 3403 102c EAE0      		ldi r30,lo8(10)
 3404 102e E29F      		mul r30,r18
 3405 1030 C001      		movw r24,r0
 3406 1032 E39F      		mul r30,r19
 3407 1034 900D      		add r25,r0
 3408 1036 1124      		clr __zero_reg__
 3409 1038 2091 0000 		lds r18,rtc_czas+1
 3410 103c 2053      		subi r18,48
 3411 103e 330B      		sbc r19,r19
 3412 1040 820F      		add r24,r18
 3413 1042 931F      		adc r25,r19
 180:main_sim900.h **** 
 3414               		.loc 2 180 0
 3415 1044 6CE3      		ldi r22,lo8(60)
 3416 1046 689F      		mul r22,r24
 3417 1048 A001      		movw r20,r0
 3418 104a 699F      		mul r22,r25
 3419 104c 500D      		add r21,r0
 3420 104e 1124      		clr __zero_reg__
 179:main_sim900.h ****                   int curr_time = curr_h * 60 + curr_m;
 3421               		.loc 2 179 0
 3422 1050 2091 0000 		lds r18,rtc_czas+3
 3423 1054 2053      		subi r18,48
 3424 1056 330B      		sbc r19,r19
 3425 1058 E29F      		mul r30,r18
 3426 105a C001      		movw r24,r0
 3427 105c E39F      		mul r30,r19
 3428 105e 900D      		add r25,r0
 3429 1060 1124      		clr __zero_reg__
 3430 1062 2091 0000 		lds r18,rtc_czas+4
 3431 1066 2053      		subi r18,48
 3432 1068 330B      		sbc r19,r19
 3433 106a 820F      		add r24,r18
 3434 106c 931F      		adc r25,r19
 180:main_sim900.h **** 
 3435               		.loc 2 180 0
 3436 106e 480F      		add r20,r24
 3437 1070 591F      		adc r21,r25
 3438               	.LVL303:
 182:main_sim900.h ****                   int stop_time = czas_stop_h * 60 + czas_stop_m;
 3439               		.loc 2 182 0
 3440 1072 2091 0000 		lds r18,czas_start_m
 3441 1076 30E0      		ldi r19,0
 3442 1078 769F      		mul r23,r22
 3443 107a 200D      		add r18,r0
 3444 107c 311D      		adc r19,r1
 3445 107e 1124      		clr __zero_reg__
 3446               	.LVL304:
 183:main_sim900.h **** 
 3447               		.loc 2 183 0
 3448 1080 7091 0000 		lds r23,czas_stop_h
 3449 1084 8091 0000 		lds r24,czas_stop_m
 3450 1088 90E0      		ldi r25,0
 3451 108a 769F      		mul r23,r22
 3452 108c 800D      		add r24,r0
 3453 108e 911D      		adc r25,r1
 3454 1090 1124      		clr __zero_reg__
 3455               	.LVL305:
 185:main_sim900.h ****                     // Normalny przedzial (np. 08:00 - 16:00)
 3456               		.loc 2 185 0
 3457 1092 8217      		cp r24,r18
 3458 1094 9307      		cpc r25,r19
 3459 1096 04F0      		brlt .L218
 187:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 3460               		.loc 2 187 0
 3461 1098 4217      		cp r20,r18
 3462 109a 5307      		cpc r21,r19
 3463 109c 04F0      		brlt .L219
 3464               	.L376:
 193:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 3465               		.loc 2 193 0 discriminator 1
 3466 109e 8417      		cp r24,r20
 3467 10a0 9507      		cpc r25,r21
 3468 10a2 04F0      		brlt .+2
 3469 10a4 00C0      		rjmp .L220
 3470               	.L219:
 190:main_sim900.h ****                   } else {
 3471               		.loc 2 190 0
 3472 10a6 8FEF      		ldi r24,lo8(-1)
 3473               	.LVL306:
 3474 10a8 8093 0000 		sts blokada_sterowania_czasowa,r24
 3475 10ac 00C0      		rjmp .L187
 3476               	.LVL307:
 3477               	.L218:
 193:main_sim900.h ****                       blokada_sterowania_czasowa = FALSE;
 3478               		.loc 2 193 0
 3479 10ae 4217      		cp r20,r18
 3480 10b0 5307      		cpc r21,r19
 3481 10b2 04F0      		brlt .L376
 3482 10b4 00C0      		rjmp .L220
 3483               	.LVL308:
 3484               	.L207:
 3485               	.LBE483:
 3486               	.LBE482:
 3487               	.LBE481:
 3488               	.LBE480:
 3489               	.LBE477:
 3490               	.LBB484:
 210:main_sim900.h ****       if (polozenie_polecenia_SIM900(polecenie_pin_ready) != NULL) {
 3491               		.loc 2 210 0
 3492 10b6 D130      		cpi r29,lo8(1)
 3493 10b8 01F4      		brne .L221
 211:main_sim900.h ****         podlaczona_karta_SIM_SIM900 = TRUE;
 3494               		.loc 2 211 0
 3495 10ba 80E0      		ldi r24,lo8(polecenie_pin_ready.3207)
 3496 10bc 90E0      		ldi r25,hi8(polecenie_pin_ready.3207)
 3497 10be 0E94 0000 		call polozenie_polecenia_SIM900
 3498               	.LVL309:
 3499 10c2 892B      		or r24,r25
 3500 10c4 01F0      		breq .L222
 212:main_sim900.h ****         bledny_PIN = FALSE;
 3501               		.loc 2 212 0
 3502 10c6 8FEF      		ldi r24,lo8(-1)
 3503 10c8 8093 0000 		sts podlaczona_karta_SIM_SIM900,r24
 213:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 3504               		.loc 2 213 0
 3505 10cc 1092 0000 		sts bledny_PIN,__zero_reg__
 214:main_sim900.h ****       } else
 3506               		.loc 2 214 0
 3507 10d0 81E9      		ldi r24,lo8(-111)
 3508               	.L377:
 216:main_sim900.h ****       nr_zapytania_o_pin = 0;
 3509               		.loc 2 216 0
 3510 10d2 0E94 0000 		call dodaj_komende
 3511               	.LVL310:
 3512               	.L381:
 224:main_sim900.h ****       } else {
 3513               		.loc 2 224 0
 3514 10d6 1092 0000 		sts nr_zapytania_o_pin.3208,__zero_reg__
 3515 10da 00C0      		rjmp .L187
 3516               	.L222:
 216:main_sim900.h ****       nr_zapytania_o_pin = 0;
 3517               		.loc 2 216 0
 3518 10dc 8DE8      		ldi r24,lo8(-115)
 3519 10de 00C0      		rjmp .L377
 3520               	.L221:
 218:main_sim900.h ****                numer_bledu_cme == CME_SIM_BUSY)
 3521               		.loc 2 218 0
 3522 10e0 D530      		cpi r29,lo8(5)
 3523 10e2 01F4      		brne .L224
 218:main_sim900.h ****                numer_bledu_cme == CME_SIM_BUSY)
 3524               		.loc 2 218 0 is_stmt 0 discriminator 1
 3525 10e4 8091 0000 		lds r24,numer_bledu_cme
 3526 10e8 9091 0000 		lds r25,numer_bledu_cme+1
 3527 10ec 0E97      		sbiw r24,14
 3528 10ee 01F4      		brne .L225
 3529               	.L385:
 227:main_sim900.h ****       }
 3530               		.loc 2 227 0 is_stmt 1
 3531 10f0 8EE9      		ldi r24,lo8(-98)
 3532               	.L383:
 3533               	.LBE484:
 265:main_sim900.h ****     else if (kom == CMS_ERROR_KOMENDA_SIM900) {
 3534               		.loc 2 265 0
 3535 10f2 0E94 0000 		call dodaj_komende
 3536               	.LVL311:
 3537 10f6 00C0      		rjmp .L187
 3538               	.L224:
 3539               	.LBB485:
 221:main_sim900.h ****       if (++nr_zapytania_o_pin >= 20) {
 3540               		.loc 2 221 0
 3541 10f8 D430      		cpi r29,lo8(4)
 3542 10fa 01F0      		breq .L226
 3543               	.L225:
 221:main_sim900.h ****       if (++nr_zapytania_o_pin >= 20) {
 3544               		.loc 2 221 0 is_stmt 0 discriminator 1
 3545 10fc 8091 0000 		lds r24,komenda_SIM900
 3546 1100 8038      		cpi r24,lo8(-128)
 3547 1102 01F4      		brne .L385
 3548               	.L226:
 222:main_sim900.h ****         reset_modulu_SIM900();
 3549               		.loc 2 222 0 is_stmt 1
 3550 1104 8091 0000 		lds r24,nr_zapytania_o_pin.3208
 3551 1108 8F5F      		subi r24,lo8(-(1))
 3552 110a 8093 0000 		sts nr_zapytania_o_pin.3208,r24
 3553 110e 8431      		cpi r24,lo8(20)
 3554 1110 00F0      		brlo .L228
 223:main_sim900.h ****         nr_zapytania_o_pin = 0;
 3555               		.loc 2 223 0
 3556 1112 0E94 0000 		call reset_modulu_SIM900
 3557               	.LVL312:
 3558 1116 00C0      		rjmp .L381
 3559               	.L228:
 226:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3560               		.loc 2 226 0
 3561 1118 84E1      		ldi r24,lo8(20)
 3562 111a 8093 0000 		sts opoznienie_SIM900_100MS,r24
 3563 111e 00C0      		rjmp .L385
 3564               	.L195:
 3565               	.LBE485:
 234:main_sim900.h ****       podlaczona_karta_SIM_SIM900 = TRUE;
 3566               		.loc 2 234 0
 3567 1120 D130      		cpi r29,lo8(1)
 3568 1122 01F4      		brne .L229
 235:main_sim900.h ****       bledny_PIN = FALSE;
 3569               		.loc 2 235 0
 3570 1124 8FEF      		ldi r24,lo8(-1)
 3571 1126 8093 0000 		sts podlaczona_karta_SIM_SIM900,r24
 236:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 3572               		.loc 2 236 0
 3573 112a 1092 0000 		sts bledny_PIN,__zero_reg__
 237:main_sim900.h ****       opoznienie_SIM900_100MS = 50;
 3574               		.loc 2 237 0
 3575 112e 81E9      		ldi r24,lo8(-111)
 3576 1130 0E94 0000 		call dodaj_komende
 3577               	.LVL313:
 238:main_sim900.h ****     } else if (kom == CME_ERROR_KOMENDA_SIM900 &&
 3578               		.loc 2 238 0
 3579 1134 82E3      		ldi r24,lo8(50)
 3580               	.L382:
 533:main_sim900.h ****       break;
 3581               		.loc 2 533 0
 3582 1136 8093 0000 		sts opoznienie_SIM900_100MS,r24
 534:main_sim900.h ****     } // bez break
 3583               		.loc 2 534 0
 3584 113a 00C0      		rjmp .L187
 3585               	.L229:
 239:main_sim900.h ****                numer_bledu_cme == CME_SIM_INCORECT_PASWORD)
 3586               		.loc 2 239 0
 3587 113c D530      		cpi r29,lo8(5)
 3588 113e 01F4      		brne .L230
 240:main_sim900.h ****       bledny_PIN = TRUE;
 3589               		.loc 2 240 0 discriminator 1
 3590 1140 8091 0000 		lds r24,numer_bledu_cme
 3591 1144 9091 0000 		lds r25,numer_bledu_cme+1
 239:main_sim900.h ****                numer_bledu_cme == CME_SIM_INCORECT_PASWORD)
 3592               		.loc 2 239 0 discriminator 1
 3593 1148 8031      		cpi r24,16
 3594 114a 9105      		cpc r25,__zero_reg__
 3595 114c 01F4      		brne .L231
 241:main_sim900.h ****     else if (kom == CME_ERROR_KOMENDA_SIM900 && numer_bledu_cme == CME_SIM_BUSY)
 3596               		.loc 2 241 0
 3597 114e 8FEF      		ldi r24,lo8(-1)
 3598 1150 8093 0000 		sts bledny_PIN,r24
 3599 1154 00C0      		rjmp .L187
 3600               	.L231:
 242:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3601               		.loc 2 242 0 discriminator 1
 3602 1156 0E97      		sbiw r24,14
 3603 1158 01F4      		brne .L232
 3604               	.L233:
 243:main_sim900.h ****     else if (kom == ERROR_KOMENDA_SIM900 || czy_jest_blad_SIM900())
 3605               		.loc 2 243 0
 3606 115a 8DE8      		ldi r24,lo8(-115)
 3607 115c 00C0      		rjmp .L383
 3608               	.L230:
 244:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3609               		.loc 2 244 0
 3610 115e D430      		cpi r29,lo8(4)
 3611 1160 01F0      		breq .L233
 3612               	.L232:
 244:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3613               		.loc 2 244 0 is_stmt 0 discriminator 1
 3614 1162 8091 0000 		lds r24,komenda_SIM900
 3615 1166 00C0      		rjmp .L233
 3616               	.L196:
 251:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW);
 3617               		.loc 2 251 0 is_stmt 1
 3618 1168 D130      		cpi r29,lo8(1)
 3619 116a 01F4      		brne .L234
 3620               	.L384:
 274:main_sim900.h ****     }
 3621               		.loc 2 274 0
 3622 116c 8FE9      		ldi r24,lo8(-97)
 3623 116e 00C0      		rjmp .L383
 3624               	.L234:
 253:main_sim900.h ****       if (numer_bledu_cms == CMS_SIM_BUSY ||
 3625               		.loc 2 253 0
 3626 1170 D630      		cpi r29,lo8(6)
 3627 1172 01F4      		brne .L235
 254:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 3628               		.loc 2 254 0
 3629 1174 8091 0000 		lds r24,numer_bledu_cms
 3630 1178 9091 0000 		lds r25,numer_bledu_cms+1
 3631 117c 8A33      		cpi r24,58
 3632 117e 21E0      		ldi r18,1
 3633 1180 9207      		cpc r25,r18
 3634 1182 01F0      		breq .L236
 254:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 3635               		.loc 2 254 0 is_stmt 0 discriminator 1
 3636 1184 8530      		cpi r24,5
 3637 1186 9240      		sbci r25,2
 3638 1188 01F0      		breq .+2
 3639 118a 00C0      		rjmp .L187
 3640               	.L236:
 256:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3641               		.loc 2 256 0 is_stmt 1
 3642 118c 8CE3      		ldi r24,lo8(60)
 3643 118e 8093 0000 		sts opoznienie_SIM900_100MS,r24
 3644               	.L237:
 260:main_sim900.h ****     break;
 3645               		.loc 2 260 0
 3646 1192 81E9      		ldi r24,lo8(-111)
 3647 1194 00C0      		rjmp .L383
 3648               	.L235:
 259:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3649               		.loc 2 259 0
 3650 1196 D430      		cpi r29,lo8(4)
 3651 1198 01F0      		breq .L237
 259:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3652               		.loc 2 259 0 is_stmt 0 discriminator 1
 3653 119a 8091 0000 		lds r24,komenda_SIM900
 3654 119e 8038      		cpi r24,lo8(-128)
 3655 11a0 01F0      		breq .+2
 3656 11a2 00C0      		rjmp .L187
 3657 11a4 00C0      		rjmp .L237
 3658               	.L238:
 266:main_sim900.h ****       if (numer_bledu_cms == CMS_SIM_BUSY ||
 3659               		.loc 2 266 0 is_stmt 1
 3660 11a6 D630      		cpi r29,lo8(6)
 3661 11a8 01F4      		brne .L239
 267:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 3662               		.loc 2 267 0
 3663 11aa 8091 0000 		lds r24,numer_bledu_cms
 3664 11ae 9091 0000 		lds r25,numer_bledu_cms+1
 3665 11b2 8A33      		cpi r24,58
 3666 11b4 21E0      		ldi r18,1
 3667 11b6 9207      		cpc r25,r18
 3668 11b8 01F0      		breq .L240
 267:main_sim900.h ****           numer_bledu_cms == CMS_SM_BL_NOT_READY) {
 3669               		.loc 2 267 0 is_stmt 0 discriminator 1
 3670 11ba 8530      		cpi r24,5
 3671 11bc 9240      		sbci r25,2
 3672 11be 01F0      		breq .+2
 3673 11c0 00C0      		rjmp .L187
 3674               	.L240:
 269:main_sim900.h ****         dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3675               		.loc 2 269 0 is_stmt 1
 3676 11c2 84E1      		ldi r24,lo8(20)
 3677               	.L386:
 273:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3678               		.loc 2 273 0
 3679 11c4 8093 0000 		sts opoznienie_SIM900_100MS,r24
 3680 11c8 00C0      		rjmp .L384
 3681               	.L239:
 3682 11ca 8AE0      		ldi r24,lo8(10)
 3683 11cc 00C0      		rjmp .L386
 3684               	.L209:
 279:main_sim900.h ****         (kom == CME_ERROR_KOMENDA_SIM900 &&
 3685               		.loc 2 279 0
 3686 11ce D130      		cpi r29,lo8(1)
 3687 11d0 01F0      		breq .L241
 279:main_sim900.h ****         (kom == CME_ERROR_KOMENDA_SIM900 &&
 3688               		.loc 2 279 0 is_stmt 0 discriminator 1
 3689 11d2 D530      		cpi r29,lo8(5)
 3690 11d4 01F4      		brne .L242
 281:main_sim900.h ****           numer_bledu_cme == CME_OPERATION_NOT_SUPPORTED))) {
 3691               		.loc 2 281 0 is_stmt 1
 3692 11d6 8091 0000 		lds r24,numer_bledu_cme
 3693 11da 9091 0000 		lds r25,numer_bledu_cme+1
 3694 11de 0397      		sbiw r24,3
 280:main_sim900.h ****          (numer_bledu_cme == CME_OPERATION_NOT_ALLOWED ||
 3695               		.loc 2 280 0
 3696 11e0 0297      		sbiw r24,2
 3697 11e2 00F4      		brsh .L242
 3698               	.L241:
 283:main_sim900.h ****       nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 3699               		.loc 2 283 0
 3700 11e4 8091 0000 		lds r24,nastepne_wysylane_polecenie_SIM900
 3701 11e8 0E94 0000 		call dodaj_komende
 3702               	.LVL314:
 3703               	.L275:
 563:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 3704               		.loc 2 563 0
 3705 11ec 1092 0000 		sts nastepne_wysylane_polecenie_SIM900,__zero_reg__
 564:main_sim900.h ****     }
 3706               		.loc 2 564 0
 3707 11f0 1092 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,__zero_reg__
 3708 11f4 00C0      		rjmp .L243
 3709               	.L242:
 287:main_sim900.h ****                    MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 3710               		.loc 2 287 0 discriminator 1
 3711 11f6 8091 0000 		lds r24,liczba_wykonanych_komend_identycznego_polecenia
 3712 11fa 8F5F      		subi r24,lo8(-(1))
 286:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 3713               		.loc 2 286 0 discriminator 1
 3714 11fc 8093 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,r24
 3715 1200 8330      		cpi r24,lo8(3)
 3716 1202 00F4      		brsh .L243
 289:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 3717               		.loc 2 289 0
 3718 1204 81EA      		ldi r24,lo8(-95)
 3719               	.L378:
 3720 1206 0E94 0000 		call dodaj_komende
 3721               	.LVL315:
 3722               	.L243:
 290:main_sim900.h ****     break;
 3723               		.loc 2 290 0
 3724 120a 82E0      		ldi r24,lo8(2)
 3725 120c 00C0      		rjmp .L382
 3726               	.L202:
 294:main_sim900.h ****       static const uchar urc[] PROGMEM = "+CSQ:";
 3727               		.loc 2 294 0
 3728 120e D130      		cpi r29,lo8(1)
 3729 1210 01F4      		brne .L245
 3730               	.LBB486:
 296:main_sim900.h ****       if (p1 != NULL) {
 3731               		.loc 2 296 0
 3732 1212 80E0      		ldi r24,lo8(urc.3214)
 3733 1214 90E0      		ldi r25,hi8(urc.3214)
 3734 1216 0E94 0000 		call polozenie_polecenia_SIM900
 3735               	.LVL316:
 297:main_sim900.h ****         p1 += strlen_R(urc) + 1;
 3736               		.loc 2 297 0
 3737 121a 0097      		sbiw r24,0
 3738 121c 01F4      		brne .+2
 3739 121e 00C0      		rjmp .L187
 3740               	.LVL317:
 299:main_sim900.h ****         // if ( poziom_sieci_gsm != POZIOM_SIECI_BLAD )
 3741               		.loc 2 299 0
 3742 1220 4AE0      		ldi r20,lo8(10)
 3743 1222 50E0      		ldi r21,0
 3744 1224 70E0      		ldi r23,0
 3745 1226 60E0      		ldi r22,0
 3746 1228 0696      		adiw r24,6
 3747               	.LVL318:
 3748 122a 0E94 0000 		call strtol
 3749               	.LVL319:
 3750 122e 6093 0000 		sts poziom_sieci_gsm,r22
 3751 1232 00C0      		rjmp .L187
 3752               	.L245:
 3753               	.LBE486:
 308:main_sim900.h ****     break;
 3754               		.loc 2 308 0
 3755 1234 83E6      		ldi r24,lo8(99)
 3756 1236 8093 0000 		sts poziom_sieci_gsm,r24
 3757 123a 00C0      		rjmp .L187
 3758               	.LVL320:
 3759               	.L246:
 3760               	.LBB487:
 3761               	.LBB476:
 318:main_sim900.h ****         if (*p1 != ',')
 3762               		.loc 2 318 0
 3763 123c 3896      		adiw r30,8
 3764               	.LVL321:
 3765 123e 00C0      		rjmp .L247
 3766               	.LVL322:
 3767               	.L251:
 328:main_sim900.h ****           modul_zalogowany_w_sieci = TRUE;
 3768               		.loc 2 328 0
 3769 1240 6B7F      		andi r22,lo8(-5)
 3770               	.LVL323:
 3771 1242 6130      		cpi r22,lo8(1)
 3772 1244 01F0      		breq .+2
 3773 1246 00C0      		rjmp .L187
 329:main_sim900.h ****         }
 3774               		.loc 2 329 0
 3775 1248 8FEF      		ldi r24,lo8(-1)
 3776 124a 8093 0000 		sts modul_zalogowany_w_sieci,r24
 3777 124e 00C0      		rjmp .L187
 3778               	.L198:
 3779               	.LBE476:
 3780               	.LBE487:
 336:main_sim900.h ****                                      (numer_bledu_cme == CME_INVALID_INDEX ||
 3781               		.loc 2 336 0
 3782 1250 D130      		cpi r29,lo8(1)
 3783 1252 01F0      		breq .L252
 336:main_sim900.h ****                                      (numer_bledu_cme == CME_INVALID_INDEX ||
 3784               		.loc 2 336 0 is_stmt 0 discriminator 1
 3785 1254 D530      		cpi r29,lo8(5)
 3786 1256 01F4      		brne .L253
 337:main_sim900.h ****                                       numer_bledu_cme == CME_NOT_FOUND))) {
 3787               		.loc 2 337 0 is_stmt 1 discriminator 2
 3788 1258 8091 0000 		lds r24,numer_bledu_cme
 3789 125c 9091 0000 		lds r25,numer_bledu_cme+1
 3790 1260 4597      		sbiw r24,21
 336:main_sim900.h ****                                      (numer_bledu_cme == CME_INVALID_INDEX ||
 3791               		.loc 2 336 0 discriminator 2
 3792 1262 0297      		sbiw r24,2
 3793 1264 00F4      		brsh .L253
 3794               	.L252:
 339:main_sim900.h ****     } else {
 3795               		.loc 2 339 0
 3796 1266 1092 0000 		sts licznik_blad_stanu_karty_SIM,__zero_reg__
 3797 126a 00C0      		rjmp .L187
 3798               	.L253:
 341:main_sim900.h ****     }
 3799               		.loc 2 341 0
 3800 126c 8091 0000 		lds r24,licznik_blad_stanu_karty_SIM
 3801 1270 8F5F      		subi r24,lo8(-(1))
 3802 1272 8093 0000 		sts licznik_blad_stanu_karty_SIM,r24
 3803 1276 00C0      		rjmp .L187
 3804               	.L203:
 3805               	.LVL324:
 3806               	.LBB488:
 348:main_sim900.h ****       const uchar *p1 =
 3807               		.loc 2 348 0
 3808 1278 D130      		cpi r29,lo8(1)
 3809 127a 01F0      		breq .+2
 3810 127c 00C0      		rjmp .L254
 3811               	.LVL325:
 3812               	.LBB489:
 3813               	.LBB490:
  47:main_sim900.h **** }
 3814               		.loc 2 47 0
 3815 127e 46E0      		ldi r20,lo8(6)
 3816 1280 50E0      		ldi r21,0
 3817 1282 60E0      		ldi r22,lo8(polecenie_operator.3222)
 3818 1284 70E0      		ldi r23,hi8(polecenie_operator.3222)
 3819 1286 80E0      		ldi r24,lo8(odebrany_blok_SIM900+2)
 3820 1288 90E0      		ldi r25,hi8(odebrany_blok_SIM900+2)
 3821 128a 0E94 0000 		call strncmp_P
 3822               	.LVL326:
 3823               	.LBE490:
 3824               	.LBE489:
 348:main_sim900.h ****       const uchar *p1 =
 3825               		.loc 2 348 0
 3826 128e 892B      		or r24,r25
 3827 1290 01F4      		brne .L254
 3828               	.LBB491:
 350:main_sim900.h ****       if (p1 != NULL) {
 3829               		.loc 2 350 0
 3830 1292 80E0      		ldi r24,lo8(polecenie_operator.3222)
 3831 1294 90E0      		ldi r25,hi8(polecenie_operator.3222)
 3832 1296 0E94 0000 		call polozenie_polecenia_SIM900
 3833               	.LVL327:
 349:main_sim900.h ****           strchr(polozenie_polecenia_SIM900(polecenie_operator), ',');
 3834               		.loc 2 349 0
 3835 129a 6CE2      		ldi r22,lo8(44)
 3836 129c 70E0      		ldi r23,0
 3837 129e 0E94 0000 		call strchr
 3838               	.LVL328:
 351:main_sim900.h ****         p1 = strchr(p1, ',');
 3839               		.loc 2 351 0
 3840 12a2 0097      		sbiw r24,0
 3841 12a4 01F0      		breq .L254
 352:main_sim900.h ****         if (p1 != NULL) {
 3842               		.loc 2 352 0
 3843 12a6 6CE2      		ldi r22,lo8(44)
 3844 12a8 70E0      		ldi r23,0
 3845 12aa 0E94 0000 		call strchr
 3846               	.LVL329:
 353:main_sim900.h ****           p1 = strchr(p1, '\"');
 3847               		.loc 2 353 0
 3848 12ae 0097      		sbiw r24,0
 3849 12b0 01F0      		breq .L254
 354:main_sim900.h ****           if (p1++ != NULL) {
 3850               		.loc 2 354 0
 3851 12b2 62E2      		ldi r22,lo8(34)
 3852 12b4 70E0      		ldi r23,0
 3853 12b6 0E94 0000 		call strchr
 3854               	.LVL330:
 355:main_sim900.h ****             const uchar *p2 = strchr(p1, '\"');
 3855               		.loc 2 355 0
 3856 12ba 0097      		sbiw r24,0
 3857 12bc 01F0      		breq .L254
 3858 12be 8C01      		movw r16,r24
 3859 12c0 0F5F      		subi r16,-1
 3860 12c2 1F4F      		sbci r17,-1
 3861               	.LVL331:
 3862               	.LBB492:
 356:main_sim900.h ****             if (p2 != NULL && p1 != p2) {
 3863               		.loc 2 356 0
 3864 12c4 62E2      		ldi r22,lo8(34)
 3865 12c6 70E0      		ldi r23,0
 3866 12c8 C801      		movw r24,r16
 3867 12ca 0E94 0000 		call strchr
 3868               	.LVL332:
 357:main_sim900.h ****               const uchar m = min(p2 - p1, ROZMIAR_NAZWA_OPERATORA);
 3869               		.loc 2 357 0
 3870 12ce 0097      		sbiw r24,0
 3871 12d0 01F0      		breq .L254
 357:main_sim900.h ****               const uchar m = min(p2 - p1, ROZMIAR_NAZWA_OPERATORA);
 3872               		.loc 2 357 0 is_stmt 0 discriminator 1
 3873 12d2 0817      		cp r16,r24
 3874 12d4 1907      		cpc r17,r25
 3875 12d6 01F0      		breq .L254
 3876               	.LVL333:
 3877               	.LBB493:
 358:main_sim900.h ****               memcpy(nazwa_operatora, p1, m);
 3878               		.loc 2 358 0 is_stmt 1
 3879 12d8 801B      		sub r24,r16
 3880 12da 910B      		sbc r25,r17
 3881               	.LVL334:
 3882 12dc 8C30      		cpi r24,12
 3883 12de 9105      		cpc r25,__zero_reg__
 3884 12e0 04F0      		brlt .L255
 3885 12e2 8BE0      		ldi r24,lo8(11)
 3886 12e4 90E0      		ldi r25,0
 3887               	.L255:
 3888 12e6 EC01      		movw r28,r24
 3889 12e8 DD27      		clr r29
 359:main_sim900.h ****               nazwa_operatora[m] = '\0';
 3890               		.loc 2 359 0
 3891 12ea AE01      		movw r20,r28
 3892 12ec B801      		movw r22,r16
 3893 12ee 80E0      		ldi r24,lo8(nazwa_operatora)
 3894 12f0 90E0      		ldi r25,hi8(nazwa_operatora)
 3895 12f2 0E94 0000 		call memcpy
 3896               	.LVL335:
 360:main_sim900.h ****               w = TRUE;
 3897               		.loc 2 360 0
 3898 12f6 C050      		subi r28,lo8(-(nazwa_operatora))
 3899 12f8 D040      		sbci r29,hi8(-(nazwa_operatora))
 3900 12fa 1882      		st Y,__zero_reg__
 3901               	.LVL336:
 3902               	.LBE493:
 3903               	.LBE492:
 3904               	.LBE491:
 368:main_sim900.h ****     else {
 3905               		.loc 2 368 0
 3906 12fc 1092 0000 		sts licznik_blad_zalogowania_u_operatora,__zero_reg__
 3907 1300 00C0      		rjmp .L187
 3908               	.LVL337:
 3909               	.L254:
 370:main_sim900.h ****     }
 3910               		.loc 2 370 0
 3911 1302 8091 0000 		lds r24,licznik_blad_zalogowania_u_operatora
 3912 1306 8F5F      		subi r24,lo8(-(1))
 3913 1308 8093 0000 		sts licznik_blad_zalogowania_u_operatora,r24
 3914 130c 00C0      		rjmp .L187
 3915               	.LVL338:
 3916               	.L190:
 3917               	.LBE488:
 376:main_sim900.h ****         CMS_ERROR_KOMENDA_SIM900 /*&& numer_bledu_cms == CMS_SMS_ME_RESERVED*/) // co le interpretu
 3918               		.loc 2 376 0
 3919 130e D630      		cpi r29,lo8(6)
 3920 1310 01F4      		brne .+2
 3921 1312 00C0      		rjmp .L243
 380:main_sim900.h ****     opoznienie_SIM900_100MS = 2;
 3922               		.loc 2 380 0
 3923 1314 84E9      		ldi r24,lo8(-108)
 379:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 3924               		.loc 2 379 0
 3925 1316 D130      		cpi r29,lo8(1)
 3926 1318 01F0      		breq .+2
 3927 131a 00C0      		rjmp .L378
 3928 131c 00C0      		rjmp .L243
 3929               	.L200:
 385:main_sim900.h ****         czy_jest_komenda_uzytkownik_odebral_rozmowe()) {
 3930               		.loc 2 385 0
 3931 131e D130      		cpi r29,lo8(1)
 3932 1320 01F0      		breq .L257
 386:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = TRUE;
 3933               		.loc 2 386 0 discriminator 1
 3934 1322 8091 0000 		lds r24,komenda_SIM900
 385:main_sim900.h ****         czy_jest_komenda_uzytkownik_odebral_rozmowe()) {
 3935               		.loc 2 385 0 discriminator 1
 3936 1326 8C30      		cpi r24,lo8(12)
 3937 1328 01F4      		brne .L258
 3938               	.L257:
 387:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 3939               		.loc 2 387 0
 3940 132a 8FEF      		ldi r24,lo8(-1)
 3941 132c 8093 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,r24
 388:main_sim900.h **** 
 3942               		.loc 2 388 0
 3943 1330 1092 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,__zero_reg__
 391:main_sim900.h ****         licznik_timeout_rozmowy_100ms = MAX_LICZNIK_TIMEOUT_ROZMOWY_100MS;
 3944               		.loc 2 391 0
 3945 1334 8091 0000 		lds r24,tryb_clip
 3946 1338 8111      		cpse r24,__zero_reg__
 3947 133a 00C0      		rjmp .L187
 392:main_sim900.h ****         opoznienie_SIM900_100MS =
 3948               		.loc 2 392 0
 3949 133c 8CE2      		ldi r24,lo8(44)
 3950 133e 91E0      		ldi r25,lo8(1)
 3951 1340 9093 0000 		sts licznik_timeout_rozmowy_100ms+1,r25
 3952 1344 8093 0000 		sts licznik_timeout_rozmowy_100ms,r24
 393:main_sim900.h ****             20; // 2 sekundy opoznienia przed wyslaniem tonu
 3953               		.loc 2 393 0
 3954 1348 84E1      		ldi r24,lo8(20)
 3955 134a 8093 0000 		sts opoznienie_SIM900_100MS,r24
 395:main_sim900.h ****       }
 3956               		.loc 2 395 0
 3957 134e 84EA      		ldi r24,lo8(-92)
 3958 1350 00C0      		rjmp .L383
 3959               	.L258:
 397:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 3960               		.loc 2 397 0
 3961 1352 D430      		cpi r29,lo8(4)
 3962 1354 01F0      		breq .L259
 397:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 3963               		.loc 2 397 0 is_stmt 0 discriminator 2
 3964 1356 8091 0000 		lds r24,komenda_SIM900
 3965 135a 8038      		cpi r24,lo8(-128)
 3966 135c 01F4      		brne .L260
 3967               	.L259:
 398:main_sim900.h ****                    MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 3968               		.loc 2 398 0 is_stmt 1 discriminator 3
 3969 135e 8091 0000 		lds r24,liczba_wykonanych_komend_identycznego_polecenia
 3970 1362 8F5F      		subi r24,lo8(-(1))
 397:main_sim900.h ****                ++liczba_wykonanych_komend_identycznego_polecenia <
 3971               		.loc 2 397 0 discriminator 3
 3972 1364 8093 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,r24
 3973 1368 8330      		cpi r24,lo8(3)
 3974 136a 00F4      		brsh .L260
 400:main_sim900.h ****     else if (kom == NO_CARRIER_KOMENDA_SIM900) {
 3975               		.loc 2 400 0
 3976 136c 85E9      		ldi r24,lo8(-107)
 3977 136e 00C0      		rjmp .L383
 3978               	.L260:
 401:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 3979               		.loc 2 401 0
 3980 1370 D330      		cpi r29,lo8(3)
 3981 1372 01F4      		brne .L261
 402:main_sim900.h ****       liczba_wykonanych_komend_identycznego_polecenia = 0;
 3982               		.loc 2 402 0
 3983 1374 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 3984               	.L261:
 405:main_sim900.h ****     break;
 3985               		.loc 2 405 0
 3986 1378 1092 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,__zero_reg__
 3987 137c 00C0      		rjmp .L187
 3988               	.L375:
 438:main_sim900.h ****       // odczytany sms
 3989               		.loc 2 438 0
 3990 137e D130      		cpi r29,lo8(1)
 3991 1380 01F4      		brne .L263
 3992               	.LBB494:
 440:main_sim900.h ****       ptr = strchr(ptr, ZNAK_KONCA_ODBIERANIA_ZNAKOW_LF);            // (1)
 3993               		.loc 2 440 0
 3994 1382 80E0      		ldi r24,lo8(__c.3251)
 3995 1384 90E0      		ldi r25,hi8(__c.3251)
 3996 1386 0E94 0000 		call polozenie_polecenia_SIM900
 3997               	.LVL339:
 441:main_sim900.h ****       // const uchar* ptr = strchr(&odebrany_blok_SIM900[7],
 3998               		.loc 2 441 0
 3999 138a 6AE0      		ldi r22,lo8(10)
 4000 138c 70E0      		ldi r23,0
 4001 138e 0E94 0000 		call strchr
 4002               	.LVL340:
 444:main_sim900.h ****         ++ptr;
 4003               		.loc 2 444 0
 4004 1392 0097      		sbiw r24,0
 4005 1394 01F0      		breq .L264
 4006               	.LBB495:
 445:main_sim900.h ****         const uchar *ptr2 = strchr(ptr, ZNAK_KONCA_WYSYLANIA_ZNAKOW_CR);
 4007               		.loc 2 445 0
 4008 1396 EC01      		movw r28,r24
 4009 1398 2196      		adiw r28,1
 4010               	.LVL341:
 446:main_sim900.h ****         if (ptr2 != NULL) {
 4011               		.loc 2 446 0
 4012 139a 6DE0      		ldi r22,lo8(13)
 4013 139c 70E0      		ldi r23,0
 4014 139e CE01      		movw r24,r28
 4015 13a0 0E94 0000 		call strchr
 4016               	.LVL342:
 447:main_sim900.h ****           dlugosc_pdu = (ptr2 - ptr) / 2;
 4017               		.loc 2 447 0
 4018 13a4 0097      		sbiw r24,0
 4019 13a6 01F0      		breq .L264
 4020               	.LBB496:
 448:main_sim900.h ****           if (dlugosc_pdu > MAX_DLUGOSC_PDU)
 4021               		.loc 2 448 0
 4022 13a8 8C1B      		sub r24,r28
 4023 13aa 9D0B      		sbc r25,r29
 4024               	.LVL343:
 4025 13ac 97FD      		sbrc r25,7
 4026 13ae 0196      		adiw r24,1
 4027               	.L265:
 4028 13b0 9595      		asr r25
 4029 13b2 8795      		ror r24
 449:main_sim900.h ****             dlugosc_pdu = MAX_DLUGOSC_PDU;
 4030               		.loc 2 449 0
 4031 13b4 893C      		cpi r24,lo8(-55)
 4032 13b6 00F4      		brsh .L266
 4033               	.L379:
 450:main_sim900.h ****           konwertuj_blok_dwa_znaki_na_znak_pdu(ptr, dlugosc_pdu, bufor_pdu);
 4034               		.loc 2 450 0
 4035 13b8 8093 0000 		sts dlugosc_pdu,r24
 451:main_sim900.h ****           dodaj_komende(KOMENDA_KOLEJKI_INTERPRETUJ_PDU);
 4036               		.loc 2 451 0
 4037 13bc 40E0      		ldi r20,lo8(bufor_pdu)
 4038 13be 50E0      		ldi r21,hi8(bufor_pdu)
 4039 13c0 6091 0000 		lds r22,dlugosc_pdu
 4040 13c4 CE01      		movw r24,r28
 4041 13c6 0E94 0000 		call konwertuj_blok_dwa_znaki_na_znak_pdu
 4042               	.LVL344:
 452:main_sim900.h ****           const uchar nr_smsa = aktualnie_wysylane_polecenie_SIM900 -
 4043               		.loc 2 452 0
 4044 13ca 81ED      		ldi r24,lo8(-47)
 4045 13cc 0E94 0000 		call dodaj_komende
 4046               	.LVL345:
 455:main_sim900.h ****           flaga_odczytywanie_smsa = TRUE;
 4047               		.loc 2 455 0
 4048 13d0 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4049 13d4 8C5E      		subi r24,lo8(-(20))
 4050 13d6 0E94 0000 		call dodaj_komende
 4051               	.LVL346:
 456:main_sim900.h ****           POMOC_DODAJ2('#', 'O');
 4052               		.loc 2 456 0
 4053 13da 8FEF      		ldi r24,lo8(-1)
 4054 13dc 8093 0000 		sts flaga_odczytywanie_smsa,r24
 4055               	.LVL347:
 4056 13e0 00C0      		rjmp .L187
 4057               	.LVL348:
 4058               	.L266:
 450:main_sim900.h ****           konwertuj_blok_dwa_znaki_na_znak_pdu(ptr, dlugosc_pdu, bufor_pdu);
 4059               		.loc 2 450 0
 4060 13e2 88EC      		ldi r24,lo8(-56)
 4061 13e4 00C0      		rjmp .L379
 4062               	.LVL349:
 4063               	.L264:
 4064               	.LBE496:
 459:main_sim900.h ****       } else
 4065               		.loc 2 459 0
 4066 13e6 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 4067 13ea 00C0      		rjmp .L187
 4068               	.L263:
 4069               	.LBE495:
 4070               	.LBE494:
 462:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 4071               		.loc 2 462 0
 4072 13ec D630      		cpi r29,lo8(6)
 4073 13ee 01F0      		breq .L268
 4074               	.L387:
 467:main_sim900.h ****       opoznienie_SIM900_100MS = 60;
 4075               		.loc 2 467 0
 4076 13f0 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 468:main_sim900.h ****       POMOC_DODAJ2('#', 'P');
 4077               		.loc 2 468 0
 4078 13f4 8CE3      		ldi r24,lo8(60)
 4079 13f6 00C0      		rjmp .L382
 4080               	.L268:
 466:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 4081               		.loc 2 466 0
 4082 13f8 8C2F      		mov r24,r28
 4083 13fa 0E94 0000 		call dodaj_komende
 4084               	.LVL350:
 4085 13fe 00C0      		rjmp .L387
 4086               	.L269:
 501:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 4087               		.loc 2 501 0
 4088 1400 D430      		cpi r29,lo8(4)
 4089 1402 01F4      		brne .+2
 4090 1404 00C0      		rjmp .L380
 4091               	.L270:
 503:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 4092               		.loc 2 503 0
 4093 1406 8091 0000 		lds r24,komenda_SIM900
 4094 140a 8038      		cpi r24,lo8(-128)
 4095 140c 01F4      		brne .+2
 4096 140e 00C0      		rjmp .L380
 4097               	.L271:
 4098               	.LVL351:
 506:main_sim900.h ****     break;
 4099               		.loc 2 506 0
 4100 1410 89E1      		ldi r24,lo8(25)
 4101 1412 00C0      		rjmp .L382
 4102               	.LVL352:
 4103               	.L213:
 514:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 4104               		.loc 2 514 0
 4105 1414 D430      		cpi r29,lo8(4)
 4106 1416 01F0      		breq .L272
 514:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 4107               		.loc 2 514 0 is_stmt 0 discriminator 1
 4108 1418 8091 0000 		lds r24,komenda_SIM900
 4109 141c 8038      		cpi r24,lo8(-128)
 4110 141e 01F0      		breq .+2
 4111 1420 00C0      		rjmp .L261
 4112               	.L272:
 515:main_sim900.h ****       if (++liczba_wykonanych_komend_identycznego_polecenia <
 4113               		.loc 2 515 0 is_stmt 1
 4114 1422 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 516:main_sim900.h ****           MAX_LICZBA_WYKONANYCH_KOMEND_IDENTYCZNEGO_POLECENIA)
 4115               		.loc 2 516 0
 4116 1426 8091 0000 		lds r24,liczba_wykonanych_komend_identycznego_polecenia
 4117 142a 8F5F      		subi r24,lo8(-(1))
 4118 142c 8093 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,r24
 4119 1430 8330      		cpi r24,lo8(3)
 4120 1432 00F4      		brsh .L273
 518:main_sim900.h ****       else {
 4121               		.loc 2 518 0
 4122 1434 85ED      		ldi r24,lo8(-43)
 4123 1436 00C0      		rjmp .L383
 4124               	.L273:
 520:main_sim900.h ****         zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 4125               		.loc 2 520 0
 4126 1438 1092 0000 		sts liczba_wykonanych_komend_identycznego_polecenia,__zero_reg__
 521:main_sim900.h ****         trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 4127               		.loc 2 521 0
 4128 143c 80E0      		ldi r24,0
 4129 143e 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 4130               	.LVL353:
 522:main_sim900.h ****         wykonywanie_rozmowy_telefonicznej = FALSE;
 4131               		.loc 2 522 0
 4132 1442 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 523:main_sim900.h ****         licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 4133               		.loc 2 523 0
 4134 1446 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 524:main_sim900.h ****       }
 4135               		.loc 2 524 0
 4136 144a 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 4137 144e 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 4138 1452 00C0      		rjmp .L187
 4139               	.L192:
 531:main_sim900.h ****       dodaj_komende(aktualnie_wysylane_polecenie_SIM900);
 4140               		.loc 2 531 0
 4141 1454 D130      		cpi r29,lo8(1)
 4142 1456 01F0      		breq .L274
 532:main_sim900.h ****       opoznienie_SIM900_100MS = 20;
 4143               		.loc 2 532 0
 4144 1458 8EE8      		ldi r24,lo8(-114)
 4145 145a 0E94 0000 		call dodaj_komende
 4146               	.LVL354:
 533:main_sim900.h ****       break;
 4147               		.loc 2 533 0
 4148 145e 84E1      		ldi r24,lo8(20)
 4149 1460 00C0      		rjmp .L382
 4150               	.L274:
 556:main_sim900.h ****       if (nastepne_wysylane_polecenie_SIM900 >=
 4151               		.loc 2 556 0
 4152 1462 8091 0000 		lds r24,nastepne_wysylane_polecenie_SIM900
 4153 1466 0E94 0000 		call dodaj_komende
 4154               	.LVL355:
 558:main_sim900.h ****           nastepne_wysylane_polecenie_SIM900 <=
 4155               		.loc 2 558 0
 4156 146a 8091 0000 		lds r24,nastepne_wysylane_polecenie_SIM900
 4157 146e 895A      		subi r24,lo8(-(87))
 557:main_sim900.h ****               KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 4158               		.loc 2 557 0
 4159 1470 8431      		cpi r24,lo8(20)
 4160 1472 00F0      		brlo .+2
 4161 1474 00C0      		rjmp .L275
 561:main_sim900.h ****       }
 4162               		.loc 2 561 0
 4163 1476 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 4164 147a 00C0      		rjmp .L275
 4165               		.cfi_endproc
 4166               	.LFE49:
 4168               	.global	obsluga_komendy_SIM900
 4170               	obsluga_komendy_SIM900:
 4171               	.LFB50:
 573:main_sim900.h **** 
 574:main_sim900.h **** void obsluga_komendy_SIM900(void) {
 4172               		.loc 2 574 0
 4173               		.cfi_startproc
 4174 147c 0F93      		push r16
 4175               	.LCFI61:
 4176               		.cfi_def_cfa_offset 3
 4177               		.cfi_offset 16, -2
 4178 147e 1F93      		push r17
 4179               	.LCFI62:
 4180               		.cfi_def_cfa_offset 4
 4181               		.cfi_offset 17, -3
 4182 1480 CF93      		push r28
 4183               	.LCFI63:
 4184               		.cfi_def_cfa_offset 5
 4185               		.cfi_offset 28, -4
 4186 1482 DF93      		push r29
 4187               	.LCFI64:
 4188               		.cfi_def_cfa_offset 6
 4189               		.cfi_offset 29, -5
 4190               	/* prologue: function */
 4191               	/* frame size = 0 */
 4192               	/* stack size = 4 */
 4193               	.L__stack_usage = 4
 575:main_sim900.h ****   if (!czy_jest_bezczynny_SIM900())
 4194               		.loc 2 575 0
 4195 1484 8091 0000 		lds r24,komenda_SIM900
 576:main_sim900.h ****     POMOC_SIM900_DODAJ(odebrany_blok_SIM900);
 577:main_sim900.h **** 
 578:main_sim900.h ****   if (czy_jest_blad_SIM900() || oproznij_bufor_SIM900_po_bledzie) {
 4196               		.loc 2 578 0
 4197 1488 8091 0000 		lds r24,komenda_SIM900
 4198 148c 8038      		cpi r24,lo8(-128)
 4199 148e 01F0      		breq .L389
 4200               		.loc 2 578 0 is_stmt 0 discriminator 1
 4201 1490 8091 0000 		lds r24,oproznij_bufor_SIM900_po_bledzie
 4202 1494 8823      		tst r24
 4203 1496 01F0      		breq .L390
 4204               	.L389:
 579:main_sim900.h ****     komenda_SIM900 = BLAD_SIM900;
 4205               		.loc 2 579 0 is_stmt 1
 4206 1498 80E8      		ldi r24,lo8(-128)
 4207 149a 8093 0000 		sts komenda_SIM900,r24
 580:main_sim900.h ****     odpowiedz_na_polecenie();
 4208               		.loc 2 580 0
 4209 149e 0E94 0000 		call odpowiedz_na_polecenie
 4210               	.LVL356:
 581:main_sim900.h ****     opoznienie_SIM900_100MS = 50;
 4211               		.loc 2 581 0
 4212 14a2 82E3      		ldi r24,lo8(50)
 4213 14a4 8093 0000 		sts opoznienie_SIM900_100MS,r24
 582:main_sim900.h ****     oproznij_bufor_SIM900_po_bledzie = TRUE;
 4214               		.loc 2 582 0
 4215 14a8 8FEF      		ldi r24,lo8(-1)
 4216 14aa 8093 0000 		sts oproznij_bufor_SIM900_po_bledzie,r24
 4217               	.LVL357:
 4218               	.L388:
 4219               	/* epilogue start */
 583:main_sim900.h ****     POMOC_DODAJ2('*', 'd');
 584:main_sim900.h ****     return;
 585:main_sim900.h ****   }
 586:main_sim900.h **** 
 587:main_sim900.h ****   if (czy_jest_komenda_wyslane_polecenie_SIM900()) {
 588:main_sim900.h ****     if ((liczba_wysylanych_znakow_SIM900 != liczba_odebranych_znakow_SIM900 ||
 589:main_sim900.h ****          memcmp(odebrany_blok_SIM900, wysylany_blok_SIM900,
 590:main_sim900.h ****                 liczba_wysylanych_znakow_SIM900) != 0) &&
 591:main_sim900.h ****         !czekanie_na_odebranie_zachety) {
 592:main_sim900.h ****       komenda_SIM900 = BLAD_SIM900;
 593:main_sim900.h ****       oproznij_bufor_SIM900_po_bledzie = TRUE;
 594:main_sim900.h ****       opoznienie_SIM900_100MS = 50;
 595:main_sim900.h ****       POMOC_DODAJ2('*', 'e');
 596:main_sim900.h ****     }
 597:main_sim900.h ****     return;
 598:main_sim900.h ****   }
 599:main_sim900.h **** 
 600:main_sim900.h ****   if (czy_jest_komenda_rozmowa_telefoniczna()) {
 601:main_sim900.h ****     POMOC_DODAJ2('#', 'b');
 602:main_sim900.h ****     // numer_telefonu_ktory_dzwoni[0] = '\0';  // REMOVED: Niepotrzebne
 603:main_sim900.h ****     // czyszczenie - numer jest zaraz nadpisywany
 604:main_sim900.h ****     const uchar *p1 = strchr(polozenie_polecenia_SIM900(PSTR("+CLIP:")), '\"');
 605:main_sim900.h ****     if (p1++ != NULL) {
 606:main_sim900.h ****       const uchar *p2 = strchr(p1, '\"');
 607:main_sim900.h ****       if (p2 != NULL) {
 608:main_sim900.h ****         const uchar l = p2 - p1;
 609:main_sim900.h ****         if (l < MAX_LICZBA_ZNAKOW_TELEFON) {
 610:main_sim900.h ****           memcpy(numer_telefonu_ktory_dzwoni, p1, l);
 611:main_sim900.h ****           numer_telefonu_ktory_dzwoni[l] = '\0';
 612:main_sim900.h ****           POMOC_DODAJ_HEX(l);
 613:main_sim900.h ****           if (licznik_blad_zalogowania_u_operatora != 0)
 614:main_sim900.h ****             licznik_blad_zalogowania_u_operatora = 0;
 615:main_sim900.h ****           if (poziom_sieci_gsm == 0 || poziom_sieci_gsm == POZIOM_SIECI_BLAD)
 616:main_sim900.h ****             poziom_sieci_gsm = 16;
 617:main_sim900.h ****         }
 618:main_sim900.h ****       }
 619:main_sim900.h ****     }
 620:main_sim900.h ****     filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_PRZYCHODZACA_ROZMOWE);
 621:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 622:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 623:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 624:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 625:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 626:main_sim900.h ****     }
 627:main_sim900.h ****     wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 628:main_sim900.h ****     return;
 629:main_sim900.h ****   }
 630:main_sim900.h **** 
 631:main_sim900.h ****   if (czy_jest_komenda_zakonczenie_rozmowy_telefonicznej()) {
 632:main_sim900.h ****     POMOC_DODAJ2('#', 'c');
 633:main_sim900.h ****     zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 634:main_sim900.h ****     trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 635:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 636:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 637:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 ==
 638:main_sim900.h ****         KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE) {
 639:main_sim900.h ****       wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 640:main_sim900.h ****     }
 641:main_sim900.h ****     return;
 642:main_sim900.h ****   }
 643:main_sim900.h **** 
 644:main_sim900.h ****   if (czy_jest_komenda_uzytkownik_odebral_dzwonek()) {
 645:main_sim900.h ****     POMOC_DODAJ2('#', 'd');
 646:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 == KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE)
 647:main_sim900.h ****       odpowiedz_na_polecenie();
 648:main_sim900.h ****     if (ustaw_maksymalny_czas_dzwonienia == 0)
 649:main_sim900.h ****       maksymalny_czas_dzwonienia = 90; // standardowy czas czekania 9 sekund
 650:main_sim900.h ****     else {
 651:main_sim900.h ****       maksymalny_czas_dzwonienia = ustaw_maksymalny_czas_dzwonienia;
 652:main_sim900.h ****       ustaw_maksymalny_czas_dzwonienia = 0;
 653:main_sim900.h ****     }
 654:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = TRUE;
 655:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 656:main_sim900.h ****     return;
 657:main_sim900.h ****   }
 658:main_sim900.h **** 
 659:main_sim900.h ****   // Obsluga +DTMF:
 660:main_sim900.h ****   const uchar *ptr_dtmf = polozenie_polecenia_SIM900(PSTR("+DTMF:"));
 661:main_sim900.h ****   if (ptr_dtmf != NULL) {
 662:main_sim900.h ****     POMOC_DODAJ2('#', 'D');
 663:main_sim900.h ****     ptr_dtmf += 7; // Skip "+DTMF: "
 664:main_sim900.h ****     while (*ptr_dtmf == ' ')
 665:main_sim900.h ****       ++ptr_dtmf;
 666:main_sim900.h ****     const uchar dtmf_key = *ptr_dtmf;
 667:main_sim900.h ****     POMOC_DODAJ(dtmf_key);
 668:main_sim900.h **** 
 669:main_sim900.h ****     if (!tryb_clip) // Tylko w trybie DTMF
 670:main_sim900.h ****     {
 671:main_sim900.h ****       if (dtmf_key == '1') {
 672:main_sim900.h ****         stan_wyjscie[0] = TRUE;
 673:main_sim900.h ****         licznik_przelacznik_wyjscia[0] = 2 * 10ul; // 2 sekundy retrigger
 674:main_sim900.h ****         zapal_diode_led(10);
 675:main_sim900.h ****       }
 676:main_sim900.h ****     }
 677:main_sim900.h ****     resetuj_komende_SIM900(); // Krytyczne dla kolejnych znakow
 678:main_sim900.h ****     return;
 679:main_sim900.h ****   }
 680:main_sim900.h **** 
 681:main_sim900.h ****   if (czy_jest_komenda_uzytkownik_odebral_rozmowe()) {
 682:main_sim900.h ****     POMOC_DODAJ2('#', 'e');
 683:main_sim900.h ****     if (tryb_clip) {
 684:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 685:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
 686:main_sim900.h ****     }
 687:main_sim900.h ****     return;
 688:main_sim900.h ****   }
 689:main_sim900.h ****   if (czy_jest_komenda_brak_sygnalu_tonowego()) {
 690:main_sim900.h ****     POMOC_DODAJ2('#', 'f');
 691:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 == KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE)
 692:main_sim900.h ****       odpowiedz_na_polecenie();
 693:main_sim900.h ****     zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 694:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 695:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 696:main_sim900.h ****     return;
 697:main_sim900.h ****   }
 698:main_sim900.h **** 
 699:main_sim900.h ****   if (czy_jest_komenda_telefon_zajety()) {
 700:main_sim900.h ****     POMOC_DODAJ2('#', 'g');
 701:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 == KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE)
 702:main_sim900.h ****       odpowiedz_na_polecenie();
 703:main_sim900.h ****     zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 704:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 705:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 706:main_sim900.h ****     return;
 707:main_sim900.h ****   }
 708:main_sim900.h **** 
 709:main_sim900.h ****   if (czy_jest_komenda_nowy_SMS()) {
 710:main_sim900.h ****     const uchar *ptr = strchr(polozenie_polecenia_SIM900(PSTR("+CMTI:")), ',');
 711:main_sim900.h ****     if (ptr != NULL) {
 712:main_sim900.h ****       uint numer_smsa = (uint)strtoul(ptr + 1, NULL, 10);
 713:main_sim900.h ****       if (numer_smsa > 0 && numer_smsa <= 20) // Hardcoded 20
 714:main_sim900.h ****       {
 715:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 + numer_smsa - 1);
 716:main_sim900.h ****         opoznienie_SIM900_100MS = 1; // 20 (1)
 717:main_sim900.h ****       }
 718:main_sim900.h ****     }
 719:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 720:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 721:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 722:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 723:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 724:main_sim900.h ****       wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 725:main_sim900.h ****     }
 726:main_sim900.h ****     return;
 727:main_sim900.h ****   }
 728:main_sim900.h **** 
 729:main_sim900.h ****   if (czy_jest_komenda_otrzymano_sms_flash()) {
 730:main_sim900.h ****     opoznienie_SIM900_100MS = 20;
 731:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 732:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 733:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 734:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) {
 735:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 736:main_sim900.h ****       wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 737:main_sim900.h ****     }
 738:main_sim900.h ****     const uchar *p1 = strchr(polozenie_polecenia_SIM900(PSTR("+CUSD:")), '\"');
 739:main_sim900.h ****     if (p1++ != NULL) {
 740:main_sim900.h ****       uchar *p2 = strchr(p1, '\"');
 741:main_sim900.h ****       if (p2 != NULL) {
 742:main_sim900.h ****         //*p2 = '\0';
 743:main_sim900.h ****         // tekst_wysylanego_smsa[0] = '*';
 744:main_sim900.h ****         // strncpy(&tekst_wysylanego_smsa[1], p1, MAX_LICZBA_ZNAKOW_SMS - 1);
 745:main_sim900.h ****         // tekst_wysylanego_smsa[MAX_LICZBA_ZNAKOW_SMS] = 0;
 746:main_sim900.h ****       }
 747:main_sim900.h ****     }
 748:main_sim900.h ****     return;
 749:main_sim900.h ****   }
 750:main_sim900.h **** 
 751:main_sim900.h ****   if (flaga_wysylanie_smsa)
 752:main_sim900.h ****     obsluga_wysylania_sms();
 753:main_sim900.h **** 
 754:main_sim900.h ****   if (liczba_odebranych_znakow_SIM900 != 0 &&
 755:main_sim900.h ****       komenda_SIM900 != BRAK_KOMENDY_SIM900)
 756:main_sim900.h ****     odpowiedz_na_polecenie();
 757:main_sim900.h **** }
 4220               		.loc 2 757 0
 4221 14ae DF91      		pop r29
 4222 14b0 CF91      		pop r28
 4223 14b2 1F91      		pop r17
 4224 14b4 0F91      		pop r16
 4225 14b6 0895      		ret
 4226               	.L390:
 587:main_sim900.h ****     if ((liczba_wysylanych_znakow_SIM900 != liczba_odebranych_znakow_SIM900 ||
 4227               		.loc 2 587 0
 4228 14b8 8091 0000 		lds r24,komenda_SIM900
 4229 14bc 8138      		cpi r24,lo8(-127)
 4230 14be 01F4      		brne .L392
 588:main_sim900.h ****          memcmp(odebrany_blok_SIM900, wysylany_blok_SIM900,
 4231               		.loc 2 588 0
 4232 14c0 2091 0000 		lds r18,liczba_wysylanych_znakow_SIM900
 4233 14c4 3091 0000 		lds r19,liczba_wysylanych_znakow_SIM900+1
 4234 14c8 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 4235 14cc 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
 4236 14d0 2817      		cp r18,r24
 4237 14d2 3907      		cpc r19,r25
 4238 14d4 01F4      		brne .L393
 589:main_sim900.h ****                 liczba_wysylanych_znakow_SIM900) != 0) &&
 4239               		.loc 2 589 0 discriminator 1
 4240 14d6 4091 0000 		lds r20,liczba_wysylanych_znakow_SIM900
 4241 14da 5091 0000 		lds r21,liczba_wysylanych_znakow_SIM900+1
 4242 14de 60E0      		ldi r22,lo8(wysylany_blok_SIM900)
 4243 14e0 70E0      		ldi r23,hi8(wysylany_blok_SIM900)
 4244 14e2 80E0      		ldi r24,lo8(odebrany_blok_SIM900)
 4245 14e4 90E0      		ldi r25,hi8(odebrany_blok_SIM900)
 4246 14e6 0E94 0000 		call memcmp
 4247               	.LVL358:
 588:main_sim900.h ****          memcmp(odebrany_blok_SIM900, wysylany_blok_SIM900,
 4248               		.loc 2 588 0 discriminator 1
 4249 14ea 892B      		or r24,r25
 4250 14ec 01F0      		breq .L388
 4251               	.L393:
 591:main_sim900.h ****       komenda_SIM900 = BLAD_SIM900;
 4252               		.loc 2 591 0
 4253 14ee 8091 0000 		lds r24,czekanie_na_odebranie_zachety
 590:main_sim900.h ****         !czekanie_na_odebranie_zachety) {
 4254               		.loc 2 590 0
 4255 14f2 8111      		cpse r24,__zero_reg__
 4256 14f4 00C0      		rjmp .L388
 592:main_sim900.h ****       oproznij_bufor_SIM900_po_bledzie = TRUE;
 4257               		.loc 2 592 0
 4258 14f6 80E8      		ldi r24,lo8(-128)
 4259 14f8 8093 0000 		sts komenda_SIM900,r24
 593:main_sim900.h ****       opoznienie_SIM900_100MS = 50;
 4260               		.loc 2 593 0
 4261 14fc 8FEF      		ldi r24,lo8(-1)
 4262 14fe 8093 0000 		sts oproznij_bufor_SIM900_po_bledzie,r24
 594:main_sim900.h ****       POMOC_DODAJ2('*', 'e');
 4263               		.loc 2 594 0
 4264 1502 82E3      		ldi r24,lo8(50)
 4265 1504 8093 0000 		sts opoznienie_SIM900_100MS,r24
 4266               	.LVL359:
 4267 1508 00C0      		rjmp .L388
 4268               	.LVL360:
 4269               	.L392:
 4270               	.LBB511:
 4271               	.LBB512:
 600:main_sim900.h ****     POMOC_DODAJ2('#', 'b');
 4272               		.loc 2 600 0
 4273 150a 8091 0000 		lds r24,komenda_SIM900
 4274 150e 8A30      		cpi r24,lo8(10)
 4275 1510 01F0      		breq .+2
 4276 1512 00C0      		rjmp .L395
 4277               	.LVL361:
 4278               	.LBB513:
 604:main_sim900.h ****     if (p1++ != NULL) {
 4279               		.loc 2 604 0
 4280 1514 80E0      		ldi r24,lo8(__c.3293)
 4281 1516 90E0      		ldi r25,hi8(__c.3293)
 4282 1518 0E94 0000 		call polozenie_polecenia_SIM900
 4283               	.LVL362:
 4284 151c 62E2      		ldi r22,lo8(34)
 4285 151e 70E0      		ldi r23,0
 4286 1520 0E94 0000 		call strchr
 4287               	.LVL363:
 605:main_sim900.h ****       const uchar *p2 = strchr(p1, '\"');
 4288               		.loc 2 605 0
 4289 1524 0097      		sbiw r24,0
 4290 1526 01F0      		breq .L397
 4291 1528 8C01      		movw r16,r24
 4292 152a 0F5F      		subi r16,-1
 4293 152c 1F4F      		sbci r17,-1
 4294               	.LVL364:
 4295               	.LBB514:
 606:main_sim900.h ****       if (p2 != NULL) {
 4296               		.loc 2 606 0
 4297 152e 62E2      		ldi r22,lo8(34)
 4298 1530 70E0      		ldi r23,0
 4299 1532 C801      		movw r24,r16
 4300 1534 0E94 0000 		call strchr
 4301               	.LVL365:
 607:main_sim900.h ****         const uchar l = p2 - p1;
 4302               		.loc 2 607 0
 4303 1538 0097      		sbiw r24,0
 4304 153a 01F0      		breq .L397
 4305               	.LBB515:
 608:main_sim900.h ****         if (l < MAX_LICZBA_ZNAKOW_TELEFON) {
 4306               		.loc 2 608 0
 4307 153c EC01      		movw r28,r24
 4308 153e C01B      		sub r28,r16
 4309 1540 D10B      		sbc r29,r17
 4310               	.LVL366:
 609:main_sim900.h ****           memcpy(numer_telefonu_ktory_dzwoni, p1, l);
 4311               		.loc 2 609 0
 4312 1542 C031      		cpi r28,lo8(16)
 4313 1544 00F4      		brsh .L397
 4314 1546 DD27      		clr r29
 4315               	.LVL367:
 610:main_sim900.h ****           numer_telefonu_ktory_dzwoni[l] = '\0';
 4316               		.loc 2 610 0
 4317 1548 AE01      		movw r20,r28
 4318 154a B801      		movw r22,r16
 4319 154c 80E0      		ldi r24,lo8(numer_telefonu_ktory_dzwoni)
 4320 154e 90E0      		ldi r25,hi8(numer_telefonu_ktory_dzwoni)
 4321               	.LVL368:
 4322 1550 0E94 0000 		call memcpy
 4323               	.LVL369:
 611:main_sim900.h ****           POMOC_DODAJ_HEX(l);
 4324               		.loc 2 611 0
 4325 1554 C050      		subi r28,lo8(-(numer_telefonu_ktory_dzwoni))
 4326 1556 D040      		sbci r29,hi8(-(numer_telefonu_ktory_dzwoni))
 4327 1558 1882      		st Y,__zero_reg__
 4328               	.LVL370:
 613:main_sim900.h ****             licznik_blad_zalogowania_u_operatora = 0;
 4329               		.loc 2 613 0
 4330 155a 8091 0000 		lds r24,licznik_blad_zalogowania_u_operatora
 4331 155e 8111      		cpse r24,__zero_reg__
 614:main_sim900.h ****           if (poziom_sieci_gsm == 0 || poziom_sieci_gsm == POZIOM_SIECI_BLAD)
 4332               		.loc 2 614 0
 4333 1560 1092 0000 		sts licznik_blad_zalogowania_u_operatora,__zero_reg__
 4334               	.L399:
 615:main_sim900.h ****             poziom_sieci_gsm = 16;
 4335               		.loc 2 615 0
 4336 1564 8091 0000 		lds r24,poziom_sieci_gsm
 4337 1568 8823      		tst r24
 4338 156a 01F0      		breq .L400
 4339 156c 8336      		cpi r24,lo8(99)
 4340 156e 01F4      		brne .L397
 4341               	.L400:
 616:main_sim900.h ****         }
 4342               		.loc 2 616 0
 4343 1570 80E1      		ldi r24,lo8(16)
 4344 1572 8093 0000 		sts poziom_sieci_gsm,r24
 4345               	.LVL371:
 4346               	.L397:
 4347               	.LBE515:
 4348               	.LBE514:
 620:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 4349               		.loc 2 620 0
 4350 1576 87E9      		ldi r24,lo8(-105)
 4351 1578 0E94 0000 		call filtruj_i_dodaj_komende
 4352               	.LVL372:
 622:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 4353               		.loc 2 622 0
 4354 157c 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4355 1580 895A      		subi r24,lo8(-(87))
 621:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 4356               		.loc 2 621 0
 4357 1582 8431      		cpi r24,lo8(20)
 4358 1584 00F4      		brsh .L401
 4359               	.LVL373:
 4360               	.L457:
 625:main_sim900.h ****     }
 4361               		.loc 2 625 0
 4362 1586 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 4363               	.L401:
 627:main_sim900.h ****     return;
 4364               		.loc 2 627 0
 4365 158a 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 4366 158e 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 4367 1592 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
 4368 1596 00C0      		rjmp .L388
 4369               	.L395:
 4370               	.LBE513:
 631:main_sim900.h ****     POMOC_DODAJ2('#', 'c');
 4371               		.loc 2 631 0
 4372 1598 8091 0000 		lds r24,komenda_SIM900
 4373 159c 8330      		cpi r24,lo8(3)
 4374 159e 01F4      		brne .L402
 4375               	.LVL374:
 633:main_sim900.h ****     trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 4376               		.loc 2 633 0
 4377 15a0 80E0      		ldi r24,0
 4378 15a2 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 4379               	.LVL375:
 634:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 4380               		.loc 2 634 0
 4381 15a6 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 635:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 4382               		.loc 2 635 0
 4383 15aa 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 636:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 ==
 4384               		.loc 2 636 0
 4385 15ae 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 4386 15b2 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 637:main_sim900.h ****         KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE) {
 4387               		.loc 2 637 0
 4388 15b6 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4389 15ba 853D      		cpi r24,lo8(-43)
 4390 15bc 01F0      		breq .+2
 4391 15be 00C0      		rjmp .L388
 4392 15c0 00C0      		rjmp .L401
 4393               	.LVL376:
 4394               	.L402:
 644:main_sim900.h ****     POMOC_DODAJ2('#', 'd');
 4395               		.loc 2 644 0
 4396 15c2 8091 0000 		lds r24,komenda_SIM900
 4397 15c6 8230      		cpi r24,lo8(2)
 4398 15c8 01F4      		brne .L403
 4399               	.LVL377:
 646:main_sim900.h ****       odpowiedz_na_polecenie();
 4400               		.loc 2 646 0
 4401 15ca 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4402 15ce 853D      		cpi r24,lo8(-43)
 4403 15d0 01F4      		brne .L404
 647:main_sim900.h ****     if (ustaw_maksymalny_czas_dzwonienia == 0)
 4404               		.loc 2 647 0
 4405 15d2 0E94 0000 		call odpowiedz_na_polecenie
 4406               	.LVL378:
 4407               	.L404:
 648:main_sim900.h ****       maksymalny_czas_dzwonienia = 90; // standardowy czas czekania 9 sekund
 4408               		.loc 2 648 0
 4409 15d6 8091 0000 		lds r24,ustaw_maksymalny_czas_dzwonienia
 4410 15da 8111      		cpse r24,__zero_reg__
 4411 15dc 00C0      		rjmp .L405
 649:main_sim900.h ****     else {
 4412               		.loc 2 649 0
 4413 15de 8AE5      		ldi r24,lo8(90)
 4414 15e0 8093 0000 		sts maksymalny_czas_dzwonienia,r24
 4415               	.L406:
 654:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 4416               		.loc 2 654 0
 4417 15e4 8FEF      		ldi r24,lo8(-1)
 4418 15e6 8093 0000 		sts wykonywanie_rozmowy_telefonicznej,r24
 4419               	.LVL379:
 4420               	.L458:
 695:main_sim900.h ****     return;
 4421               		.loc 2 695 0
 4422 15ea 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,__zero_reg__
 4423 15ee 1092 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,__zero_reg__
 4424 15f2 00C0      		rjmp .L388
 4425               	.LVL380:
 4426               	.L405:
 651:main_sim900.h ****       ustaw_maksymalny_czas_dzwonienia = 0;
 4427               		.loc 2 651 0
 4428 15f4 8093 0000 		sts maksymalny_czas_dzwonienia,r24
 652:main_sim900.h ****     }
 4429               		.loc 2 652 0
 4430 15f8 1092 0000 		sts ustaw_maksymalny_czas_dzwonienia,__zero_reg__
 4431 15fc 00C0      		rjmp .L406
 4432               	.LVL381:
 4433               	.L403:
 660:main_sim900.h ****   if (ptr_dtmf != NULL) {
 4434               		.loc 2 660 0
 4435 15fe 80E0      		ldi r24,lo8(__c.3298)
 4436 1600 90E0      		ldi r25,hi8(__c.3298)
 4437 1602 0E94 0000 		call polozenie_polecenia_SIM900
 4438               	.LVL382:
 661:main_sim900.h ****     POMOC_DODAJ2('#', 'D');
 4439               		.loc 2 661 0
 4440 1606 0097      		sbiw r24,0
 4441 1608 01F0      		breq .L407
 4442               	.LVL383:
 4443               	.LBB516:
 663:main_sim900.h ****     while (*ptr_dtmf == ' ')
 4444               		.loc 2 663 0
 4445 160a FC01      		movw r30,r24
 4446 160c 3796      		adiw r30,7
 4447               	.LVL384:
 4448               	.L408:
 664:main_sim900.h ****       ++ptr_dtmf;
 4449               		.loc 2 664 0
 4450 160e 8191      		ld r24,Z+
 4451               	.LVL385:
 4452 1610 8032      		cpi r24,lo8(32)
 4453 1612 01F0      		breq .L408
 4454               	.LVL386:
 669:main_sim900.h ****     {
 4455               		.loc 2 669 0
 4456 1614 9091 0000 		lds r25,tryb_clip
 4457 1618 9111      		cpse r25,__zero_reg__
 4458 161a 00C0      		rjmp .L409
 671:main_sim900.h ****         stan_wyjscie[0] = TRUE;
 4459               		.loc 2 671 0
 4460 161c 8133      		cpi r24,lo8(49)
 4461 161e 01F4      		brne .L409
 672:main_sim900.h ****         licznik_przelacznik_wyjscia[0] = 2 * 10ul; // 2 sekundy retrigger
 4462               		.loc 2 672 0
 4463 1620 8FEF      		ldi r24,lo8(-1)
 4464               	.LVL387:
 4465 1622 8093 0000 		sts stan_wyjscie,r24
 4466               	.LVL388:
 673:main_sim900.h ****         zapal_diode_led(10);
 4467               		.loc 2 673 0
 4468 1626 84E1      		ldi r24,lo8(20)
 4469 1628 90E0      		ldi r25,0
 4470 162a A0E0      		ldi r26,0
 4471 162c B0E0      		ldi r27,0
 4472 162e 8093 0000 		sts licznik_przelacznik_wyjscia,r24
 4473 1632 9093 0000 		sts licznik_przelacznik_wyjscia+1,r25
 4474 1636 A093 0000 		sts licznik_przelacznik_wyjscia+2,r26
 4475 163a B093 0000 		sts licznik_przelacznik_wyjscia+3,r27
 674:main_sim900.h ****       }
 4476               		.loc 2 674 0
 4477 163e 8BE0      		ldi r24,lo8(11)
 4478 1640 8093 0000 		sts licznik_100ms_dioda_led,r24
 4479               	.L409:
 677:main_sim900.h ****     return;
 4480               		.loc 2 677 0
 4481 1644 1092 0000 		sts komenda_SIM900,__zero_reg__
 4482 1648 00C0      		rjmp .L388
 4483               	.LVL389:
 4484               	.L407:
 4485               	.LBE516:
 681:main_sim900.h ****     POMOC_DODAJ2('#', 'e');
 4486               		.loc 2 681 0
 4487 164a 8091 0000 		lds r24,komenda_SIM900
 4488               	.LVL390:
 4489 164e 8C30      		cpi r24,lo8(12)
 4490 1650 01F4      		brne .L410
 4491               	.LVL391:
 683:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 4492               		.loc 2 683 0
 4493 1652 8091 0000 		lds r24,tryb_clip
 4494 1656 8823      		tst r24
 4495 1658 01F4      		brne .+2
 4496 165a 00C0      		rjmp .L388
 684:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
 4497               		.loc 2 684 0
 4498 165c 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
 685:main_sim900.h ****     }
 4499               		.loc 2 685 0
 4500 1660 86E9      		ldi r24,lo8(-106)
 4501               	/* epilogue start */
 4502               	.LBE512:
 4503               	.LBE511:
 4504               		.loc 2 757 0
 4505 1662 DF91      		pop r29
 4506 1664 CF91      		pop r28
 4507 1666 1F91      		pop r17
 4508 1668 0F91      		pop r16
 4509               	.LBB522:
 4510               	.LBB520:
 685:main_sim900.h ****     }
 4511               		.loc 2 685 0
 4512 166a 0C94 0000 		jmp dodaj_komende
 4513               	.LVL392:
 4514               	.L410:
 689:main_sim900.h ****     POMOC_DODAJ2('#', 'f');
 4515               		.loc 2 689 0
 4516 166e 8091 0000 		lds r24,komenda_SIM900
 4517 1672 8930      		cpi r24,lo8(9)
 4518 1674 01F4      		brne .L411
 4519               	.L455:
 4520               	.LVL393:
 691:main_sim900.h ****       odpowiedz_na_polecenie();
 4521               		.loc 2 691 0
 4522 1676 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4523 167a 853D      		cpi r24,lo8(-43)
 4524 167c 01F4      		brne .L412
 692:main_sim900.h ****     zakonczono_rozmowe_telefoniczna(powod_zakonczenia_rozmowy_odrzucenie);
 4525               		.loc 2 692 0
 4526 167e 0E94 0000 		call odpowiedz_na_polecenie
 4527               	.LVL394:
 4528               	.L412:
 693:main_sim900.h ****     wykonywanie_rozmowy_telefonicznej = FALSE;
 4529               		.loc 2 693 0
 4530 1682 80E0      		ldi r24,0
 4531 1684 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 4532               	.LVL395:
 694:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 0;
 4533               		.loc 2 694 0
 4534 1688 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 4535 168c 00C0      		rjmp .L458
 4536               	.LVL396:
 4537               	.L411:
 699:main_sim900.h ****     POMOC_DODAJ2('#', 'g');
 4538               		.loc 2 699 0
 4539 168e 8091 0000 		lds r24,komenda_SIM900
 4540 1692 8730      		cpi r24,lo8(7)
 4541 1694 01F0      		breq .L455
 709:main_sim900.h ****     const uchar *ptr = strchr(polozenie_polecenia_SIM900(PSTR("+CMTI:")), ',');
 4542               		.loc 2 709 0
 4543 1696 8091 0000 		lds r24,komenda_SIM900
 4544 169a 8830      		cpi r24,lo8(8)
 4545 169c 01F4      		brne .L415
 4546               	.LBB517:
 710:main_sim900.h ****     if (ptr != NULL) {
 4547               		.loc 2 710 0
 4548 169e 80E0      		ldi r24,lo8(__c.3305)
 4549 16a0 90E0      		ldi r25,hi8(__c.3305)
 4550 16a2 0E94 0000 		call polozenie_polecenia_SIM900
 4551               	.LVL397:
 4552 16a6 6CE2      		ldi r22,lo8(44)
 4553 16a8 70E0      		ldi r23,0
 4554 16aa 0E94 0000 		call strchr
 4555               	.LVL398:
 711:main_sim900.h ****       uint numer_smsa = (uint)strtoul(ptr + 1, NULL, 10);
 4556               		.loc 2 711 0
 4557 16ae 0097      		sbiw r24,0
 4558 16b0 01F0      		breq .L417
 4559               	.LBB518:
 712:main_sim900.h ****       if (numer_smsa > 0 && numer_smsa <= 20) // Hardcoded 20
 4560               		.loc 2 712 0
 4561 16b2 4AE0      		ldi r20,lo8(10)
 4562 16b4 50E0      		ldi r21,0
 4563 16b6 70E0      		ldi r23,0
 4564 16b8 60E0      		ldi r22,0
 4565 16ba 0196      		adiw r24,1
 4566               	.LVL399:
 4567 16bc 0E94 0000 		call strtoul
 4568               	.LVL400:
 713:main_sim900.h ****       {
 4569               		.loc 2 713 0
 4570 16c0 9B01      		movw r18,r22
 4571 16c2 2150      		subi r18,1
 4572 16c4 3109      		sbc r19,__zero_reg__
 4573 16c6 2431      		cpi r18,20
 4574 16c8 3105      		cpc r19,__zero_reg__
 4575 16ca 00F4      		brsh .L417
 715:main_sim900.h ****         opoznienie_SIM900_100MS = 1; // 20 (1)
 4576               		.loc 2 715 0
 4577 16cc 88EA      		ldi r24,lo8(-88)
 4578 16ce 860F      		add r24,r22
 4579 16d0 0E94 0000 		call dodaj_komende
 4580               	.LVL401:
 716:main_sim900.h ****       }
 4581               		.loc 2 716 0
 4582 16d4 81E0      		ldi r24,lo8(1)
 4583               	.L456:
 4584 16d6 8093 0000 		sts opoznienie_SIM900_100MS,r24
 4585               	.L417:
 4586               	.LBE518:
 720:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 <=
 4587               		.loc 2 720 0
 4588 16da 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4589 16de 895A      		subi r24,lo8(-(87))
 719:main_sim900.h ****             KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
 4590               		.loc 2 719 0
 4591 16e0 8431      		cpi r24,lo8(20)
 4592 16e2 00F4      		brsh .+2
 4593 16e4 00C0      		rjmp .L457
 4594 16e6 00C0      		rjmp .L388
 4595               	.L415:
 4596               	.LBE517:
 729:main_sim900.h ****     opoznienie_SIM900_100MS = 20;
 4597               		.loc 2 729 0
 4598 16e8 8091 0000 		lds r24,komenda_SIM900
 4599 16ec 8E30      		cpi r24,lo8(14)
 4600 16ee 01F4      		brne .L419
 4601               	.LBB519:
 730:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 >=
 4602               		.loc 2 730 0
 4603 16f0 84E1      		ldi r24,lo8(20)
 4604 16f2 00C0      		rjmp .L456
 4605               	.L419:
 4606               	.LBE519:
 751:main_sim900.h ****     obsluga_wysylania_sms();
 4607               		.loc 2 751 0
 4608 16f4 8091 0000 		lds r24,flaga_wysylanie_smsa
 4609 16f8 8111      		cpse r24,__zero_reg__
 752:main_sim900.h **** 
 4610               		.loc 2 752 0
 4611 16fa 0E94 0000 		call obsluga_wysylania_sms
 4612               	.LVL402:
 4613               	.L421:
 754:main_sim900.h ****       komenda_SIM900 != BRAK_KOMENDY_SIM900)
 4614               		.loc 2 754 0
 4615 16fe 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 4616 1702 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
 4617 1706 892B      		or r24,r25
 4618 1708 01F4      		brne .+2
 4619 170a 00C0      		rjmp .L388
 755:main_sim900.h ****     odpowiedz_na_polecenie();
 4620               		.loc 2 755 0
 4621 170c 8091 0000 		lds r24,komenda_SIM900
 754:main_sim900.h ****       komenda_SIM900 != BRAK_KOMENDY_SIM900)
 4622               		.loc 2 754 0
 4623 1710 8823      		tst r24
 4624 1712 01F4      		brne .+2
 4625 1714 00C0      		rjmp .L388
 4626               	/* epilogue start */
 4627               	.LBE520:
 4628               	.LBE522:
 4629               		.loc 2 757 0
 4630 1716 DF91      		pop r29
 4631 1718 CF91      		pop r28
 4632 171a 1F91      		pop r17
 4633 171c 0F91      		pop r16
 4634               	.LBB523:
 4635               	.LBB521:
 756:main_sim900.h **** }
 4636               		.loc 2 756 0
 4637 171e 0C94 0000 		jmp odpowiedz_na_polecenie
 4638               	.LVL403:
 4639               	.LBE521:
 4640               	.LBE523:
 4641               		.cfi_endproc
 4642               	.LFE50:
 4644               	.global	wyslanie_polecenia_ROM
 4646               	wyslanie_polecenia_ROM:
 4647               	.LFB51:
 758:main_sim900.h **** 
 759:main_sim900.h **** uchar wyslanie_polecenia_ROM(const uchar czy_mozna_wysylac_dane_do_SIM900,
 760:main_sim900.h ****                              const komenda_typ wykonywana_komenda,
 761:main_sim900.h ****                              const komenda_typ nastepne_wysylane_polecenie,
 762:main_sim900.h ****                              PGM_P instrukcja) {
 4648               		.loc 2 762 0
 4649               		.cfi_startproc
 4650               	.LVL404:
 4651               	/* prologue: function */
 4652               	/* frame size = 0 */
 4653               	/* stack size = 0 */
 4654               	.L__stack_usage = 0
 763:main_sim900.h ****   if (!czy_mozna_wysylac_dane_do_SIM900) {
 4655               		.loc 2 763 0
 4656 1722 8111      		cpse r24,__zero_reg__
 4657 1724 00C0      		rjmp .L460
 764:main_sim900.h ****     dodaj_komende(wykonywana_komenda);
 4658               		.loc 2 764 0
 4659 1726 862F      		mov r24,r22
 4660               	.LVL405:
 4661 1728 0E94 0000 		call dodaj_komende
 4662               	.LVL406:
 765:main_sim900.h ****     return FALSE;
 4663               		.loc 2 765 0
 4664 172c 80E0      		ldi r24,0
 4665 172e 0895      		ret
 4666               	.LVL407:
 4667               	.L460:
 766:main_sim900.h ****   }
 767:main_sim900.h ****   wysylane_polecenie_SIM900 = wykonywana_komenda;
 4668               		.loc 2 767 0
 4669 1730 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 4670 1734 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 4671 1738 6093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r22
 768:main_sim900.h ****   nastepne_wysylane_polecenie_SIM900 = nastepne_wysylane_polecenie;
 4672               		.loc 2 768 0
 4673 173c 4093 0000 		sts nastepne_wysylane_polecenie_SIM900,r20
 769:main_sim900.h ****   wyslij_polecenie_ROM_SIM900(instrukcja);
 4674               		.loc 2 769 0
 4675 1740 C901      		movw r24,r18
 4676               	.LVL408:
 4677 1742 0E94 0000 		call wyslij_polecenie_ROM_SIM900
 4678               	.LVL409:
 770:main_sim900.h ****   return TRUE;
 4679               		.loc 2 770 0
 4680 1746 8FEF      		ldi r24,lo8(-1)
 4681               	/* epilogue start */
 771:main_sim900.h **** }
 4682               		.loc 2 771 0
 4683 1748 0895      		ret
 4684               		.cfi_endproc
 4685               	.LFE51:
 4687               	.global	wyslij_sms
 4689               	wyslij_sms:
 4690               	.LFB52:
 772:main_sim900.h **** 
 773:main_sim900.h **** #ifndef memcpy_E
 774:main_sim900.h **** #define memcpy_E(sink, source, l)                                              \
 775:main_sim900.h ****   eeprom_read_block((sink), (void *)(source), (l))
 776:main_sim900.h **** #endif
 777:main_sim900.h **** 
 778:main_sim900.h **** void wyslij_sms(const uchar wyslij_pdu) {
 4691               		.loc 2 778 0
 4692               		.cfi_startproc
 4693               	.LVL410:
 4694 174a 0F93      		push r16
 4695               	.LCFI65:
 4696               		.cfi_def_cfa_offset 3
 4697               		.cfi_offset 16, -2
 4698 174c CF93      		push r28
 4699               	.LCFI66:
 4700               		.cfi_def_cfa_offset 4
 4701               		.cfi_offset 28, -3
 4702 174e DF93      		push r29
 4703               	.LCFI67:
 4704               		.cfi_def_cfa_offset 5
 4705               		.cfi_offset 29, -4
 4706               	/* prologue: function */
 4707               	/* frame size = 0 */
 4708               	/* stack size = 3 */
 4709               	.L__stack_usage = 3
 779:main_sim900.h ****   czekanie_na_odebranie_zachety = TRUE;
 4710               		.loc 2 779 0
 4711 1750 9FEF      		ldi r25,lo8(-1)
 4712 1752 9093 0000 		sts czekanie_na_odebranie_zachety,r25
 780:main_sim900.h ****   flaga_odebrany_znak_zachety = FALSE;
 4713               		.loc 2 780 0
 4714 1756 1092 0000 		sts flaga_odebrany_znak_zachety,__zero_reg__
 781:main_sim900.h ****   if (!wyslij_pdu) {
 4715               		.loc 2 781 0
 4716 175a 8111      		cpse r24,__zero_reg__
 4717 175c 00C0      		rjmp .L463
 4718               	.LBB524:
 782:main_sim900.h ****     // Zmiana: 5 blyskow LED przy wysylaniu SMS
 783:main_sim900.h ****     zapal_diode_led_blyski(5);
 4719               		.loc 2 783 0
 4720 175e 85E0      		ldi r24,lo8(5)
 4721               	.LVL411:
 4722 1760 8093 0000 		sts liczba_blyskow_led,r24
 4723 1764 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 784:main_sim900.h ****     flaga_wysylanie_smsa = KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT;
 4724               		.loc 2 784 0
 4725 1768 82ED      		ldi r24,lo8(-46)
 4726 176a 8093 0000 		sts flaga_wysylanie_smsa,r24
 785:main_sim900.h ****     bufor_pdu[0] = 0xff; // memcpy_E(bufor_pdu, (void*)EEPROM_ADRES_CENTRUM_SMS,
 4727               		.loc 2 785 0
 4728 176e 9093 0000 		sts bufor_pdu,r25
 786:main_sim900.h ****                          // LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 787:main_sim900.h ****     konwertuj_blok_eeprom_na_telefon(
 4729               		.loc 2 787 0
 4730 1772 4AE0      		ldi r20,lo8(10)
 4731 1774 60E0      		ldi r22,lo8(bufor_eeprom)
 4732 1776 70E0      		ldi r23,hi8(bufor_eeprom)
 4733 1778 80E0      		ldi r24,lo8(bufor_pdu)
 4734 177a 90E0      		ldi r25,hi8(bufor_pdu)
 4735 177c 0E94 0000 		call konwertuj_blok_eeprom_na_telefon
 4736               	.LVL412:
 788:main_sim900.h ****         bufor_pdu, bufor_eeprom, 2 * LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 789:main_sim900.h ****     uchar *ptr = zapisz_naglowek_pdu(bufor_pdu, numer_telefonu_wysylanego_smsa,
 4737               		.loc 2 789 0
 4738 1780 00E0      		ldi r16,0
 4739 1782 20E0      		ldi r18,0
 4740 1784 40E0      		ldi r20,lo8(bufor_eeprom)
 4741 1786 50E0      		ldi r21,hi8(bufor_eeprom)
 4742 1788 60E0      		ldi r22,lo8(numer_telefonu_wysylanego_smsa)
 4743 178a 70E0      		ldi r23,hi8(numer_telefonu_wysylanego_smsa)
 4744 178c 80E0      		ldi r24,lo8(bufor_pdu)
 4745 178e 90E0      		ldi r25,hi8(bufor_pdu)
 4746 1790 0E94 0000 		call zapisz_naglowek_pdu
 4747               	.LVL413:
 790:main_sim900.h ****                                      bufor_eeprom, 0x00, 0x00);
 791:main_sim900.h ****     dlugosc_pdu = ascii_to_pdu(ptr, tekst_wysylanego_smsa) - bufor_pdu;
 4748               		.loc 2 791 0
 4749 1794 40E0      		ldi r20,lo8(tekst_wysylanego_smsa)
 4750 1796 50E0      		ldi r21,hi8(tekst_wysylanego_smsa)
 4751 1798 FA01      		movw r30,r20
 4752               		0:
 4753 179a 0190      		ld __tmp_reg__,Z+
 4754 179c 0020      		tst __tmp_reg__
 4755 179e 01F4      		brne 0b
 4756 17a0 AF01      		movw r20,r30
 4757 17a2 4150      		subi r20,1
 4758 17a4 5109      		sbc r21,__zero_reg__
 4759 17a6 60E0      		ldi r22,lo8(tekst_wysylanego_smsa)
 4760 17a8 70E0      		ldi r23,hi8(tekst_wysylanego_smsa)
 4761 17aa 0E94 0000 		call ascii_to_pdu_blok
 4762               	.LVL414:
 4763               	.L465:
 4764               	.LBE524:
 4765               	.LBB525:
 792:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 793:main_sim900.h ****     uchar l = strlen(numer_telefonu_wysylanego_smsa);
 794:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
 795:main_sim900.h ****       POMOC_DODAJ(numer_telefonu_wysylanego_smsa[i]);
 796:main_sim900.h ****     POMOC_DODAJ(' ');
 797:main_sim900.h ****     l = strlen(tekst_wysylanego_smsa);
 798:main_sim900.h ****     if (l > 20)
 799:main_sim900.h ****       l = 20;
 800:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
 801:main_sim900.h ****       POMOC_DODAJ(tekst_wysylanego_smsa[i]);
 802:main_sim900.h **** #endif
 803:main_sim900.h ****   } else {
 804:main_sim900.h ****     // Zmiana: 5 blyskow LED przy wysylaniu PDU
 805:main_sim900.h ****     zapal_diode_led_blyski(5);
 806:main_sim900.h ****     flaga_wysylanie_smsa = KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU;
 807:main_sim900.h ****     const uchar TP_DCS = tekst_wysylanego_smsa[0]; // message class
 808:main_sim900.h ****     bufor_pdu[0] = 0xff; // memcpy_E(bufor_pdu, (void*)EEPROM_ADRES_CENTRUM_SMS,
 809:main_sim900.h ****                          // LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 810:main_sim900.h ****     konwertuj_blok_eeprom_na_telefon(
 811:main_sim900.h ****         bufor_pdu, bufor_eeprom, 2 * LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 812:main_sim900.h ****     uchar *ptr = zapisz_naglowek_pdu(bufor_pdu, numer_telefonu_wysylanego_smsa,
 813:main_sim900.h ****                                      bufor_eeprom, 0x00, TP_DCS);
 814:main_sim900.h ****     memcpy(ptr, &tekst_wysylanego_smsa[2], tekst_wysylanego_smsa[1]);
 815:main_sim900.h ****     dlugosc_pdu = (ptr + tekst_wysylanego_smsa[1]) - bufor_pdu;
 4766               		.loc 2 815 0
 4767 17ae 8050      		subi r24,lo8(bufor_pdu)
 4768 17b0 9040      		sbci r25,hi8(bufor_pdu)
 4769 17b2 8093 0000 		sts dlugosc_pdu,r24
 4770               	.LBE525:
 816:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 817:main_sim900.h ****     uchar l = strlen(numer_telefonu_wysylanego_smsa);
 818:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
 819:main_sim900.h ****       POMOC_DODAJ(numer_telefonu_wysylanego_smsa[i]);
 820:main_sim900.h ****     POMOC_DODAJ(' ');
 821:main_sim900.h ****     POMOC_DODAJ('P');
 822:main_sim900.h ****     POMOC_DODAJ('D');
 823:main_sim900.h ****     POMOC_DODAJ('U');
 824:main_sim900.h **** #endif
 825:main_sim900.h ****   }
 826:main_sim900.h ****   const uchar oktety = dlugosc_pdu - 1 - bufor_pdu[0];
 4771               		.loc 2 826 0
 4772 17b6 C091 0000 		lds r28,dlugosc_pdu
 4773 17ba C150      		subi r28,lo8(-(-1))
 4774 17bc 8091 0000 		lds r24,bufor_pdu
 4775 17c0 C81B      		sub r28,r24
 4776               	.LVL415:
 827:main_sim900.h ****   static const char instrukcja_wyslij_smsa[] PROGMEM = "+cmgs=";
 828:main_sim900.h ****   memcpy_R(wysylane_dane_RAM_SIM900, instrukcja_wyslij_smsa);
 4777               		.loc 2 828 0
 4778 17c2 46E0      		ldi r20,lo8(6)
 4779 17c4 50E0      		ldi r21,0
 4780 17c6 60E0      		ldi r22,lo8(instrukcja_wyslij_smsa.3325)
 4781 17c8 70E0      		ldi r23,hi8(instrukcja_wyslij_smsa.3325)
 4782 17ca 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 4783 17cc 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 4784 17ce 0E94 0000 		call memcpy_P
 4785               	.LVL416:
 4786               	.LBB526:
 4787               	.LBB527:
 4788               		.loc 6 527 0
 4789 17d2 4AE0      		ldi r20,lo8(10)
 4790 17d4 60E0      		ldi r22,lo8(wysylany_blok_SIM900+8)
 4791 17d6 70E0      		ldi r23,hi8(wysylany_blok_SIM900+8)
 4792               	.LVL417:
 4793 17d8 8C2F      		mov r24,r28
 4794 17da 90E0      		ldi r25,0
 4795 17dc 0E94 0000 		call __utoa_ncheck
 4796               	.LVL418:
 4797               	.LBE527:
 4798               	.LBE526:
 829:main_sim900.h ****   utoa(oktety, wysylane_dane_RAM_SIM900 + strlen_R(instrukcja_wyslij_smsa), 10);
 830:main_sim900.h ****   max_oczekiwanie_na_odpowiedz = 250;
 4799               		.loc 2 830 0
 4800 17e0 8AEF      		ldi r24,lo8(-6)
 4801 17e2 8093 0000 		sts max_oczekiwanie_na_odpowiedz,r24
 4802               	/* epilogue start */
 831:main_sim900.h ****   wyslij_polecenie_RAM_SIM900();
 832:main_sim900.h ****   POMOC_DODAJ2('#', 'S');
 833:main_sim900.h **** }
 4803               		.loc 2 833 0
 4804 17e6 DF91      		pop r29
 4805 17e8 CF91      		pop r28
 4806               	.LVL419:
 4807 17ea 0F91      		pop r16
 831:main_sim900.h ****   wyslij_polecenie_RAM_SIM900();
 4808               		.loc 2 831 0
 4809 17ec 0C94 0000 		jmp wyslij_polecenie_RAM_SIM900
 4810               	.LVL420:
 4811               	.L463:
 4812               	.LBB528:
 805:main_sim900.h ****     flaga_wysylanie_smsa = KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU;
 4813               		.loc 2 805 0
 4814 17f0 85E0      		ldi r24,lo8(5)
 4815               	.LVL421:
 4816 17f2 8093 0000 		sts liczba_blyskow_led,r24
 4817 17f6 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
 806:main_sim900.h ****     const uchar TP_DCS = tekst_wysylanego_smsa[0]; // message class
 4818               		.loc 2 806 0
 4819 17fa 83ED      		ldi r24,lo8(-45)
 4820 17fc 8093 0000 		sts flaga_wysylanie_smsa,r24
 807:main_sim900.h ****     bufor_pdu[0] = 0xff; // memcpy_E(bufor_pdu, (void*)EEPROM_ADRES_CENTRUM_SMS,
 4821               		.loc 2 807 0
 4822 1800 0091 0000 		lds r16,tekst_wysylanego_smsa
 4823               	.LVL422:
 808:main_sim900.h ****                          // LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 4824               		.loc 2 808 0
 4825 1804 9093 0000 		sts bufor_pdu,r25
 810:main_sim900.h ****         bufor_pdu, bufor_eeprom, 2 * LICZBA_BAJTOW_NUMERU_TELEFONU_W_EEPROM);
 4826               		.loc 2 810 0
 4827 1808 4AE0      		ldi r20,lo8(10)
 4828 180a 60E0      		ldi r22,lo8(bufor_eeprom)
 4829 180c 70E0      		ldi r23,hi8(bufor_eeprom)
 4830 180e 80E0      		ldi r24,lo8(bufor_pdu)
 4831 1810 90E0      		ldi r25,hi8(bufor_pdu)
 4832 1812 0E94 0000 		call konwertuj_blok_eeprom_na_telefon
 4833               	.LVL423:
 812:main_sim900.h ****                                      bufor_eeprom, 0x00, TP_DCS);
 4834               		.loc 2 812 0
 4835 1816 20E0      		ldi r18,0
 4836 1818 40E0      		ldi r20,lo8(bufor_eeprom)
 4837 181a 50E0      		ldi r21,hi8(bufor_eeprom)
 4838 181c 60E0      		ldi r22,lo8(numer_telefonu_wysylanego_smsa)
 4839 181e 70E0      		ldi r23,hi8(numer_telefonu_wysylanego_smsa)
 4840 1820 80E0      		ldi r24,lo8(bufor_pdu)
 4841 1822 90E0      		ldi r25,hi8(bufor_pdu)
 4842 1824 0E94 0000 		call zapisz_naglowek_pdu
 4843               	.LVL424:
 4844 1828 EC01      		movw r28,r24
 4845               	.LVL425:
 814:main_sim900.h ****     dlugosc_pdu = (ptr + tekst_wysylanego_smsa[1]) - bufor_pdu;
 4846               		.loc 2 814 0
 4847 182a 4091 0000 		lds r20,tekst_wysylanego_smsa+1
 4848 182e 50E0      		ldi r21,0
 4849 1830 60E0      		ldi r22,lo8(tekst_wysylanego_smsa+2)
 4850 1832 70E0      		ldi r23,hi8(tekst_wysylanego_smsa+2)
 4851 1834 0E94 0000 		call memcpy
 4852               	.LVL426:
 815:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 4853               		.loc 2 815 0
 4854 1838 8091 0000 		lds r24,tekst_wysylanego_smsa+1
 4855 183c 8C0F      		add r24,r28
 4856 183e 9D2F      		mov r25,r29
 4857 1840 911D      		adc r25,__zero_reg__
 4858 1842 00C0      		rjmp .L465
 4859               	.LBE528:
 4860               		.cfi_endproc
 4861               	.LFE52:
 4863               	.global	wykonanie_komend_SIM900
 4865               	wykonanie_komend_SIM900:
 4866               	.LFB53:
 834:main_sim900.h **** 
 835:main_sim900.h **** uchar wykonanie_komend_SIM900(void) {
 4867               		.loc 2 835 0
 4868               		.cfi_startproc
 4869 1844 EF92      		push r14
 4870               	.LCFI68:
 4871               		.cfi_def_cfa_offset 3
 4872               		.cfi_offset 14, -2
 4873 1846 FF92      		push r15
 4874               	.LCFI69:
 4875               		.cfi_def_cfa_offset 4
 4876               		.cfi_offset 15, -3
 4877 1848 0F93      		push r16
 4878               	.LCFI70:
 4879               		.cfi_def_cfa_offset 5
 4880               		.cfi_offset 16, -4
 4881 184a 1F93      		push r17
 4882               	.LCFI71:
 4883               		.cfi_def_cfa_offset 6
 4884               		.cfi_offset 17, -5
 4885 184c CF93      		push r28
 4886               	.LCFI72:
 4887               		.cfi_def_cfa_offset 7
 4888               		.cfi_offset 28, -6
 4889 184e DF93      		push r29
 4890               	.LCFI73:
 4891               		.cfi_def_cfa_offset 8
 4892               		.cfi_offset 29, -7
 4893 1850 00D0      		rcall .
 4894 1852 1F92      		push __zero_reg__
 4895               	.LCFI74:
 4896               		.cfi_def_cfa_offset 11
 4897 1854 CDB7      		in r28,__SP_L__
 4898 1856 DEB7      		in r29,__SP_H__
 4899               	.LCFI75:
 4900               		.cfi_def_cfa_register 28
 4901               	/* prologue: function */
 4902               	/* frame size = 3 */
 4903               	/* stack size = 9 */
 4904               	.L__stack_usage = 9
 836:main_sim900.h ****   const uchar czy_gsm_zajety =
 837:main_sim900.h ****       flaga_odczytywanie_smsa || flaga_wysylanie_smsa ||
 4905               		.loc 2 837 0
 4906 1858 9091 0000 		lds r25,flaga_odczytywanie_smsa
 838:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej ||
 839:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika ||
 840:main_sim900.h ****       aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
 841:main_sim900.h ****       opoznienie_SIM900_100MS || czekanie_na_odebranie_zachety;
 4907               		.loc 2 841 0
 4908 185c 9111      		cpse r25,__zero_reg__
 4909 185e 00C0      		rjmp .L568
 837:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej ||
 4910               		.loc 2 837 0
 4911 1860 8091 0000 		lds r24,flaga_wysylanie_smsa
 4912 1864 8111      		cpse r24,__zero_reg__
 4913 1866 00C0      		rjmp .L568
 837:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej ||
 4914               		.loc 2 837 0 is_stmt 0 discriminator 1
 4915 1868 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 4916 186c 8111      		cpse r24,__zero_reg__
 4917 186e 00C0      		rjmp .L568
 838:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej ||
 4918               		.loc 2 838 0 is_stmt 1
 4919 1870 8091 0000 		lds r24,trwa_rozmowa_przychodzaca_od_uzytkownika
 4920 1874 8111      		cpse r24,__zero_reg__
 4921 1876 00C0      		rjmp .L568
 839:main_sim900.h ****       aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
 4922               		.loc 2 839 0
 4923 1878 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 4924 187c 8111      		cpse r24,__zero_reg__
 4925 187e 00C0      		rjmp .L568
 840:main_sim900.h ****       opoznienie_SIM900_100MS || czekanie_na_odebranie_zachety;
 4926               		.loc 2 840 0
 4927 1880 8091 0000 		lds r24,opoznienie_SIM900_100MS
 4928 1884 8111      		cpse r24,__zero_reg__
 4929 1886 00C0      		rjmp .L568
 4930               		.loc 2 841 0 discriminator 2
 4931 1888 2091 0000 		lds r18,czekanie_na_odebranie_zachety
 4932 188c 81E0      		ldi r24,lo8(1)
 4933 188e 2111      		cpse r18,__zero_reg__
 4934 1890 00C0      		rjmp .L468
 4935 1892 80E0      		ldi r24,0
 4936               	.L468:
 4937               	.LVL427:
 842:main_sim900.h **** 
 843:main_sim900.h ****   const uchar czy_mozna_wysylac_dane_do_SIM900 =
 844:main_sim900.h ****       !czy_gsm_zajety && CZY_MOZNA_WYSYLAC_DANE_SIM900() &&
 4938               		.loc 2 844 0 discriminator 2
 4939 1894 8111      		cpse r24,__zero_reg__
 4940 1896 00C0      		rjmp .L571
 4941               	.LVL428:
 4942               		.loc 2 844 0 is_stmt 0 discriminator 1
 4943 1898 2091 C100 		lds r18,193
 4944 189c 26FD      		sbrc r18,6
 4945 189e 00C0      		rjmp .L571
 4946               		.loc 2 844 0 discriminator 3
 4947 18a0 2091 0000 		lds r18,podlaczony_modul_gsm_SIM900
 4948 18a4 2223      		tst r18
 4949 18a6 01F0      		breq .L571
 845:main_sim900.h ****       czy_jest_bezczynny_SIM900();
 4950               		.loc 2 845 0 is_stmt 1 discriminator 5
 4951 18a8 2091 0000 		lds r18,komenda_SIM900
 844:main_sim900.h ****       czy_jest_bezczynny_SIM900();
 4952               		.loc 2 844 0 discriminator 5
 4953 18ac 01E0      		ldi r16,lo8(1)
 4954 18ae 2111      		cpse r18,__zero_reg__
 4955 18b0 00C0      		rjmp .L571
 4956               	.LVL429:
 4957               	.L469:
 846:main_sim900.h **** 
 847:main_sim900.h ****   const komenda_typ wykonywana_komenda = komendy_kolejka[0];
 4958               		.loc 2 847 0
 4959 18b2 1091 0000 		lds r17,komendy_kolejka
 4960               	.LVL430:
 848:main_sim900.h ****   switch (wykonywana_komenda) {
 4961               		.loc 2 848 0
 4962 18b6 E12E      		mov r14,r17
 4963 18b8 F12C      		mov r15,__zero_reg__
 4964 18ba 1C39      		cpi r17,lo8(-100)
 4965 18bc 01F4      		brne .+2
 4966 18be 00C0      		rjmp .L472
 4967 18c0 00F0      		brlo .+2
 4968 18c2 00C0      		rjmp .L473
 4969 18c4 1139      		cpi r17,lo8(-111)
 4970 18c6 01F4      		brne .+2
 4971 18c8 00C0      		rjmp .L474
 4972 18ca 00F4      		brsh .L475
 4973 18cc 1C38      		cpi r17,lo8(-116)
 4974 18ce 01F4      		brne .+2
 4975 18d0 00C0      		rjmp .L476
 4976 18d2 00F4      		brsh .L477
 4977 18d4 1A38      		cpi r17,lo8(-118)
 4978 18d6 01F4      		brne .+2
 4979 18d8 00C0      		rjmp .L478
 4980 18da 00F0      		brlo .+2
 4981 18dc 00C0      		rjmp .L479
 4982 18de 1938      		cpi r17,lo8(-119)
 4983 18e0 01F4      		brne .+2
 4984 18e2 00C0      		rjmp .L480
 4985               	.L471:
 849:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 850:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU: {
 851:main_sim900.h ****     POWTORZ_JESLI(flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS);
 852:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 853:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 854:main_sim900.h ****     wyslij_sms(wykonywana_komenda == KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
 855:main_sim900.h ****     break;
 856:main_sim900.h ****   }
 857:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_PDU: {
 858:main_sim900.h ****     czekanie_na_odebranie_zachety = FALSE;
 859:main_sim900.h ****     konwertuj_pdu_na_blok_wysylany(wysylany_blok_SIM900, bufor_pdu,
 860:main_sim900.h ****                                    dlugosc_pdu);
 861:main_sim900.h ****     const uint liczba_znakow = 2 * dlugosc_pdu + 1;
 862:main_sim900.h ****     wysylany_blok_SIM900[liczba_znakow - 1] = ZNAK_CTRL_Z;
 863:main_sim900.h ****     wyslij_znaki_SIM900(liczba_znakow);
 864:main_sim900.h ****     break;
 865:main_sim900.h ****   }
 866:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1:
 867:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_2:
 868:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_3:
 869:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_4:
 870:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_5:
 871:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_6:
 872:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_7:
 873:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_8:
 874:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_9:
 875:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_10:
 876:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_11:
 877:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_12:
 878:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_13:
 879:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_14:
 880:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_15:
 881:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_16:
 882:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_17:
 883:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_18:
 884:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_19:
 885:main_sim900.h ****   case KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20: {
 886:main_sim900.h ****     POWTORZ_JESLI(flaga_odczytywanie_smsa || !modul_zalogowany_w_sieci ||
 887:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 888:main_sim900.h ****                   wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK ||
 889:main_sim900.h ****                   flaga_wysylanie_smsa ||
 890:main_sim900.h ****                   aktualnie_wysylane_polecenie_SIM900 ==
 891:main_sim900.h ****                       KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY);
 892:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 893:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 894:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW,
 895:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW) ||
 896:main_sim900.h ****                   czy_sa_komendy_z_przedzialu(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT,
 897:main_sim900.h ****                                               KOMENDA_KOLEJKI_WYSLIJ_PDU) ||
 898:main_sim900.h ****                   czy_sa_komendy_z_przedzialu(
 899:main_sim900.h ****                       KOMENDA_KOLEJKI_ODBIERZ_ROZMOWE,
 900:main_sim900.h ****                       KOMENDA_KOLEJKI_SPRAWDZ_PRZYCHODZACA_ROZMOWE));
 901:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 902:main_sim900.h ****     flaga_odczytywanie_smsa = TRUE;
 903:main_sim900.h ****     static const char instrukcja_odczytaj_smsa[] PROGMEM = "+cmgr=";
 904:main_sim900.h ****     memcpy_R(wysylane_dane_RAM_SIM900, instrukcja_odczytaj_smsa);
 905:main_sim900.h ****     const uint nr_smsa =
 906:main_sim900.h ****         wykonywana_komenda - KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 + 1;
 907:main_sim900.h ****     utoa(nr_smsa, wysylane_dane_RAM_SIM900 + strlen_R(instrukcja_odczytaj_smsa),
 908:main_sim900.h ****          10);
 909:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 910:main_sim900.h ****     POMOC_DODAJ2('#', 'X');
 911:main_sim900.h ****     break;
 912:main_sim900.h ****   }
 913:main_sim900.h ****   case KOMENDA_KOLEJKI_INTERPRETUJ_PDU: {
 914:main_sim900.h ****     const uchar *ptr = pobierz_numer_telefonu_nadawcy_z_PDU(
 915:main_sim900.h ****         bufor_pdu, numer_telefonu_odebranego_smsa,
 916:main_sim900.h ****         &nie_wysylaj_echa_z_powodu_nietypowego_smsa);
 917:main_sim900.h ****     if (ptr == 0) // (1)
 918:main_sim900.h ****     {
 919:main_sim900.h ****       flaga_odczytywanie_smsa = FALSE;
 920:main_sim900.h ****       break;
 921:main_sim900.h ****     }
 922:main_sim900.h ****     {
 923:main_sim900.h ****       uchar rok, miesiac, dzien;
 924:main_sim900.h ****       ptr = pobierz_date_z_PDU(ptr, &rok, &miesiac, &dzien);
 925:main_sim900.h ****     }
 926:main_sim900.h ****     {
 927:main_sim900.h ****       uchar godzina, minuta;
 928:main_sim900.h ****       ptr = pobierz_czas_z_PDU(ptr, &godzina, &minuta);
 929:main_sim900.h ****     }
 930:main_sim900.h ****     ptr_start_pdu_z_wiadomoscia = (uchar *)ptr;
 931:main_sim900.h ****     pdu_to_ascii(ptr, tekst_odebranego_smsa, MAX_LICZBA_ZNAKOW_SMS + 1);
 932:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 933:main_sim900.h ****     const uchar l = min(strlen(tekst_odebranego_smsa), 20);
 934:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
 935:main_sim900.h ****       POMOC_DODAJ(tekst_odebranego_smsa[i]);
 936:main_sim900.h **** #endif
 937:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_INTERPRETUJ_ODEBRANEGO_SMSA);
 938:main_sim900.h ****     break;
 939:main_sim900.h ****   }
 940:main_sim900.h ****   case KOMENDA_KOLEJKI_INTERPRETUJ_ODEBRANEGO_SMSA: {
 941:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 942:main_sim900.h ****     zapal_diode_led(10);
 943:main_sim900.h ****     wykonanie_polecenia_sms();
 944:main_sim900.h ****     flaga_odczytywanie_smsa = FALSE;
 945:main_sim900.h ****     break;
 946:main_sim900.h ****   }
 947:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_1:
 948:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_2:
 949:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_3:
 950:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_4:
 951:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_5:
 952:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_6:
 953:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_7:
 954:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_8:
 955:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_9:
 956:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_10:
 957:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_11:
 958:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_12:
 959:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_13:
 960:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_14:
 961:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_15:
 962:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_16:
 963:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_17:
 964:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_18:
 965:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_19:
 966:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_SMSA_20: {
 967:main_sim900.h ****     POWTORZ_JESLI(flaga_odczytywanie_smsa || flaga_trwa_rozmowa_wychodzaca ||
 968:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 969:main_sim900.h ****                   czekanie_na_odebranie_zachety)
 970:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 971:main_sim900.h ****     static const char instrukcja_usun_smsa[] PROGMEM = "+cmgd=";
 972:main_sim900.h ****     memcpy_R(wysylane_dane_RAM_SIM900, instrukcja_usun_smsa);
 973:main_sim900.h ****     const uint nr_smsa = wykonywana_komenda - KOMENDA_KOLEJKI_USUN_SMSA_1 + 1;
 974:main_sim900.h ****     utoa(nr_smsa, wysylane_dane_RAM_SIM900 + strlen_R(instrukcja_usun_smsa),
 975:main_sim900.h ****          10);
 976:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 977:main_sim900.h ****     POMOC_DODAJ2('#', 'Y');
 978:main_sim900.h ****     break;
 979:main_sim900.h ****   }
 980:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_PRZYCHODZACA_ROZMOWE: {
 981:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 982:main_sim900.h ****     zapal_diode_led(10);
 983:main_sim900.h **** 
 984:main_sim900.h ****     uchar status_ok =
 985:main_sim900.h ****         sprawdz_przychodzaca_rozmowe(); // Returns TRUE if number authorized
 986:main_sim900.h **** 
 987:main_sim900.h ****     if (status_ok) {
 988:main_sim900.h ****       if (tryb_clip) {
 989:main_sim900.h ****         // Tryb CLIP: wlacz wyjscie i ODRZUC polaczenie
 990:main_sim900.h ****         if (polozenie_polecenia_SIM900(PSTR("+CMTI:")) == NULL) {
 991:main_sim900.h ****           ustaw_wyjscie_clip();
 992:main_sim900.h ****         }
 993:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
 994:main_sim900.h ****       } else {
 995:main_sim900.h ****         // Tryb DTMF: ODBIERZ polaczenie
 996:main_sim900.h ****         dodaj_komende(KOMENDA_KOLEJKI_ODBIERZ_ROZMOWE);
 997:main_sim900.h ****       }
 998:main_sim900.h ****     } else {
 999:main_sim900.h ****       // Status NIE OK - odrzuc
1000:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
1001:main_sim900.h ****     }
1002:main_sim900.h ****     blokada_clip = TRUE;
1003:main_sim900.h ****     break;
1004:main_sim900.h ****   }
1005:main_sim900.h ****   case KOMENDA_KOLEJKI_ODRZUC_ROZMOWE: {
1006:main_sim900.h ****     POWTORZ_JESLI(
1007:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
1008:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
1009:main_sim900.h ****         czekanie_na_odebranie_zachety || wykonywanie_rozmowy_telefonicznej ||
1010:main_sim900.h ****         !CZY_MOZNA_WYSYLAC_DANE_SIM900() || !czy_jest_bezczynny_SIM900());
1011:main_sim900.h ****     wysylane_polecenie_SIM900 = wykonywana_komenda;
1012:main_sim900.h ****     static const char instrukcja_odrzuc_rozmowe[] PROGMEM = "h";
1013:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_odrzuc_rozmowe);
1014:main_sim900.h ****     break;
1015:main_sim900.h ****   }
1016:main_sim900.h ****   case KOMENDA_KOLEJKI_ODBIERZ_ROZMOWE: {
1017:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1018:main_sim900.h ****     static const char instrukcja_odbierz_rozmowe[] PROGMEM = "a";
1019:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_odbierz_rozmowe);
1020:main_sim900.h ****     POMOC_DODAJ2('#', 'p');
1021:main_sim900.h ****     break;
1022:main_sim900.h ****   }
1023:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_TON_DTMF: {
1024:main_sim900.h ****     // Czekaj na koncowke inicjalizacji polaczenia/opoznienia?
1025:main_sim900.h ****     POWTORZ_JESLI(opoznienie_SIM900_100MS);
1026:main_sim900.h ****     if (!CZY_MOZNA_WYSYLAC_DANE_SIM900() || !czy_jest_bezczynny_SIM900() ||
1027:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
1028:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
1029:main_sim900.h ****       break;
1030:main_sim900.h ****     }
1031:main_sim900.h ****     wysylane_polecenie_SIM900 = wykonywana_komenda;
1032:main_sim900.h ****     static const char instrukcja_vts[] PROGMEM = "+vts=1";
1033:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_vts);
1034:main_sim900.h ****     POMOC_DODAJ2('#', 'V');
1035:main_sim900.h ****     break;
1036:main_sim900.h ****   }
1037:main_sim900.h ****   case KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE: {
1038:main_sim900.h ****     POWTORZ_JESLI(!modul_zalogowany_w_sieci || opoznienie_SIM900_100MS);
1039:main_sim900.h ****     if (wykonywanie_rozmowy_telefonicznej)
1040:main_sim900.h ****       break;
1041:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1042:main_sim900.h ****     zapal_diode_led(20);
1043:main_sim900.h ****     wysylane_dane_RAM_SIM900[0] = 'd';
1044:main_sim900.h ****     // static const char doladowanie[] PROGMEM = "*100*59484869838559#";
1045:main_sim900.h ****     // strcpy_P(numer_telefonu_do_ktorego_dzwonic, doladowanie);
1046:main_sim900.h ****     strcpy(wysylane_dane_RAM_SIM900 + 1, numer_telefonu_do_ktorego_dzwonic);
1047:main_sim900.h ****     uchar l = strlen(numer_telefonu_do_ktorego_dzwonic) + 1;
1048:main_sim900.h ****     wysylane_dane_RAM_SIM900[l] = ';';
1049:main_sim900.h ****     wysylane_dane_RAM_SIM900[l + 1] = '\0';
1050:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
1051:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 300;
1052:main_sim900.h ****     POMOC_DODAJ2('#', 'h');
1053:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
1054:main_sim900.h ****     for (uchar i = 0; i < l; ++i)
1055:main_sim900.h ****       POMOC_DODAJ(numer_telefonu_do_ktorego_dzwonic[i]);
1056:main_sim900.h **** #endif
1057:main_sim900.h ****     break;
1058:main_sim900.h ****   }
1059:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_POZIOM_SIECI: {
1060:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1061:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1062:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1063:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1064:main_sim900.h ****       if (poziom_sieci_gsm == POZIOM_SIECI_BLAD ||
1065:main_sim900.h ****           poziom_sieci_gsm == 0) // poziom sieci bez zmian
1066:main_sim900.h ****         poziom_sieci_gsm = 16;
1067:main_sim900.h ****       break;
1068:main_sim900.h ****     }
1069:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1070:main_sim900.h ****     static const char instrukcja_poziom_sieci[] PROGMEM = "+csq";
1071:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_poziom_sieci);
1072:main_sim900.h ****     break;
1073:main_sim900.h ****   }
1074:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_ZAREJESTROWANIE: {
1075:main_sim900.h ****     // Usunięto warunek !modul_zalogowany_w_sieci - musimy sprawdzać ZAWSZE!
1076:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1077:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1078:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1079:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1080:main_sim900.h ****       break;
1081:main_sim900.h ****     }
1082:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1083:main_sim900.h ****     static const char instrukcja_creg[] PROGMEM = "+creg?";
1084:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_creg);
1085:main_sim900.h ****     break;
1086:main_sim900.h ****   }
1087:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_STAN_KARTY_SIM: {
1088:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1089:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1090:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1091:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1092:main_sim900.h ****       licznik_blad_stanu_karty_SIM = 0;
1093:main_sim900.h ****       break;
1094:main_sim900.h ****     }
1095:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1096:main_sim900.h ****     static const char instrukcja_odczyt_ksiazki[] PROGMEM = "+cpbr=26";
1097:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_odczyt_ksiazki);
1098:main_sim900.h ****     break;
1099:main_sim900.h ****   }
1100:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_ZALOGOWANIE_U_OPERATORA: {
1101:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1102:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1103:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1104:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
1105:main_sim900.h ****       licznik_blad_zalogowania_u_operatora = 0;
1106:main_sim900.h ****       break;
1107:main_sim900.h ****     }
1108:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1109:main_sim900.h ****     static const char instrukcja_sprawdz_operatora[] PROGMEM = "+cops?";
1110:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_sprawdz_operatora);
1111:main_sim900.h ****     break;
1112:main_sim900.h ****   }
1113:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE: {
1114:main_sim900.h ****     if (flaga_trwa_rozmowa_wychodzaca ||
1115:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
1116:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
1117:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK)
1118:main_sim900.h ****       break;
1119:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1120:main_sim900.h ****     static const char instrukcja_cclk[] PROGMEM = "+cclk?";
1121:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_cclk);
1122:main_sim900.h ****     break;
1123:main_sim900.h ****   }
1124:main_sim900.h ****   case KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS: {
1125:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1126:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM = "+cdscb";
1127:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_ustawienie_pamieci);
1128:main_sim900.h ****     break;
1129:main_sim900.h ****   }
1130:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW: {
1131:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1132:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM =
1133:main_sim900.h ****         "+cpms=\"SM\",\"SM\",\"SM\"";
1134:main_sim900.h ****     nastepne_wysylane_polecenie_SIM900 =
1135:main_sim900.h ****         KOMENDA_KOLEJKI_WSTAWIENIE_MORING_GDY_DZWONI;
1136:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_ustawienie_pamieci);
1137:main_sim900.h ****     break;
1138:main_sim900.h ****   }
1139:main_sim900.h ****   case KOMENDA_KOLEJKI_PODLACZONY_MODUL_GSM: {
1140:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT);
1141:main_sim900.h ****     opoznienie_zatrzymaj_odpytywanie_urzadzenia = 20;
1142:main_sim900.h ****     ustaw_odbior_SIM900();
1143:main_sim900.h ****     break;
1144:main_sim900.h ****   }
1145:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT: { // po wczeniu zasilania wysya 2
1146:main_sim900.h ****                                               // razy, bo za pierwszym razem nie
1147:main_sim900.h ****                                               // dziaa kontrola RTS / CTS w
1148:main_sim900.h ****                                               // SIM800
1149:main_sim900.h ****     if (max_oczekiwanie_na_odpowiedz_at)
1150:main_sim900.h ****       break;
1151:main_sim900.h ****     if (opoznienie_zatrzymaj_odpytywanie_urzadzenia) {
1152:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
1153:main_sim900.h ****       break;
1154:main_sim900.h ****     }
1155:main_sim900.h ****     if (CZY_WYSYLANIE_DANYCH_SIM900()) {
1156:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
1157:main_sim900.h ****       break;
1158:main_sim900.h ****     }
1159:main_sim900.h ****     ustaw_odbior_SIM900();
1160:main_sim900.h ****     wysylane_polecenie_SIM900 = wykonywana_komenda;
1161:main_sim900.h ****     max_oczekiwanie_na_odpowiedz_at = 20;
1162:main_sim900.h ****     static const char instrukcja_at[] PROGMEM = "+ifc=2,2";
1163:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_at);
1164:main_sim900.h ****     break;
1165:main_sim900.h ****   }
1166:main_sim900.h ****   case KOMENDA_KOLEJKI_ODEBRANO_POLECENIE_ROZPOCZYNAJACE: {
1167:main_sim900.h ****     podlaczony_modul_gsm_SIM900 = TRUE;
1168:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_PIN);
1169:main_sim900.h ****     opoznienie_SIM900_100MS = 40;
1170:main_sim900.h ****     break;
1171:main_sim900.h ****   }
1172:main_sim900.h ****   case KOMENDA_KOLEJKI_PODAJ_PIN: {
1173:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1174:main_sim900.h ****     static const char instrukcja_podaj_pin[] PROGMEM = "+cpin=\"1976\"";
1175:main_sim900.h ****     strcpy_P(wysylane_dane_RAM_SIM900, instrukcja_podaj_pin);
1176:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
1177:main_sim900.h ****     break;
1178:main_sim900.h ****   }
1179:main_sim900.h ****   case KOMENDA_KOLEJKI_USUN_WSZYSTKIE_SMSY: {
1180:main_sim900.h ****     static uchar drugi_raz = FALSE;
1181:main_sim900.h ****     if (drugi_raz) {
1182:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW);
1183:main_sim900.h ****       break;
1184:main_sim900.h ****     }
1185:main_sim900.h ****     drugi_raz = TRUE;
1186:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1187:main_sim900.h ****     static const char instrukcja_usun_wszystkie_smsy[] PROGMEM = "+cmgda=6";
1188:main_sim900.h ****     wyslij_polecenie_ROM_SIM900(instrukcja_usun_wszystkie_smsy);
1189:main_sim900.h ****     break;
1190:main_sim900.h ****   }
1191:main_sim900.h ****   case KOMENDA_KOLEJKI_KOMENDA_SIM900: {
1192:main_sim900.h ****     obsluga_komendy_SIM900();
1193:main_sim900.h ****     if (komenda_SIM900 != KOMENDA_SIM900_WYSLANE_POLECENIE)
1194:main_sim900.h ****       max_oczekiwanie_na_odpowiedz = 20;
1195:main_sim900.h ****     resetuj_komende_SIM900();
1196:main_sim900.h ****     break;
1197:main_sim900.h ****   }
1198:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_WZMOCNIENIE_MIKROFONU: {
1199:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1200:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1201:main_sim900.h ****     static const char instrukcja[] PROGMEM =
1202:main_sim900.h ****         "+cmic=0,15"; // ustawienie od 0 ... 15
1203:main_sim900.h ****     strcpy_P(wysylane_dane_RAM_SIM900, instrukcja);
1204:main_sim900.h ****     nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_ROZPOCZNIJ_PRACE;
1205:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
1206:main_sim900.h ****     break;
1207:main_sim900.h ****   }
1208:main_sim900.h ****   case KOMENDA_KOLEJKI_ROZPOCZNIJ_PRACE: {
1209:main_sim900.h ****     POMOC_DODAJ2('*', 'h');
1210:main_sim900.h ****     if (podlaczona_karta_SIM_SIM900) {
1211:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS);
1212:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_MODUL_ZALOGOWANY);
1213:main_sim900.h ****     }
1214:main_sim900.h ****     break;
1215:main_sim900.h ****   }
1216:main_sim900.h ****   case KOMENDA_KOLEJKI_MODUL_ZALOGOWANY: {
1217:main_sim900.h ****     // Nie ustawiamy modul_zalogowany_w_sieci tutaj!
1218:main_sim900.h ****     // Flaga jest ustawiana tylko przez +CREG gdy faktycznie zalogowany
1219:main_sim900.h ****     break;
1220:main_sim900.h ****   }
1221:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_ZEGAR_SIM900: {
1222:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
1223:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
1224:main_sim900.h ****     strcpy(wysylane_dane_RAM_SIM900, bufor_ustaw_czas);
1225:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
1226:main_sim900.h ****     break;
1227:main_sim900.h ****   }
1228:main_sim900.h ****   case KOMENDA_KOLEJKI_SPRAWDZ_PIN:
1229:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW:
1230:main_sim900.h ****   case KOMENDA_KOLEJKI_WSTAWIENIE_MORING_GDY_DZWONI:
1231:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_WYSYLANIE_INFO_O_DZWONIACYM:
1232:main_sim900.h ****   case KOMENDA_KOLEJKI_WLACZ_DETEKCJE_DTMF:
1233:main_sim900.h ****   case KOMENDA_KOLEJKI_USTAW_CICHY_TRYB:
1234:main_sim900.h ****   case KOMENDA_KOLEJKI_WYCISZ_DZWONKI:
1235:main_sim900.h ****   case KOMENDA_KOLEJKI_ODBIERAJ_SMS_FLASH:
1236:main_sim900.h ****   case KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ:
1237:main_sim900.h ****   case KOMENDA_KOLEJKI_WLACZ_CZAS_Z_SIECI: {
1238:main_sim900.h **** 
1239:main_sim900.h **** #define MAX_ROZMIAR_POLECENIA_GSM 14
1240:main_sim900.h **** 
1241:main_sim900.h ****     static const char instrukcje[10][MAX_ROZMIAR_POLECENIA_GSM] PROGMEM = {
1242:main_sim900.h ****         "+cpin?",         "+cnmi=2,1,2,1", "+moring=1", "+clip=1",
1243:main_sim900.h ****         "+ddet=1,10,1",   "+calm=1",       "+crsl=1",   "+cusd=1",
1244:main_sim900.h ****         "+cpbw=26,\"1\"", "+clts=1",
1245:main_sim900.h ****     };
1246:main_sim900.h ****     static const komenda_typ nastepna_komenda[10] PROGMEM = {
1247:main_sim900.h ****         KOMENDA_KOLEJKI_BRAK_KOMENDY,
1248:main_sim900.h ****         KOMENDA_KOLEJKI_BRAK_KOMENDY,
1249:main_sim900.h ****         KOMENDA_KOLEJKI_USTAW_WYSYLANIE_INFO_O_DZWONIACYM,
1250:main_sim900.h ****         KOMENDA_KOLEJKI_WLACZ_DETEKCJE_DTMF,
1251:main_sim900.h ****         KOMENDA_KOLEJKI_USTAW_CICHY_TRYB,
1252:main_sim900.h ****         KOMENDA_KOLEJKI_WYCISZ_DZWONKI,
1253:main_sim900.h ****         KOMENDA_KOLEJKI_ODBIERAJ_SMS_FLASH,
1254:main_sim900.h ****         KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ,
1255:main_sim900.h ****         KOMENDA_KOLEJKI_WLACZ_CZAS_Z_SIECI,
1256:main_sim900.h ****         KOMENDA_KOLEJKI_USTAW_WZMOCNIENIE_MIKROFONU,
1257:main_sim900.h ****     };
1258:main_sim900.h ****     // RE-DOING THIS CHUNK TO BE SAFE AND CORRECT
1259:main_sim900.h **** 
1260:main_sim900.h ****     const uchar nr = wykonywana_komenda - KOMENDA_KOLEJKI_SPRAWDZ_PIN;
1261:main_sim900.h ****     if (!wyslanie_polecenia_ROM(
1262:main_sim900.h ****             czy_mozna_wysylac_dane_do_SIM900, wykonywana_komenda,
1263:main_sim900.h ****             pgm_read_word(&nastepna_komenda[nr]), &instrukcje[nr][0]))
1264:main_sim900.h ****       break;
1265:main_sim900.h ****     POMOC_DODAJ2('*', 's');
1266:main_sim900.h ****     POMOC_DODAJ_HEX(nr);
1267:main_sim900.h ****     break;
1268:main_sim900.h ****   }
1269:main_sim900.h ****   default:
1270:main_sim900.h ****     return FALSE;
 4986               		.loc 2 1270 0
 4987 18e4 80E0      		ldi r24,0
 4988               	.LVL431:
 4989               	.L466:
 4990               	/* epilogue start */
1271:main_sim900.h ****   }
1272:main_sim900.h ****   return TRUE;
1273:main_sim900.h **** }
 4991               		.loc 2 1273 0
 4992 18e6 0F90      		pop __tmp_reg__
 4993 18e8 0F90      		pop __tmp_reg__
 4994 18ea 0F90      		pop __tmp_reg__
 4995 18ec DF91      		pop r29
 4996 18ee CF91      		pop r28
 4997 18f0 1F91      		pop r17
 4998 18f2 0F91      		pop r16
 4999               	.LVL432:
 5000 18f4 FF90      		pop r15
 5001 18f6 EF90      		pop r14
 5002               	.LVL433:
 5003 18f8 0895      		ret
 5004               	.L568:
 841:main_sim900.h **** 
 5005               		.loc 2 841 0
 5006 18fa 81E0      		ldi r24,lo8(1)
 5007               	.L571:
 844:main_sim900.h ****       czy_jest_bezczynny_SIM900();
 5008               		.loc 2 844 0
 5009 18fc 00E0      		ldi r16,0
 5010 18fe 00C0      		rjmp .L469
 5011               	.LVL434:
 5012               	.L477:
 848:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5013               		.loc 2 848 0
 5014 1900 1E38      		cpi r17,lo8(-114)
 5015 1902 01F4      		brne .+2
 5016 1904 00C0      		rjmp .L481
 5017 1906 00F4      		brsh .+2
 5018 1908 00C0      		rjmp .L482
 5019 190a 1F38      		cpi r17,lo8(-113)
 5020 190c 01F4      		brne .+2
 5021 190e 00C0      		rjmp .L483
 5022 1910 1039      		cpi r17,lo8(-112)
 5023 1912 01F4      		brne .L471
 5024               	.L588:
1272:main_sim900.h **** }
 5025               		.loc 2 1272 0
 5026 1914 8FEF      		ldi r24,lo8(-1)
 5027 1916 00C0      		rjmp .L466
 5028               	.L475:
 848:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5029               		.loc 2 848 0
 5030 1918 1639      		cpi r17,lo8(-106)
 5031 191a 01F4      		brne .+2
 5032 191c 00C0      		rjmp .L485
 5033 191e 00F4      		brsh .L486
 5034 1920 1439      		cpi r17,lo8(-108)
 5035 1922 01F4      		brne .+2
 5036 1924 00C0      		rjmp .L487
 5037 1926 00F0      		brlo .+2
 5038 1928 00C0      		rjmp .L488
 5039 192a 1339      		cpi r17,lo8(-109)
 5040 192c 01F4      		brne .L471
 5041               	.LBB529:
1199:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5042               		.loc 2 1199 0
 5043 192e 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5044 1932 8111      		cpse r24,__zero_reg__
 5045 1934 00C0      		rjmp .L559
1199:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5046               		.loc 2 1199 0 is_stmt 0 discriminator 2
 5047 1936 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5048 193a 8111      		cpse r24,__zero_reg__
 5049 193c 00C0      		rjmp .L559
1199:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5050               		.loc 2 1199 0 discriminator 4
 5051 193e 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5052 1942 8111      		cpse r24,__zero_reg__
 5053 1944 00C0      		rjmp .L559
1199:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5054               		.loc 2 1199 0 discriminator 6
 5055 1946 F99B      		sbis 0x1f,1
 5056 1948 00C0      		rjmp .L560
 5057               	.L559:
1199:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5058               		.loc 2 1199 0 discriminator 7
 5059 194a 83E9      		ldi r24,lo8(-109)
 5060 194c 00C0      		rjmp .L629
 5061               	.L486:
 5062               	.LBE529:
 848:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5063               		.loc 2 848 0 is_stmt 1
 5064 194e 1839      		cpi r17,lo8(-104)
 5065 1950 01F4      		brne .+2
 5066 1952 00C0      		rjmp .L490
 5067 1954 00F4      		brsh .+2
 5068 1956 00C0      		rjmp .L491
 5069 1958 1939      		cpi r17,lo8(-103)
 5070 195a 01F4      		brne .+2
 5071 195c 00C0      		rjmp .L492
 5072 195e 1A39      		cpi r17,lo8(-102)
 5073 1960 01F4      		brne .L471
 5074               	.LBB530:
1060:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5075               		.loc 2 1060 0
 5076 1962 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 5077 1966 9111      		cpse r25,__zero_reg__
 5078 1968 00C0      		rjmp .L539
1060:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5079               		.loc 2 1060 0 is_stmt 0 discriminator 1
 5080 196a 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 5081 196e 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5082 1972 232B      		or r18,r19
 5083 1974 01F4      		brne .L539
1060:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5084               		.loc 2 1060 0 discriminator 2
 5085 1976 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 5086 197a 9111      		cpse r25,__zero_reg__
 5087 197c 00C0      		rjmp .L539
1061:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 5088               		.loc 2 1061 0 is_stmt 1
 5089 197e 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 5090 1982 9111      		cpse r25,__zero_reg__
 5091 1984 00C0      		rjmp .L539
1062:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 5092               		.loc 2 1062 0
 5093 1986 8111      		cpse r24,__zero_reg__
 5094 1988 00C0      		rjmp .L539
1062:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 5095               		.loc 2 1062 0 is_stmt 0 discriminator 1
 5096 198a 8091 0000 		lds r24,wysylanie_smsa_clipa
 5097 198e 8823      		tst r24
 5098 1990 01F4      		brne .+2
 5099 1992 00C0      		rjmp .L540
 5100               	.L539:
1064:main_sim900.h ****           poziom_sieci_gsm == 0) // poziom sieci bez zmian
 5101               		.loc 2 1064 0 is_stmt 1
 5102 1994 8091 0000 		lds r24,poziom_sieci_gsm
 5103 1998 8336      		cpi r24,lo8(99)
 5104 199a 01F0      		breq .L541
1064:main_sim900.h ****           poziom_sieci_gsm == 0) // poziom sieci bez zmian
 5105               		.loc 2 1064 0 is_stmt 0 discriminator 1
 5106 199c 8111      		cpse r24,__zero_reg__
 5107 199e 00C0      		rjmp .L588
 5108               	.L541:
1066:main_sim900.h ****       break;
 5109               		.loc 2 1066 0 is_stmt 1
 5110 19a0 80E1      		ldi r24,lo8(16)
 5111 19a2 8093 0000 		sts poziom_sieci_gsm,r24
 5112 19a6 00C0      		rjmp .L588
 5113               	.L473:
 5114               	.LBE530:
 848:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5115               		.loc 2 848 0
 5116 19a8 113D      		cpi r17,lo8(-47)
 5117 19aa 00F0      		brlo .+2
 5118 19ac 00C0      		rjmp .L494
 5119 19ae 1D3B      		cpi r17,lo8(-67)
 5120 19b0 00F0      		brlo .+2
 5121 19b2 00C0      		rjmp .L495
 5122 19b4 143A      		cpi r17,lo8(-92)
 5123 19b6 01F4      		brne .+2
 5124 19b8 00C0      		rjmp .L496
 5125 19ba 00F4      		brsh .L497
 5126 19bc 1D39      		cpi r17,lo8(-99)
 5127 19be 01F4      		brne .+2
 5128 19c0 00C0      		rjmp .L498
 5129               	.L499:
 5130               	.LBB531:
1260:main_sim900.h ****     if (!wyslanie_polecenia_ROM(
 5131               		.loc 2 1260 0
 5132 19c2 22E6      		ldi r18,lo8(98)
 5133 19c4 210F      		add r18,r17
 5134               	.LVL435:
 5135               	.LBB532:
1263:main_sim900.h ****       break;
 5136               		.loc 2 1263 0
 5137 19c6 E22F      		mov r30,r18
 5138 19c8 F0E0      		ldi r31,0
 5139 19ca E050      		subi r30,lo8(-(nastepna_komenda.3441))
 5140 19cc F040      		sbci r31,hi8(-(nastepna_komenda.3441))
 5141               	.LVL436:
 5142               	/* #APP */
 5143               	 ;  1263 "main_sim900.h" 1
 5144 19ce 4591      		lpm r20, Z+
 5145 19d0 5491      		lpm r21, Z
 5146               		
 5147               	 ;  0 "" 2
 5148               	.LVL437:
 5149               	/* #NOAPP */
 5150               	.LBE532:
1261:main_sim900.h ****             czy_mozna_wysylac_dane_do_SIM900, wykonywana_komenda,
 5151               		.loc 2 1261 0
 5152 19d2 FEE0      		ldi r31,lo8(14)
 5153 19d4 2F9F      		mul r18,r31
 5154 19d6 9001      		movw r18,r0
 5155 19d8 1124      		clr __zero_reg__
 5156               	.LVL438:
 5157 19da 2050      		subi r18,lo8(-(instrukcje.3440))
 5158 19dc 3040      		sbci r19,hi8(-(instrukcje.3440))
 5159 19de 612F      		mov r22,r17
 5160 19e0 802F      		mov r24,r16
 5161 19e2 0E94 0000 		call wyslanie_polecenia_ROM
 5162               	.LVL439:
 5163 19e6 00C0      		rjmp .L588
 5164               	.LVL440:
 5165               	.L497:
 5166               	.LBE531:
 848:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5167               		.loc 2 848 0
 5168 19e8 193A      		cpi r17,lo8(-87)
 5169 19ea 00F0      		brlo .L499
 5170               	.LBB533:
 886:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5171               		.loc 2 886 0
 5172 19ec 9111      		cpse r25,__zero_reg__
 5173 19ee 00C0      		rjmp .L635
 886:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5174               		.loc 2 886 0 is_stmt 0 discriminator 2
 5175 19f0 8091 0000 		lds r24,modul_zalogowany_w_sieci
 5176 19f4 8823      		tst r24
 5177 19f6 01F4      		brne .+2
 5178 19f8 00C0      		rjmp .L635
 886:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5179               		.loc 2 886 0 discriminator 4
 5180 19fa 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5181 19fe 8111      		cpse r24,__zero_reg__
 5182 1a00 00C0      		rjmp .L635
 886:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5183               		.loc 2 886 0 discriminator 6
 5184 1a02 8091 0000 		lds r24,licznik_bezpieczenstwa_wykonywana_rozmowa
 5185 1a06 9091 0000 		lds r25,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5186 1a0a 892B      		or r24,r25
 5187 1a0c 01F0      		breq .+2
 5188 1a0e 00C0      		rjmp .L635
 886:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5189               		.loc 2 886 0 discriminator 8
 5190 1a10 8091 0000 		lds r24,opoznienie_SIM900_100MS
 5191 1a14 8111      		cpse r24,__zero_reg__
 5192 1a16 00C0      		rjmp .L635
 886:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5193               		.loc 2 886 0 discriminator 10
 5194 1a18 8091 0000 		lds r24,wysylanie_smsa_clipa
 5195 1a1c 8111      		cpse r24,__zero_reg__
 5196 1a1e 00C0      		rjmp .L635
 886:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5197               		.loc 2 886 0 discriminator 12
 5198 1a20 8091 0000 		lds r24,flaga_wysylanie_smsa
 5199 1a24 8111      		cpse r24,__zero_reg__
 5200 1a26 00C0      		rjmp .L635
 886:main_sim900.h ****                   flaga_trwa_rozmowa_wychodzaca || opoznienie_SIM900_100MS ||
 5201               		.loc 2 886 0 discriminator 14
 5202 1a28 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 5203 1a2c 8139      		cpi r24,lo8(-111)
 5204 1a2e 01F4      		brne .+2
 5205 1a30 00C0      		rjmp .L635
 892:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 5206               		.loc 2 892 0 is_stmt 1
 5207 1a32 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5208 1a36 8111      		cpse r24,__zero_reg__
 5209 1a38 00C0      		rjmp .L635
 892:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 5210               		.loc 2 892 0 is_stmt 0 discriminator 2
 5211 1a3a 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5212 1a3e 8111      		cpse r24,__zero_reg__
 5213 1a40 00C0      		rjmp .L635
 892:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 5214               		.loc 2 892 0 discriminator 4
 5215 1a42 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5216 1a46 8111      		cpse r24,__zero_reg__
 5217 1a48 00C0      		rjmp .L635
 892:main_sim900.h ****     POWTORZ_JESLI(czy_sa_komendy_z_przedzialu(
 5218               		.loc 2 892 0 discriminator 6
 5219 1a4a F999      		sbic 0x1f,1
 5220 1a4c 00C0      		rjmp .L635
 893:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW,
 5221               		.loc 2 893 0 is_stmt 1
 5222 1a4e 61E0      		ldi r22,lo8(1)
 5223 1a50 81E0      		ldi r24,lo8(1)
 5224 1a52 0E94 0000 		call czy_sa_komendy_z_przedzialu
 5225               	.LVL441:
 5226 1a56 8111      		cpse r24,__zero_reg__
 5227 1a58 00C0      		rjmp .L635
 893:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW,
 5228               		.loc 2 893 0 is_stmt 0 discriminator 2
 5229 1a5a 64ED      		ldi r22,lo8(-44)
 5230 1a5c 82ED      		ldi r24,lo8(-46)
 5231 1a5e 0E94 0000 		call czy_sa_komendy_z_przedzialu
 5232               	.LVL442:
 5233 1a62 8111      		cpse r24,__zero_reg__
 5234 1a64 00C0      		rjmp .L635
 893:main_sim900.h ****                       KOMENDA_KOLEJKI_WYSLIJ_SMSA_I_CLIP_DO_UZYTKOWNIKOW,
 5235               		.loc 2 893 0 discriminator 4
 5236 1a66 67E9      		ldi r22,lo8(-105)
 5237 1a68 85E9      		ldi r24,lo8(-107)
 5238 1a6a 0E94 0000 		call czy_sa_komendy_z_przedzialu
 5239               	.LVL443:
 5240 1a6e 8111      		cpse r24,__zero_reg__
 5241 1a70 00C0      		rjmp .L635
 901:main_sim900.h ****     flaga_odczytywanie_smsa = TRUE;
 5242               		.loc 2 901 0 is_stmt 1
 5243 1a72 0023      		tst r16
 5244 1a74 01F4      		brne .+2
 5245 1a76 00C0      		rjmp .L635
 901:main_sim900.h ****     flaga_odczytywanie_smsa = TRUE;
 5246               		.loc 2 901 0 is_stmt 0 discriminator 2
 5247 1a78 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5248 1a7c 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5249 1a80 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
 902:main_sim900.h ****     static const char instrukcja_odczytaj_smsa[] PROGMEM = "+cmgr=";
 5250               		.loc 2 902 0 is_stmt 1 discriminator 2
 5251 1a84 8FEF      		ldi r24,lo8(-1)
 5252 1a86 8093 0000 		sts flaga_odczytywanie_smsa,r24
 904:main_sim900.h ****     const uint nr_smsa =
 5253               		.loc 2 904 0 discriminator 2
 5254 1a8a 46E0      		ldi r20,lo8(6)
 5255 1a8c 50E0      		ldi r21,0
 5256 1a8e 60E0      		ldi r22,lo8(instrukcja_odczytaj_smsa.3357)
 5257 1a90 70E0      		ldi r23,hi8(instrukcja_odczytaj_smsa.3357)
 5258 1a92 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 5259 1a94 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 5260 1a96 0E94 0000 		call memcpy_P
 5261               	.LVL444:
 5262               	.LBB534:
 5263               	.LBB535:
 5264               		.loc 6 527 0 discriminator 2
 5265 1a9a 4AE0      		ldi r20,lo8(10)
 5266 1a9c 60E0      		ldi r22,lo8(wysylany_blok_SIM900+8)
 5267 1a9e 70E0      		ldi r23,hi8(wysylany_blok_SIM900+8)
 5268               	.LVL445:
 5269 1aa0 C701      		movw r24,r14
 5270 1aa2 885A      		subi r24,-88
 5271 1aa4 9109      		sbc r25,__zero_reg__
 5272               	.LVL446:
 5273               	.L636:
 5274               	.LBE535:
 5275               	.LBE534:
 5276               	.LBE533:
 5277               	.LBB536:
 5278               	.LBB537:
 5279               	.LBB538:
 5280 1aa6 0E94 0000 		call __utoa_ncheck
 5281               	.LVL447:
 5282               	.L630:
 5283               	.LBE538:
 5284               	.LBE537:
 5285               	.LBE536:
1225:main_sim900.h ****     break;
 5286               		.loc 2 1225 0 discriminator 2
 5287 1aaa 0E94 0000 		call wyslij_polecenie_RAM_SIM900
 5288               	.LVL448:
 5289 1aae 00C0      		rjmp .L588
 5290               	.L494:
 848:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5291               		.loc 2 848 0
 5292 1ab0 143D      		cpi r17,lo8(-44)
 5293 1ab2 01F4      		brne .+2
 5294 1ab4 00C0      		rjmp .L501
 5295 1ab6 00F4      		brsh .L502
 5296 1ab8 113D      		cpi r17,lo8(-47)
 5297 1aba 01F4      		brne .L627
 5298               	.LBB541:
 914:main_sim900.h ****         bufor_pdu, numer_telefonu_odebranego_smsa,
 5299               		.loc 2 914 0
 5300 1abc 40E0      		ldi r20,lo8(nie_wysylaj_echa_z_powodu_nietypowego_smsa)
 5301 1abe 50E0      		ldi r21,hi8(nie_wysylaj_echa_z_powodu_nietypowego_smsa)
 5302 1ac0 60E0      		ldi r22,lo8(numer_telefonu_odebranego_smsa)
 5303 1ac2 70E0      		ldi r23,hi8(numer_telefonu_odebranego_smsa)
 5304 1ac4 80E0      		ldi r24,lo8(bufor_pdu)
 5305 1ac6 90E0      		ldi r25,hi8(bufor_pdu)
 5306 1ac8 0E94 0000 		call pobierz_numer_telefonu_nadawcy_z_PDU
 5307               	.LVL449:
 917:main_sim900.h ****     {
 5308               		.loc 2 917 0
 5309 1acc 0097      		sbiw r24,0
 5310 1ace 01F0      		breq .+2
 5311 1ad0 00C0      		rjmp .L521
 5312               	.LVL450:
 5313               	.L631:
 5314               	.LBE541:
 944:main_sim900.h ****     break;
 5315               		.loc 2 944 0
 5316 1ad2 1092 0000 		sts flaga_odczytywanie_smsa,__zero_reg__
 5317 1ad6 00C0      		rjmp .L588
 5318               	.L502:
 848:main_sim900.h ****   case KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT:
 5319               		.loc 2 848 0
 5320 1ad8 173D      		cpi r17,lo8(-41)
 5321 1ada 01F4      		brne .+2
 5322 1adc 00C0      		rjmp .L505
 5323 1ade 1D3F      		cpi r17,lo8(-3)
 5324 1ae0 01F4      		brne .+2
 5325 1ae2 00C0      		rjmp .L506
 5326 1ae4 153D      		cpi r17,lo8(-43)
 5327 1ae6 01F0      		breq .+2
 5328 1ae8 00C0      		rjmp .L471
 5329               	.LBB544:
1038:main_sim900.h ****     if (wykonywanie_rozmowy_telefonicznej)
 5330               		.loc 2 1038 0
 5331 1aea 8091 0000 		lds r24,modul_zalogowany_w_sieci
 5332 1aee 8823      		tst r24
 5333 1af0 01F0      		breq .L537
1038:main_sim900.h ****     if (wykonywanie_rozmowy_telefonicznej)
 5334               		.loc 2 1038 0 is_stmt 0 discriminator 2
 5335 1af2 8091 0000 		lds r24,opoznienie_SIM900_100MS
 5336 1af6 8823      		tst r24
 5337 1af8 01F4      		brne .+2
 5338 1afa 00C0      		rjmp .L538
 5339               	.L537:
1038:main_sim900.h ****     if (wykonywanie_rozmowy_telefonicznej)
 5340               		.loc 2 1038 0 discriminator 3
 5341 1afc 85ED      		ldi r24,lo8(-43)
 5342 1afe 00C0      		rjmp .L629
 5343               	.L627:
 5344               	.LBE544:
 851:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 5345               		.loc 2 851 0 is_stmt 1
 5346 1b00 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5347 1b04 8111      		cpse r24,__zero_reg__
 5348 1b06 00C0      		rjmp .L635
 851:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 5349               		.loc 2 851 0 is_stmt 0 discriminator 2
 5350 1b08 8091 0000 		lds r24,licznik_bezpieczenstwa_wykonywana_rozmowa
 5351 1b0c 9091 0000 		lds r25,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5352 1b10 892B      		or r24,r25
 5353 1b12 01F4      		brne .L635
 851:main_sim900.h ****     JESLI_EEPROM_ZAJETY_WYKONAJ_POZNIEJ();
 5354               		.loc 2 851 0 discriminator 4
 5355 1b14 8091 0000 		lds r24,opoznienie_SIM900_100MS
 5356 1b18 8823      		tst r24
 5357 1b1a 01F0      		breq .L509
 5358               	.L635:
 5359               	.LBB545:
 970:main_sim900.h ****     static const char instrukcja_usun_smsa[] PROGMEM = "+cmgd=";
 5360               		.loc 2 970 0 is_stmt 1 discriminator 1
 5361 1b1c 812F      		mov r24,r17
 5362 1b1e 00C0      		rjmp .L629
 5363               	.L509:
 5364               	.LBE545:
 852:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5365               		.loc 2 852 0
 5366 1b20 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5367 1b24 8111      		cpse r24,__zero_reg__
 5368 1b26 00C0      		rjmp .L635
 852:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5369               		.loc 2 852 0 is_stmt 0 discriminator 2
 5370 1b28 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5371 1b2c 8111      		cpse r24,__zero_reg__
 5372 1b2e 00C0      		rjmp .L635
 852:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5373               		.loc 2 852 0 discriminator 4
 5374 1b30 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5375 1b34 8111      		cpse r24,__zero_reg__
 5376 1b36 00C0      		rjmp .L635
 852:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5377               		.loc 2 852 0 discriminator 6
 5378 1b38 F999      		sbic 0x1f,1
 5379 1b3a 00C0      		rjmp .L635
 853:main_sim900.h ****     wyslij_sms(wykonywana_komenda == KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
 5380               		.loc 2 853 0 is_stmt 1
 5381 1b3c 0023      		tst r16
 5382 1b3e 01F0      		breq .L635
 853:main_sim900.h ****     wyslij_sms(wykonywana_komenda == KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
 5383               		.loc 2 853 0 is_stmt 0 discriminator 2
 5384 1b40 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5385 1b44 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5386 1b48 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
 854:main_sim900.h ****     break;
 5387               		.loc 2 854 0 is_stmt 1 discriminator 2
 5388 1b4c 81E0      		ldi r24,lo8(1)
 5389 1b4e 133D      		cpi r17,lo8(-45)
 5390 1b50 01F0      		breq .L513
 5391 1b52 80E0      		ldi r24,0
 5392               	.L513:
 5393 1b54 0E94 0000 		call wyslij_sms
 5394               	.LVL451:
 5395 1b58 00C0      		rjmp .L588
 5396               	.L501:
 5397               	.LBB546:
 858:main_sim900.h ****     konwertuj_pdu_na_blok_wysylany(wysylany_blok_SIM900, bufor_pdu,
 5398               		.loc 2 858 0
 5399 1b5a 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
 859:main_sim900.h ****                                    dlugosc_pdu);
 5400               		.loc 2 859 0
 5401 1b5e 4091 0000 		lds r20,dlugosc_pdu
 5402 1b62 60E0      		ldi r22,lo8(bufor_pdu)
 5403 1b64 70E0      		ldi r23,hi8(bufor_pdu)
 5404 1b66 80E0      		ldi r24,lo8(wysylany_blok_SIM900)
 5405 1b68 90E0      		ldi r25,hi8(wysylany_blok_SIM900)
 5406 1b6a 0E94 0000 		call konwertuj_pdu_na_blok_wysylany
 5407               	.LVL452:
 861:main_sim900.h ****     wysylany_blok_SIM900[liczba_znakow - 1] = ZNAK_CTRL_Z;
 5408               		.loc 2 861 0
 5409 1b6e 8091 0000 		lds r24,dlugosc_pdu
 5410 1b72 90E0      		ldi r25,0
 5411 1b74 880F      		lsl r24
 5412 1b76 991F      		rol r25
 5413 1b78 0196      		adiw r24,1
 5414               	.LVL453:
 862:main_sim900.h ****     wyslij_znaki_SIM900(liczba_znakow);
 5415               		.loc 2 862 0
 5416 1b7a FC01      		movw r30,r24
 5417 1b7c E050      		subi r30,lo8(-(wysylany_blok_SIM900-1))
 5418 1b7e F040      		sbci r31,hi8(-(wysylany_blok_SIM900-1))
 5419 1b80 2AE1      		ldi r18,lo8(26)
 5420 1b82 2083      		st Z,r18
 863:main_sim900.h ****     break;
 5421               		.loc 2 863 0
 5422 1b84 0E94 0000 		call wyslij_znaki_SIM900
 5423               	.LVL454:
 5424 1b88 00C0      		rjmp .L588
 5425               	.LVL455:
 5426               	.L521:
 5427               	.LBE546:
 5428               	.LBB547:
 5429               	.LBB542:
 924:main_sim900.h ****     }
 5430               		.loc 2 924 0
 5431 1b8a 9E01      		movw r18,r28
 5432 1b8c 2F5F      		subi r18,-1
 5433 1b8e 3F4F      		sbci r19,-1
 5434 1b90 AE01      		movw r20,r28
 5435 1b92 4E5F      		subi r20,-2
 5436 1b94 5F4F      		sbci r21,-1
 5437 1b96 BE01      		movw r22,r28
 5438 1b98 6D5F      		subi r22,-3
 5439 1b9a 7F4F      		sbci r23,-1
 5440 1b9c 0E94 0000 		call pobierz_date_z_PDU
 5441               	.LVL456:
 5442               	.LBE542:
 5443               	.LBB543:
 928:main_sim900.h ****     }
 5444               		.loc 2 928 0
 5445 1ba0 AE01      		movw r20,r28
 5446 1ba2 4F5F      		subi r20,-1
 5447 1ba4 5F4F      		sbci r21,-1
 5448 1ba6 BE01      		movw r22,r28
 5449 1ba8 6E5F      		subi r22,-2
 5450 1baa 7F4F      		sbci r23,-1
 5451 1bac 0E94 0000 		call pobierz_czas_z_PDU
 5452               	.LVL457:
 5453               	.LBE543:
 930:main_sim900.h ****     pdu_to_ascii(ptr, tekst_odebranego_smsa, MAX_LICZBA_ZNAKOW_SMS + 1);
 5454               		.loc 2 930 0
 5455 1bb0 9093 0000 		sts ptr_start_pdu_z_wiadomoscia+1,r25
 5456 1bb4 8093 0000 		sts ptr_start_pdu_z_wiadomoscia,r24
 931:main_sim900.h **** #ifdef WLACZ_TESTY_OGOLNE
 5457               		.loc 2 931 0
 5458 1bb8 41EA      		ldi r20,lo8(-95)
 5459 1bba 60E0      		ldi r22,lo8(wysylany_blok_SIM900+239)
 5460 1bbc 70E0      		ldi r23,hi8(wysylany_blok_SIM900+239)
 5461 1bbe 0E94 0000 		call pdu_to_ascii
 5462               	.LVL458:
 5463               	.L522:
 5464               	.LBE547:
 941:main_sim900.h ****     zapal_diode_led(10);
 5465               		.loc 2 941 0 discriminator 7
 5466 1bc2 87ED      		ldi r24,lo8(-41)
 5467               	.L629:
1222:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 5468               		.loc 2 1222 0 discriminator 7
 5469 1bc4 0E94 0000 		call dodaj_komende
 5470               	.LVL459:
 5471 1bc8 00C0      		rjmp .L588
 5472               	.L505:
 941:main_sim900.h ****     zapal_diode_led(10);
 5473               		.loc 2 941 0
 5474 1bca 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5475 1bce 8111      		cpse r24,__zero_reg__
 5476 1bd0 00C0      		rjmp .L522
 941:main_sim900.h ****     zapal_diode_led(10);
 5477               		.loc 2 941 0 is_stmt 0 discriminator 2
 5478 1bd2 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5479 1bd6 8111      		cpse r24,__zero_reg__
 5480 1bd8 00C0      		rjmp .L522
 941:main_sim900.h ****     zapal_diode_led(10);
 5481               		.loc 2 941 0 discriminator 4
 5482 1bda 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5483 1bde 8111      		cpse r24,__zero_reg__
 5484 1be0 00C0      		rjmp .L522
 941:main_sim900.h ****     zapal_diode_led(10);
 5485               		.loc 2 941 0 discriminator 6
 5486 1be2 F999      		sbic 0x1f,1
 5487 1be4 00C0      		rjmp .L522
 942:main_sim900.h ****     wykonanie_polecenia_sms();
 5488               		.loc 2 942 0 is_stmt 1
 5489 1be6 8BE0      		ldi r24,lo8(11)
 5490 1be8 8093 0000 		sts licznik_100ms_dioda_led,r24
 943:main_sim900.h ****     flaga_odczytywanie_smsa = FALSE;
 5491               		.loc 2 943 0
 5492 1bec 0E94 0000 		call wykonanie_polecenia_sms
 5493               	.LVL460:
 5494 1bf0 00C0      		rjmp .L631
 5495               	.L495:
 5496               	.LBB548:
 967:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5497               		.loc 2 967 0
 5498 1bf2 9111      		cpse r25,__zero_reg__
 5499 1bf4 00C0      		rjmp .L635
 967:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5500               		.loc 2 967 0 is_stmt 0 discriminator 2
 5501 1bf6 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5502 1bfa 8111      		cpse r24,__zero_reg__
 5503 1bfc 00C0      		rjmp .L635
 967:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5504               		.loc 2 967 0 discriminator 4
 5505 1bfe 8091 0000 		lds r24,licznik_bezpieczenstwa_wykonywana_rozmowa
 5506 1c02 9091 0000 		lds r25,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5507 1c06 892B      		or r24,r25
 5508 1c08 01F0      		breq .+2
 5509 1c0a 00C0      		rjmp .L635
 967:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5510               		.loc 2 967 0 discriminator 6
 5511 1c0c 8091 0000 		lds r24,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 5512 1c10 8111      		cpse r24,__zero_reg__
 5513 1c12 00C0      		rjmp .L635
 967:main_sim900.h ****                   opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5514               		.loc 2 967 0 discriminator 8
 5515 1c14 8091 0000 		lds r24,czekanie_na_odebranie_zachety
 5516 1c18 8111      		cpse r24,__zero_reg__
 5517 1c1a 00C0      		rjmp .L635
 970:main_sim900.h ****     static const char instrukcja_usun_smsa[] PROGMEM = "+cmgd=";
 5518               		.loc 2 970 0 is_stmt 1
 5519 1c1c 0023      		tst r16
 5520 1c1e 01F4      		brne .+2
 5521 1c20 00C0      		rjmp .L635
 970:main_sim900.h ****     static const char instrukcja_usun_smsa[] PROGMEM = "+cmgd=";
 5522               		.loc 2 970 0 is_stmt 0 discriminator 2
 5523 1c22 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5524 1c26 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5525 1c2a 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
 972:main_sim900.h ****     const uint nr_smsa = wykonywana_komenda - KOMENDA_KOLEJKI_USUN_SMSA_1 + 1;
 5526               		.loc 2 972 0 is_stmt 1 discriminator 2
 5527 1c2e 46E0      		ldi r20,lo8(6)
 5528 1c30 50E0      		ldi r21,0
 5529 1c32 60E0      		ldi r22,lo8(instrukcja_usun_smsa.3387)
 5530 1c34 70E0      		ldi r23,hi8(instrukcja_usun_smsa.3387)
 5531 1c36 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 5532 1c38 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 5533 1c3a 0E94 0000 		call memcpy_P
 5534               	.LVL461:
 5535               	.LBB540:
 5536               	.LBB539:
 5537               		.loc 6 527 0 discriminator 2
 5538 1c3e 4AE0      		ldi r20,lo8(10)
 5539 1c40 60E0      		ldi r22,lo8(wysylany_blok_SIM900+8)
 5540 1c42 70E0      		ldi r23,hi8(wysylany_blok_SIM900+8)
 5541               	.LVL462:
 5542 1c44 C701      		movw r24,r14
 5543 1c46 8C5B      		subi r24,-68
 5544 1c48 9109      		sbc r25,__zero_reg__
 5545               	.LVL463:
 5546 1c4a 00C0      		rjmp .L636
 5547               	.LVL464:
 5548               	.L491:
 5549               	.LBE539:
 5550               	.LBE540:
 5551               	.LBE548:
 5552               	.LBB549:
 981:main_sim900.h ****     zapal_diode_led(10);
 5553               		.loc 2 981 0
 5554 1c4c 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 5555 1c50 8111      		cpse r24,__zero_reg__
 5556 1c52 00C0      		rjmp .L527
 981:main_sim900.h ****     zapal_diode_led(10);
 5557               		.loc 2 981 0 is_stmt 0 discriminator 2
 5558 1c54 8091 0000 		lds r24,liczba_znakow_do_zapisu
 5559 1c58 8111      		cpse r24,__zero_reg__
 5560 1c5a 00C0      		rjmp .L527
 981:main_sim900.h ****     zapal_diode_led(10);
 5561               		.loc 2 981 0 discriminator 4
 5562 1c5c 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 5563 1c60 8111      		cpse r24,__zero_reg__
 5564 1c62 00C0      		rjmp .L527
 981:main_sim900.h ****     zapal_diode_led(10);
 5565               		.loc 2 981 0 discriminator 6
 5566 1c64 F99B      		sbis 0x1f,1
 5567 1c66 00C0      		rjmp .L528
 5568               	.L527:
 981:main_sim900.h ****     zapal_diode_led(10);
 5569               		.loc 2 981 0 discriminator 7
 5570 1c68 87E9      		ldi r24,lo8(-105)
 5571 1c6a 00C0      		rjmp .L629
 5572               	.L528:
 982:main_sim900.h **** 
 5573               		.loc 2 982 0 is_stmt 1
 5574 1c6c 8BE0      		ldi r24,lo8(11)
 5575 1c6e 8093 0000 		sts licznik_100ms_dioda_led,r24
 984:main_sim900.h ****         sprawdz_przychodzaca_rozmowe(); // Returns TRUE if number authorized
 5576               		.loc 2 984 0
 5577 1c72 0E94 0000 		call sprawdz_przychodzaca_rozmowe
 5578               	.LVL465:
 987:main_sim900.h ****       if (tryb_clip) {
 5579               		.loc 2 987 0
 5580 1c76 8823      		tst r24
 5581 1c78 01F0      		breq .L529
 988:main_sim900.h ****         // Tryb CLIP: wlacz wyjscie i ODRZUC polaczenie
 5582               		.loc 2 988 0
 5583 1c7a 8091 0000 		lds r24,tryb_clip
 5584               	.LVL466:
 5585 1c7e 8823      		tst r24
 5586 1c80 01F0      		breq .L530
 990:main_sim900.h ****           ustaw_wyjscie_clip();
 5587               		.loc 2 990 0
 5588 1c82 80E0      		ldi r24,lo8(__c.3391)
 5589 1c84 90E0      		ldi r25,hi8(__c.3391)
 5590 1c86 0E94 0000 		call polozenie_polecenia_SIM900
 5591               	.LVL467:
 5592 1c8a 892B      		or r24,r25
 5593 1c8c 01F4      		brne .L529
 991:main_sim900.h ****         }
 5594               		.loc 2 991 0
 5595 1c8e 0E94 0000 		call ustaw_wyjscie_clip
 5596               	.LVL468:
 5597               	.L529:
 993:main_sim900.h ****       } else {
 5598               		.loc 2 993 0
 5599 1c92 86E9      		ldi r24,lo8(-106)
 5600               	.L628:
 996:main_sim900.h ****       }
 5601               		.loc 2 996 0
 5602 1c94 0E94 0000 		call dodaj_komende
 5603               	.LVL469:
1002:main_sim900.h ****     break;
 5604               		.loc 2 1002 0
 5605 1c98 8FEF      		ldi r24,lo8(-1)
 5606 1c9a 8093 0000 		sts blokada_clip,r24
1003:main_sim900.h ****   }
 5607               		.loc 2 1003 0
 5608 1c9e 00C0      		rjmp .L466
 5609               	.L530:
 996:main_sim900.h ****       }
 5610               		.loc 2 996 0
 5611 1ca0 85E9      		ldi r24,lo8(-107)
 5612 1ca2 00C0      		rjmp .L628
 5613               	.L485:
 5614               	.LBE549:
 5615               	.LBB550:
1006:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5616               		.loc 2 1006 0
 5617 1ca4 8091 0000 		lds r24,flaga_wysylanie_smsa
 5618 1ca8 8111      		cpse r24,__zero_reg__
 5619 1caa 00C0      		rjmp .L532
1006:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5620               		.loc 2 1006 0 is_stmt 0 discriminator 2
 5621 1cac 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5622 1cb0 8111      		cpse r24,__zero_reg__
 5623 1cb2 00C0      		rjmp .L532
1006:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5624               		.loc 2 1006 0 discriminator 4
 5625 1cb4 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 5626 1cb8 8111      		cpse r24,__zero_reg__
 5627 1cba 00C0      		rjmp .L532
1006:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5628               		.loc 2 1006 0 discriminator 6
 5629 1cbc 8091 0000 		lds r24,czekanie_na_odebranie_zachety
 5630 1cc0 8111      		cpse r24,__zero_reg__
 5631 1cc2 00C0      		rjmp .L532
1006:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5632               		.loc 2 1006 0 discriminator 10
 5633 1cc4 8091 C100 		lds r24,193
 5634 1cc8 86FD      		sbrc r24,6
 5635 1cca 00C0      		rjmp .L532
1006:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5636               		.loc 2 1006 0 discriminator 12
 5637 1ccc 8091 0000 		lds r24,podlaczony_modul_gsm_SIM900
 5638 1cd0 8823      		tst r24
 5639 1cd2 01F0      		breq .L532
1006:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5640               		.loc 2 1006 0 discriminator 14
 5641 1cd4 8091 0000 		lds r24,komenda_SIM900
 5642 1cd8 8823      		tst r24
 5643 1cda 01F0      		breq .L533
 5644               	.L532:
1006:main_sim900.h ****         flaga_wysylanie_smsa || wykonywanie_rozmowy_telefonicznej ||
 5645               		.loc 2 1006 0 discriminator 15
 5646 1cdc 86E9      		ldi r24,lo8(-106)
 5647 1cde 00C0      		rjmp .L629
 5648               	.L533:
1011:main_sim900.h ****     static const char instrukcja_odrzuc_rozmowe[] PROGMEM = "h";
 5649               		.loc 2 1011 0 is_stmt 1
 5650 1ce0 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5651 1ce4 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5652 1ce8 86E9      		ldi r24,lo8(-106)
 5653 1cea 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1013:main_sim900.h ****     break;
 5654               		.loc 2 1013 0
 5655 1cee 80E0      		ldi r24,lo8(instrukcja_odrzuc_rozmowe.3394)
 5656 1cf0 90E0      		ldi r25,hi8(instrukcja_odrzuc_rozmowe.3394)
 5657               	.L632:
 5658               	.LBE550:
 5659               	.LBB551:
1188:main_sim900.h ****     break;
 5660               		.loc 2 1188 0 discriminator 2
 5661 1cf2 0E94 0000 		call wyslij_polecenie_ROM_SIM900
 5662               	.LVL470:
 5663 1cf6 00C0      		rjmp .L588
 5664               	.L488:
 5665               	.LBE551:
 5666               	.LBB552:
1017:main_sim900.h ****     static const char instrukcja_odbierz_rozmowe[] PROGMEM = "a";
 5667               		.loc 2 1017 0
 5668 1cf8 85E9      		ldi r24,lo8(-107)
 5669 1cfa 0023      		tst r16
 5670 1cfc 01F4      		brne .+2
 5671 1cfe 00C0      		rjmp .L629
1017:main_sim900.h ****     static const char instrukcja_odbierz_rozmowe[] PROGMEM = "a";
 5672               		.loc 2 1017 0 is_stmt 0 discriminator 2
 5673 1d00 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5674 1d04 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5675 1d08 85E9      		ldi r24,lo8(-107)
 5676 1d0a 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1019:main_sim900.h ****     POMOC_DODAJ2('#', 'p');
 5677               		.loc 2 1019 0 is_stmt 1 discriminator 2
 5678 1d0e 80E0      		ldi r24,lo8(instrukcja_odbierz_rozmowe.3396)
 5679 1d10 90E0      		ldi r25,hi8(instrukcja_odbierz_rozmowe.3396)
 5680 1d12 00C0      		rjmp .L632
 5681               	.L496:
 5682               	.LBE552:
 5683               	.LBB553:
1025:main_sim900.h ****     if (!CZY_MOZNA_WYSYLAC_DANE_SIM900() || !czy_jest_bezczynny_SIM900() ||
 5684               		.loc 2 1025 0
 5685 1d14 8091 0000 		lds r24,opoznienie_SIM900_100MS
 5686 1d18 8823      		tst r24
 5687 1d1a 01F0      		breq .L535
 5688               	.L536:
1025:main_sim900.h ****     if (!CZY_MOZNA_WYSYLAC_DANE_SIM900() || !czy_jest_bezczynny_SIM900() ||
 5689               		.loc 2 1025 0 is_stmt 0 discriminator 1
 5690 1d1c 84EA      		ldi r24,lo8(-92)
 5691 1d1e 00C0      		rjmp .L629
 5692               	.L535:
1026:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 5693               		.loc 2 1026 0 is_stmt 1
 5694 1d20 8091 C100 		lds r24,193
 5695 1d24 86FD      		sbrc r24,6
 5696 1d26 00C0      		rjmp .L536
1026:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 5697               		.loc 2 1026 0 is_stmt 0 discriminator 1
 5698 1d28 8091 0000 		lds r24,podlaczony_modul_gsm_SIM900
 5699 1d2c 8823      		tst r24
 5700 1d2e 01F0      		breq .L536
1026:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 5701               		.loc 2 1026 0 discriminator 2
 5702 1d30 8091 0000 		lds r24,komenda_SIM900
 5703 1d34 8111      		cpse r24,__zero_reg__
 5704 1d36 00C0      		rjmp .L536
1026:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 5705               		.loc 2 1026 0 discriminator 3
 5706 1d38 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 5707 1d3c 8111      		cpse r24,__zero_reg__
 5708 1d3e 00C0      		rjmp .L536
1031:main_sim900.h ****     static const char instrukcja_vts[] PROGMEM = "+vts=1";
 5709               		.loc 2 1031 0 is_stmt 1
 5710 1d40 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5711 1d44 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5712 1d48 84EA      		ldi r24,lo8(-92)
 5713 1d4a 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1033:main_sim900.h ****     POMOC_DODAJ2('#', 'V');
 5714               		.loc 2 1033 0
 5715 1d4e 80E0      		ldi r24,lo8(instrukcja_vts.3398)
 5716 1d50 90E0      		ldi r25,hi8(instrukcja_vts.3398)
 5717 1d52 00C0      		rjmp .L632
 5718               	.L538:
 5719               	.LBE553:
 5720               	.LBB554:
1039:main_sim900.h ****       break;
 5721               		.loc 2 1039 0
 5722 1d54 8091 0000 		lds r24,wykonywanie_rozmowy_telefonicznej
 5723 1d58 8111      		cpse r24,__zero_reg__
 5724 1d5a 00C0      		rjmp .L588
1041:main_sim900.h ****     zapal_diode_led(20);
 5725               		.loc 2 1041 0
 5726 1d5c 0023      		tst r16
 5727 1d5e 01F4      		brne .+2
 5728 1d60 00C0      		rjmp .L537
1041:main_sim900.h ****     zapal_diode_led(20);
 5729               		.loc 2 1041 0 is_stmt 0 discriminator 2
 5730 1d62 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5731 1d66 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5732 1d6a 85ED      		ldi r24,lo8(-43)
 5733 1d6c 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1042:main_sim900.h ****     wysylane_dane_RAM_SIM900[0] = 'd';
 5734               		.loc 2 1042 0 is_stmt 1 discriminator 2
 5735 1d70 85E1      		ldi r24,lo8(21)
 5736 1d72 8093 0000 		sts licznik_100ms_dioda_led,r24
1043:main_sim900.h ****     // static const char doladowanie[] PROGMEM = "*100*59484869838559#";
 5737               		.loc 2 1043 0 discriminator 2
 5738 1d76 84E6      		ldi r24,lo8(100)
 5739 1d78 8093 0000 		sts wysylany_blok_SIM900+2,r24
1046:main_sim900.h ****     uchar l = strlen(numer_telefonu_do_ktorego_dzwonic) + 1;
 5740               		.loc 2 1046 0 discriminator 2
 5741 1d7c 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 5742 1d7e 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 5743 1d80 80E0      		ldi r24,lo8(wysylany_blok_SIM900+3)
 5744 1d82 90E0      		ldi r25,hi8(wysylany_blok_SIM900+3)
 5745 1d84 0E94 0000 		call strcpy
 5746               	.LVL471:
1047:main_sim900.h ****     wysylane_dane_RAM_SIM900[l] = ';';
 5747               		.loc 2 1047 0 discriminator 2
 5748 1d88 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 5749 1d8a 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 5750 1d8c FC01      		movw r30,r24
 5751               		0:
 5752 1d8e 0190      		ld __tmp_reg__,Z+
 5753 1d90 0020      		tst __tmp_reg__
 5754 1d92 01F4      		brne 0b
 5755 1d94 CF01      		movw r24,r30
 5756 1d96 8050      		subi r24,lo8(numer_telefonu_do_ktorego_dzwonic+1)
 5757 1d98 9040      		sbci r25,hi8(numer_telefonu_do_ktorego_dzwonic+1)
 5758               	.LVL472:
 5759 1d9a 8F5F      		subi r24,lo8(-(1))
 5760               	.LVL473:
1048:main_sim900.h ****     wysylane_dane_RAM_SIM900[l + 1] = '\0';
 5761               		.loc 2 1048 0 discriminator 2
 5762 1d9c 90E0      		ldi r25,0
 5763 1d9e FC01      		movw r30,r24
 5764               	.LVL474:
 5765 1da0 E050      		subi r30,lo8(-(wysylany_blok_SIM900+2))
 5766 1da2 F040      		sbci r31,hi8(-(wysylany_blok_SIM900+2))
 5767 1da4 2BE3      		ldi r18,lo8(59)
 5768 1da6 2083      		st Z,r18
1049:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 5769               		.loc 2 1049 0 discriminator 2
 5770 1da8 8050      		subi r24,lo8(-(wysylany_blok_SIM900+3))
 5771 1daa 9040      		sbci r25,hi8(-(wysylany_blok_SIM900+3))
 5772 1dac FC01      		movw r30,r24
 5773 1dae 1082      		st Z,__zero_reg__
1050:main_sim900.h ****     licznik_bezpieczenstwa_wykonywana_rozmowa = 300;
 5774               		.loc 2 1050 0 discriminator 2
 5775 1db0 0E94 0000 		call wyslij_polecenie_RAM_SIM900
 5776               	.LVL475:
1051:main_sim900.h ****     POMOC_DODAJ2('#', 'h');
 5777               		.loc 2 1051 0 discriminator 2
 5778 1db4 8CE2      		ldi r24,lo8(44)
 5779 1db6 91E0      		ldi r25,lo8(1)
 5780 1db8 9093 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,r25
 5781 1dbc 8093 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,r24
 5782               	.LVL476:
 5783 1dc0 00C0      		rjmp .L588
 5784               	.LVL477:
 5785               	.L540:
 5786               	.LBE554:
 5787               	.LBB555:
1069:main_sim900.h ****     static const char instrukcja_poziom_sieci[] PROGMEM = "+csq";
 5788               		.loc 2 1069 0
 5789 1dc2 8AE9      		ldi r24,lo8(-102)
 5790 1dc4 0023      		tst r16
 5791 1dc6 01F4      		brne .+2
 5792 1dc8 00C0      		rjmp .L629
1069:main_sim900.h ****     static const char instrukcja_poziom_sieci[] PROGMEM = "+csq";
 5793               		.loc 2 1069 0 is_stmt 0 discriminator 2
 5794 1dca 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5795 1dce 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5796 1dd2 8AE9      		ldi r24,lo8(-102)
 5797 1dd4 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1071:main_sim900.h ****     break;
 5798               		.loc 2 1071 0 is_stmt 1 discriminator 2
 5799 1dd8 80E0      		ldi r24,lo8(instrukcja_poziom_sieci.3402)
 5800 1dda 90E0      		ldi r25,hi8(instrukcja_poziom_sieci.3402)
 5801 1ddc 00C0      		rjmp .L632
 5802               	.L472:
 5803               	.LBE555:
 5804               	.LBB556:
1076:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5805               		.loc 2 1076 0
 5806 1dde 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 5807 1de2 9111      		cpse r25,__zero_reg__
 5808 1de4 00C0      		rjmp .L588
1076:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5809               		.loc 2 1076 0 is_stmt 0 discriminator 1
 5810 1de6 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 5811 1dea 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5812 1dee 232B      		or r18,r19
 5813 1df0 01F0      		breq .+2
 5814 1df2 00C0      		rjmp .L588
1076:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5815               		.loc 2 1076 0 discriminator 2
 5816 1df4 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 5817 1df8 9111      		cpse r25,__zero_reg__
 5818 1dfa 00C0      		rjmp .L588
1077:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 5819               		.loc 2 1077 0 is_stmt 1
 5820 1dfc 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 5821 1e00 9111      		cpse r25,__zero_reg__
 5822 1e02 00C0      		rjmp .L588
1078:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 5823               		.loc 2 1078 0
 5824 1e04 8111      		cpse r24,__zero_reg__
 5825 1e06 00C0      		rjmp .L588
1078:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 5826               		.loc 2 1078 0 is_stmt 0 discriminator 1
 5827 1e08 8091 0000 		lds r24,wysylanie_smsa_clipa
 5828 1e0c 8111      		cpse r24,__zero_reg__
 5829 1e0e 00C0      		rjmp .L588
1082:main_sim900.h ****     static const char instrukcja_creg[] PROGMEM = "+creg?";
 5830               		.loc 2 1082 0 is_stmt 1
 5831 1e10 8CE9      		ldi r24,lo8(-100)
 5832 1e12 0023      		tst r16
 5833 1e14 01F4      		brne .+2
 5834 1e16 00C0      		rjmp .L629
1082:main_sim900.h ****     static const char instrukcja_creg[] PROGMEM = "+creg?";
 5835               		.loc 2 1082 0 is_stmt 0 discriminator 2
 5836 1e18 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5837 1e1c 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5838 1e20 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
1084:main_sim900.h ****     break;
 5839               		.loc 2 1084 0 is_stmt 1 discriminator 2
 5840 1e24 80E0      		ldi r24,lo8(instrukcja_creg.3404)
 5841 1e26 90E0      		ldi r25,hi8(instrukcja_creg.3404)
 5842 1e28 00C0      		rjmp .L632
 5843               	.L490:
 5844               	.LBE556:
 5845               	.LBB557:
1088:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5846               		.loc 2 1088 0
 5847 1e2a 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 5848 1e2e 9111      		cpse r25,__zero_reg__
 5849 1e30 00C0      		rjmp .L544
1088:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5850               		.loc 2 1088 0 is_stmt 0 discriminator 1
 5851 1e32 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 5852 1e36 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5853 1e3a 232B      		or r18,r19
 5854 1e3c 01F4      		brne .L544
1088:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5855               		.loc 2 1088 0 discriminator 2
 5856 1e3e 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 5857 1e42 9111      		cpse r25,__zero_reg__
 5858 1e44 00C0      		rjmp .L544
1089:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 5859               		.loc 2 1089 0 is_stmt 1
 5860 1e46 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 5861 1e4a 9111      		cpse r25,__zero_reg__
 5862 1e4c 00C0      		rjmp .L544
1090:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 5863               		.loc 2 1090 0
 5864 1e4e 8111      		cpse r24,__zero_reg__
 5865 1e50 00C0      		rjmp .L544
1090:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 5866               		.loc 2 1090 0 is_stmt 0 discriminator 1
 5867 1e52 8091 0000 		lds r24,wysylanie_smsa_clipa
 5868 1e56 8823      		tst r24
 5869 1e58 01F0      		breq .L545
 5870               	.L544:
1092:main_sim900.h ****       break;
 5871               		.loc 2 1092 0 is_stmt 1
 5872 1e5a 1092 0000 		sts licznik_blad_stanu_karty_SIM,__zero_reg__
 5873 1e5e 00C0      		rjmp .L588
 5874               	.L545:
1095:main_sim900.h ****     static const char instrukcja_odczyt_ksiazki[] PROGMEM = "+cpbr=26";
 5875               		.loc 2 1095 0
 5876 1e60 88E9      		ldi r24,lo8(-104)
 5877 1e62 0023      		tst r16
 5878 1e64 01F4      		brne .+2
 5879 1e66 00C0      		rjmp .L629
1095:main_sim900.h ****     static const char instrukcja_odczyt_ksiazki[] PROGMEM = "+cpbr=26";
 5880               		.loc 2 1095 0 is_stmt 0 discriminator 2
 5881 1e68 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5882 1e6c 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5883 1e70 88E9      		ldi r24,lo8(-104)
 5884 1e72 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1097:main_sim900.h ****     break;
 5885               		.loc 2 1097 0 is_stmt 1 discriminator 2
 5886 1e76 80E0      		ldi r24,lo8(instrukcja_odczyt_ksiazki.3406)
 5887 1e78 90E0      		ldi r25,hi8(instrukcja_odczyt_ksiazki.3406)
 5888 1e7a 00C0      		rjmp .L632
 5889               	.L492:
 5890               	.LBE557:
 5891               	.LBB558:
1101:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5892               		.loc 2 1101 0
 5893 1e7c 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 5894 1e80 9111      		cpse r25,__zero_reg__
 5895 1e82 00C0      		rjmp .L547
1101:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5896               		.loc 2 1101 0 is_stmt 0 discriminator 1
 5897 1e84 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 5898 1e88 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5899 1e8c 232B      		or r18,r19
 5900 1e8e 01F4      		brne .L547
1101:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5901               		.loc 2 1101 0 discriminator 2
 5902 1e90 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 5903 1e94 9111      		cpse r25,__zero_reg__
 5904 1e96 00C0      		rjmp .L547
1102:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 5905               		.loc 2 1102 0 is_stmt 1
 5906 1e98 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 5907 1e9c 9111      		cpse r25,__zero_reg__
 5908 1e9e 00C0      		rjmp .L547
1103:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 5909               		.loc 2 1103 0
 5910 1ea0 8111      		cpse r24,__zero_reg__
 5911 1ea2 00C0      		rjmp .L547
1103:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 5912               		.loc 2 1103 0 is_stmt 0 discriminator 1
 5913 1ea4 8091 0000 		lds r24,wysylanie_smsa_clipa
 5914 1ea8 8823      		tst r24
 5915 1eaa 01F0      		breq .L548
 5916               	.L547:
1105:main_sim900.h ****       break;
 5917               		.loc 2 1105 0 is_stmt 1
 5918 1eac 1092 0000 		sts licznik_blad_zalogowania_u_operatora,__zero_reg__
 5919 1eb0 00C0      		rjmp .L588
 5920               	.L548:
1108:main_sim900.h ****     static const char instrukcja_sprawdz_operatora[] PROGMEM = "+cops?";
 5921               		.loc 2 1108 0
 5922 1eb2 89E9      		ldi r24,lo8(-103)
 5923 1eb4 0023      		tst r16
 5924 1eb6 01F4      		brne .+2
 5925 1eb8 00C0      		rjmp .L629
1108:main_sim900.h ****     static const char instrukcja_sprawdz_operatora[] PROGMEM = "+cops?";
 5926               		.loc 2 1108 0 is_stmt 0 discriminator 2
 5927 1eba 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5928 1ebe 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5929 1ec2 89E9      		ldi r24,lo8(-103)
 5930 1ec4 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1110:main_sim900.h ****     break;
 5931               		.loc 2 1110 0 is_stmt 1 discriminator 2
 5932 1ec8 80E0      		ldi r24,lo8(instrukcja_sprawdz_operatora.3408)
 5933 1eca 90E0      		ldi r25,hi8(instrukcja_sprawdz_operatora.3408)
 5934 1ecc 00C0      		rjmp .L632
 5935               	.L498:
 5936               	.LBE558:
 5937               	.LBB559:
1114:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5938               		.loc 2 1114 0
 5939 1ece 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 5940 1ed2 9111      		cpse r25,__zero_reg__
 5941 1ed4 00C0      		rjmp .L588
1114:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5942               		.loc 2 1114 0 is_stmt 0 discriminator 1
 5943 1ed6 2091 0000 		lds r18,licznik_bezpieczenstwa_wykonywana_rozmowa
 5944 1eda 3091 0000 		lds r19,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 5945 1ede 232B      		or r18,r19
 5946 1ee0 01F0      		breq .+2
 5947 1ee2 00C0      		rjmp .L588
1114:main_sim900.h ****         opoznienie_zatrzymaj_odpytywanie_urzadzenia ||
 5948               		.loc 2 1114 0 discriminator 2
 5949 1ee4 9091 0000 		lds r25,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 5950 1ee8 9111      		cpse r25,__zero_reg__
 5951 1eea 00C0      		rjmp .L588
1115:main_sim900.h ****         czekanie_na_odebranie_zachety || czy_gsm_zajety ||
 5952               		.loc 2 1115 0 is_stmt 1
 5953 1eec 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 5954 1ef0 9111      		cpse r25,__zero_reg__
 5955 1ef2 00C0      		rjmp .L588
1116:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK)
 5956               		.loc 2 1116 0
 5957 1ef4 8111      		cpse r24,__zero_reg__
 5958 1ef6 00C0      		rjmp .L588
1116:main_sim900.h ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK)
 5959               		.loc 2 1116 0 is_stmt 0 discriminator 1
 5960 1ef8 8091 0000 		lds r24,wysylanie_smsa_clipa
 5961 1efc 8111      		cpse r24,__zero_reg__
 5962 1efe 00C0      		rjmp .L588
1119:main_sim900.h ****     static const char instrukcja_cclk[] PROGMEM = "+cclk?";
 5963               		.loc 2 1119 0 is_stmt 1
 5964 1f00 8DE9      		ldi r24,lo8(-99)
 5965 1f02 0023      		tst r16
 5966 1f04 01F4      		brne .+2
 5967 1f06 00C0      		rjmp .L629
1119:main_sim900.h ****     static const char instrukcja_cclk[] PROGMEM = "+cclk?";
 5968               		.loc 2 1119 0 is_stmt 0 discriminator 2
 5969 1f08 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5970 1f0c 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5971 1f10 8DE9      		ldi r24,lo8(-99)
 5972 1f12 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1121:main_sim900.h ****     break;
 5973               		.loc 2 1121 0 is_stmt 1 discriminator 2
 5974 1f16 80E0      		ldi r24,lo8(instrukcja_cclk.3410)
 5975 1f18 90E0      		ldi r25,hi8(instrukcja_cclk.3410)
 5976 1f1a 00C0      		rjmp .L632
 5977               	.L487:
 5978               	.LBE559:
 5979               	.LBB560:
1125:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM = "+cdscb";
 5980               		.loc 2 1125 0
 5981 1f1c 84E9      		ldi r24,lo8(-108)
 5982 1f1e 0023      		tst r16
 5983 1f20 01F4      		brne .+2
 5984 1f22 00C0      		rjmp .L629
1125:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM = "+cdscb";
 5985               		.loc 2 1125 0 is_stmt 0 discriminator 2
 5986 1f24 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 5987 1f28 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 5988 1f2c 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
1127:main_sim900.h ****     break;
 5989               		.loc 2 1127 0 is_stmt 1 discriminator 2
 5990 1f30 80E0      		ldi r24,lo8(instrukcja_ustawienie_pamieci.3412)
 5991 1f32 90E0      		ldi r25,hi8(instrukcja_ustawienie_pamieci.3412)
 5992 1f34 00C0      		rjmp .L632
 5993               	.L481:
 5994               	.LBE560:
 5995               	.LBB561:
1131:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM =
 5996               		.loc 2 1131 0
 5997 1f36 8EE8      		ldi r24,lo8(-114)
 5998 1f38 0023      		tst r16
 5999 1f3a 01F4      		brne .+2
 6000 1f3c 00C0      		rjmp .L629
1131:main_sim900.h ****     static const char instrukcja_ustawienie_pamieci[] PROGMEM =
 6001               		.loc 2 1131 0 is_stmt 0 discriminator 2
 6002 1f3e 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6003 1f42 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6004 1f46 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
1134:main_sim900.h ****         KOMENDA_KOLEJKI_WSTAWIENIE_MORING_GDY_DZWONI;
 6005               		.loc 2 1134 0 is_stmt 1 discriminator 2
 6006 1f4a 80EA      		ldi r24,lo8(-96)
 6007 1f4c 8093 0000 		sts nastepne_wysylane_polecenie_SIM900,r24
1136:main_sim900.h ****     break;
 6008               		.loc 2 1136 0 discriminator 2
 6009 1f50 80E0      		ldi r24,lo8(instrukcja_ustawienie_pamieci.3414)
 6010 1f52 90E0      		ldi r25,hi8(instrukcja_ustawienie_pamieci.3414)
 6011 1f54 00C0      		rjmp .L632
 6012               	.L478:
 6013               	.LBE561:
1140:main_sim900.h ****     opoznienie_zatrzymaj_odpytywanie_urzadzenia = 20;
 6014               		.loc 2 1140 0
 6015 1f56 8BE8      		ldi r24,lo8(-117)
 6016 1f58 0E94 0000 		call dodaj_komende
 6017               	.LVL478:
1141:main_sim900.h ****     ustaw_odbior_SIM900();
 6018               		.loc 2 1141 0
 6019 1f5c 84E1      		ldi r24,lo8(20)
 6020 1f5e 8093 0000 		sts opoznienie_zatrzymaj_odpytywanie_urzadzenia,r24
1142:main_sim900.h ****     break;
 6021               		.loc 2 1142 0
 6022 1f62 1092 0000 		sts liczba_odebranych_znakow_SIM900+1,__zero_reg__
 6023 1f66 1092 0000 		sts liczba_odebranych_znakow_SIM900,__zero_reg__
 6024 1f6a 1092 0000 		sts licznik_opoznienie_oczekiwania_na_bajt_SIM900,__zero_reg__
 6025 1f6e 80B7      		in r24,0x30
 6026 1f70 8260      		ori r24,lo8(2)
 6027 1f72 80BF      		out 0x30,r24
 6028               	/* #APP */
 6029               	 ;  1142 "main_sim900.h" 1
 6030 1f74 F894      		cli
 6031               	 ;  0 "" 2
 6032               	/* #NOAPP */
 6033 1f76 8091 C100 		lds r24,193
 6034 1f7a 8068      		ori r24,lo8(-128)
 6035 1f7c 8093 C100 		sts 193,r24
 6036               	/* #APP */
 6037               	 ;  1142 "main_sim900.h" 1
 6038 1f80 7894      		sei
 6039               	 ;  0 "" 2
 6040               	 ;  1142 "main_sim900.h" 1
 6041 1f82 0000      		nop
 6042               	 ;  0 "" 2
 6043               	/* #NOAPP */
 6044 1f84 4598      		cbi 0x8,5
 6045 1f86 00C0      		rjmp .L588
 6046               	.L479:
 6047               	.LBB562:
1149:main_sim900.h ****       break;
 6048               		.loc 2 1149 0
 6049 1f88 8091 0000 		lds r24,max_oczekiwanie_na_odpowiedz_at
 6050 1f8c 8111      		cpse r24,__zero_reg__
 6051 1f8e 00C0      		rjmp .L588
1151:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
 6052               		.loc 2 1151 0
 6053 1f90 8091 0000 		lds r24,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6054 1f94 8823      		tst r24
 6055 1f96 01F0      		breq .L553
 6056               	.L554:
1152:main_sim900.h ****       break;
 6057               		.loc 2 1152 0
 6058 1f98 8BE8      		ldi r24,lo8(-117)
 6059 1f9a 00C0      		rjmp .L629
 6060               	.L553:
1155:main_sim900.h ****       dodaj_komende(wykonywana_komenda);
 6061               		.loc 2 1155 0
 6062 1f9c 8091 C100 		lds r24,193
 6063 1fa0 86FD      		sbrc r24,6
 6064 1fa2 00C0      		rjmp .L554
1159:main_sim900.h ****     wysylane_polecenie_SIM900 = wykonywana_komenda;
 6065               		.loc 2 1159 0
 6066 1fa4 1092 0000 		sts liczba_odebranych_znakow_SIM900+1,__zero_reg__
 6067 1fa8 1092 0000 		sts liczba_odebranych_znakow_SIM900,__zero_reg__
 6068 1fac 1092 0000 		sts licznik_opoznienie_oczekiwania_na_bajt_SIM900,__zero_reg__
 6069 1fb0 80B7      		in r24,0x30
 6070 1fb2 8260      		ori r24,lo8(2)
 6071 1fb4 80BF      		out 0x30,r24
 6072               	/* #APP */
 6073               	 ;  1159 "main_sim900.h" 1
 6074 1fb6 F894      		cli
 6075               	 ;  0 "" 2
 6076               	/* #NOAPP */
 6077 1fb8 8091 C100 		lds r24,193
 6078 1fbc 8068      		ori r24,lo8(-128)
 6079 1fbe 8093 C100 		sts 193,r24
 6080               	/* #APP */
 6081               	 ;  1159 "main_sim900.h" 1
 6082 1fc2 7894      		sei
 6083               	 ;  0 "" 2
 6084               	 ;  1159 "main_sim900.h" 1
 6085 1fc4 0000      		nop
 6086               	 ;  0 "" 2
 6087               	/* #NOAPP */
 6088 1fc6 4598      		cbi 0x8,5
1160:main_sim900.h ****     max_oczekiwanie_na_odpowiedz_at = 20;
 6089               		.loc 2 1160 0
 6090 1fc8 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6091 1fcc 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6092 1fd0 8BE8      		ldi r24,lo8(-117)
 6093 1fd2 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1161:main_sim900.h ****     static const char instrukcja_at[] PROGMEM = "+ifc=2,2";
 6094               		.loc 2 1161 0
 6095 1fd6 84E1      		ldi r24,lo8(20)
 6096 1fd8 8093 0000 		sts max_oczekiwanie_na_odpowiedz_at,r24
1163:main_sim900.h ****     break;
 6097               		.loc 2 1163 0
 6098 1fdc 80E0      		ldi r24,lo8(instrukcja_at.3417)
 6099 1fde 90E0      		ldi r25,hi8(instrukcja_at.3417)
 6100 1fe0 00C0      		rjmp .L632
 6101               	.L476:
 6102               	.LBE562:
1167:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_PIN);
 6103               		.loc 2 1167 0
 6104 1fe2 8FEF      		ldi r24,lo8(-1)
 6105 1fe4 8093 0000 		sts podlaczony_modul_gsm_SIM900,r24
1168:main_sim900.h ****     opoznienie_SIM900_100MS = 40;
 6106               		.loc 2 1168 0
 6107 1fe8 8EE9      		ldi r24,lo8(-98)
 6108 1fea 0E94 0000 		call dodaj_komende
 6109               	.LVL479:
1169:main_sim900.h ****     break;
 6110               		.loc 2 1169 0
 6111 1fee 88E2      		ldi r24,lo8(40)
 6112 1ff0 8093 0000 		sts opoznienie_SIM900_100MS,r24
 6113 1ff4 00C0      		rjmp .L588
 6114               	.L482:
 6115               	.LBB563:
1173:main_sim900.h ****     static const char instrukcja_podaj_pin[] PROGMEM = "+cpin=\"1976\"";
 6116               		.loc 2 1173 0
 6117 1ff6 8DE8      		ldi r24,lo8(-115)
 6118 1ff8 0023      		tst r16
 6119 1ffa 01F4      		brne .+2
 6120 1ffc 00C0      		rjmp .L629
1173:main_sim900.h ****     static const char instrukcja_podaj_pin[] PROGMEM = "+cpin=\"1976\"";
 6121               		.loc 2 1173 0 is_stmt 0 discriminator 2
 6122 1ffe 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6123 2002 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6124 2006 8DE8      		ldi r24,lo8(-115)
 6125 2008 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1175:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 6126               		.loc 2 1175 0 is_stmt 1 discriminator 2
 6127 200c 60E0      		ldi r22,lo8(instrukcja_podaj_pin.3420)
 6128 200e 70E0      		ldi r23,hi8(instrukcja_podaj_pin.3420)
 6129 2010 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 6130 2012 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 6131 2014 0E94 0000 		call strcpy_P
 6132               	.LVL480:
 6133 2018 00C0      		rjmp .L630
 6134               	.L474:
 6135               	.LBE563:
 6136               	.LBB564:
1181:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_USTAW_ODBIERANIE_SMSOW);
 6137               		.loc 2 1181 0
 6138 201a 8091 0000 		lds r24,drugi_raz.3422
 6139 201e 8823      		tst r24
 6140 2020 01F0      		breq .L556
1182:main_sim900.h ****       break;
 6141               		.loc 2 1182 0
 6142 2022 8FE9      		ldi r24,lo8(-97)
 6143 2024 00C0      		rjmp .L629
 6144               	.L556:
1185:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6145               		.loc 2 1185 0
 6146 2026 8FEF      		ldi r24,lo8(-1)
 6147 2028 8093 0000 		sts drugi_raz.3422,r24
1186:main_sim900.h ****     static const char instrukcja_usun_wszystkie_smsy[] PROGMEM = "+cmgda=6";
 6148               		.loc 2 1186 0
 6149 202c 81E9      		ldi r24,lo8(-111)
 6150 202e 0023      		tst r16
 6151 2030 01F4      		brne .+2
 6152 2032 00C0      		rjmp .L629
1186:main_sim900.h ****     static const char instrukcja_usun_wszystkie_smsy[] PROGMEM = "+cmgda=6";
 6153               		.loc 2 1186 0 is_stmt 0 discriminator 2
 6154 2034 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6155 2038 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6156 203c 1093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r17
1188:main_sim900.h ****     break;
 6157               		.loc 2 1188 0 is_stmt 1 discriminator 2
 6158 2040 80E0      		ldi r24,lo8(instrukcja_usun_wszystkie_smsy.3423)
 6159 2042 90E0      		ldi r25,hi8(instrukcja_usun_wszystkie_smsy.3423)
 6160 2044 00C0      		rjmp .L632
 6161               	.L480:
 6162               	.LBE564:
1192:main_sim900.h ****     if (komenda_SIM900 != KOMENDA_SIM900_WYSLANE_POLECENIE)
 6163               		.loc 2 1192 0
 6164 2046 0E94 0000 		call obsluga_komendy_SIM900
 6165               	.LVL481:
1193:main_sim900.h ****       max_oczekiwanie_na_odpowiedz = 20;
 6166               		.loc 2 1193 0
 6167 204a 8091 0000 		lds r24,komenda_SIM900
 6168 204e 8138      		cpi r24,lo8(-127)
 6169 2050 01F0      		breq .L558
1194:main_sim900.h ****     resetuj_komende_SIM900();
 6170               		.loc 2 1194 0
 6171 2052 84E1      		ldi r24,lo8(20)
 6172 2054 8093 0000 		sts max_oczekiwanie_na_odpowiedz,r24
 6173               	.L558:
1195:main_sim900.h ****     break;
 6174               		.loc 2 1195 0
 6175 2058 1092 0000 		sts komenda_SIM900,__zero_reg__
 6176 205c 00C0      		rjmp .L588
 6177               	.L560:
 6178               	.LBB565:
1200:main_sim900.h ****     static const char instrukcja[] PROGMEM =
 6179               		.loc 2 1200 0
 6180 205e 0023      		tst r16
 6181 2060 01F4      		brne .+2
 6182 2062 00C0      		rjmp .L559
1200:main_sim900.h ****     static const char instrukcja[] PROGMEM =
 6183               		.loc 2 1200 0 is_stmt 0 discriminator 2
 6184 2064 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6185 2068 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6186 206c 83E9      		ldi r24,lo8(-109)
 6187 206e 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1203:main_sim900.h ****     nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_ROZPOCZNIJ_PRACE;
 6188               		.loc 2 1203 0 is_stmt 1 discriminator 2
 6189 2072 60E0      		ldi r22,lo8(instrukcja.3426)
 6190 2074 70E0      		ldi r23,hi8(instrukcja.3426)
 6191 2076 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 6192 2078 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 6193 207a 0E94 0000 		call strcpy_P
 6194               	.LVL482:
1204:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 6195               		.loc 2 1204 0 discriminator 2
 6196 207e 8FE8      		ldi r24,lo8(-113)
 6197 2080 8093 0000 		sts nastepne_wysylane_polecenie_SIM900,r24
 6198 2084 00C0      		rjmp .L630
 6199               	.L483:
 6200               	.LVL483:
 6201               	.LBE565:
1210:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS);
 6202               		.loc 2 1210 0
 6203 2086 8091 0000 		lds r24,podlaczona_karta_SIM_SIM900
 6204 208a 8823      		tst r24
 6205 208c 01F4      		brne .+2
 6206 208e 00C0      		rjmp .L588
1211:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_MODUL_ZALOGOWANY);
 6207               		.loc 2 1211 0
 6208 2090 84E9      		ldi r24,lo8(-108)
 6209 2092 0E94 0000 		call dodaj_komende
 6210               	.LVL484:
1212:main_sim900.h ****     }
 6211               		.loc 2 1212 0
 6212 2096 80E9      		ldi r24,lo8(-112)
 6213 2098 00C0      		rjmp .L629
 6214               	.LVL485:
 6215               	.L506:
1222:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6216               		.loc 2 1222 0
 6217 209a 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 6218 209e 8111      		cpse r24,__zero_reg__
 6219 20a0 00C0      		rjmp .L561
1222:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6220               		.loc 2 1222 0 is_stmt 0 discriminator 2
 6221 20a2 8091 0000 		lds r24,liczba_znakow_do_zapisu
 6222 20a6 8111      		cpse r24,__zero_reg__
 6223 20a8 00C0      		rjmp .L561
1222:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6224               		.loc 2 1222 0 discriminator 4
 6225 20aa 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 6226 20ae 8111      		cpse r24,__zero_reg__
 6227 20b0 00C0      		rjmp .L561
1222:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6228               		.loc 2 1222 0 discriminator 6
 6229 20b2 F99B      		sbis 0x1f,1
 6230 20b4 00C0      		rjmp .L562
 6231               	.L561:
1222:main_sim900.h ****     JESLI_SIM900_WYSYLA_DANE_WYKONAJ_POZNIEJ();
 6232               		.loc 2 1222 0 discriminator 7
 6233 20b6 8DEF      		ldi r24,lo8(-3)
 6234 20b8 00C0      		rjmp .L629
 6235               	.L562:
1223:main_sim900.h ****     strcpy(wysylane_dane_RAM_SIM900, bufor_ustaw_czas);
 6236               		.loc 2 1223 0 is_stmt 1
 6237 20ba 0023      		tst r16
 6238 20bc 01F0      		breq .L561
1223:main_sim900.h ****     strcpy(wysylane_dane_RAM_SIM900, bufor_ustaw_czas);
 6239               		.loc 2 1223 0 is_stmt 0 discriminator 2
 6240 20be 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6241 20c2 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6242 20c6 8DEF      		ldi r24,lo8(-3)
 6243 20c8 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1224:main_sim900.h ****     wyslij_polecenie_RAM_SIM900();
 6244               		.loc 2 1224 0 is_stmt 1 discriminator 2
 6245 20cc 60E0      		ldi r22,lo8(bufor_ustaw_czas)
 6246 20ce 70E0      		ldi r23,hi8(bufor_ustaw_czas)
 6247 20d0 80E0      		ldi r24,lo8(wysylany_blok_SIM900+2)
 6248 20d2 90E0      		ldi r25,hi8(wysylany_blok_SIM900+2)
 6249 20d4 0E94 0000 		call strcpy
 6250               	.LVL486:
 6251 20d8 00C0      		rjmp .L630
 6252               		.cfi_endproc
 6253               	.LFE53:
 6255               	.global	steruj_SIM900_100MS
 6257               	steruj_SIM900_100MS:
 6258               	.LFB54:
1274:main_sim900.h **** 
1275:main_sim900.h **** void steruj_SIM900_100MS(void) {
 6259               		.loc 2 1275 0
 6260               		.cfi_startproc
 6261               	/* prologue: function */
 6262               	/* frame size = 0 */
 6263               	/* stack size = 0 */
 6264               	.L__stack_usage = 0
1276:main_sim900.h ****   if (opoznienie_SIM900_100MS && --opoznienie_SIM900_100MS == 0)
 6265               		.loc 2 1276 0
 6266 20da 8091 0000 		lds r24,opoznienie_SIM900_100MS
 6267 20de 8823      		tst r24
 6268 20e0 01F0      		breq .L639
 6269               		.loc 2 1276 0 is_stmt 0 discriminator 1
 6270 20e2 8150      		subi r24,lo8(-(-1))
 6271 20e4 8093 0000 		sts opoznienie_SIM900_100MS,r24
 6272 20e8 8111      		cpse r24,__zero_reg__
 6273 20ea 00C0      		rjmp .L639
1277:main_sim900.h ****     oproznij_bufor_SIM900_po_bledzie = FALSE;
 6274               		.loc 2 1277 0 is_stmt 1
 6275 20ec 1092 0000 		sts oproznij_bufor_SIM900_po_bledzie,__zero_reg__
 6276               	.L639:
1278:main_sim900.h **** 
1279:main_sim900.h ****   if (opoznienie_wysylania_clipow_100MS)
 6277               		.loc 2 1279 0
 6278 20f0 8091 0000 		lds r24,opoznienie_wysylania_clipow_100MS
 6279 20f4 9091 0000 		lds r25,opoznienie_wysylania_clipow_100MS+1
 6280 20f8 0097      		sbiw r24,0
 6281 20fa 01F0      		breq .L641
1280:main_sim900.h ****     --opoznienie_wysylania_clipow_100MS;
 6282               		.loc 2 1280 0
 6283 20fc 0197      		sbiw r24,1
 6284 20fe 9093 0000 		sts opoznienie_wysylania_clipow_100MS+1,r25
 6285 2102 8093 0000 		sts opoznienie_wysylania_clipow_100MS,r24
 6286               	.L641:
1281:main_sim900.h **** 
1282:main_sim900.h ****   // Timeout rozmowy - automatyczne rozlaczenie po 30 sekundach
1283:main_sim900.h ****   if (licznik_timeout_rozmowy_100ms) {
 6287               		.loc 2 1283 0
 6288 2106 8091 0000 		lds r24,licznik_timeout_rozmowy_100ms
 6289 210a 9091 0000 		lds r25,licznik_timeout_rozmowy_100ms+1
 6290 210e 0097      		sbiw r24,0
 6291 2110 01F0      		breq .L643
1284:main_sim900.h ****     if (--licznik_timeout_rozmowy_100ms == 0 &&
 6292               		.loc 2 1284 0
 6293 2112 0197      		sbiw r24,1
 6294 2114 9093 0000 		sts licznik_timeout_rozmowy_100ms+1,r25
 6295 2118 8093 0000 		sts licznik_timeout_rozmowy_100ms,r24
 6296 211c 892B      		or r24,r25
 6297 211e 01F4      		brne .L643
 6298               		.loc 2 1284 0 is_stmt 0 discriminator 1
 6299 2120 8091 0000 		lds r24,trwa_rozmowa_przychodzaca_od_uzytkownika
 6300 2124 8823      		tst r24
 6301 2126 01F0      		breq .L643
1285:main_sim900.h ****         trwa_rozmowa_przychodzaca_od_uzytkownika) {
1286:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
 6302               		.loc 2 1286 0 is_stmt 1
 6303 2128 86E9      		ldi r24,lo8(-106)
 6304 212a 0E94 0000 		call dodaj_komende
 6305               	.LVL487:
 6306               	.L643:
1287:main_sim900.h ****       POMOC_DODAJ2('#', 'X'); // Timeout marker
1288:main_sim900.h ****     }
1289:main_sim900.h ****   }
1290:main_sim900.h **** 
1291:main_sim900.h ****   if (max_oczekiwanie_na_odpowiedz_at) {
 6307               		.loc 2 1291 0
 6308 212e 8091 0000 		lds r24,max_oczekiwanie_na_odpowiedz_at
 6309 2132 8823      		tst r24
 6310 2134 01F0      		breq .L646
1292:main_sim900.h ****     if (--max_oczekiwanie_na_odpowiedz_at == 0) {
 6311               		.loc 2 1292 0
 6312 2136 8150      		subi r24,lo8(-(-1))
 6313 2138 8093 0000 		sts max_oczekiwanie_na_odpowiedz_at,r24
 6314 213c 8111      		cpse r24,__zero_reg__
 6315 213e 00C0      		rjmp .L646
1293:main_sim900.h ****       wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 6316               		.loc 2 1293 0
 6317 2140 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6318 2144 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6319 2148 1092 0000 		sts aktualnie_wysylane_polecenie_SIM900,__zero_reg__
1294:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT);
 6320               		.loc 2 1294 0
 6321 214c 8BE8      		ldi r24,lo8(-117)
 6322 214e 0E94 0000 		call dodaj_komende
 6323               	.LVL488:
1295:main_sim900.h ****       sprawdzaj_wejscie_CTS_SIM900 = FALSE;
 6324               		.loc 2 1295 0
 6325 2152 1092 0000 		sts sprawdzaj_wejscie_CTS_SIM900,__zero_reg__
1296:main_sim900.h ****       zakoncz_wysylanie_SIM900();
 6326               		.loc 2 1296 0
 6327               	/* #APP */
 6328               	 ;  1296 "main_sim900.h" 1
 6329 2156 F894      		cli
 6330               	 ;  0 "" 2
 6331               	/* #NOAPP */
 6332 2158 8091 C100 		lds r24,193
 6333 215c 8F7B      		andi r24,lo8(-65)
 6334 215e 8093 C100 		sts 193,r24
 6335               	/* #APP */
 6336               	 ;  1296 "main_sim900.h" 1
 6337 2162 7894      		sei
 6338               	 ;  0 "" 2
 6339               	 ;  1296 "main_sim900.h" 1
 6340 2164 0000      		nop
 6341               	 ;  0 "" 2
 6342               	/* #NOAPP */
 6343               	.L646:
1297:main_sim900.h ****     }
1298:main_sim900.h ****   }
1299:main_sim900.h **** 
1300:main_sim900.h ****   if (procedura_inicjalizacyjna_SIM900_100MS())
 6344               		.loc 2 1300 0
 6345 2166 0E94 0000 		call procedura_inicjalizacyjna_SIM900_100MS
 6346               	.LVL489:
 6347 216a 8823      		tst r24
 6348 216c 01F0      		breq .L648
1301:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_PODLACZONY_MODUL_GSM);
 6349               		.loc 2 1301 0
 6350 216e 8AE8      		ldi r24,lo8(-118)
 6351 2170 0E94 0000 		call dodaj_komende
 6352               	.LVL490:
 6353               	.L648:
1302:main_sim900.h **** 
1303:main_sim900.h ****   if (maksymalny_czas_dzwonienia) {
 6354               		.loc 2 1303 0
 6355 2174 8091 0000 		lds r24,maksymalny_czas_dzwonienia
 6356 2178 8823      		tst r24
 6357 217a 01F0      		breq .L650
1304:main_sim900.h ****     if (--maksymalny_czas_dzwonienia == 0) {
 6358               		.loc 2 1304 0
 6359 217c 8150      		subi r24,lo8(-(-1))
 6360 217e 8093 0000 		sts maksymalny_czas_dzwonienia,r24
 6361 2182 8111      		cpse r24,__zero_reg__
 6362 2184 00C0      		rjmp .L650
 6363               	.LVL491:
1305:main_sim900.h ****       POMOC_DODAJ2('#', 'i');
1306:main_sim900.h ****       dodaj_komende(KOMENDA_KOLEJKI_ODRZUC_ROZMOWE);
 6364               		.loc 2 1306 0
 6365 2186 86E9      		ldi r24,lo8(-106)
 6366 2188 0E94 0000 		call dodaj_komende
 6367               	.LVL492:
 6368               	.L650:
1307:main_sim900.h ****     }
1308:main_sim900.h ****   }
1309:main_sim900.h **** 
1310:main_sim900.h ****   if (licznik_bezpieczenstwa_wykonywana_rozmowa) {
 6369               		.loc 2 1310 0
 6370 218c 8091 0000 		lds r24,licznik_bezpieczenstwa_wykonywana_rozmowa
 6371 2190 9091 0000 		lds r25,licznik_bezpieczenstwa_wykonywana_rozmowa+1
 6372 2194 0097      		sbiw r24,0
 6373 2196 01F0      		breq .L653
1311:main_sim900.h ****     if (--licznik_bezpieczenstwa_wykonywana_rozmowa == 0) {
 6374               		.loc 2 1311 0
 6375 2198 0197      		sbiw r24,1
 6376 219a 9093 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa+1,r25
 6377 219e 8093 0000 		sts licznik_bezpieczenstwa_wykonywana_rozmowa,r24
 6378 21a2 892B      		or r24,r25
 6379 21a4 01F4      		brne .L653
 6380               	.LVL493:
1312:main_sim900.h ****       POMOC_DODAJ2('#', 'j');
1313:main_sim900.h ****       zakonczono_rozmowe_telefoniczna(
 6381               		.loc 2 1313 0
 6382 21a6 82E0      		ldi r24,lo8(2)
 6383 21a8 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 6384               	.LVL494:
1314:main_sim900.h ****           powod_zakonczenia_rozmowy_przekroczony_czas);
1315:main_sim900.h ****       trwa_rozmowa_przychodzaca_od_uzytkownika = FALSE;
 6385               		.loc 2 1315 0
 6386 21ac 1092 0000 		sts trwa_rozmowa_przychodzaca_od_uzytkownika,__zero_reg__
1316:main_sim900.h ****       wykonywanie_rozmowy_telefonicznej = FALSE;
 6387               		.loc 2 1316 0
 6388 21b0 1092 0000 		sts wykonywanie_rozmowy_telefonicznej,__zero_reg__
 6389               	.LVL495:
 6390               	.L653:
 6391               	.LBB566:
1317:main_sim900.h ****     }
1318:main_sim900.h ****   }
1319:main_sim900.h **** 
1320:main_sim900.h **** #ifndef WYLACZ_AUTOMATYCZNE_KONTROLOWANIE_SIMCOM
1321:main_sim900.h **** 
1322:main_sim900.h ****   { // poziom sieci i zalogowanie u operatora
1323:main_sim900.h ****     static uchar licznik_cyklu_8_sek = 0;
1324:main_sim900.h ****     if (++licznik_cyklu_8_sek == 48)
 6392               		.loc 2 1324 0
 6393 21b4 8091 0000 		lds r24,licznik_cyklu_8_sek.3450
 6394 21b8 8F5F      		subi r24,lo8(-(1))
 6395 21ba 8093 0000 		sts licznik_cyklu_8_sek.3450,r24
 6396 21be 8033      		cpi r24,lo8(48)
 6397 21c0 01F0      		breq .+2
 6398 21c2 00C0      		rjmp .L655
1325:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_POZIOM_SIECI);
 6399               		.loc 2 1325 0
 6400 21c4 8AE9      		ldi r24,lo8(-102)
 6401               	.L697:
1326:main_sim900.h ****     else if (licznik_cyklu_8_sek == 52)
1327:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_ZAREJESTROWANIE);
1328:main_sim900.h ****     else if (licznik_cyklu_8_sek == 56)
1329:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_ZALOGOWANIE_U_OPERATORA);
1330:main_sim900.h ****     else if (licznik_cyklu_8_sek == 60) {
1331:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_STAN_KARTY_SIM);
1332:main_sim900.h ****     } else if (licznik_cyklu_8_sek >= 80) {
1333:main_sim900.h ****       licznik_cyklu_8_sek = 0;
1334:main_sim900.h ****       if (modul_zalogowany_w_sieci)
1335:main_sim900.h ****         filtruj_i_dodaj_komende(
 6402               		.loc 2 1335 0
 6403 21c6 0E94 0000 		call filtruj_i_dodaj_komende
 6404               	.LVL496:
 6405               	.L656:
 6406               	.LBE566:
1336:main_sim900.h ****             KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE);
1337:main_sim900.h ****     }
1338:main_sim900.h ****   }
1339:main_sim900.h **** 
1340:main_sim900.h ****   if (opoznienie_zatrzymaj_odpytywanie_urzadzenia)
 6407               		.loc 2 1340 0
 6408 21ca 8091 0000 		lds r24,opoznienie_zatrzymaj_odpytywanie_urzadzenia
 6409 21ce 8823      		tst r24
 6410 21d0 01F0      		breq .L662
1341:main_sim900.h ****     --opoznienie_zatrzymaj_odpytywanie_urzadzenia;
 6411               		.loc 2 1341 0
 6412 21d2 8150      		subi r24,lo8(-(-1))
 6413 21d4 8093 0000 		sts opoznienie_zatrzymaj_odpytywanie_urzadzenia,r24
 6414               	.L662:
1342:main_sim900.h **** 
1343:main_sim900.h ****   if (modul_zalogowany_w_sieci &&
 6415               		.loc 2 1343 0
 6416 21d8 8091 0000 		lds r24,modul_zalogowany_w_sieci
 6417 21dc 8823      		tst r24
 6418 21de 01F4      		brne .+2
 6419 21e0 00C0      		rjmp .L663
1344:main_sim900.h ****       (poziom_sieci_gsm == POZIOM_SIECI_BLAD || poziom_sieci_gsm == 0)) {
 6420               		.loc 2 1344 0 discriminator 1
 6421 21e2 8091 0000 		lds r24,poziom_sieci_gsm
1343:main_sim900.h ****       (poziom_sieci_gsm == POZIOM_SIECI_BLAD || poziom_sieci_gsm == 0)) {
 6422               		.loc 2 1343 0 discriminator 1
 6423 21e6 8336      		cpi r24,lo8(99)
 6424 21e8 01F0      		breq .L664
 6425               		.loc 2 1344 0
 6426 21ea 8111      		cpse r24,__zero_reg__
 6427 21ec 00C0      		rjmp .L663
 6428               	.L664:
1345:main_sim900.h ****     if (licznik_awaria_brak_zasiegu < MAX_LICZNIK_AWARIA_BRAK_ZASIEGU) {
 6429               		.loc 2 1345 0
 6430 21ee 8091 0000 		lds r24,licznik_awaria_brak_zasiegu
 6431 21f2 9091 0000 		lds r25,licznik_awaria_brak_zasiegu+1
 6432 21f6 8835      		cpi r24,88
 6433 21f8 22E0      		ldi r18,2
 6434 21fa 9207      		cpc r25,r18
 6435 21fc 00F4      		brsh .L666
1346:main_sim900.h ****       if (++licznik_awaria_brak_zasiegu == MAX_LICZNIK_AWARIA_BRAK_ZASIEGU) {
 6436               		.loc 2 1346 0
 6437 21fe 0196      		adiw r24,1
 6438 2200 8835      		cpi r24,88
 6439 2202 22E0      		ldi r18,2
 6440 2204 9207      		cpc r25,r18
 6441 2206 01F4      		brne .+2
 6442 2208 00C0      		rjmp .L667
 6443 220a 9093 0000 		sts licznik_awaria_brak_zasiegu+1,r25
 6444 220e 8093 0000 		sts licznik_awaria_brak_zasiegu,r24
 6445               	.L666:
1347:main_sim900.h ****         licznik_awaria_brak_zasiegu = 0;
1348:main_sim900.h ****         POMOC_DODAJ2('*', 'j');
1349:main_sim900.h ****         reset_modulu_SIM900();
1350:main_sim900.h ****       }
1351:main_sim900.h ****     }
1352:main_sim900.h ****   } else
1353:main_sim900.h ****     licznik_awaria_brak_zasiegu = 0;
1354:main_sim900.h **** 
1355:main_sim900.h ****   if (CZY_BLAD_KARTY_SIM() || CZY_BLAD_ZALOGOWANIA_U_OPERATORA()) {
 6446               		.loc 2 1355 0
 6447 2212 8091 0000 		lds r24,licznik_blad_stanu_karty_SIM
 6448 2216 8630      		cpi r24,lo8(6)
 6449 2218 00F4      		brsh .L669
 6450               		.loc 2 1355 0 is_stmt 0 discriminator 1
 6451 221a 8091 0000 		lds r24,licznik_blad_zalogowania_u_operatora
 6452 221e 8431      		cpi r24,lo8(20)
 6453 2220 00F0      		brlo .L670
 6454               	.L669:
 6455               	.LVL497:
1356:main_sim900.h ****     POMOC_DODAJ2('*', 'k');
1357:main_sim900.h ****     reset_modulu_SIM900();
 6456               		.loc 2 1357 0 is_stmt 1
 6457 2222 0E94 0000 		call reset_modulu_SIM900
 6458               	.LVL498:
 6459               	.L670:
1358:main_sim900.h ****   }
1359:main_sim900.h **** #endif
1360:main_sim900.h **** 
1361:main_sim900.h ****   if (licznik_reset_modulu_SIM900) {
 6460               		.loc 2 1361 0
 6461 2226 8091 0000 		lds r24,licznik_reset_modulu_SIM900
 6462 222a 8823      		tst r24
 6463 222c 01F0      		breq .L672
1362:main_sim900.h ****     if (--licznik_reset_modulu_SIM900 == 0) {
 6464               		.loc 2 1362 0
 6465 222e 8150      		subi r24,lo8(-(-1))
 6466 2230 8093 0000 		sts licznik_reset_modulu_SIM900,r24
 6467 2234 8111      		cpse r24,__zero_reg__
 6468 2236 00C0      		rjmp .L672
 6469               	.LVL499:
1363:main_sim900.h ****       POMOC_DODAJ2('*', 'l');
1364:main_sim900.h ****       reset_modulu_SIM900();
 6470               		.loc 2 1364 0
 6471 2238 0E94 0000 		call reset_modulu_SIM900
 6472               	.LVL500:
 6473               	.L672:
1365:main_sim900.h ****     }
1366:main_sim900.h ****   }
1367:main_sim900.h **** 
1368:main_sim900.h ****   if (!modul_zalogowany_w_sieci) {
 6474               		.loc 2 1368 0
 6475 223c 8091 0000 		lds r24,modul_zalogowany_w_sieci
 6476 2240 8111      		cpse r24,__zero_reg__
 6477 2242 00C0      		rjmp .L674
1369:main_sim900.h ****     if (++licznik_ogolny_blad_zalogowania > MAX_LICZNIK_OGOLNY_BLAD_ZALOGOWANIA)
 6478               		.loc 2 1369 0
 6479 2244 8091 0000 		lds r24,licznik_ogolny_blad_zalogowania
 6480 2248 9091 0000 		lds r25,licznik_ogolny_blad_zalogowania+1
 6481 224c 0196      		adiw r24,1
 6482 224e 9093 0000 		sts licznik_ogolny_blad_zalogowania+1,r25
 6483 2252 8093 0000 		sts licznik_ogolny_blad_zalogowania,r24
 6484 2256 813B      		cpi r24,-79
 6485 2258 9440      		sbci r25,4
 6486 225a 00F0      		brlo .L637
1370:main_sim900.h ****       reset_modulu_SIM900();
 6487               		.loc 2 1370 0
 6488 225c 0C94 0000 		jmp reset_modulu_SIM900
 6489               	.LVL501:
 6490               	.L655:
 6491               	.LBB567:
1326:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_ZAREJESTROWANIE);
 6492               		.loc 2 1326 0
 6493 2260 8433      		cpi r24,lo8(52)
 6494 2262 01F4      		brne .L657
1327:main_sim900.h ****     else if (licznik_cyklu_8_sek == 56)
 6495               		.loc 2 1327 0
 6496 2264 8CE9      		ldi r24,lo8(-100)
 6497 2266 00C0      		rjmp .L697
 6498               	.L657:
1328:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_ZALOGOWANIE_U_OPERATORA);
 6499               		.loc 2 1328 0
 6500 2268 8833      		cpi r24,lo8(56)
 6501 226a 01F4      		brne .L658
1329:main_sim900.h ****     else if (licznik_cyklu_8_sek == 60) {
 6502               		.loc 2 1329 0
 6503 226c 89E9      		ldi r24,lo8(-103)
 6504 226e 00C0      		rjmp .L697
 6505               	.L658:
1330:main_sim900.h ****       filtruj_i_dodaj_komende(KOMENDA_KOLEJKI_SPRAWDZ_STAN_KARTY_SIM);
 6506               		.loc 2 1330 0
 6507 2270 8C33      		cpi r24,lo8(60)
 6508 2272 01F4      		brne .L659
1331:main_sim900.h ****     } else if (licznik_cyklu_8_sek >= 80) {
 6509               		.loc 2 1331 0
 6510 2274 88E9      		ldi r24,lo8(-104)
 6511 2276 00C0      		rjmp .L697
 6512               	.L659:
1332:main_sim900.h ****       licznik_cyklu_8_sek = 0;
 6513               		.loc 2 1332 0
 6514 2278 8035      		cpi r24,lo8(80)
 6515 227a 00F4      		brsh .+2
 6516 227c 00C0      		rjmp .L656
 6517 227e 8091 0000 		lds r24,modul_zalogowany_w_sieci
1333:main_sim900.h ****       if (modul_zalogowany_w_sieci)
 6518               		.loc 2 1333 0
 6519 2282 1092 0000 		sts licznik_cyklu_8_sek.3450,__zero_reg__
1334:main_sim900.h ****         filtruj_i_dodaj_komende(
 6520               		.loc 2 1334 0
 6521 2286 8823      		tst r24
 6522 2288 01F4      		brne .+2
 6523 228a 00C0      		rjmp .L656
1335:main_sim900.h ****             KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_ODCZYTAJ_GODZINE);
 6524               		.loc 2 1335 0
 6525 228c 8DE9      		ldi r24,lo8(-99)
 6526 228e 00C0      		rjmp .L697
 6527               	.L667:
 6528               	.LBE567:
1347:main_sim900.h ****         POMOC_DODAJ2('*', 'j');
 6529               		.loc 2 1347 0
 6530 2290 1092 0000 		sts licznik_awaria_brak_zasiegu+1,__zero_reg__
 6531 2294 1092 0000 		sts licznik_awaria_brak_zasiegu,__zero_reg__
 6532               	.LVL502:
1349:main_sim900.h ****       }
 6533               		.loc 2 1349 0
 6534 2298 0E94 0000 		call reset_modulu_SIM900
 6535               	.LVL503:
 6536 229c 00C0      		rjmp .L666
 6537               	.LVL504:
 6538               	.L663:
1353:main_sim900.h **** 
 6539               		.loc 2 1353 0
 6540 229e 1092 0000 		sts licznik_awaria_brak_zasiegu+1,__zero_reg__
 6541 22a2 1092 0000 		sts licznik_awaria_brak_zasiegu,__zero_reg__
 6542 22a6 00C0      		rjmp .L666
 6543               	.L674:
1371:main_sim900.h ****   } else
1372:main_sim900.h ****     licznik_ogolny_blad_zalogowania = 0;
 6544               		.loc 2 1372 0
 6545 22a8 1092 0000 		sts licznik_ogolny_blad_zalogowania+1,__zero_reg__
 6546 22ac 1092 0000 		sts licznik_ogolny_blad_zalogowania,__zero_reg__
 6547               	.L637:
 6548               	/* epilogue start */
1373:main_sim900.h **** }
 6549               		.loc 2 1373 0
 6550 22b0 0895      		ret
 6551               		.cfi_endproc
 6552               	.LFE54:
 6554               	.global	steruj_SIM900_10MS
 6556               	steruj_SIM900_10MS:
 6557               	.LFB55:
1374:main_sim900.h **** 
1375:main_sim900.h **** void steruj_SIM900_10MS(void) {
 6558               		.loc 2 1375 0
 6559               		.cfi_startproc
 6560               	/* prologue: function */
 6561               	/* frame size = 0 */
 6562               	/* stack size = 0 */
 6563               	.L__stack_usage = 0
1376:main_sim900.h ****   if (czy_jest_komenda_SIM900())
 6564               		.loc 2 1376 0
 6565 22b2 8091 0000 		lds r24,komenda_SIM900
 6566 22b6 8823      		tst r24
 6567 22b8 01F4      		brne .+2
 6568 22ba 00C0      		rjmp .L699
 6569               	.L701:
1377:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_KOMENDA_SIM900);
 6570               		.loc 2 1377 0
 6571 22bc 89E8      		ldi r24,lo8(-119)
 6572 22be 0E94 0000 		call dodaj_komende
 6573               	.LVL505:
 6574               	.L700:
1378:main_sim900.h **** 
1379:main_sim900.h ****   if (flaga_odebrany_znak_zachety) {
 6575               		.loc 2 1379 0
 6576 22c2 8091 0000 		lds r24,flaga_odebrany_znak_zachety
 6577 22c6 8823      		tst r24
 6578 22c8 01F0      		breq .L702
1380:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_PDU);
 6579               		.loc 2 1380 0
 6580 22ca 84ED      		ldi r24,lo8(-44)
 6581 22cc 0E94 0000 		call dodaj_komende
 6582               	.LVL506:
1381:main_sim900.h ****     // czekanie_na_odebranie_zachety = FALSE;	// byo
1382:main_sim900.h ****     flaga_odebrany_znak_zachety = FALSE;
 6583               		.loc 2 1382 0
 6584 22d0 1092 0000 		sts flaga_odebrany_znak_zachety,__zero_reg__
 6585               	.LVL507:
 6586               	.L702:
 6587               	.LBB568:
1383:main_sim900.h ****     POMOC_DODAJ2('#', 'm');
1384:main_sim900.h ****   }
1385:main_sim900.h **** 
1386:main_sim900.h ****   { // kontrola wysyania sms-w i clipw
1387:main_sim900.h ****     static uint licznik_bezpieczenstwa = 0;
1388:main_sim900.h ****     if (modul_zalogowany_w_sieci && flaga_wysylanie_smsa) {
 6588               		.loc 2 1388 0
 6589 22d4 8091 0000 		lds r24,modul_zalogowany_w_sieci
 6590 22d8 8823      		tst r24
 6591 22da 01F4      		brne .+2
 6592 22dc 00C0      		rjmp .L703
 6593               		.loc 2 1388 0 is_stmt 0 discriminator 1
 6594 22de 8091 0000 		lds r24,flaga_wysylanie_smsa
 6595 22e2 8823      		tst r24
 6596 22e4 01F4      		brne .+2
 6597 22e6 00C0      		rjmp .L703
1389:main_sim900.h ****       if (++licznik_bezpieczenstwa >= 5000) // 50 sek
 6598               		.loc 2 1389 0 is_stmt 1
 6599 22e8 8091 0000 		lds r24,licznik_bezpieczenstwa.3454
 6600 22ec 9091 0000 		lds r25,licznik_bezpieczenstwa.3454+1
 6601 22f0 0196      		adiw r24,1
 6602 22f2 8838      		cpi r24,-120
 6603 22f4 23E1      		ldi r18,19
 6604 22f6 9207      		cpc r25,r18
 6605 22f8 00F0      		brlo .+2
 6606 22fa 00C0      		rjmp .L704
 6607 22fc 9093 0000 		sts licznik_bezpieczenstwa.3454+1,r25
 6608 2300 8093 0000 		sts licznik_bezpieczenstwa.3454,r24
 6609               	.L705:
 6610               	.LBE568:
 6611               	.LBB569:
1390:main_sim900.h ****       {
1391:main_sim900.h ****         POMOC_DODAJ2('#', 'Z');
1392:main_sim900.h ****         licznik_bezpieczenstwa = 0;
1393:main_sim900.h ****         komenda_SIM900 = ERROR_KOMENDA_SIM900;
1394:main_sim900.h ****         obsluga_wysylania_sms();
1395:main_sim900.h ****       }
1396:main_sim900.h ****     } else
1397:main_sim900.h ****       licznik_bezpieczenstwa = 0;
1398:main_sim900.h ****   }
1399:main_sim900.h **** 
1400:main_sim900.h ****   { // kontrola programu: zbyt dugi okres wykonywania polecenia do SIM900 lub
1401:main_sim900.h ****     // jego brak
1402:main_sim900.h ****     static komenda_typ poprzednia_komenda;
1403:main_sim900.h ****     static uint licznik_poprzednia_komenda;
1404:main_sim900.h ****     static uint licznik_odebranych_znakow;
1405:main_sim900.h ****     if (aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY &&
 6612               		.loc 2 1405 0
 6613 2304 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 6614 2308 9091 0000 		lds r25,trwa_rozmowa_przychodzaca_od_uzytkownika
 6615 230c 8823      		tst r24
 6616 230e 01F4      		brne .+2
 6617 2310 00C0      		rjmp .L706
 6618               		.loc 2 1405 0 is_stmt 0 discriminator 1
 6619 2312 2091 0000 		lds r18,poprzednia_komenda.3455
 6620 2316 8213      		cpse r24,r18
 6621 2318 00C0      		rjmp .L707
1406:main_sim900.h ****         aktualnie_wysylane_polecenie_SIM900 == poprzednia_komenda &&
 6622               		.loc 2 1406 0 is_stmt 1
 6623 231a 9111      		cpse r25,__zero_reg__
 6624 231c 00C0      		rjmp .L708
 6625               	.LVL508:
 6626               	.LBB570:
1407:main_sim900.h ****         !trwa_rozmowa_przychodzaca_od_uzytkownika) {
1408:main_sim900.h ****       uint max_licznik_poprzednia_komenda = 5 * 100; // 5 sek;
1409:main_sim900.h ****       if (aktualnie_wysylane_polecenie_SIM900 ==
 6627               		.loc 2 1409 0
 6628 231e 8B38      		cpi r24,lo8(-117)
 6629 2320 01F0      		breq .L722
1410:main_sim900.h ****               KOMENDA_KOLEJKI_WYSLIJ_DO_SIM900_AT ||
 6630               		.loc 2 1410 0
 6631 2322 9CE2      		ldi r25,lo8(44)
 6632 2324 980F      		add r25,r24
1408:main_sim900.h ****       if (aktualnie_wysylane_polecenie_SIM900 ==
 6633               		.loc 2 1408 0
 6634 2326 44EF      		ldi r20,lo8(-12)
 6635 2328 51E0      		ldi r21,lo8(1)
 6636               		.loc 2 1410 0
 6637 232a 9230      		cpi r25,lo8(2)
 6638 232c 00F4      		brsh .L709
 6639               	.L722:
1411:main_sim900.h ****           aktualnie_wysylane_polecenie_SIM900 == KOMENDA_KOLEJKI_WYSLIJ_PDU ||
1412:main_sim900.h ****           aktualnie_wysylane_polecenie_SIM900 ==
1413:main_sim900.h ****               KOMENDA_KOLEJKI_WYKONAJ_ROZMOWE)
1414:main_sim900.h ****         max_licznik_poprzednia_komenda = 2 * 60 * 100; // 2 minuty
 6640               		.loc 2 1414 0
 6641 232e 40EE      		ldi r20,lo8(-32)
 6642 2330 5EE2      		ldi r21,lo8(46)
 6643               	.L709:
 6644               	.LVL509:
1415:main_sim900.h **** 
1416:main_sim900.h ****       if (aktualnie_wysylane_polecenie_SIM900 ==
1417:main_sim900.h ****               KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT // zmienione (1)
1418:main_sim900.h ****           || aktualnie_wysylane_polecenie_SIM900 ==
 6645               		.loc 2 1418 0
 6646 2332 9EE2      		ldi r25,lo8(46)
 6647 2334 980F      		add r25,r24
1416:main_sim900.h ****               KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT // zmienione (1)
 6648               		.loc 2 1416 0
 6649 2336 9230      		cpi r25,lo8(2)
 6650 2338 00F4      		brsh .L710
1419:main_sim900.h ****                  KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU)
1420:main_sim900.h ****         max_licznik_poprzednia_komenda = 15 * 100;
 6651               		.loc 2 1420 0
 6652 233a 4CED      		ldi r20,lo8(-36)
 6653 233c 55E0      		ldi r21,lo8(5)
 6654               	.LVL510:
 6655               	.L710:
1421:main_sim900.h **** 
1422:main_sim900.h ****       if (++licznik_poprzednia_komenda >= max_licznik_poprzednia_komenda) {
 6656               		.loc 2 1422 0
 6657 233e 2091 0000 		lds r18,licznik_poprzednia_komenda.3456
 6658 2342 3091 0000 		lds r19,licznik_poprzednia_komenda.3456+1
 6659 2346 2F5F      		subi r18,-1
 6660 2348 3F4F      		sbci r19,-1
 6661 234a 2417      		cp r18,r20
 6662 234c 3507      		cpc r19,r21
 6663 234e 00F4      		brsh .L711
 6664 2350 3093 0000 		sts licznik_poprzednia_komenda.3456+1,r19
 6665 2354 2093 0000 		sts licznik_poprzednia_komenda.3456,r18
 6666               	.LVL511:
 6667               	.L712:
1423:main_sim900.h ****         licznik_poprzednia_komenda = 0;
1424:main_sim900.h ****         POMOC_DODAJ2('#', 'r');
1425:main_sim900.h ****         POMOC_DODAJ_HEX(aktualnie_wysylane_polecenie_SIM900 >> 8);
1426:main_sim900.h ****         POMOC_DODAJ_HEX(aktualnie_wysylane_polecenie_SIM900);
1427:main_sim900.h ****         if (aktualnie_wysylane_polecenie_SIM900 !=
1428:main_sim900.h ****             KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1) {
1429:main_sim900.h ****           if (aktualnie_wysylane_polecenie_SIM900 ==
1430:main_sim900.h ****                   KOMENDA_KOLEJKI_ODRZUC_ROZMOWE ||
1431:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
1432:main_sim900.h ****                   KOMENDA_KOLEJKI_PODAJ_PIN ||
1433:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
1434:main_sim900.h ****                   KOMENDA_KOLEJKI_USTAW_PAMIEC_SM_DLA_SMSOW ||
1435:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
1436:main_sim900.h ****                   KOMENDA_KOLEJKI_USTAW_WZMOCNIENIE_MIKROFONU ||
1437:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
1438:main_sim900.h ****                   KOMENDA_KOLEJKI_RESETUJ_CELL_BROADCAST_SMS ||
1439:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
1440:main_sim900.h ****                    KOMENDA_KOLEJKI_SPRAWDZ_PIN &&
1441:main_sim900.h ****                aktualnie_wysylane_polecenie_SIM900 <=
1442:main_sim900.h ****                    KOMENDA_KOLEJKI_WPISZ_POZYCJE_1_W_KSIAZCE_TELEFONICZNEJ) ||
1443:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
1444:main_sim900.h ****                    KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_1 &&
1445:main_sim900.h ****                aktualnie_wysylane_polecenie_SIM900 <=
1446:main_sim900.h ****                    KOMENDA_KOLEJKI_ODCZYTAJ_SMSA_20) ||
1447:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
1448:main_sim900.h ****                    KOMENDA_KOLEJKI_USUN_SMSA_1 &&
1449:main_sim900.h ****                aktualnie_wysylane_polecenie_SIM900 <=
1450:main_sim900.h ****                    KOMENDA_KOLEJKI_USUN_SMSA_20)) {
1451:main_sim900.h ****             nastepne_wysylane_polecenie_SIM900 =
1452:main_sim900.h ****                 aktualnie_wysylane_polecenie_SIM900;
1453:main_sim900.h ****           } else
1454:main_sim900.h ****             nastepne_wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_BRAK_KOMENDY;
1455:main_sim900.h ****           wyzerowanie_danych_SIM900();
1456:main_sim900.h ****           wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1;
1457:main_sim900.h ****           wysylane_dane_RAM_SIM900[0] = '\0';
1458:main_sim900.h ****           wyslij_polecenie_RAM_SIM900();
1459:main_sim900.h ****         } else
1460:main_sim900.h ****           reset_modulu_SIM900();
1461:main_sim900.h ****       }
1462:main_sim900.h ****       licznik_odebranych_znakow = 0;
 6668               		.loc 2 1462 0
 6669 2358 1092 0000 		sts licznik_odebranych_znakow.3457+1,__zero_reg__
 6670 235c 1092 0000 		sts licznik_odebranych_znakow.3457,__zero_reg__
 6671               	.L716:
 6672               	.LBE570:
1463:main_sim900.h ****     } else if (aktualnie_wysylane_polecenie_SIM900 !=
1464:main_sim900.h ****                    KOMENDA_KOLEJKI_BRAK_KOMENDY &&
1465:main_sim900.h ****                trwa_rozmowa_przychodzaca_od_uzytkownika &&
1466:main_sim900.h ****                czy_jest_bezczynny_SIM900()) {
1467:main_sim900.h ****       {
1468:main_sim900.h ****         cli();
1469:main_sim900.h ****         const uint l = liczba_odebranych_znakow_SIM900;
1470:main_sim900.h ****         sei();
1471:main_sim900.h ****         if (licznik_odebranych_znakow < l)
1472:main_sim900.h ****           licznik_odebranych_znakow = l;
1473:main_sim900.h ****       }
1474:main_sim900.h ****       if (licznik_odebranych_znakow >=
1475:main_sim900.h ****           MIN_LICZBA_ODEBRANYCH_ZNAKOW_KONCZACYCH_ROZMOWE_W_TRAKCIE_PODSLUCHU) {
1476:main_sim900.h ****         if (++licznik_poprzednia_komenda >= 5 * 100) // 5 sek
1477:main_sim900.h ****         {
1478:main_sim900.h ****           licznik_poprzednia_komenda = 0;
1479:main_sim900.h ****           zakonczono_rozmowe_telefoniczna(
1480:main_sim900.h ****               powod_zakonczenia_rozmowy_zakonczenie);
1481:main_sim900.h ****           licznik_odebranych_znakow = 0;
1482:main_sim900.h ****           POMOC_DODAJ2('#', 'q');
1483:main_sim900.h ****           reset_modulu_SIM900();
1484:main_sim900.h ****         }
1485:main_sim900.h ****       }
1486:main_sim900.h ****     } else {
1487:main_sim900.h ****       licznik_poprzednia_komenda = 0;
1488:main_sim900.h ****       if (!trwa_rozmowa_przychodzaca_od_uzytkownika)
1489:main_sim900.h ****         licznik_odebranych_znakow = 0;
1490:main_sim900.h ****     }
1491:main_sim900.h **** 
1492:main_sim900.h ****     poprzednia_komenda = aktualnie_wysylane_polecenie_SIM900;
 6673               		.loc 2 1492 0
 6674 2360 8091 0000 		lds r24,aktualnie_wysylane_polecenie_SIM900
 6675 2364 8093 0000 		sts poprzednia_komenda.3455,r24
 6676               	/* epilogue start */
 6677               	.LBE569:
1493:main_sim900.h ****   }
1494:main_sim900.h **** }
 6678               		.loc 2 1494 0
 6679 2368 0895      		ret
 6680               	.L699:
1376:main_sim900.h ****     dodaj_komende(KOMENDA_KOLEJKI_KOMENDA_SIM900);
 6681               		.loc 2 1376 0 discriminator 1
 6682 236a 0E94 0000 		call czy_jest_nowa_komenda_SIM900
 6683               	.LVL512:
 6684 236e 8111      		cpse r24,__zero_reg__
 6685 2370 00C0      		rjmp .L701
 6686 2372 00C0      		rjmp .L700
 6687               	.L704:
 6688               	.LVL513:
 6689               	.LBB573:
1392:main_sim900.h ****         komenda_SIM900 = ERROR_KOMENDA_SIM900;
 6690               		.loc 2 1392 0
 6691 2374 1092 0000 		sts licznik_bezpieczenstwa.3454+1,__zero_reg__
 6692 2378 1092 0000 		sts licznik_bezpieczenstwa.3454,__zero_reg__
1393:main_sim900.h ****         obsluga_wysylania_sms();
 6693               		.loc 2 1393 0
 6694 237c 84E0      		ldi r24,lo8(4)
 6695 237e 8093 0000 		sts komenda_SIM900,r24
1394:main_sim900.h ****       }
 6696               		.loc 2 1394 0
 6697 2382 0E94 0000 		call obsluga_wysylania_sms
 6698               	.LVL514:
 6699 2386 00C0      		rjmp .L705
 6700               	.LVL515:
 6701               	.L703:
1397:main_sim900.h ****   }
 6702               		.loc 2 1397 0
 6703 2388 1092 0000 		sts licznik_bezpieczenstwa.3454+1,__zero_reg__
 6704 238c 1092 0000 		sts licznik_bezpieczenstwa.3454,__zero_reg__
 6705 2390 00C0      		rjmp .L705
 6706               	.LVL516:
 6707               	.L711:
 6708               	.LBE573:
 6709               	.LBB574:
 6710               	.LBB571:
1423:main_sim900.h ****         POMOC_DODAJ2('#', 'r');
 6711               		.loc 2 1423 0
 6712 2392 1092 0000 		sts licznik_poprzednia_komenda.3456+1,__zero_reg__
 6713 2396 1092 0000 		sts licznik_poprzednia_komenda.3456,__zero_reg__
 6714               	.LVL517:
1427:main_sim900.h ****             KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1) {
 6715               		.loc 2 1427 0
 6716 239a 8C3F      		cpi r24,lo8(-4)
 6717 239c 01F0      		breq .L713
1429:main_sim900.h ****                   KOMENDA_KOLEJKI_ODRZUC_ROZMOWE ||
 6718               		.loc 2 1429 0
 6719 239e 8639      		cpi r24,lo8(-106)
 6720 23a0 01F0      		breq .L714
1430:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
 6721               		.loc 2 1430 0
 6722 23a2 93E7      		ldi r25,lo8(115)
 6723 23a4 980F      		add r25,r24
 6724 23a6 9230      		cpi r25,lo8(2)
 6725 23a8 00F0      		brlo .L714
1434:main_sim900.h ****               aktualnie_wysylane_polecenie_SIM900 ==
 6726               		.loc 2 1434 0
 6727 23aa 9DE6      		ldi r25,lo8(109)
 6728 23ac 980F      		add r25,r24
 6729 23ae 9230      		cpi r25,lo8(2)
 6730 23b0 00F0      		brlo .L714
1440:main_sim900.h ****                aktualnie_wysylane_polecenie_SIM900 <=
 6731               		.loc 2 1440 0
 6732 23b2 92E6      		ldi r25,lo8(98)
 6733 23b4 980F      		add r25,r24
1438:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
 6734               		.loc 2 1438 0
 6735 23b6 9A30      		cpi r25,lo8(10)
 6736 23b8 00F0      		brlo .L714
1442:main_sim900.h ****               (aktualnie_wysylane_polecenie_SIM900 >=
 6737               		.loc 2 1442 0
 6738 23ba 97E5      		ldi r25,lo8(87)
 6739 23bc 980F      		add r25,r24
 6740 23be 9832      		cpi r25,lo8(40)
 6741 23c0 00F0      		brlo .L714
1454:main_sim900.h ****           wyzerowanie_danych_SIM900();
 6742               		.loc 2 1454 0
 6743 23c2 1092 0000 		sts nastepne_wysylane_polecenie_SIM900,__zero_reg__
 6744               	.L715:
1455:main_sim900.h ****           wysylane_polecenie_SIM900 = KOMENDA_KOLEJKI_ODZYSKIWANIE_URZADZENIA_1;
 6745               		.loc 2 1455 0
 6746 23c6 0E94 0000 		call wyzerowanie_danych_SIM900
 6747               	.LVL518:
1456:main_sim900.h ****           wysylane_dane_RAM_SIM900[0] = '\0';
 6748               		.loc 2 1456 0
 6749 23ca 1092 0000 		sts licznik_wysylane_polecenie_SIM900+1,__zero_reg__
 6750 23ce 1092 0000 		sts licznik_wysylane_polecenie_SIM900,__zero_reg__
 6751 23d2 8CEF      		ldi r24,lo8(-4)
 6752 23d4 8093 0000 		sts aktualnie_wysylane_polecenie_SIM900,r24
1457:main_sim900.h ****           wyslij_polecenie_RAM_SIM900();
 6753               		.loc 2 1457 0
 6754 23d8 1092 0000 		sts wysylany_blok_SIM900+2,__zero_reg__
1458:main_sim900.h ****         } else
 6755               		.loc 2 1458 0
 6756 23dc 0E94 0000 		call wyslij_polecenie_RAM_SIM900
 6757               	.LVL519:
 6758 23e0 00C0      		rjmp .L712
 6759               	.LVL520:
 6760               	.L714:
1451:main_sim900.h ****                 aktualnie_wysylane_polecenie_SIM900;
 6761               		.loc 2 1451 0
 6762 23e2 8093 0000 		sts nastepne_wysylane_polecenie_SIM900,r24
 6763 23e6 00C0      		rjmp .L715
 6764               	.L713:
1460:main_sim900.h ****       }
 6765               		.loc 2 1460 0
 6766 23e8 0E94 0000 		call reset_modulu_SIM900
 6767               	.LVL521:
 6768 23ec 00C0      		rjmp .L712
 6769               	.LVL522:
 6770               	.L707:
 6771               	.LBE571:
1464:main_sim900.h ****                trwa_rozmowa_przychodzaca_od_uzytkownika &&
 6772               		.loc 2 1464 0
 6773 23ee 9923      		tst r25
 6774 23f0 01F0      		breq .L706
 6775               	.L708:
1466:main_sim900.h ****       {
 6776               		.loc 2 1466 0
 6777 23f2 8091 0000 		lds r24,komenda_SIM900
1465:main_sim900.h ****                czy_jest_bezczynny_SIM900()) {
 6778               		.loc 2 1465 0
 6779 23f6 8111      		cpse r24,__zero_reg__
 6780 23f8 00C0      		rjmp .L706
 6781               	.LBB572:
1468:main_sim900.h ****         const uint l = liczba_odebranych_znakow_SIM900;
 6782               		.loc 2 1468 0
 6783               	/* #APP */
 6784               	 ;  1468 "main_sim900.h" 1
 6785 23fa F894      		cli
 6786               	 ;  0 "" 2
1469:main_sim900.h ****         sei();
 6787               		.loc 2 1469 0
 6788               	/* #NOAPP */
 6789 23fc 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 6790 2400 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
 6791               	.LVL523:
1470:main_sim900.h ****         if (licznik_odebranych_znakow < l)
 6792               		.loc 2 1470 0
 6793               	/* #APP */
 6794               	 ;  1470 "main_sim900.h" 1
 6795 2404 7894      		sei
 6796               	 ;  0 "" 2
1471:main_sim900.h ****           licznik_odebranych_znakow = l;
 6797               		.loc 2 1471 0
 6798               	/* #NOAPP */
 6799 2406 2091 0000 		lds r18,licznik_odebranych_znakow.3457
 6800 240a 3091 0000 		lds r19,licznik_odebranych_znakow.3457+1
 6801 240e 2817      		cp r18,r24
 6802 2410 3907      		cpc r19,r25
 6803 2412 00F4      		brsh .L717
1472:main_sim900.h ****       }
 6804               		.loc 2 1472 0
 6805 2414 9093 0000 		sts licznik_odebranych_znakow.3457+1,r25
 6806 2418 8093 0000 		sts licznik_odebranych_znakow.3457,r24
 6807               	.L717:
 6808               	.LBE572:
1474:main_sim900.h ****           MIN_LICZBA_ODEBRANYCH_ZNAKOW_KONCZACYCH_ROZMOWE_W_TRAKCIE_PODSLUCHU) {
 6809               		.loc 2 1474 0
 6810 241c 8091 0000 		lds r24,licznik_odebranych_znakow.3457
 6811 2420 9091 0000 		lds r25,licznik_odebranych_znakow.3457+1
 6812               	.LVL524:
 6813 2424 0A97      		sbiw r24,10
 6814 2426 00F4      		brsh .+2
 6815 2428 00C0      		rjmp .L716
1476:main_sim900.h ****         {
 6816               		.loc 2 1476 0
 6817 242a 8091 0000 		lds r24,licznik_poprzednia_komenda.3456
 6818 242e 9091 0000 		lds r25,licznik_poprzednia_komenda.3456+1
 6819 2432 0196      		adiw r24,1
 6820 2434 843F      		cpi r24,-12
 6821 2436 21E0      		ldi r18,1
 6822 2438 9207      		cpc r25,r18
 6823 243a 00F4      		brsh .L719
 6824 243c 9093 0000 		sts licznik_poprzednia_komenda.3456+1,r25
 6825 2440 8093 0000 		sts licznik_poprzednia_komenda.3456,r24
 6826 2444 00C0      		rjmp .L716
 6827               	.L719:
1478:main_sim900.h ****           zakonczono_rozmowe_telefoniczna(
 6828               		.loc 2 1478 0
 6829 2446 1092 0000 		sts licznik_poprzednia_komenda.3456+1,__zero_reg__
 6830 244a 1092 0000 		sts licznik_poprzednia_komenda.3456,__zero_reg__
1479:main_sim900.h ****               powod_zakonczenia_rozmowy_zakonczenie);
 6831               		.loc 2 1479 0
 6832 244e 81E0      		ldi r24,lo8(1)
 6833 2450 0E94 0000 		call zakonczono_rozmowe_telefoniczna
 6834               	.LVL525:
1481:main_sim900.h ****           POMOC_DODAJ2('#', 'q');
 6835               		.loc 2 1481 0
 6836 2454 1092 0000 		sts licznik_odebranych_znakow.3457+1,__zero_reg__
 6837 2458 1092 0000 		sts licznik_odebranych_znakow.3457,__zero_reg__
 6838               	.LVL526:
1483:main_sim900.h ****         }
 6839               		.loc 2 1483 0
 6840 245c 0E94 0000 		call reset_modulu_SIM900
 6841               	.LVL527:
 6842 2460 00C0      		rjmp .L716
 6843               	.LVL528:
 6844               	.L706:
1487:main_sim900.h ****       if (!trwa_rozmowa_przychodzaca_od_uzytkownika)
 6845               		.loc 2 1487 0
 6846 2462 1092 0000 		sts licznik_poprzednia_komenda.3456+1,__zero_reg__
 6847 2466 1092 0000 		sts licznik_poprzednia_komenda.3456,__zero_reg__
1488:main_sim900.h ****         licznik_odebranych_znakow = 0;
 6848               		.loc 2 1488 0
 6849 246a 9923      		tst r25
 6850 246c 01F4      		brne .+2
 6851 246e 00C0      		rjmp .L712
 6852 2470 00C0      		rjmp .L716
 6853               	.LBE574:
 6854               		.cfi_endproc
 6855               	.LFE55:
 6857               	.global	wykonanie_komend_powiadomien
 6859               	wykonanie_komend_powiadomien:
 6860               	.LFB59:
1228:main.c        ****   const komenda_typ aktualnie_wykonywana_komenda = komendy_kolejka[0];
 6861               		.loc 1 1228 0
 6862               		.cfi_startproc
 6863 2472 BF92      		push r11
 6864               	.LCFI76:
 6865               		.cfi_def_cfa_offset 3
 6866               		.cfi_offset 11, -2
 6867 2474 CF92      		push r12
 6868               	.LCFI77:
 6869               		.cfi_def_cfa_offset 4
 6870               		.cfi_offset 12, -3
 6871 2476 DF92      		push r13
 6872               	.LCFI78:
 6873               		.cfi_def_cfa_offset 5
 6874               		.cfi_offset 13, -4
 6875 2478 EF92      		push r14
 6876               	.LCFI79:
 6877               		.cfi_def_cfa_offset 6
 6878               		.cfi_offset 14, -5
 6879 247a FF92      		push r15
 6880               	.LCFI80:
 6881               		.cfi_def_cfa_offset 7
 6882               		.cfi_offset 15, -6
 6883 247c 0F93      		push r16
 6884               	.LCFI81:
 6885               		.cfi_def_cfa_offset 8
 6886               		.cfi_offset 16, -7
 6887 247e 1F93      		push r17
 6888               	.LCFI82:
 6889               		.cfi_def_cfa_offset 9
 6890               		.cfi_offset 17, -8
 6891 2480 CF93      		push r28
 6892               	.LCFI83:
 6893               		.cfi_def_cfa_offset 10
 6894               		.cfi_offset 28, -9
 6895 2482 DF93      		push r29
 6896               	.LCFI84:
 6897               		.cfi_def_cfa_offset 11
 6898               		.cfi_offset 29, -10
 6899               	/* prologue: function */
 6900               	/* frame size = 0 */
 6901               	/* stack size = 9 */
 6902               	.L__stack_usage = 9
1229:main.c        **** 
 6903               		.loc 1 1229 0
 6904 2484 8091 0000 		lds r24,komendy_kolejka
 6905               	.LVL529:
1236:main.c        **** 
 6906               		.loc 1 1236 0
 6907 2488 9091 0000 		lds r25,flaga_odczytywanie_smsa
 6908 248c 9111      		cpse r25,__zero_reg__
 6909 248e 00C0      		rjmp .L748
1232:main.c        ****       wykonywanie_rozmowy_telefonicznej ||
 6910               		.loc 1 1232 0
 6911 2490 9091 0000 		lds r25,flaga_wysylanie_smsa
 6912 2494 9111      		cpse r25,__zero_reg__
 6913 2496 00C0      		rjmp .L748
1232:main.c        ****       wykonywanie_rozmowy_telefonicznej ||
 6914               		.loc 1 1232 0 is_stmt 0 discriminator 1
 6915 2498 9091 0000 		lds r25,wykonywanie_rozmowy_telefonicznej
 6916 249c 9111      		cpse r25,__zero_reg__
 6917 249e 00C0      		rjmp .L748
1233:main.c        ****       trwa_rozmowa_przychodzaca_od_uzytkownika ||
 6918               		.loc 1 1233 0 is_stmt 1
 6919 24a0 9091 0000 		lds r25,trwa_rozmowa_przychodzaca_od_uzytkownika
 6920 24a4 9111      		cpse r25,__zero_reg__
 6921 24a6 00C0      		rjmp .L748
1234:main.c        ****       aktualnie_wysylane_polecenie_SIM900 != KOMENDA_KOLEJKI_BRAK_KOMENDY ||
 6922               		.loc 1 1234 0
 6923 24a8 9091 0000 		lds r25,aktualnie_wysylane_polecenie_SIM900
 6924 24ac 9111      		cpse r25,__zero_reg__
 6925 24ae 00C0      		rjmp .L748
1235:main.c        ****       opoznienie_SIM900_100MS || czekanie_na_odebranie_zachety;
 6926               		.loc 1 1235 0
 6927 24b0 9091 0000 		lds r25,opoznienie_SIM900_100MS
 6928 24b4 9111      		cpse r25,__zero_reg__
 6929 24b6 00C0      		rjmp .L748
1236:main.c        **** 
 6930               		.loc 1 1236 0 discriminator 2
 6931 24b8 9091 0000 		lds r25,czekanie_na_odebranie_zachety
 6932 24bc 21E0      		ldi r18,lo8(1)
 6933 24be 30E0      		ldi r19,0
 6934 24c0 9111      		cpse r25,__zero_reg__
 6935 24c2 00C0      		rjmp .L747
 6936 24c4 30E0      		ldi r19,0
 6937 24c6 20E0      		ldi r18,0
 6938               	.L747:
 6939               	.LVL530:
1239:main.c        ****       czy_jest_bezczynny_SIM900();
 6940               		.loc 1 1239 0 discriminator 2
 6941 24c8 232B      		or r18,r19
 6942 24ca 01F4      		brne .L748
 6943               	.LVL531:
1239:main.c        ****       czy_jest_bezczynny_SIM900();
 6944               		.loc 1 1239 0 is_stmt 0 discriminator 1
 6945 24cc 9091 C100 		lds r25,193
 6946 24d0 96FD      		sbrc r25,6
 6947 24d2 00C0      		rjmp .L748
1239:main.c        ****       czy_jest_bezczynny_SIM900();
 6948               		.loc 1 1239 0 discriminator 3
 6949 24d4 9091 0000 		lds r25,podlaczony_modul_gsm_SIM900
 6950 24d8 9923      		tst r25
 6951 24da 01F0      		breq .L748
1240:main.c        **** 
 6952               		.loc 1 1240 0 is_stmt 1 discriminator 5
 6953 24dc 9091 0000 		lds r25,komenda_SIM900
1239:main.c        ****       czy_jest_bezczynny_SIM900();
 6954               		.loc 1 1239 0 discriminator 5
 6955 24e0 9923      		tst r25
 6956 24e2 01F4      		brne .+2
 6957 24e4 00C0      		rjmp .L749
 6958               	.LVL532:
 6959               	.L748:
1242:main.c        ****   case KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW: {
 6960               		.loc 1 1242 0
 6961 24e6 8838      		cpi r24,lo8(-120)
 6962 24e8 01F0      		breq .+2
 6963 24ea 00C0      		rjmp .L784
 6964 24ec 00C0      		rjmp .L750
 6965               	.LVL533:
 6966               	.L782:
 6967               	.LBB575:
1249:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
 6968               		.loc 1 1249 0
 6969 24ee 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 6970 24f2 8111      		cpse r24,__zero_reg__
 6971 24f4 00C0      		rjmp .L750
1249:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
 6972               		.loc 1 1249 0 is_stmt 0 discriminator 2
 6973 24f6 8091 0000 		lds r24,liczba_znakow_do_zapisu
 6974 24fa 8111      		cpse r24,__zero_reg__
 6975 24fc 00C0      		rjmp .L750
1249:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
 6976               		.loc 1 1249 0 discriminator 4
 6977 24fe 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 6978 2502 8111      		cpse r24,__zero_reg__
 6979 2504 00C0      		rjmp .L750
1249:main.c        ****     uchar *sms = &tekst_wysylanego_smsa[0];
 6980               		.loc 1 1249 0 discriminator 6
 6981 2506 F999      		sbic 0x1f,1
 6982 2508 00C0      		rjmp .L750
 6983               	.LVL534:
1251:main.c        ****     for (;;) {
 6984               		.loc 1 1251 0 is_stmt 1
 6985 250a 8AE2      		ldi r24,lo8(42)
 6986 250c 8093 0000 		sts tekst_wysylanego_smsa,r24
 6987 2510 00E0      		ldi r16,lo8(tekst_wysylanego_smsa+1)
 6988 2512 10E0      		ldi r17,hi8(tekst_wysylanego_smsa+1)
 6989               	.LVL535:
1253:main.c        ****               numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama)) {
 6990               		.loc 1 1253 0
 6991 2514 85E0      		ldi r24,lo8(5)
 6992 2516 D82E      		mov r13,r24
1259:main.c        ****         *sms++ = '\n';
 6993               		.loc 1 1259 0
 6994 2518 93E2      		ldi r25,lo8(35)
 6995 251a C92E      		mov r12,r25
1260:main.c        ****         ++numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama;
 6996               		.loc 1 1260 0
 6997 251c 2AE0      		ldi r18,lo8(10)
 6998 251e B22E      		mov r11,r18
 6999               	.LVL536:
 7000               	.L752:
1253:main.c        ****               numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama)) {
 7001               		.loc 1 1253 0
 7002 2520 C091 0000 		lds r28,numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama
 7003 2524 CD9D      		mul r28,r13
 7004 2526 7001      		movw r14,r0
 7005 2528 1124      		clr __zero_reg__
 7006 252a 88E0      		ldi r24,8
 7007 252c E80E      		add r14,r24
 7008 252e F11C      		adc r15,__zero_reg__
 7009 2530 C701      		movw r24,r14
 7010 2532 0E94 0000 		call eeprom_read_byte
 7011               	.LVL537:
 7012 2536 8F3F      		cpi r24,lo8(-1)
 7013 2538 01F0      		breq .L753
1255:main.c        ****             (void *)EEPROM_NUMER_TELEFONU_BRAMA(
 7014               		.loc 1 1255 0
 7015 253a 4FEF      		ldi r20,lo8(-1)
 7016 253c B801      		movw r22,r16
 7017 253e C701      		movw r24,r14
 7018 2540 0E94 0000 		call kopiuj_blok_eeprom_na_telefon
 7019               	.LVL538:
 7020 2544 E801      		movw r28,r16
 7021 2546 C80F      		add r28,r24
 7022 2548 D11D      		adc r29,__zero_reg__
 7023               	.LVL539:
1259:main.c        ****         *sms++ = '\n';
 7024               		.loc 1 1259 0
 7025 254a C882      		st Y,r12
1260:main.c        ****         ++numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama;
 7026               		.loc 1 1260 0
 7027 254c 8E01      		movw r16,r28
 7028 254e 0E5F      		subi r16,-2
 7029 2550 1F4F      		sbci r17,-1
 7030               	.LVL540:
 7031 2552 B982      		std Y+1,r11
1261:main.c        ****         if ((sms + MAX_LICZBA_ZNAKOW_TELEFON + 1 >=
 7032               		.loc 1 1261 0
 7033 2554 8091 0000 		lds r24,numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama
 7034 2558 8F5F      		subi r24,lo8(-(1))
 7035 255a 8093 0000 		sts numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama,r24
1262:main.c        ****              &tekst_wysylanego_smsa[MAX_LICZBA_ZNAKOW_SMS]) ||
 7036               		.loc 1 1262 0
 7037 255e 9E01      		movw r18,r28
 7038 2560 2D5E      		subi r18,-19
 7039 2562 3F4F      		sbci r19,-1
 7040 2564 2050      		subi r18,lo8(tekst_wysylanego_smsa+160)
 7041 2566 3040      		sbci r19,hi8(tekst_wysylanego_smsa+160)
 7042 2568 00F4      		brsh .L754
1263:main.c        ****             (numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama >=
 7043               		.loc 1 1263 0
 7044 256a 8F3F      		cpi r24,lo8(-1)
 7045 256c 01F4      		brne .L752
 7046               	.L755:
1269:main.c        ****           dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 7047               		.loc 1 1269 0
 7048 256e 1A82      		std Y+2,__zero_reg__
1270:main.c        ****           wysylanie_smsa_clipa = WYSYLANIE_SMSA_WYSYLANIE;
 7049               		.loc 1 1270 0
 7050 2570 82ED      		ldi r24,lo8(-46)
 7051 2572 0E94 0000 		call dodaj_komende
 7052               	.LVL541:
1271:main.c        ****           break;
 7053               		.loc 1 1271 0
 7054 2576 81E0      		ldi r24,lo8(1)
 7055 2578 8093 0000 		sts wysylanie_smsa_clipa,r24
 7056 257c 00C0      		rjmp .L785
 7057               	.L754:
1266:main.c        ****                MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER))
 7058               		.loc 1 1266 0
 7059 257e 8F3F      		cpi r24,lo8(-1)
 7060 2580 01F0      		breq .L755
1268:main.c        ****           *sms = '\0';
 7061               		.loc 1 1268 0
 7062 2582 88E8      		ldi r24,lo8(-120)
 7063 2584 0E94 0000 		call dodaj_komende
 7064               	.LVL542:
 7065 2588 00C0      		rjmp .L755
 7066               	.L753:
1275:main.c        ****             MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA_USER) {
 7067               		.loc 1 1275 0
 7068 258a CF5F      		subi r28,lo8(-(1))
 7069 258c C093 0000 		sts numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama,r28
 7070 2590 CF3F      		cpi r28,lo8(-1)
 7071 2592 01F4      		brne .L752
1277:main.c        ****             *sms = '\0';
 7072               		.loc 1 1277 0
 7073 2594 E0E0      		ldi r30,hi8(tekst_wysylanego_smsa)
 7074 2596 0030      		cpi r16,lo8(tekst_wysylanego_smsa)
 7075 2598 1E07      		cpc r17,r30
 7076 259a 01F0      		breq .L745
1278:main.c        ****             dodaj_komende(KOMENDA_KOLEJKI_WYSLIJ_SMSA_TEXT);
 7077               		.loc 1 1278 0
 7078 259c F801      		movw r30,r16
 7079 259e 1082      		st Z,__zero_reg__
1279:main.c        ****             wysylanie_smsa_clipa = WYSYLANIE_SMSA_WYSYLANIE;
 7080               		.loc 1 1279 0
 7081 25a0 82ED      		ldi r24,lo8(-46)
 7082 25a2 0E94 0000 		call dodaj_komende
 7083               	.LVL543:
1280:main.c        ****           }
 7084               		.loc 1 1280 0
 7085 25a6 81E0      		ldi r24,lo8(1)
 7086 25a8 8093 0000 		sts wysylanie_smsa_clipa,r24
 7087 25ac 00C0      		rjmp .L745
 7088               	.LVL544:
 7089               	.L757:
1244:main.c        ****         wysylanie_smsa_clipa != WYSYLANIE_SMSA_CLIPA_BRAK) {
 7090               		.loc 1 1244 0
 7091 25ae 8091 0000 		lds r24,wysylanie_smsa_clipa
 7092               	.LVL545:
 7093 25b2 8823      		tst r24
 7094 25b4 01F4      		brne .+2
 7095 25b6 00C0      		rjmp .L782
 7096               	.LVL546:
 7097               	.L750:
1246:main.c        ****       break;
 7098               		.loc 1 1246 0
 7099 25b8 88E8      		ldi r24,lo8(-120)
 7100 25ba 0E94 0000 		call dodaj_komende
 7101               	.LVL547:
 7102               	.L785:
 7103               	.LBE575:
1291:main.c        **** }
 7104               		.loc 1 1291 0
 7105 25be CFEF      		ldi r28,lo8(-1)
 7106               	.L745:
1292:main.c        **** 
 7107               		.loc 1 1292 0
 7108 25c0 8C2F      		mov r24,r28
 7109               	/* epilogue start */
 7110 25c2 DF91      		pop r29
 7111 25c4 CF91      		pop r28
 7112 25c6 1F91      		pop r17
 7113 25c8 0F91      		pop r16
 7114 25ca FF90      		pop r15
 7115 25cc EF90      		pop r14
 7116 25ce DF90      		pop r13
 7117 25d0 CF90      		pop r12
 7118 25d2 BF90      		pop r11
 7119 25d4 0895      		ret
 7120               	.LVL548:
 7121               	.L749:
1242:main.c        ****   case KOMENDA_KOLEJKI_WYSLIJ_RAPORT_UZYTKOWNIKOW: {
 7122               		.loc 1 1242 0
 7123 25d6 8838      		cpi r24,lo8(-120)
 7124 25d8 01F0      		breq .L757
 7125               	.LVL549:
 7126               	.L784:
1289:main.c        ****   }
 7127               		.loc 1 1289 0
 7128 25da C0E0      		ldi r28,0
 7129 25dc 00C0      		rjmp .L745
 7130               		.cfi_endproc
 7131               	.LFE59:
 7133               	.global	test_sms_clip_100ms
 7135               	test_sms_clip_100ms:
 7136               	.LFB61:
1306:main.c        ****   // static ulong licznik_sms;
 7137               		.loc 1 1306 0
 7138               		.cfi_startproc
 7139               	/* prologue: function */
 7140               	/* frame size = 0 */
 7141               	/* stack size = 0 */
 7142               	.L__stack_usage = 0
 7143               	/* epilogue start */
1325:main.c        **** 
 7144               		.loc 1 1325 0
 7145 25de 0895      		ret
 7146               		.cfi_endproc
 7147               	.LFE61:
 7149               	.global	steruj_wejscia_wyjscia_100ms
 7151               	steruj_wejscia_wyjscia_100ms:
 7152               	.LFB62:
1327:main.c        ****   aktualizuj_stan_wyzwolenia_wejsc_100ms();
 7153               		.loc 1 1327 0
 7154               		.cfi_startproc
 7155               	/* prologue: function */
 7156               	/* frame size = 0 */
 7157               	/* stack size = 0 */
 7158               	.L__stack_usage = 0
1328:main.c        ****   steruj_wejsciem_reset_100ms();
 7159               		.loc 1 1328 0
 7160 25e0 0E94 0000 		call aktualizuj_stan_wyzwolenia_wejsc_100ms
 7161               	.LVL550:
1329:main.c        ****   steruj_wyjscia_100ms();
 7162               		.loc 1 1329 0
 7163 25e4 0E94 0000 		call steruj_wejsciem_reset_100ms
 7164               	.LVL551:
1330:main.c        **** }
 7165               		.loc 1 1330 0
 7166 25e8 0C94 0000 		jmp steruj_wyjscia_100ms
 7167               	.LVL552:
 7168               		.cfi_endproc
 7169               	.LFE62:
 7171               	.global	zapis_w_eeprom_stanu_wyjsc
 7173               	zapis_w_eeprom_stanu_wyjsc:
 7174               	.LFB63:
1333:main.c        ****   if (not czy_wolny_eeprom())
 7175               		.loc 1 1333 0
 7176               		.cfi_startproc
 7177 25ec CF93      		push r28
 7178               	.LCFI85:
 7179               		.cfi_def_cfa_offset 3
 7180               		.cfi_offset 28, -2
 7181 25ee DF93      		push r29
 7182               	.LCFI86:
 7183               		.cfi_def_cfa_offset 4
 7184               		.cfi_offset 29, -3
 7185 25f0 1F92      		push __zero_reg__
 7186               	.LCFI87:
 7187               		.cfi_def_cfa_offset 5
 7188 25f2 CDB7      		in r28,__SP_L__
 7189 25f4 DEB7      		in r29,__SP_H__
 7190               	.LCFI88:
 7191               		.cfi_def_cfa_register 28
 7192               	/* prologue: function */
 7193               	/* frame size = 1 */
 7194               	/* stack size = 3 */
 7195               	.L__stack_usage = 3
1334:main.c        ****     return;
 7196               		.loc 1 1334 0
 7197 25f6 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 7198 25fa 8111      		cpse r24,__zero_reg__
 7199 25fc 00C0      		rjmp .L788
1334:main.c        ****     return;
 7200               		.loc 1 1334 0 is_stmt 0 discriminator 1
 7201 25fe 8091 0000 		lds r24,liczba_znakow_do_zapisu
 7202 2602 8111      		cpse r24,__zero_reg__
 7203 2604 00C0      		rjmp .L788
1334:main.c        ****     return;
 7204               		.loc 1 1334 0 discriminator 2
 7205 2606 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 7206 260a 8111      		cpse r24,__zero_reg__
 7207 260c 00C0      		rjmp .L788
1334:main.c        ****     return;
 7208               		.loc 1 1334 0 discriminator 3
 7209 260e F999      		sbic 0x1f,1
 7210 2610 00C0      		rjmp .L788
 7211               	.LBB578:
 7212               	.LBB579:
1336:main.c        ****   if ((stan_wyjscie[0] != 0) ^ (licznik_przelacznik_wyjscia[0] != 0))
 7213               		.loc 1 1336 0 is_stmt 1
 7214 2612 1982      		std Y+1,__zero_reg__
1337:main.c        ****     par |= BIT(0);
 7215               		.loc 1 1337 0
 7216 2614 91E0      		ldi r25,lo8(1)
 7217 2616 8091 0000 		lds r24,stan_wyjscie
 7218 261a 8111      		cpse r24,__zero_reg__
 7219 261c 00C0      		rjmp .L791
 7220 261e 90E0      		ldi r25,0
 7221               	.L791:
 7222 2620 81E0      		ldi r24,lo8(1)
 7223 2622 4091 0000 		lds r20,licznik_przelacznik_wyjscia
 7224 2626 5091 0000 		lds r21,licznik_przelacznik_wyjscia+1
 7225 262a 6091 0000 		lds r22,licznik_przelacznik_wyjscia+2
 7226 262e 7091 0000 		lds r23,licznik_przelacznik_wyjscia+3
 7227 2632 452B      		or r20,r21
 7228 2634 462B      		or r20,r22
 7229 2636 472B      		or r20,r23
 7230 2638 01F4      		brne .L792
 7231 263a 80E0      		ldi r24,0
 7232               	.L792:
 7233 263c 9817      		cp r25,r24
 7234 263e 01F0      		breq .L790
1338:main.c        ****   if (par != eeprom_read_byte((void *)EEPROM_USTAWIENIE_STANOW_WYJSC))
 7235               		.loc 1 1338 0
 7236 2640 81E0      		ldi r24,lo8(1)
 7237 2642 8983      		std Y+1,r24
 7238               	.L790:
1339:main.c        ****     zapisz_znaki_w_eeprom(&par, (uint)EEPROM_USTAWIENIE_STANOW_WYJSC, 1);
 7239               		.loc 1 1339 0
 7240 2644 85E0      		ldi r24,lo8(5)
 7241 2646 90E0      		ldi r25,0
 7242 2648 0E94 0000 		call eeprom_read_byte
 7243               	.LVL553:
 7244 264c 9981      		ldd r25,Y+1
 7245 264e 8917      		cp r24,r25
 7246 2650 01F0      		breq .L788
1340:main.c        **** }
 7247               		.loc 1 1340 0
 7248 2652 41E0      		ldi r20,lo8(1)
 7249 2654 65E0      		ldi r22,lo8(5)
 7250 2656 70E0      		ldi r23,0
 7251 2658 CE01      		movw r24,r28
 7252 265a 0196      		adiw r24,1
 7253 265c 0E94 0000 		call zapisz_znaki_w_eeprom
 7254               	.LVL554:
 7255               	.L788:
 7256               	/* epilogue start */
 7257               	.LBE579:
 7258               	.LBE578:
1341:main.c        **** 
 7259               		.loc 1 1341 0
 7260 2660 0F90      		pop __tmp_reg__
 7261 2662 DF91      		pop r29
 7262 2664 CF91      		pop r28
 7263 2666 0895      		ret
 7264               		.cfi_endproc
 7265               	.LFE63:
 7267               	.global	steruj_urzadzeniem_100MS
 7269               	steruj_urzadzeniem_100MS:
 7270               	.LFB64:
1356:main.c        ****   steruj_wejscia_wyjscia_100ms();
 7271               		.loc 1 1356 0
 7272               		.cfi_startproc
 7273               	/* prologue: function */
 7274               	/* frame size = 0 */
 7275               	/* stack size = 0 */
 7276               	.L__stack_usage = 0
1357:main.c        ****   steruj_SIM900_100MS();
 7277               		.loc 1 1357 0
 7278 2668 0E94 0000 		call steruj_wejscia_wyjscia_100ms
 7279               	.LVL555:
1358:main.c        ****   if (licznik_100ms_dioda_led) {
 7280               		.loc 1 1358 0
 7281 266c 0E94 0000 		call steruj_SIM900_100MS
 7282               	.LVL556:
1359:main.c        ****     if (--licznik_100ms_dioda_led == 0)
 7283               		.loc 1 1359 0
 7284 2670 8091 0000 		lds r24,licznik_100ms_dioda_led
 7285 2674 8823      		tst r24
 7286 2676 01F0      		breq .L795
1360:main.c        ****       ustaw_stan_led(FALSE);
 7287               		.loc 1 1360 0
 7288 2678 8150      		subi r24,lo8(-(-1))
 7289 267a 8093 0000 		sts licznik_100ms_dioda_led,r24
 7290 267e 8111      		cpse r24,__zero_reg__
 7291 2680 00C0      		rjmp .L796
1361:main.c        ****     else
 7292               		.loc 1 1361 0 discriminator 1
 7293 2682 409A      		sbi 0x8,0
 7294               	.L795:
1367:main.c        ****     --timer_report_user_100ms;
 7295               		.loc 1 1367 0
 7296 2684 8091 0000 		lds r24,timer_report_user_100ms
 7297 2688 9091 0000 		lds r25,timer_report_user_100ms+1
 7298 268c 0097      		sbiw r24,0
 7299 268e 01F0      		breq .L797
1368:main.c        ****     if (timer_report_user_100ms == 0) {
 7300               		.loc 1 1368 0
 7301 2690 0197      		sbiw r24,1
 7302 2692 9093 0000 		sts timer_report_user_100ms+1,r25
 7303 2696 8093 0000 		sts timer_report_user_100ms,r24
1369:main.c        ****       // Okno czasowe minelo - resetuj licznik
 7304               		.loc 1 1369 0
 7305 269a 892B      		or r24,r25
 7306 269c 01F4      		brne .L798
 7307               	.L797:
1371:main.c        ****     }
 7308               		.loc 1 1371 0
 7309 269e 1092 0000 		sts licznik_report_user,__zero_reg__
 7310               	.L798:
1381:main.c        ****   if (pierwsza_komenda != KOMENDA_KOLEJKI_BRAK_KOMENDY) {
 7311               		.loc 1 1381 0
 7312 26a2 8091 0000 		lds r24,komendy_kolejka
 7313               	.LVL557:
1382:main.c        ****     // Sprawdz czy pierwsza komenda to SMS - jesli tak i stoi zbyt dlugo,
 7314               		.loc 1 1382 0
 7315 26a6 8823      		tst r24
 7316 26a8 01F4      		brne .+2
 7317 26aa 00C0      		rjmp .L799
1385:main.c        ****         pierwsza_komenda <= KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU) {
 7318               		.loc 1 1385 0
 7319 26ac 9EE2      		ldi r25,lo8(46)
 7320 26ae 980F      		add r25,r24
 7321 26b0 9230      		cpi r25,lo8(2)
 7322 26b2 00F0      		brlo .+2
 7323 26b4 00C0      		rjmp .L800
1388:main.c        ****         // Ta sama komenda SMS jest na poczatku kolejki - kolejka moze stac
 7324               		.loc 1 1388 0
 7325 26b6 9091 0000 		lds r25,ostatnia_pierwsza_komenda
 7326 26ba 9813      		cpse r25,r24
 7327 26bc 00C0      		rjmp .L800
1390:main.c        ****           ++licznik_kolejka_stoi_100ms;
 7328               		.loc 1 1390 0
 7329 26be 8091 0000 		lds r24,licznik_kolejka_stoi_100ms
 7330 26c2 9091 0000 		lds r25,licznik_kolejka_stoi_100ms+1
 7331               	.LVL558:
 7332 26c6 8639      		cpi r24,-106
 7333 26c8 9105      		cpc r25,__zero_reg__
 7334 26ca 00F0      		brlo .+2
 7335 26cc 00C0      		rjmp .L802
1391:main.c        ****         else {
 7336               		.loc 1 1391 0
 7337 26ce 0196      		adiw r24,1
 7338 26d0 9093 0000 		sts licznik_kolejka_stoi_100ms+1,r25
 7339 26d4 8093 0000 		sts licznik_kolejka_stoi_100ms,r24
 7340               	.LVL559:
 7341               	.L803:
1430:main.c        ****     if (licznik_watchdog_wysylanie_smsa_100ms < WATCHDOG_WYSYLANIA_SMS_100MS) {
 7342               		.loc 1 1430 0
 7343 26d8 8091 0000 		lds r24,flaga_wysylanie_smsa
 7344 26dc 8823      		tst r24
 7345 26de 01F4      		brne .+2
 7346 26e0 00C0      		rjmp .L805
1431:main.c        ****       ++licznik_watchdog_wysylanie_smsa_100ms;
 7347               		.loc 1 1431 0
 7348 26e2 8091 0000 		lds r24,licznik_watchdog_wysylanie_smsa_100ms
 7349 26e6 9091 0000 		lds r25,licznik_watchdog_wysylanie_smsa_100ms+1
 7350 26ea 8C32      		cpi r24,44
 7351 26ec 21E0      		ldi r18,1
 7352 26ee 9207      		cpc r25,r18
 7353 26f0 00F0      		brlo .+2
 7354 26f2 00C0      		rjmp .L806
1432:main.c        ****     } else {
 7355               		.loc 1 1432 0
 7356 26f4 0196      		adiw r24,1
 7357 26f6 9093 0000 		sts licznik_watchdog_wysylanie_smsa_100ms+1,r25
 7358 26fa 8093 0000 		sts licznik_watchdog_wysylanie_smsa_100ms,r24
 7359               	.L807:
1454:main.c        ****     if (watchdog_sms_licznik_100ms < WATCHDOG_SMS_TIMEOUT_100MS)
 7360               		.loc 1 1454 0
 7361 26fe 8091 0000 		lds r24,watchdog_sms_aktywny
 7362 2702 8823      		tst r24
 7363 2704 01F4      		brne .+2
 7364 2706 00C0      		rjmp .L809
1455:main.c        ****       ++watchdog_sms_licznik_100ms;
 7365               		.loc 1 1455 0
 7366 2708 8091 0000 		lds r24,watchdog_sms_licznik_100ms
 7367 270c 9091 0000 		lds r25,watchdog_sms_licznik_100ms+1
 7368 2710 8436      		cpi r24,100
 7369 2712 9105      		cpc r25,__zero_reg__
 7370 2714 00F0      		brlo .+2
 7371 2716 00C0      		rjmp .L810
1456:main.c        ****     else {
 7372               		.loc 1 1456 0
 7373 2718 8091 0000 		lds r24,watchdog_sms_licznik_100ms
 7374 271c 9091 0000 		lds r25,watchdog_sms_licznik_100ms+1
 7375 2720 0196      		adiw r24,1
 7376 2722 9093 0000 		sts watchdog_sms_licznik_100ms+1,r25
 7377 2726 8093 0000 		sts watchdog_sms_licznik_100ms,r24
 7378               	.L811:
1469:main.c        ****     ++stan_cyklu_blysku;
 7379               		.loc 1 1469 0
 7380 272a 8091 0000 		lds r24,liczba_blyskow_led
 7381 272e 8823      		tst r24
 7382 2730 01F4      		brne .+2
 7383 2732 00C0      		rjmp .L813
1470:main.c        ****     if (stan_cyklu_blysku >= 6) {
 7384               		.loc 1 1470 0
 7385 2734 9091 0000 		lds r25,stan_cyklu_blysku
 7386 2738 9F5F      		subi r25,lo8(-(1))
 7387 273a 9093 0000 		sts stan_cyklu_blysku,r25
1471:main.c        ****       stan_cyklu_blysku = 0;
 7388               		.loc 1 1471 0
 7389 273e 9630      		cpi r25,lo8(6)
 7390 2740 00F0      		brlo .L814
1472:main.c        ****       --liczba_blyskow_led;
 7391               		.loc 1 1472 0
 7392 2742 1092 0000 		sts stan_cyklu_blysku,__zero_reg__
1473:main.c        ****     }
 7393               		.loc 1 1473 0
 7394 2746 8150      		subi r24,lo8(-(-1))
 7395 2748 8093 0000 		sts liczba_blyskow_led,r24
 7396               	.L814:
1475:main.c        ****     return;
 7397               		.loc 1 1475 0
 7398 274c 8091 0000 		lds r24,stan_cyklu_blysku
 7399 2750 8230      		cpi r24,lo8(2)
 7400 2752 00F4      		brsh .+2
 7401 2754 00C0      		rjmp .L815
1475:main.c        ****     return;
 7402               		.loc 1 1475 0 is_stmt 0 discriminator 1
 7403 2756 409A      		sbi 0x8,0
 7404 2758 0895      		ret
 7405               	.L796:
1363:main.c        ****   }
 7406               		.loc 1 1363 0 is_stmt 1 discriminator 2
 7407 275a 4098      		cbi 0x8,0
 7408 275c 00C0      		rjmp .L795
 7409               	.LVL560:
 7410               	.L802:
1395:main.c        ****                                        KOMENDA_KOLEJKI_WYSLIJ_SMSA_PDU);
 7411               		.loc 1 1395 0
 7412 275e 63ED      		ldi r22,lo8(-45)
 7413 2760 82ED      		ldi r24,lo8(-46)
 7414 2762 0E94 0000 		call filtruj_komendy_z_przedzialu
 7415               	.LVL561:
1397:main.c        ****             ++licznik_awaryjnych_resetow_kolejki;
 7416               		.loc 1 1397 0
 7417 2766 8091 0000 		lds r24,licznik_awaryjnych_resetow_kolejki
 7418 276a 9091 0000 		lds r25,licznik_awaryjnych_resetow_kolejki+1
 7419 276e 8F3F      		cpi r24,-1
 7420 2770 9807      		cpc r25,r24
 7421 2772 01F0      		breq .L804
1398:main.c        **** 
 7422               		.loc 1 1398 0
 7423 2774 0196      		adiw r24,1
 7424 2776 9093 0000 		sts licznik_awaryjnych_resetow_kolejki+1,r25
 7425 277a 8093 0000 		sts licznik_awaryjnych_resetow_kolejki,r24
 7426               	.L804:
1400:main.c        **** 
 7427               		.loc 1 1400 0
 7428 277e 81E9      		ldi r24,lo8(-111)
 7429 2780 0E94 0000 		call filtruj_i_dodaj_komende
 7430               	.LVL562:
1403:main.c        ****           timer_report_user_100ms = 0;
 7431               		.loc 1 1403 0
 7432 2784 1092 0000 		sts licznik_report_user,__zero_reg__
1404:main.c        **** 
 7433               		.loc 1 1404 0
 7434 2788 1092 0000 		sts timer_report_user_100ms+1,__zero_reg__
 7435 278c 1092 0000 		sts timer_report_user_100ms,__zero_reg__
1407:main.c        ****           ostatnia_pierwsza_komenda = KOMENDA_KOLEJKI_BRAK_KOMENDY;
 7436               		.loc 1 1407 0
 7437 2790 1092 0000 		sts licznik_kolejka_stoi_100ms+1,__zero_reg__
 7438 2794 1092 0000 		sts licznik_kolejka_stoi_100ms,__zero_reg__
1408:main.c        **** 
 7439               		.loc 1 1408 0
 7440 2798 1092 0000 		sts ostatnia_pierwsza_komenda,__zero_reg__
1411:main.c        ****         }
 7441               		.loc 1 1411 0
 7442 279c 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
 7443 27a0 00C0      		rjmp .L803
 7444               	.LVL563:
 7445               	.L800:
1420:main.c        ****       licznik_kolejka_stoi_100ms = 0;
 7446               		.loc 1 1420 0
 7447 27a2 8093 0000 		sts ostatnia_pierwsza_komenda,r24
 7448               	.L844:
1426:main.c        ****   }
 7449               		.loc 1 1426 0
 7450 27a6 1092 0000 		sts licznik_kolejka_stoi_100ms+1,__zero_reg__
 7451 27aa 1092 0000 		sts licznik_kolejka_stoi_100ms,__zero_reg__
 7452 27ae 00C0      		rjmp .L803
 7453               	.L799:
1425:main.c        ****     licznik_kolejka_stoi_100ms = 0;
 7454               		.loc 1 1425 0
 7455 27b0 1092 0000 		sts ostatnia_pierwsza_komenda,__zero_reg__
 7456 27b4 00C0      		rjmp .L844
 7457               	.LVL564:
 7458               	.L806:
1434:main.c        ****       // Awaryjne odblokowanie
 7459               		.loc 1 1434 0
 7460 27b6 1092 0000 		sts licznik_watchdog_wysylanie_smsa_100ms+1,__zero_reg__
 7461 27ba 1092 0000 		sts licznik_watchdog_wysylanie_smsa_100ms,__zero_reg__
1436:main.c        ****       flaga_wysylanie_smsa = 0;
 7462               		.loc 1 1436 0
 7463 27be 0E94 0000 		call watchdog_sms_disarm
 7464               	.LVL565:
1437:main.c        ****       liczba_prob_wyslania_smsa = 0;
 7465               		.loc 1 1437 0
 7466 27c2 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
1438:main.c        ****       czekanie_na_odebranie_zachety = FALSE;
 7467               		.loc 1 1438 0
 7468 27c6 1092 0000 		sts liczba_prob_wyslania_smsa,__zero_reg__
1439:main.c        ****       wysylanie_smsa_clipa = WYSYLANIE_SMSA_CLIPA_BRAK;
 7469               		.loc 1 1439 0
 7470 27ca 1092 0000 		sts czekanie_na_odebranie_zachety,__zero_reg__
1440:main.c        **** 
 7471               		.loc 1 1440 0
 7472 27ce 1092 0000 		sts wysylanie_smsa_clipa,__zero_reg__
1442:main.c        ****         ++liczba_kolejnych_watchdogow_wysylania;
 7473               		.loc 1 1442 0
 7474 27d2 8091 0000 		lds r24,liczba_kolejnych_watchdogow_wysylania
 7475 27d6 8F3F      		cpi r24,lo8(-1)
 7476 27d8 01F0      		breq .L808
1443:main.c        ****       if (liczba_kolejnych_watchdogow_wysylania >= 3) {
 7477               		.loc 1 1443 0
 7478 27da 8F5F      		subi r24,lo8(-(1))
 7479 27dc 8093 0000 		sts liczba_kolejnych_watchdogow_wysylania,r24
 7480               	.L808:
1444:main.c        ****         liczba_kolejnych_watchdogow_wysylania = 0;
 7481               		.loc 1 1444 0
 7482 27e0 8091 0000 		lds r24,liczba_kolejnych_watchdogow_wysylania
 7483 27e4 8330      		cpi r24,lo8(3)
 7484 27e6 00F4      		brsh .+2
 7485 27e8 00C0      		rjmp .L807
1445:main.c        ****         reset_modulu_SIM900();
 7486               		.loc 1 1445 0
 7487 27ea 1092 0000 		sts liczba_kolejnych_watchdogow_wysylania,__zero_reg__
1446:main.c        ****       }
 7488               		.loc 1 1446 0
 7489 27ee 0E94 0000 		call reset_modulu_SIM900
 7490               	.LVL566:
 7491 27f2 00C0      		rjmp .L807
 7492               	.L805:
1450:main.c        ****     liczba_kolejnych_watchdogow_wysylania = 0;
 7493               		.loc 1 1450 0
 7494 27f4 1092 0000 		sts licznik_watchdog_wysylanie_smsa_100ms+1,__zero_reg__
 7495 27f8 1092 0000 		sts licznik_watchdog_wysylanie_smsa_100ms,__zero_reg__
1451:main.c        ****   }
 7496               		.loc 1 1451 0
 7497 27fc 1092 0000 		sts liczba_kolejnych_watchdogow_wysylania,__zero_reg__
 7498 2800 00C0      		rjmp .L807
 7499               	.L810:
1458:main.c        ****       cli();
 7500               		.loc 1 1458 0
 7501 2802 8FEF      		ldi r24,lo8(-1)
 7502 2804 8093 0000 		sts watchdog_sms_trwa_reset,r24
1459:main.c        ****       wdt_enable(WDTO_15MS);
 7503               		.loc 1 1459 0
 7504               	/* #APP */
 7505               	 ;  1459 "main.c" 1
 7506 2808 F894      		cli
 7507               	 ;  0 "" 2
 7508               	.LVL567:
 7509               	/* #NOAPP */
 7510               	.LBB580:
 7511               	.LBB581:
 7512               		.file 7 "/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h"
   1:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
   5:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
   8:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  11:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      distribution.
  15:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  16:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  20:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  32:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /* $Id$ */
  33:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  34:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /*
  35:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****  */
  37:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  38:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  41:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  44:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /** \file */
  45:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  48:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  57:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  61:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     the following:
  68:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  69:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     \code
  70:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  73:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  75:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     {
  80:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     }
  84:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     \endcode
  85:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  86:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** */
  91:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  92:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /**
  93:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** */
  98:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
  99:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 101:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #ifndef __DOXYGEN__
 102:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 103:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined(WDP3)
 104:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 105:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else
 106:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 107:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif
 108:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 109:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 110:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 111:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 112:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 113:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else
 114:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 115:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif
 116:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 117:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined(WDTOE)
 118:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 119:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else
 120:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 121:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif
 122:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 123:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif	/* !__DOXYGEN__ */
 124:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 125:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 126:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /**
 127:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 128:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 129:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 130:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 131:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 132:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 133:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 134:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 135:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** */
 136:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 137:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 138:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 139:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 140:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #if defined (WDT_CTRLA) && !defined(RAMPD)
 141:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 142:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 143:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** do { \
 144:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** uint8_t temp; \
 145:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 146:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"wdr"									"\n\t" \
 147:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]"		"\n\t" \
 148:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"				"\n\t" \
 149:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"sbr %[tmp], %[wdt_enable_timeout]"		"\n\t" \
 150:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"				"\n\t" \
 151:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"1:lds %[tmp], %[wdt_status_reg]"		"\n\t" \
 152:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"sbrc %[tmp], %[wdt_syncbusy_bit]"		"\n\t" \
 153:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"rjmp 1b"								"\n\t" \
 154:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	: [tmp]					"=r" (temp) \
 155:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	: [ccp_reg]				"I"  (_SFR_IO_ADDR(CCP)), \
 156:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [ioreg_cen_mask]		"r"  ((uint8_t)CCP_IOREG_gc), \
 157:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [wdt_reg]				"n"  (_SFR_MEM_ADDR(WDT_CTRLA)), \
 158:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [wdt_enable_timeout]	"M"  (timeout), \
 159:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [wdt_status_reg]		"n"  (_SFR_MEM_ADDR(WDT_STATUS)), \
 160:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	  [wdt_syncbusy_bit]	"I"  (WDT_SYNCBUSY_bm) \
 161:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ); \
 162:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** } while(0)
 163:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 164:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_disable() \
 165:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** do { \
 166:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** uint8_t temp; \
 167:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 168:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"wdr"								"\n\t" \
 169:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 170:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"			"\n\t" \
 171:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"cbr %[tmp], %[timeout_mask]"       "\n\t" \
 172:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"			"\n\t" \
 173:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [tmp]            "=r" (temp) \
 174:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [ccp_reg]        "I" (_SFR_IO_ADDR(CCP)),       \
 175:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ioreg_cen_mask] "r" ((uint8_t)CCP_IOREG_gc),   \
 176:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_reg]        "n" (_SFR_MEM_ADDR(WDT_CTRLA)),\
 177:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [timeout_mask]   "I" (WDT_PERIOD_gm) \
 178:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ); \
 179:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** } while(0)
 180:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 181:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else // defined (WDT_CTRLA) && !defined(RAMPD)
 182:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 183:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** /*
 184:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 185:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 186:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    registers to the CCP register
 187:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ** At the same time,
 188:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 189:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 190:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 191:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 192:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 193:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****    sync is finished).
 194:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** */
 195:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 196:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** do { \
 197:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** uint8_t temp; \
 198:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 199:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 200:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 201:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 202:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 203:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 204:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 205:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 206:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 207:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 208:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 209:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 210:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 211:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 212:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 213:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 214:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 215:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : "r0" \
 216:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ); \
 217:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** } while(0)
 218:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 219:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_disable() \
 220:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 221:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 222:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 223:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 224:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 225:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 226:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : \
 227:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 228:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 229:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 230:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 231:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 232:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : "r0" \
 233:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** );
 234:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 235:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #endif // defined (WDT_CTRLA) && !defined(RAMPD)
 236:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 237:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 238:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 239:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 240:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 241:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 242:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 243:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 244:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 245:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 246:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 247:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : /* no outputs */  \
 248:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 249:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 250:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 251:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 252:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 253:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : "r16" \
 254:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** )
 255:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 256:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #define wdt_disable() \
 257:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** do { \
 258:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 259:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 260:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 261:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 262:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 263:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 264:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 265:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 266:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 267:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 268:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : /*no output */ \
 269:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 270:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 271:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 272:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 273:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 274:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****     : "r16" \
 275:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** ); \
 276:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** }while(0)
 277:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 278:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #elif defined(CCP)
 279:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 280:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** static __inline__
 281:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 282:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 283:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** {
 284:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 285:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 286:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 287:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 288:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 289:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 290:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 291:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 292:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 293:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: /* no outputs */
 294:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 295:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 296:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 297:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 298:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 299:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: "r0"
 300:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			);
 301:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 302:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 303:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 304:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 305:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 306:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 307:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 308:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 309:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 310:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 311:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: /* no outputs */
 312:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 313:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 314:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 315:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 316:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 317:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: "r0"
 318:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			);
 319:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 320:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 321:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 322:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 323:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 324:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 325:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 326:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 327:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 328:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 329:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: /* no outputs */
 330:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 331:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 332:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 333:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 334:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 335:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: "r0"
 336:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			);
 337:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 338:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else
 339:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****  	{
 340:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 341:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 342:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 343:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 344:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 345:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 346:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 347:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: /* no outputs */
 348:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 349:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 350:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 351:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 352:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 353:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			: "r0"
 354:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 			);
 355:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 356:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** }
 357:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 358:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** static __inline__
 359:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 360:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** void wdt_disable (void)
 361:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** {
 362:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 363:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 364:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 365:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 366:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 367:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 368:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 369:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 370:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 371:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 372:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 373:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 374:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /*no output */
 375:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 376:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 377:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 378:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 379:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 380:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 381:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				);
 382:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 383:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 384:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 385:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 386:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 387:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 388:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 389:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 390:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 391:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 392:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 393:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 394:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 395:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /*no output */
 396:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 397:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 398:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 399:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 400:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 401:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 402:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				);
 403:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 404:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 405:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 406:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 407:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 408:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 409:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 410:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 411:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 412:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 413:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 414:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 415:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 416:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /*no output */
 417:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 418:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 419:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 420:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 421:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 422:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 423:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				);
 424:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 425:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else
 426:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 427:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 428:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 429:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 430:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 431:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 432:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 433:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 434:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 435:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 436:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 437:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /*no output */
 438:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 439:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 440:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 441:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 442:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 443:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 444:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				);
 445:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 446:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** }
 447:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 448:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** #else
 449:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 
 450:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** static __inline__
 451:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 452:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 453:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** {
 454:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 455:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 456:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 457:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 458:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 459:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 460:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 461:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 462:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 463:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: /* no outputs */
 464:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 465:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 466:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 467:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 468:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 				: "r0"
 469:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		);
 470:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	}
 471:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	else
 472:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 	{
 473:/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 7513               		.loc 7 473 0
 7514 280a 88E1      		ldi r24,lo8(24)
 7515 280c 98E0      		ldi r25,lo8(8)
 7516               	/* #APP */
 7517               	 ;  473 "/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h" 1
 7518 280e 0FB6      		in __tmp_reg__,__SREG__
 7519 2810 F894      		cli
 7520 2812 A895      		wdr
 7521 2814 8093 6000 		sts 96, r24
 7522 2818 0FBE      		out __SREG__,__tmp_reg__
 7523 281a 9093 6000 		sts 96, r25
 7524               	 	
 7525               	 ;  0 "" 2
 7526               	/* #NOAPP */
 7527               	.L812:
 7528 281e 00C0      		rjmp .L812
 7529               	.LVL568:
 7530               	.L809:
 7531               	.LBE581:
 7532               	.LBE580:
1464:main.c        ****     --watchdog_sms_safe_mode_100ms;
 7533               		.loc 1 1464 0
 7534 2820 8091 0000 		lds r24,watchdog_sms_safe_mode_100ms
 7535 2824 9091 0000 		lds r25,watchdog_sms_safe_mode_100ms+1
 7536 2828 892B      		or r24,r25
 7537 282a 01F4      		brne .+2
 7538 282c 00C0      		rjmp .L811
1465:main.c        ****   }
 7539               		.loc 1 1465 0
 7540 282e 8091 0000 		lds r24,watchdog_sms_safe_mode_100ms
 7541 2832 9091 0000 		lds r25,watchdog_sms_safe_mode_100ms+1
 7542 2836 0197      		sbiw r24,1
 7543 2838 9093 0000 		sts watchdog_sms_safe_mode_100ms+1,r25
 7544 283c 8093 0000 		sts watchdog_sms_safe_mode_100ms,r24
 7545 2840 00C0      		rjmp .L811
 7546               	.L815:
1475:main.c        ****     return;
 7547               		.loc 1 1475 0 discriminator 2
 7548 2842 4098      		cbi 0x8,0
 7549               	/* epilogue start */
1505:main.c        **** 
 7550               		.loc 1 1505 0 discriminator 2
 7551 2844 0895      		ret
 7552               	.L813:
1481:main.c        ****     // Nie zalogowany - dioda swiecei ciagle
 7553               		.loc 1 1481 0
 7554 2846 8091 0000 		lds r24,modul_zalogowany_w_sieci
 7555 284a 8111      		cpse r24,__zero_reg__
 7556 284c 00C0      		rjmp .L817
 7557               	.L822:
 7558               	.LBB582:
1498:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7559               		.loc 1 1498 0 discriminator 6
 7560 284e 4098      		cbi 0x8,0
 7561 2850 00C0      		rjmp .L818
 7562               	.L817:
 7563               	.LBE582:
1486:main.c        ****       // Mrugniecie (SMS, etc.)
 7564               		.loc 1 1486 0
 7565 2852 8091 0000 		lds r24,licznik_100ms_dioda_led
 7566 2856 8111      		cpse r24,__zero_reg__
 7567 2858 00C0      		rjmp .L822
 7568               	.LBB583:
1492:main.c        ****         if (++licznik_dioda_led_poziom_sieci >= 50)
 7569               		.loc 1 1492 0
 7570 285a 8091 0000 		lds r24,poziom_sieci_gsm
 7571 285e 8031      		cpi r24,lo8(16)
 7572 2860 00F4      		brsh .L820
1493:main.c        ****           licznik_dioda_led_poziom_sieci = 1;
 7573               		.loc 1 1493 0
 7574 2862 8091 0000 		lds r24,licznik_dioda_led_poziom_sieci.3696
 7575 2866 8F5F      		subi r24,lo8(-(1))
 7576 2868 8093 0000 		sts licznik_dioda_led_poziom_sieci.3696,r24
 7577 286c 8233      		cpi r24,lo8(50)
 7578 286e 00F0      		brlo .L821
1494:main.c        ****       } else
 7579               		.loc 1 1494 0
 7580 2870 81E0      		ldi r24,lo8(1)
 7581 2872 8093 0000 		sts licznik_dioda_led_poziom_sieci.3696,r24
 7582               	.L821:
1498:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7583               		.loc 1 1498 0
 7584 2876 8091 0000 		lds r24,licznik_dioda_led_poziom_sieci.3696
 7585 287a 8832      		cpi r24,lo8(40)
 7586 287c 01F0      		breq .L822
1498:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7587               		.loc 1 1498 0 is_stmt 0 discriminator 1
 7588 287e 8B32      		cpi r24,lo8(43)
 7589 2880 01F0      		breq .L822
1498:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7590               		.loc 1 1498 0 discriminator 3
 7591 2882 8E52      		subi r24,lo8(-(-46))
 7592 2884 8430      		cpi r24,lo8(4)
 7593 2886 00F0      		brlo .L822
1498:main.c        ****                      licznik_dioda_led_poziom_sieci == 43 ||
 7594               		.loc 1 1498 0 discriminator 5
 7595 2888 409A      		sbi 0x8,0
 7596               	.L818:
 7597               	.LBE583:
1504:main.c        **** }
 7598               		.loc 1 1504 0 is_stmt 1
 7599 288a 0C94 0000 		jmp zapis_w_eeprom_stanu_wyjsc
 7600               	.LVL569:
 7601               	.L820:
 7602               	.LBB584:
1496:main.c        **** 
 7603               		.loc 1 1496 0
 7604 288e 1092 0000 		sts licznik_dioda_led_poziom_sieci.3696,__zero_reg__
 7605 2892 00C0      		rjmp .L821
 7606               	.LBE584:
 7607               		.cfi_endproc
 7608               	.LFE64:
 7610               	.global	steruj_urzadzeniem_10MS
 7612               	steruj_urzadzeniem_10MS:
 7613               	.LFB65:
1507:main.c        ****   steruj_wejscia_10ms();
 7614               		.loc 1 1507 0
 7615               		.cfi_startproc
 7616               	/* prologue: function */
 7617               	/* frame size = 0 */
 7618               	/* stack size = 0 */
 7619               	.L__stack_usage = 0
1508:main.c        ****   steruj_SIM900_10MS();
 7620               		.loc 1 1508 0
 7621 2894 0E94 0000 		call steruj_wejscia_10ms
 7622               	.LVL570:
1509:main.c        ****   zapisz_bajt_w_EEPROM();
 7623               		.loc 1 1509 0
 7624 2898 0E94 0000 		call steruj_SIM900_10MS
 7625               	.LVL571:
1510:main.c        ****   // test_dioda_wyjscia();
 7626               		.loc 1 1510 0
 7627 289c 0C94 0000 		jmp zapisz_bajt_w_EEPROM
 7628               	.LVL572:
 7629               		.cfi_endproc
 7630               	.LFE65:
 7632               	.global	wolne_zdarzenie_timer
 7634               	wolne_zdarzenie_timer:
 7635               	.LFB66:
1515:main.c        ****   WYKONAJ_CLI_SEI(WYLACZ_PRZERWANIE_TIMER());
 7636               		.loc 1 1515 0
 7637               		.cfi_startproc
 7638               	/* prologue: function */
 7639               	/* frame size = 0 */
 7640               	/* stack size = 0 */
 7641               	.L__stack_usage = 0
1516:main.c        ****   if (!CZY_WYKONAC_ZDARZENIE_TIMER()) {
 7642               		.loc 1 1516 0
 7643               	/* #APP */
 7644               	 ;  1516 "main.c" 1
 7645 28a0 F894      		cli
 7646               	 ;  0 "" 2
 7647               	/* #NOAPP */
 7648 28a2 8091 6E00 		lds r24,110
 7649 28a6 8D7F      		andi r24,lo8(-3)
 7650 28a8 8093 6E00 		sts 110,r24
 7651               	/* #APP */
 7652               	 ;  1516 "main.c" 1
 7653 28ac 7894      		sei
 7654               	 ;  0 "" 2
 7655               	 ;  1516 "main.c" 1
 7656 28ae 0000      		nop
 7657               	 ;  0 "" 2
1517:main.c        ****     WYKONAJ_CLI_SEI(WLACZ_PRZERWANIE_TIMER());
 7658               		.loc 1 1517 0
 7659               	/* #NOAPP */
 7660 28b0 8091 0000 		lds r24,wykonaj_zdarzenie_timer
 7661 28b4 8111      		cpse r24,__zero_reg__
 7662 28b6 00C0      		rjmp .L847
1518:main.c        ****     return;
 7663               		.loc 1 1518 0
 7664               	/* #APP */
 7665               	 ;  1518 "main.c" 1
 7666 28b8 F894      		cli
 7667               	 ;  0 "" 2
 7668               	/* #NOAPP */
 7669 28ba 8091 6E00 		lds r24,110
 7670 28be 8260      		ori r24,lo8(2)
 7671 28c0 8093 6E00 		sts 110,r24
 7672               	/* #APP */
 7673               	 ;  1518 "main.c" 1
 7674 28c4 7894      		sei
 7675               	 ;  0 "" 2
 7676               	 ;  1518 "main.c" 1
 7677 28c6 0000      		nop
 7678               	 ;  0 "" 2
1519:main.c        ****   }
 7679               		.loc 1 1519 0
 7680               	/* #NOAPP */
 7681 28c8 0895      		ret
 7682               	.L847:
1521:main.c        ****   if (wykonac_watki_10MS) {
 7683               		.loc 1 1521 0
 7684 28ca 1092 0000 		sts wykonaj_zdarzenie_timer,__zero_reg__
1522:main.c        ****     wykonac_watki = WYKONAJ_WATKI_10MS;
 7685               		.loc 1 1522 0
 7686 28ce 8091 0000 		lds r24,wykonac_watki_10MS
 7687 28d2 8823      		tst r24
 7688 28d4 01F0      		breq .L849
1523:main.c        ****     wykonac_watki_10MS = FALSE;
 7689               		.loc 1 1523 0
 7690 28d6 81E0      		ldi r24,lo8(1)
 7691 28d8 8093 0000 		sts wykonac_watki,r24
1524:main.c        ****   }
 7692               		.loc 1 1524 0
 7693 28dc 1092 0000 		sts wykonac_watki_10MS,__zero_reg__
 7694               	.L849:
1526:main.c        ****   if (CZY_WYKONAC_WATKI_10MS()) {
 7695               		.loc 1 1526 0
 7696               	/* #APP */
 7697               	 ;  1526 "main.c" 1
 7698 28e0 F894      		cli
 7699               	 ;  0 "" 2
 7700               	/* #NOAPP */
 7701 28e2 8091 6E00 		lds r24,110
 7702 28e6 8260      		ori r24,lo8(2)
 7703 28e8 8093 6E00 		sts 110,r24
 7704               	/* #APP */
 7705               	 ;  1526 "main.c" 1
 7706 28ec 7894      		sei
 7707               	 ;  0 "" 2
 7708               	 ;  1526 "main.c" 1
 7709 28ee 0000      		nop
 7710               	 ;  0 "" 2
1527:main.c        ****     static uchar licznik_wybuc_watki_100MS = 0;
 7711               		.loc 1 1527 0
 7712               	/* #NOAPP */
 7713 28f0 8091 0000 		lds r24,wykonac_watki
 7714 28f4 80FF      		sbrs r24,0
 7715 28f6 00C0      		rjmp .L846
 7716               	.LBB588:
1530:main.c        ****       licznik_wybuc_watki_100MS = 0;
 7717               		.loc 1 1530 0
 7718 28f8 8091 0000 		lds r24,licznik_wybuc_watki_100MS.3703
 7719 28fc 8F5F      		subi r24,lo8(-(1))
 7720 28fe 8A30      		cpi r24,lo8(10)
 7721 2900 01F0      		breq .L850
 7722 2902 8093 0000 		sts licznik_wybuc_watki_100MS.3703,r24
 7723               	.L851:
1534:main.c        ****     cli();
 7724               		.loc 1 1534 0
 7725               	/* #APP */
 7726               	 ;  1534 "main.c" 1
 7727 2906 0000      		nop
 7728               	 ;  0 "" 2
1535:main.c        ****     if (CZY_ODBIERANIE_DANYCH_SIM900()) {
 7729               		.loc 1 1535 0
 7730               	 ;  1535 "main.c" 1
 7731 2908 F894      		cli
 7732               	 ;  0 "" 2
1536:main.c        ****       WYLACZ_PRZERWANIE_ODBIORU_DANYCH_SIM900();
 7733               		.loc 1 1536 0
 7734               	/* #NOAPP */
 7735 290a 00B6      		in __tmp_reg__,0x30
 7736 290c 01FE      		sbrs __tmp_reg__,1
 7737 290e 00C0      		rjmp .L852
1537:main.c        ****       sei();
 7738               		.loc 1 1537 0
 7739 2910 8091 C100 		lds r24,193
 7740 2914 8F77      		andi r24,lo8(127)
 7741 2916 8093 C100 		sts 193,r24
1538:main.c        ****       if (liczba_odebranych_znakow_SIM900 != 0 &&
 7742               		.loc 1 1538 0
 7743               	/* #APP */
 7744               	 ;  1538 "main.c" 1
 7745 291a 7894      		sei
 7746               	 ;  0 "" 2
1539:main.c        ****           ++licznik_opoznienie_oczekiwania_na_bajt_SIM900 >
 7747               		.loc 1 1539 0
 7748               	/* #NOAPP */
 7749 291c 8091 0000 		lds r24,liczba_odebranych_znakow_SIM900
 7750 2920 9091 0000 		lds r25,liczba_odebranych_znakow_SIM900+1
 7751 2924 892B      		or r24,r25
 7752 2926 01F0      		breq .L853
1540:main.c        ****               MAX_OPOZNIENIE_OCZEKIWANIA_NA_BAJT_SIM900_500_MS) {
 7753               		.loc 1 1540 0
 7754 2928 8091 0000 		lds r24,licznik_opoznienie_oczekiwania_na_bajt_SIM900
 7755 292c 8F5F      		subi r24,lo8(-(1))
1539:main.c        ****           ++licznik_opoznienie_oczekiwania_na_bajt_SIM900 >
 7756               		.loc 1 1539 0
 7757 292e 8093 0000 		sts licznik_opoznienie_oczekiwania_na_bajt_SIM900,r24
 7758 2932 8333      		cpi r24,lo8(51)
 7759 2934 00F0      		brlo .L853
1542:main.c        ****       } else {
 7760               		.loc 1 1542 0
 7761 2936 459A      		sbi 0x8,5
 7762 2938 8091 C100 		lds r24,193
 7763 293c 8F77      		andi r24,lo8(127)
 7764 293e 8093 C100 		sts 193,r24
 7765 2942 80B7      		in r24,0x30
 7766 2944 8D7F      		andi r24,lo8(-3)
 7767 2946 80BF      		out 0x30,r24
 7768 2948 1092 0000 		sts poczatek_polecenia_SIM900+1,__zero_reg__
 7769 294c 1092 0000 		sts poczatek_polecenia_SIM900,__zero_reg__
 7770 2950 1092 0000 		sts zakonczenie_polecenia_SIM900+1,__zero_reg__
 7771 2954 1092 0000 		sts zakonczenie_polecenia_SIM900,__zero_reg__
 7772 2958 1092 0000 		sts czy_jest_nowe_polecenie_SIM900,__zero_reg__
 7773               	.L852:
1547:main.c        ****   }
 7774               		.loc 1 1547 0
 7775               	/* #APP */
 7776               	 ;  1547 "main.c" 1
 7777 295c 7894      		sei
 7778               	 ;  0 "" 2
 7779               	/* #NOAPP */
 7780               	.L846:
 7781               	/* epilogue start */
 7782               	.LBE588:
1549:main.c        **** 
 7783               		.loc 1 1549 0
 7784 295e 0895      		ret
 7785               	.L850:
 7786               	.LBB589:
1531:main.c        ****       wykonac_watki = WYKONAJ_WATKI_100MS | WYKONAJ_WATKI_10MS;
 7787               		.loc 1 1531 0
 7788 2960 1092 0000 		sts licznik_wybuc_watki_100MS.3703,__zero_reg__
1532:main.c        ****     }
 7789               		.loc 1 1532 0
 7790 2964 83E0      		ldi r24,lo8(3)
 7791 2966 8093 0000 		sts wykonac_watki,r24
 7792 296a 00C0      		rjmp .L851
 7793               	.L853:
1544:main.c        ****       }
 7794               		.loc 1 1544 0
 7795               	/* #APP */
 7796               	 ;  1544 "main.c" 1
 7797 296c F894      		cli
 7798               	 ;  0 "" 2
 7799               	/* #NOAPP */
 7800 296e 8091 C100 		lds r24,193
 7801 2972 8068      		ori r24,lo8(-128)
 7802 2974 8093 C100 		sts 193,r24
 7803               	/* #APP */
 7804               	 ;  1544 "main.c" 1
 7805 2978 7894      		sei
 7806               	 ;  0 "" 2
 7807               	 ;  1544 "main.c" 1
 7808 297a 0000      		nop
 7809               	 ;  0 "" 2
 7810               	/* #NOAPP */
 7811 297c 00C0      		rjmp .L852
 7812               	.LBE589:
 7813               		.cfi_endproc
 7814               	.LFE66:
 7816               	.global	ustaw_parametry_dla_bezpieczenstwa
 7818               	ustaw_parametry_dla_bezpieczenstwa:
 7819               	.LFB67:
1551:main.c        ****   wdt_reset();
 7820               		.loc 1 1551 0
 7821               		.cfi_startproc
 7822               	/* prologue: function */
 7823               	/* frame size = 0 */
 7824               	/* stack size = 0 */
 7825               	.L__stack_usage = 0
1552:main.c        ****   ustaw_parametry_dla_bezpieczenstwa_rejestry();
 7826               		.loc 1 1552 0
 7827               	/* #APP */
 7828               	 ;  1552 "main.c" 1
 7829 297e A895      		wdr
 7830               	 ;  0 "" 2
1553:main.c        ****   set_sleep_mode(SLEEP_MODE_IDLE);
 7831               		.loc 1 1553 0
 7832               	/* #NOAPP */
 7833 2980 82E0      		ldi r24,lo8(2)
 7834 2982 84BD      		out 0x24,r24
 7835 2984 83E0      		ldi r24,lo8(3)
 7836 2986 85BD      		out 0x25,r24
 7837 2988 8FE3      		ldi r24,lo8(63)
 7838 298a 87BD      		out 0x27,r24
 7839 298c EEE6      		ldi r30,lo8(110)
 7840 298e F0E0      		ldi r31,0
 7841 2990 8081      		ld r24,Z
 7842 2992 8260      		ori r24,lo8(2)
 7843 2994 8083      		st Z,r24
1554:main.c        **** }
 7844               		.loc 1 1554 0
 7845 2996 83B7      		in r24,0x33
 7846 2998 817F      		andi r24,lo8(-15)
 7847 299a 83BF      		out 0x33,r24
 7848               	/* epilogue start */
1555:main.c        **** 
 7849               		.loc 1 1555 0
 7850 299c 0895      		ret
 7851               		.cfi_endproc
 7852               	.LFE67:
 7854               	.global	inicjalizuj_parametry_modulu
 7856               	inicjalizuj_parametry_modulu:
 7857               	.LFB68:
1557:main.c        ****   memcpy_E(kod_modulu, ADRES_EEPROM_KOD_DOSTEPU, LICZBA_BAJTOW_KODU_DOSTEPU);
 7858               		.loc 1 1557 0
 7859               		.cfi_startproc
 7860 299e CF93      		push r28
 7861               	.LCFI89:
 7862               		.cfi_def_cfa_offset 3
 7863               		.cfi_offset 28, -2
 7864 29a0 DF93      		push r29
 7865               	.LCFI90:
 7866               		.cfi_def_cfa_offset 4
 7867               		.cfi_offset 29, -3
 7868               	/* prologue: function */
 7869               	/* frame size = 0 */
 7870               	/* stack size = 2 */
 7871               	.L__stack_usage = 2
1558:main.c        **** 
 7872               		.loc 1 1558 0
 7873 29a2 44E0      		ldi r20,lo8(4)
 7874 29a4 50E0      		ldi r21,0
 7875 29a6 61E0      		ldi r22,lo8(1)
 7876 29a8 70E0      		ldi r23,0
 7877 29aa 80E0      		ldi r24,lo8(kod_modulu)
 7878 29ac 90E0      		ldi r25,hi8(kod_modulu)
 7879 29ae 0E94 0000 		call eeprom_read_block
 7880               	.LVL573:
1561:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 7881               		.loc 1 1561 0
 7882 29b2 8091 0000 		lds r24,kod_modulu
 7883 29b6 8150      		subi r24,lo8(-(-1))
 7884 29b8 8E3F      		cpi r24,lo8(-2)
 7885 29ba 00F0      		brlo .L868
1562:main.c        ****     kod_modulu[1] = bufor_eeprom[1] = 'B';
 7886               		.loc 1 1562 0
 7887 29bc 81E4      		ldi r24,lo8(65)
 7888 29be 8093 0000 		sts bufor_eeprom,r24
 7889 29c2 8093 0000 		sts kod_modulu,r24
1563:main.c        ****     kod_modulu[2] = bufor_eeprom[2] = 'C';
 7890               		.loc 1 1563 0
 7891 29c6 82E4      		ldi r24,lo8(66)
 7892 29c8 8093 0000 		sts bufor_eeprom+1,r24
 7893 29cc 8093 0000 		sts kod_modulu+1,r24
1564:main.c        ****     kod_modulu[3] = bufor_eeprom[3] = 'D';
 7894               		.loc 1 1564 0
 7895 29d0 83E4      		ldi r24,lo8(67)
 7896 29d2 8093 0000 		sts bufor_eeprom+2,r24
 7897 29d6 8093 0000 		sts kod_modulu+2,r24
1565:main.c        ****     // Zapisz do EEPROM natychmiast (BLOCKING)
 7898               		.loc 1 1565 0
 7899 29da 84E4      		ldi r24,lo8(68)
 7900 29dc 8093 0000 		sts bufor_eeprom+3,r24
 7901 29e0 8093 0000 		sts kod_modulu+3,r24
 7902               	.L869:
1567:main.c        ****       ;
 7903               		.loc 1 1567 0 discriminator 1
 7904 29e4 F999      		sbic 0x1f,1
 7905 29e6 00C0      		rjmp .L869
1569:main.c        ****                         LICZBA_BAJTOW_KODU_DOSTEPU);
 7906               		.loc 1 1569 0
 7907 29e8 44E0      		ldi r20,lo8(4)
 7908 29ea 50E0      		ldi r21,0
 7909 29ec 61E0      		ldi r22,lo8(1)
 7910 29ee 70E0      		ldi r23,0
 7911 29f0 80E0      		ldi r24,lo8(kod_modulu)
 7912 29f2 90E0      		ldi r25,hi8(kod_modulu)
 7913 29f4 0E94 0000 		call eeprom_update_block
 7914               	.LVL574:
 7915               	.L868:
1575:main.c        ****   if (tryb_pracy == 0xFF) {
 7916               		.loc 1 1575 0
 7917 29f8 8EEF      		ldi r24,lo8(-2)
 7918 29fa 9FE0      		ldi r25,lo8(15)
 7919 29fc 0E94 0000 		call eeprom_read_byte
 7920               	.LVL575:
1576:main.c        ****     tryb_pracy = 1; // Domyślnie Publiczny
 7921               		.loc 1 1576 0
 7922 2a00 8F3F      		cpi r24,lo8(-1)
 7923 2a02 01F4      		brne .+2
 7924 2a04 00C0      		rjmp .L870
1575:main.c        ****   if (tryb_pracy == 0xFF) {
 7925               		.loc 1 1575 0
 7926 2a06 8093 0000 		sts tryb_pracy,r24
 7927               	.L871:
1584:main.c        ****   if (tryb_clip == 0xFF) {
 7928               		.loc 1 1584 0
 7929 2a0a 8FEF      		ldi r24,lo8(-1)
 7930 2a0c 9FE0      		ldi r25,lo8(15)
 7931 2a0e 0E94 0000 		call eeprom_read_byte
 7932               	.LVL576:
1585:main.c        ****     tryb_clip = 1; // Domyślnie CLIP (1)
 7933               		.loc 1 1585 0
 7934 2a12 8F3F      		cpi r24,lo8(-1)
 7935 2a14 01F4      		brne .+2
 7936 2a16 00C0      		rjmp .L873
1584:main.c        ****   if (tryb_clip == 0xFF) {
 7937               		.loc 1 1584 0
 7938 2a18 8093 0000 		sts tryb_clip,r24
 7939               	.L874:
1593:main.c        ****   czas_start_m = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_START_M);
 7940               		.loc 1 1593 0
 7941 2a1c 8AEF      		ldi r24,lo8(-6)
 7942 2a1e 9FE0      		ldi r25,lo8(15)
 7943 2a20 0E94 0000 		call eeprom_read_byte
 7944               	.LVL577:
 7945 2a24 8093 0000 		sts czas_start_h,r24
1594:main.c        ****   czas_stop_h = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_STOP_H);
 7946               		.loc 1 1594 0
 7947 2a28 8BEF      		ldi r24,lo8(-5)
 7948 2a2a 9FE0      		ldi r25,lo8(15)
 7949 2a2c 0E94 0000 		call eeprom_read_byte
 7950               	.LVL578:
 7951 2a30 8093 0000 		sts czas_start_m,r24
1595:main.c        ****   czas_stop_m = eeprom_read_byte((const uint8_t *)ADRES_EEPROM_CZAS_STOP_M);
 7952               		.loc 1 1595 0
 7953 2a34 8CEF      		ldi r24,lo8(-4)
 7954 2a36 9FE0      		ldi r25,lo8(15)
 7955 2a38 0E94 0000 		call eeprom_read_byte
 7956               	.LVL579:
 7957 2a3c 8093 0000 		sts czas_stop_h,r24
1596:main.c        **** 
 7958               		.loc 1 1596 0
 7959 2a40 8DEF      		ldi r24,lo8(-3)
 7960 2a42 9FE0      		ldi r25,lo8(15)
 7961 2a44 0E94 0000 		call eeprom_read_byte
 7962               	.LVL580:
 7963 2a48 8093 0000 		sts czas_stop_m,r24
1599:main.c        ****   if (skryba_wlaczona == 0xFF)
 7964               		.loc 1 1599 0
 7965 2a4c 89EF      		ldi r24,lo8(-7)
 7966 2a4e 9FE0      		ldi r25,lo8(15)
 7967 2a50 0E94 0000 		call eeprom_read_byte
 7968               	.LVL581:
1600:main.c        ****     skryba_wlaczona = FALSE;
 7969               		.loc 1 1600 0
 7970 2a54 8F3F      		cpi r24,lo8(-1)
 7971 2a56 01F4      		brne .+2
 7972 2a58 00C0      		rjmp .L876
1599:main.c        ****   if (skryba_wlaczona == 0xFF)
 7973               		.loc 1 1599 0
 7974 2a5a 8093 0000 		sts skryba_wlaczona,r24
 7975               	.L877:
1604:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA_LIMIT_L);
 7976               		.loc 1 1604 0
 7977 2a5e 85EF      		ldi r24,lo8(-11)
 7978 2a60 9FE0      		ldi r25,lo8(15)
 7979 2a62 0E94 0000 		call eeprom_read_byte
 7980               	.LVL582:
 7981 2a66 C82F      		mov r28,r24
 7982               	.LVL583:
1606:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_SKRYBA_LIMIT_H);
 7983               		.loc 1 1606 0
 7984 2a68 86EF      		ldi r24,lo8(-10)
 7985 2a6a 9FE0      		ldi r25,lo8(15)
 7986               	.LVL584:
 7987 2a6c 0E94 0000 		call eeprom_read_byte
 7988               	.LVL585:
1608:main.c        ****     // Nie ustawiono - domyslnie 800
 7989               		.loc 1 1608 0
 7990 2a70 CF3F      		cpi r28,lo8(-1)
 7991 2a72 01F0      		breq .+2
 7992 2a74 00C0      		rjmp .L878
1608:main.c        ****     // Nie ustawiono - domyslnie 800
 7993               		.loc 1 1608 0 is_stmt 0 discriminator 1
 7994 2a76 8F3F      		cpi r24,lo8(-1)
 7995 2a78 01F0      		breq .+2
 7996 2a7a 00C0      		rjmp .L878
 7997               	.LVL586:
 7998               	.L880:
1610:main.c        ****   } else {
 7999               		.loc 1 1610 0 is_stmt 1
 8000 2a7c 80E2      		ldi r24,lo8(32)
 8001 2a7e 93E0      		ldi r25,lo8(3)
 8002 2a80 9093 0000 		sts skryba_limit+1,r25
 8003 2a84 8093 0000 		sts skryba_limit,r24
 8004               	.L879:
1619:main.c        **** 
 8005               		.loc 1 1619 0
 8006 2a88 81E0      		ldi r24,lo8(1)
 8007 2a8a 9091 0000 		lds r25,skryba_wlaczona
 8008 2a8e 9111      		cpse r25,__zero_reg__
 8009 2a90 00C0      		rjmp .L881
 8010 2a92 80E0      		ldi r24,0
 8011               	.L881:
 8012 2a94 6091 0000 		lds r22,skryba_limit
 8013 2a98 0E94 0000 		call zapisz_debug_do_eeprom
 8014               	.LVL587:
1623:main.c        ****       (czas_start_m > 59 && czas_start_m != 0xFF) ||
 8015               		.loc 1 1623 0
 8016 2a9c 8091 0000 		lds r24,czas_start_h
 8017 2aa0 8851      		subi r24,lo8(-(-24))
 8018 2aa2 873E      		cpi r24,lo8(-25)
 8019 2aa4 00F0      		brlo .L900
1624:main.c        ****       (czas_stop_h > 23 && czas_stop_h != 0xFF) ||
 8020               		.loc 1 1624 0 discriminator 1
 8021 2aa6 8091 0000 		lds r24,czas_start_m
 8022 2aaa 8C53      		subi r24,lo8(-(-60))
1623:main.c        ****       (czas_start_m > 59 && czas_start_m != 0xFF) ||
 8023               		.loc 1 1623 0 discriminator 1
 8024 2aac 833C      		cpi r24,lo8(-61)
 8025 2aae 00F0      		brlo .L900
1625:main.c        ****       (czas_stop_m > 59 && czas_stop_m != 0xFF)) {
 8026               		.loc 1 1625 0
 8027 2ab0 8091 0000 		lds r24,czas_stop_h
 8028 2ab4 8851      		subi r24,lo8(-(-24))
1624:main.c        ****       (czas_stop_h > 23 && czas_stop_h != 0xFF) ||
 8029               		.loc 1 1624 0
 8030 2ab6 873E      		cpi r24,lo8(-25)
 8031 2ab8 00F0      		brlo .L900
1626:main.c        ****     // Zapisz wartosci wylaczajace (0xFF) - BLOCKING
 8032               		.loc 1 1626 0
 8033 2aba 8091 0000 		lds r24,czas_stop_m
 8034 2abe 8C53      		subi r24,lo8(-(-60))
1625:main.c        ****       (czas_stop_m > 59 && czas_stop_m != 0xFF)) {
 8035               		.loc 1 1625 0
 8036 2ac0 833C      		cpi r24,lo8(-61)
 8037 2ac2 00F4      		brsh .L883
 8038               	.L900:
1628:main.c        ****       ;
 8039               		.loc 1 1628 0 discriminator 1
 8040 2ac4 F999      		sbic 0x1f,1
 8041 2ac6 00C0      		rjmp .L900
1630:main.c        ****     while (!eeprom_is_ready())
 8042               		.loc 1 1630 0
 8043 2ac8 6FEF      		ldi r22,lo8(-1)
 8044 2aca 8AEF      		ldi r24,lo8(-6)
 8045 2acc 9FE0      		ldi r25,lo8(15)
 8046 2ace 0E94 0000 		call eeprom_update_byte
 8047               	.LVL588:
 8048               	.L884:
1631:main.c        ****       ;
 8049               		.loc 1 1631 0 discriminator 1
 8050 2ad2 F999      		sbic 0x1f,1
 8051 2ad4 00C0      		rjmp .L884
1633:main.c        ****     while (!eeprom_is_ready())
 8052               		.loc 1 1633 0
 8053 2ad6 6FEF      		ldi r22,lo8(-1)
 8054 2ad8 8BEF      		ldi r24,lo8(-5)
 8055 2ada 9FE0      		ldi r25,lo8(15)
 8056 2adc 0E94 0000 		call eeprom_update_byte
 8057               	.LVL589:
 8058               	.L885:
1634:main.c        ****       ;
 8059               		.loc 1 1634 0 discriminator 1
 8060 2ae0 F999      		sbic 0x1f,1
 8061 2ae2 00C0      		rjmp .L885
1636:main.c        ****     while (!eeprom_is_ready())
 8062               		.loc 1 1636 0
 8063 2ae4 6FEF      		ldi r22,lo8(-1)
 8064 2ae6 8CEF      		ldi r24,lo8(-4)
 8065 2ae8 9FE0      		ldi r25,lo8(15)
 8066 2aea 0E94 0000 		call eeprom_update_byte
 8067               	.LVL590:
 8068               	.L886:
1637:main.c        ****       ;
 8069               		.loc 1 1637 0 discriminator 1
 8070 2aee F999      		sbic 0x1f,1
 8071 2af0 00C0      		rjmp .L886
1639:main.c        **** 
 8072               		.loc 1 1639 0
 8073 2af2 6FEF      		ldi r22,lo8(-1)
 8074 2af4 8DEF      		ldi r24,lo8(-3)
 8075 2af6 9FE0      		ldi r25,lo8(15)
 8076 2af8 0E94 0000 		call eeprom_update_byte
 8077               	.LVL591:
1641:main.c        ****     czas_start_m = 0xFF;
 8078               		.loc 1 1641 0
 8079 2afc 8FEF      		ldi r24,lo8(-1)
 8080 2afe 8093 0000 		sts czas_start_h,r24
1642:main.c        ****     czas_stop_h = 0xFF;
 8081               		.loc 1 1642 0
 8082 2b02 8093 0000 		sts czas_start_m,r24
1643:main.c        ****     czas_stop_m = 0xFF;
 8083               		.loc 1 1643 0
 8084 2b06 8093 0000 		sts czas_stop_h,r24
1644:main.c        ****   }
 8085               		.loc 1 1644 0
 8086 2b0a 8093 0000 		sts czas_stop_m,r24
 8087               	.L883:
1647:main.c        ****       FALSE; // Domyślnie odblokowane, zaktualizuje sie przy odczycie czasu
 8088               		.loc 1 1647 0
 8089 2b0e 1092 0000 		sts blokada_sterowania_czasowa,__zero_reg__
1652:main.c        ****   if (blokada_systemu == 0xFF) {
 8090               		.loc 1 1652 0
 8091 2b12 87EF      		ldi r24,lo8(-9)
 8092 2b14 9FE0      		ldi r25,lo8(15)
 8093 2b16 0E94 0000 		call eeprom_read_byte
 8094               	.LVL592:
1653:main.c        ****     blokada_systemu = FALSE; // Domyślnie odblokowany
 8095               		.loc 1 1653 0
 8096 2b1a 8F3F      		cpi r24,lo8(-1)
 8097 2b1c 01F4      		brne .+2
 8098 2b1e 00C0      		rjmp .L887
1651:main.c        ****       eeprom_read_byte((const uint8_t *)ADRES_EEPROM_BLOKADA_SYSTEMU);
 8099               		.loc 1 1651 0
 8100 2b20 8093 0000 		sts blokada_systemu,r24
 8101               	.L888:
1557:main.c        ****   memcpy_E(kod_modulu, ADRES_EEPROM_KOD_DOSTEPU, LICZBA_BAJTOW_KODU_DOSTEPU);
 8102               		.loc 1 1557 0
 8103 2b24 C0EF      		ldi r28,lo8(-16)
 8104 2b26 DFE0      		ldi r29,lo8(15)
 8105               	.LVL593:
 8106               	.L891:
 8107               	.LBB590:
1660:main.c        ****       while (!eeprom_is_ready())
 8108               		.loc 1 1660 0
 8109 2b28 CE01      		movw r24,r28
 8110 2b2a 0E94 0000 		call eeprom_read_byte
 8111               	.LVL594:
 8112 2b2e 8F3F      		cpi r24,lo8(-1)
 8113 2b30 01F4      		brne .L889
 8114               	.L890:
1661:main.c        ****         ;
 8115               		.loc 1 1661 0 discriminator 1
 8116 2b32 F999      		sbic 0x1f,1
 8117 2b34 00C0      		rjmp .L890
1663:main.c        ****     }
 8118               		.loc 1 1663 0
 8119 2b36 60E0      		ldi r22,0
 8120 2b38 CE01      		movw r24,r28
 8121 2b3a 0E94 0000 		call eeprom_update_byte
 8122               	.LVL595:
 8123               	.L889:
1659:main.c        ****     if (eeprom_read_byte((const uint8_t *)addr) == 0xFF) {
 8124               		.loc 1 1659 0
 8125 2b3e 2196      		adiw r28,1
 8126               	.LVL596:
1658:main.c        ****        addr <= ADRES_EEPROM_DEBUG_SKRYBA_5; ++addr) {
 8127               		.loc 1 1658 0
 8128 2b40 C53F      		cpi r28,-11
 8129 2b42 8FE0      		ldi r24,15
 8130 2b44 D807      		cpc r29,r24
 8131 2b46 01F4      		brne .L891
 8132               	.LBE590:
 8133               	.LBB591:
1668:main.c        ****        addr <= ADRES_EEPROM_DEBUG_USER_7; ++addr) {
 8134               		.loc 1 1668 0
 8135 2b48 C6EE      		ldi r28,lo8(-26)
 8136 2b4a DFE0      		ldi r29,lo8(15)
 8137               	.LVL597:
 8138               	.L894:
1670:main.c        ****       while (!eeprom_is_ready())
 8139               		.loc 1 1670 0
 8140 2b4c CE01      		movw r24,r28
 8141 2b4e 0E94 0000 		call eeprom_read_byte
 8142               	.LVL598:
 8143 2b52 8F3F      		cpi r24,lo8(-1)
 8144 2b54 01F4      		brne .L892
 8145               	.L893:
1671:main.c        ****         ;
 8146               		.loc 1 1671 0 discriminator 1
 8147 2b56 F999      		sbic 0x1f,1
 8148 2b58 00C0      		rjmp .L893
1673:main.c        ****     }
 8149               		.loc 1 1673 0
 8150 2b5a 60E0      		ldi r22,0
 8151 2b5c CE01      		movw r24,r28
 8152 2b5e 0E94 0000 		call eeprom_update_byte
 8153               	.LVL599:
 8154               	.L892:
1669:main.c        ****     if (eeprom_read_byte((const uint8_t *)addr) == 0xFF) {
 8155               		.loc 1 1669 0
 8156 2b62 2196      		adiw r28,1
 8157               	.LVL600:
1668:main.c        ****        addr <= ADRES_EEPROM_DEBUG_USER_7; ++addr) {
 8158               		.loc 1 1668 0
 8159 2b64 CD3E      		cpi r28,-19
 8160 2b66 2FE0      		ldi r18,15
 8161 2b68 D207      		cpc r29,r18
 8162 2b6a 01F4      		brne .L894
 8163               	.LBE591:
1679:main.c        ****   timer_report_user_100ms = 0;
 8164               		.loc 1 1679 0
 8165 2b6c 1092 0000 		sts licznik_report_user,__zero_reg__
1680:main.c        **** 
 8166               		.loc 1 1680 0
 8167 2b70 1092 0000 		sts timer_report_user_100ms+1,__zero_reg__
 8168 2b74 1092 0000 		sts timer_report_user_100ms,__zero_reg__
1683:main.c        **** 
 8169               		.loc 1 1683 0
 8170 2b78 1092 0000 		sts flaga_wysylanie_smsa,__zero_reg__
1687:main.c        ****     ++licznik_resetow;
 8171               		.loc 1 1687 0
 8172 2b7c 8091 0000 		lds r24,licznik_resetow.3747
 8173 2b80 8F3F      		cpi r24,lo8(-1)
 8174 2b82 01F0      		breq .L896
1688:main.c        ****   while (!eeprom_is_ready())
 8175               		.loc 1 1688 0
 8176 2b84 8F5F      		subi r24,lo8(-(1))
 8177 2b86 8093 0000 		sts licznik_resetow.3747,r24
 8178               	.L896:
1689:main.c        ****     ;
 8179               		.loc 1 1689 0 discriminator 1
 8180 2b8a F999      		sbic 0x1f,1
 8181 2b8c 00C0      		rjmp .L896
1691:main.c        ****   while (!eeprom_is_ready())
 8182               		.loc 1 1691 0
 8183 2b8e 6091 0000 		lds r22,licznik_resetow.3747
 8184 2b92 8CED      		ldi r24,lo8(-36)
 8185 2b94 9FE0      		ldi r25,lo8(15)
 8186 2b96 0E94 0000 		call eeprom_update_byte
 8187               	.LVL601:
 8188               	.L897:
1692:main.c        ****     ;
 8189               		.loc 1 1692 0 discriminator 1
 8190 2b9a F999      		sbic 0x1f,1
 8191 2b9c 00C0      		rjmp .L897
1694:main.c        **** }
 8192               		.loc 1 1694 0
 8193 2b9e 62E0      		ldi r22,lo8(2)
 8194 2ba0 80E0      		ldi r24,0
 8195               	/* epilogue start */
1695:main.c        **** 
 8196               		.loc 1 1695 0
 8197 2ba2 DF91      		pop r29
 8198 2ba4 CF91      		pop r28
 8199               	.LVL602:
1694:main.c        **** }
 8200               		.loc 1 1694 0
 8201 2ba6 0C94 0000 		jmp zapisz_debug_do_eeprom
 8202               	.LVL603:
 8203               	.L870:
1577:main.c        ****     while (!eeprom_is_ready())
 8204               		.loc 1 1577 0
 8205 2baa 81E0      		ldi r24,lo8(1)
 8206 2bac 8093 0000 		sts tryb_pracy,r24
 8207               	.L872:
1578:main.c        ****       ;
 8208               		.loc 1 1578 0 discriminator 1
 8209 2bb0 F999      		sbic 0x1f,1
 8210 2bb2 00C0      		rjmp .L872
1580:main.c        ****   }
 8211               		.loc 1 1580 0
 8212 2bb4 61E0      		ldi r22,lo8(1)
 8213 2bb6 8EEF      		ldi r24,lo8(-2)
 8214 2bb8 9FE0      		ldi r25,lo8(15)
 8215 2bba 0E94 0000 		call eeprom_update_byte
 8216               	.LVL604:
 8217 2bbe 00C0      		rjmp .L871
 8218               	.L873:
1586:main.c        ****     while (!eeprom_is_ready())
 8219               		.loc 1 1586 0
 8220 2bc0 81E0      		ldi r24,lo8(1)
 8221 2bc2 8093 0000 		sts tryb_clip,r24
 8222               	.L875:
1587:main.c        ****       ;
 8223               		.loc 1 1587 0 discriminator 1
 8224 2bc6 F999      		sbic 0x1f,1
 8225 2bc8 00C0      		rjmp .L875
1589:main.c        ****   }
 8226               		.loc 1 1589 0
 8227 2bca 61E0      		ldi r22,lo8(1)
 8228 2bcc 8FEF      		ldi r24,lo8(-1)
 8229 2bce 9FE0      		ldi r25,lo8(15)
 8230 2bd0 0E94 0000 		call eeprom_update_byte
 8231               	.LVL605:
 8232 2bd4 00C0      		rjmp .L874
 8233               	.L876:
1601:main.c        **** 
 8234               		.loc 1 1601 0
 8235 2bd6 1092 0000 		sts skryba_wlaczona,__zero_reg__
 8236 2bda 00C0      		rjmp .L877
 8237               	.LVL606:
 8238               	.L878:
1612:main.c        ****     // Walidacja zakresu
 8239               		.loc 1 1612 0
 8240 2bdc 982F      		mov r25,r24
 8241 2bde 8C2F      		mov r24,r28
 8242               	.LVL607:
 8243 2be0 9093 0000 		sts skryba_limit+1,r25
 8244 2be4 8093 0000 		sts skryba_limit,r24
1614:main.c        ****       skryba_limit = 800;
 8245               		.loc 1 1614 0
 8246 2be8 0197      		sbiw r24,1
 8247 2bea 8032      		cpi r24,32
 8248 2bec 9340      		sbci r25,3
 8249 2bee 00F0      		brlo .+2
 8250 2bf0 00C0      		rjmp .L880
 8251 2bf2 00C0      		rjmp .L879
 8252               	.LVL608:
 8253               	.L887:
1654:main.c        ****   }
 8254               		.loc 1 1654 0
 8255 2bf4 1092 0000 		sts blokada_systemu,__zero_reg__
 8256 2bf8 00C0      		rjmp .L888
 8257               		.cfi_endproc
 8258               	.LFE68:
 8260               	.global	wykonanie_komend_ukladow
 8262               	wykonanie_komend_ukladow:
 8263               	.LFB58:
 800:main.c        ****   const komenda_typ aktualnie_wykonywana_komenda = komendy_kolejka[0];
 8264               		.loc 1 800 0
 8265               		.cfi_startproc
 8266 2bfa DF92      		push r13
 8267               	.LCFI91:
 8268               		.cfi_def_cfa_offset 3
 8269               		.cfi_offset 13, -2
 8270 2bfc EF92      		push r14
 8271               	.LCFI92:
 8272               		.cfi_def_cfa_offset 4
 8273               		.cfi_offset 14, -3
 8274 2bfe FF92      		push r15
 8275               	.LCFI93:
 8276               		.cfi_def_cfa_offset 5
 8277               		.cfi_offset 15, -4
 8278 2c00 0F93      		push r16
 8279               	.LCFI94:
 8280               		.cfi_def_cfa_offset 6
 8281               		.cfi_offset 16, -5
 8282 2c02 1F93      		push r17
 8283               	.LCFI95:
 8284               		.cfi_def_cfa_offset 7
 8285               		.cfi_offset 17, -6
 8286 2c04 CF93      		push r28
 8287               	.LCFI96:
 8288               		.cfi_def_cfa_offset 8
 8289               		.cfi_offset 28, -7
 8290 2c06 DF93      		push r29
 8291               	.LCFI97:
 8292               		.cfi_def_cfa_offset 9
 8293               		.cfi_offset 29, -8
 8294 2c08 CDB7      		in r28,__SP_L__
 8295 2c0a DEB7      		in r29,__SP_H__
 8296               	.LCFI98:
 8297               		.cfi_def_cfa_register 28
 8298 2c0c A597      		sbiw r28,37
 8299               	.LCFI99:
 8300               		.cfi_def_cfa_offset 46
 8301 2c0e 0FB6      		in __tmp_reg__,__SREG__
 8302 2c10 F894      		cli
 8303 2c12 DEBF      		out __SP_H__,r29
 8304 2c14 0FBE      		out __SREG__,__tmp_reg__
 8305 2c16 CDBF      		out __SP_L__,r28
 8306               	/* prologue: function */
 8307               	/* frame size = 37 */
 8308               	/* stack size = 44 */
 8309               	.L__stack_usage = 44
 801:main.c        **** 
 8310               		.loc 1 801 0
 8311 2c18 1091 0000 		lds r17,komendy_kolejka
 8312               	.LVL609:
 803:main.c        ****   case KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU: {
 8313               		.loc 1 803 0
 8314 2c1c 1338      		cpi r17,lo8(-125)
 8315 2c1e 01F4      		brne .+2
 8316 2c20 00C0      		rjmp .L917
 8317 2c22 00F4      		brsh .L918
 8318 2c24 1230      		cpi r17,lo8(2)
 8319 2c26 01F0      		breq .L919
 8320 2c28 00F0      		brlo .+2
 8321 2c2a 00C0      		rjmp .L1012
 8322               	.L979:
1223:main.c        ****   }
 8323               		.loc 1 1223 0
 8324 2c2c 80E0      		ldi r24,0
 8325 2c2e 00C0      		rjmp .L915
 8326               	.L918:
 803:main.c        ****   case KOMENDA_KOLEJKI_RESET_KOD_DOSTEPU: {
 8327               		.loc 1 803 0
 8328 2c30 1538      		cpi r17,lo8(-123)
 8329 2c32 01F4      		brne .+2
 8330 2c34 00C0      		rjmp .L921
 8331 2c36 00F4      		brsh .+2
 8332 2c38 00C0      		rjmp .L922
 8333 2c3a 1638      		cpi r17,lo8(-122)
 8334 2c3c 01F4      		brne .+2
 8335 2c3e 00C0      		rjmp .L923
 8336 2c40 1738      		cpi r17,lo8(-121)
 8337 2c42 01F4      		brne .L979
1197:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8338               		.loc 1 1197 0
 8339 2c44 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8340 2c48 8111      		cpse r24,__zero_reg__
 8341 2c4a 00C0      		rjmp .L975
1197:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8342               		.loc 1 1197 0 is_stmt 0 discriminator 2
 8343 2c4c 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8344 2c50 8111      		cpse r24,__zero_reg__
 8345 2c52 00C0      		rjmp .L975
1197:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8346               		.loc 1 1197 0 discriminator 4
 8347 2c54 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 8348 2c58 8111      		cpse r24,__zero_reg__
 8349 2c5a 00C0      		rjmp .L975
1197:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8350               		.loc 1 1197 0 discriminator 6
 8351 2c5c F99B      		sbis 0x1f,1
 8352 2c5e 00C0      		rjmp .L976
 8353               	.L975:
1197:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8354               		.loc 1 1197 0 discriminator 7
 8355 2c60 87E8      		ldi r24,lo8(-121)
 8356 2c62 00C0      		rjmp .L1015
 8357               	.L919:
 805:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8358               		.loc 1 805 0 is_stmt 1
 8359 2c64 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8360 2c68 8111      		cpse r24,__zero_reg__
 8361 2c6a 00C0      		rjmp .L925
 805:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8362               		.loc 1 805 0 is_stmt 0 discriminator 2
 8363 2c6c 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8364 2c70 8111      		cpse r24,__zero_reg__
 8365 2c72 00C0      		rjmp .L925
 805:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8366               		.loc 1 805 0 discriminator 4
 8367 2c74 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 8368 2c78 8111      		cpse r24,__zero_reg__
 8369 2c7a 00C0      		rjmp .L925
 805:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8370               		.loc 1 805 0 discriminator 6
 8371 2c7c F99B      		sbis 0x1f,1
 8372 2c7e 00C0      		rjmp .L926
 8373               	.L925:
 805:main.c        ****     kod_modulu[0] = bufor_eeprom[0] = 'A';
 8374               		.loc 1 805 0 discriminator 7
 8375 2c80 82E0      		ldi r24,lo8(2)
 8376               	.LVL610:
 8377               	.L1015:
1197:main.c        ****     konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 8378               		.loc 1 1197 0 is_stmt 1 discriminator 7
 8379 2c82 0E94 0000 		call dodaj_komende
 8380               	.LVL611:
 8381 2c86 00C0      		rjmp .L1014
 8382               	.LVL612:
 8383               	.L926:
 806:main.c        ****     kod_modulu[1] = bufor_eeprom[1] = 'B';
 8384               		.loc 1 806 0
 8385 2c88 81E4      		ldi r24,lo8(65)
 8386 2c8a 8093 0000 		sts bufor_eeprom,r24
 8387 2c8e 8093 0000 		sts kod_modulu,r24
 807:main.c        ****     kod_modulu[2] = bufor_eeprom[2] = 'C';
 8388               		.loc 1 807 0
 8389 2c92 82E4      		ldi r24,lo8(66)
 8390 2c94 8093 0000 		sts bufor_eeprom+1,r24
 8391 2c98 8093 0000 		sts kod_modulu+1,r24
 808:main.c        ****     kod_modulu[3] = bufor_eeprom[3] = 'D';
 8392               		.loc 1 808 0
 8393 2c9c 83E4      		ldi r24,lo8(67)
 8394 2c9e 8093 0000 		sts bufor_eeprom+2,r24
 8395 2ca2 8093 0000 		sts kod_modulu+2,r24
 809:main.c        ****     zapisz_znaki_w_eeprom_bez_kopiowania(ADRES_EEPROM_KOD_DOSTEPU,
 8396               		.loc 1 809 0
 8397 2ca6 84E4      		ldi r24,lo8(68)
 8398 2ca8 8093 0000 		sts bufor_eeprom+3,r24
 8399 2cac 8093 0000 		sts kod_modulu+3,r24
 810:main.c        ****                                          LICZBA_BAJTOW_KODU_DOSTEPU);
 8400               		.loc 1 810 0
 8401 2cb0 64E0      		ldi r22,lo8(4)
 8402 2cb2 81E0      		ldi r24,lo8(1)
 8403 2cb4 90E0      		ldi r25,0
 8404 2cb6 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 8405               	.LVL613:
 8406               	.L1017:
 8407               	.LBB612:
 961:main.c        ****     break;
 8408               		.loc 1 961 0
 8409 2cba 83E3      		ldi r24,lo8(51)
 8410 2cbc 8093 0000 		sts licznik_100ms_dioda_led,r24
 8411               	.LVL614:
 8412               	.L1014:
 8413               	.LBE612:
1225:main.c        **** }
 8414               		.loc 1 1225 0
 8415 2cc0 8FEF      		ldi r24,lo8(-1)
 8416               	.L915:
 8417               	/* epilogue start */
1226:main.c        **** 
 8418               		.loc 1 1226 0
 8419 2cc2 A596      		adiw r28,37
 8420 2cc4 0FB6      		in __tmp_reg__,__SREG__
 8421 2cc6 F894      		cli
 8422 2cc8 DEBF      		out __SP_H__,r29
 8423 2cca 0FBE      		out __SREG__,__tmp_reg__
 8424 2ccc CDBF      		out __SP_L__,r28
 8425 2cce DF91      		pop r29
 8426 2cd0 CF91      		pop r28
 8427 2cd2 1F91      		pop r17
 8428 2cd4 0F91      		pop r16
 8429 2cd6 FF90      		pop r15
 8430 2cd8 EF90      		pop r14
 8431 2cda DF90      		pop r13
 8432 2cdc 0895      		ret
 8433               	.LVL615:
 8434               	.L1012:
 8435               	.LBB613:
 943:main.c        ****     const uchar nr_bloku =
 8436               		.loc 1 943 0
 8437 2cde 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8438 2ce2 8111      		cpse r24,__zero_reg__
 8439 2ce4 00C0      		rjmp .L927
 943:main.c        ****     const uchar nr_bloku =
 8440               		.loc 1 943 0 is_stmt 0 discriminator 2
 8441 2ce6 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8442 2cea 8111      		cpse r24,__zero_reg__
 8443 2cec 00C0      		rjmp .L927
 943:main.c        ****     const uchar nr_bloku =
 8444               		.loc 1 943 0 discriminator 4
 8445 2cee 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 8446 2cf2 8111      		cpse r24,__zero_reg__
 8447 2cf4 00C0      		rjmp .L927
 943:main.c        ****     const uchar nr_bloku =
 8448               		.loc 1 943 0 discriminator 6
 8449 2cf6 F99B      		sbis 0x1f,1
 8450 2cf8 00C0      		rjmp .L928
 8451               	.L927:
 943:main.c        ****     const uchar nr_bloku =
 8452               		.loc 1 943 0 discriminator 7
 8453 2cfa 812F      		mov r24,r17
 8454 2cfc 00C0      		rjmp .L1015
 8455               	.L928:
 944:main.c        ****         aktualnie_wykonywana_komenda - KOMENDA_KOLEJKI_RESET_USTAWIEN_0;
 8456               		.loc 1 944 0 is_stmt 1
 8457 2cfe 0DEF      		ldi r16,lo8(-3)
 8458 2d00 010F      		add r16,r17
 8459               	.LVL616:
 947:main.c        ****     if (nr_bloku == 0) {
 8460               		.loc 1 947 0
 8461 2d02 40E2      		ldi r20,lo8(32)
 8462 2d04 50E0      		ldi r21,0
 8463 2d06 6FEF      		ldi r22,lo8(-1)
 8464 2d08 70E0      		ldi r23,0
 8465 2d0a 80E0      		ldi r24,lo8(bufor_eeprom)
 8466 2d0c 90E0      		ldi r25,hi8(bufor_eeprom)
 8467 2d0e 0E94 0000 		call memset
 8468               	.LVL617:
 948:main.c        ****       kod_modulu[0] = bufor_eeprom[1] = 'A';
 8469               		.loc 1 948 0
 8470 2d12 0111      		cpse r16,__zero_reg__
 8471 2d14 00C0      		rjmp .L929
 949:main.c        ****       kod_modulu[1] = bufor_eeprom[2] = 'B';
 8472               		.loc 1 949 0
 8473 2d16 81E4      		ldi r24,lo8(65)
 8474 2d18 8093 0000 		sts bufor_eeprom+1,r24
 8475 2d1c 8093 0000 		sts kod_modulu,r24
 950:main.c        ****       kod_modulu[2] = bufor_eeprom[3] = 'C';
 8476               		.loc 1 950 0
 8477 2d20 82E4      		ldi r24,lo8(66)
 8478 2d22 8093 0000 		sts bufor_eeprom+2,r24
 8479 2d26 8093 0000 		sts kod_modulu+1,r24
 951:main.c        ****       kod_modulu[3] = bufor_eeprom[4] = 'D';
 8480               		.loc 1 951 0
 8481 2d2a 83E4      		ldi r24,lo8(67)
 8482 2d2c 8093 0000 		sts bufor_eeprom+3,r24
 8483 2d30 8093 0000 		sts kod_modulu+2,r24
 952:main.c        ****       bufor_eeprom[5] = 0;
 8484               		.loc 1 952 0
 8485 2d34 84E4      		ldi r24,lo8(68)
 8486 2d36 8093 0000 		sts bufor_eeprom+4,r24
 8487 2d3a 8093 0000 		sts kod_modulu+3,r24
 953:main.c        ****       stan_wyjscie[0] = 0;
 8488               		.loc 1 953 0
 8489 2d3e 1092 0000 		sts bufor_eeprom+5,__zero_reg__
 954:main.c        ****       licznik_przelacznik_wyjscia[0] = 0;
 8490               		.loc 1 954 0
 8491 2d42 1092 0000 		sts stan_wyjscie,__zero_reg__
 955:main.c        ****     }
 8492               		.loc 1 955 0
 8493 2d46 1092 0000 		sts licznik_przelacznik_wyjscia,__zero_reg__
 8494 2d4a 1092 0000 		sts licznik_przelacznik_wyjscia+1,__zero_reg__
 8495 2d4e 1092 0000 		sts licznik_przelacznik_wyjscia+2,__zero_reg__
 8496 2d52 1092 0000 		sts licznik_przelacznik_wyjscia+3,__zero_reg__
 8497               	.L929:
 957:main.c        ****         nr_bloku * LICZBA_BAJTOW_ZAPISYWANA_W_JEDNEJ_KOMENDZIE,
 8498               		.loc 1 957 0
 8499 2d56 60E2      		ldi r22,lo8(32)
 8500 2d58 20E2      		ldi r18,lo8(32)
 8501 2d5a 029F      		mul r16,r18
 8502 2d5c C001      		movw r24,r0
 8503 2d5e 1124      		clr __zero_reg__
 8504 2d60 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 8505               	.LVL618:
 960:main.c        ****     zapal_diode_led(50);
 8506               		.loc 1 960 0
 8507 2d64 81E0      		ldi r24,lo8(1)
 8508 2d66 810F      		add r24,r17
 8509 2d68 0E94 0000 		call dodaj_komende
 8510               	.LVL619:
 8511 2d6c 00C0      		rjmp .L1017
 8512               	.LVL620:
 8513               	.L917:
 8514               	.LBE613:
 8515               	.LBB614:
 965:main.c        ****     uchar bledny_zapis = FALSE;
 8516               		.loc 1 965 0
 8517 2d6e 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8518 2d72 8111      		cpse r24,__zero_reg__
 8519 2d74 00C0      		rjmp .L930
 965:main.c        ****     uchar bledny_zapis = FALSE;
 8520               		.loc 1 965 0 is_stmt 0 discriminator 2
 8521 2d76 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8522 2d7a 8111      		cpse r24,__zero_reg__
 8523 2d7c 00C0      		rjmp .L930
 965:main.c        ****     uchar bledny_zapis = FALSE;
 8524               		.loc 1 965 0 discriminator 4
 8525 2d7e F090 0000 		lds r15,czy_zajety_bufor_eeprom
 8526 2d82 F110      		cpse r15,__zero_reg__
 8527 2d84 00C0      		rjmp .L930
 965:main.c        ****     uchar bledny_zapis = FALSE;
 8528               		.loc 1 965 0 discriminator 6
 8529 2d86 F99B      		sbis 0x1f,1
 8530 2d88 00C0      		rjmp .L980
 8531               	.L930:
 965:main.c        ****     uchar bledny_zapis = FALSE;
 8532               		.loc 1 965 0 discriminator 7
 8533 2d8a 83E8      		ldi r24,lo8(-125)
 8534 2d8c 00C0      		rjmp .L1015
 8535               	.L980:
 8536               	.LBB615:
 970:main.c        ****       if (eeprom_read_byte((void *)i) !=
 8537               		.loc 1 970 0 is_stmt 1
 8538 2d8e 10E0      		ldi r17,0
 8539               	.LVL621:
 8540 2d90 00E0      		ldi r16,0
 8541               	.LVL622:
 8542               	.L931:
 971:main.c        ****           pgm_read_byte(tab_eeprom_fabryczny + i))
 8543               		.loc 1 971 0
 8544 2d92 C801      		movw r24,r16
 8545 2d94 0E94 0000 		call eeprom_read_byte
 8546               	.LVL623:
 8547               	.LBB616:
 972:main.c        ****         bledny_zapis = TRUE;
 8548               		.loc 1 972 0
 8549 2d98 F801      		movw r30,r16
 8550 2d9a E050      		subi r30,lo8(-(tab_eeprom_fabryczny.3612))
 8551 2d9c F040      		sbci r31,hi8(-(tab_eeprom_fabryczny.3612))
 8552               	.LVL624:
 8553               	/* #APP */
 8554               	 ;  972 "main.c" 1
 8555 2d9e E491      		lpm r30, Z
 8556               		
 8557               	 ;  0 "" 2
 8558               	.LVL625:
 8559               	/* #NOAPP */
 8560               	.LBE616:
 971:main.c        ****           pgm_read_byte(tab_eeprom_fabryczny + i))
 8561               		.loc 1 971 0
 8562 2da0 8E17      		cp r24,r30
 8563 2da2 01F0      		breq .L932
 973:main.c        ****     }
 8564               		.loc 1 973 0
 8565 2da4 FF24      		clr r15
 8566 2da6 FA94      		dec r15
 8567               	.LVL626:
 8568               	.L932:
 970:main.c        ****       if (eeprom_read_byte((void *)i) !=
 8569               		.loc 1 970 0 discriminator 2
 8570 2da8 0F5F      		subi r16,-1
 8571 2daa 1F4F      		sbci r17,-1
 8572               	.LVL627:
 8573 2dac 0630      		cpi r16,6
 8574 2dae 1105      		cpc r17,__zero_reg__
 8575 2db0 01F4      		brne .L931
 8576               	.LBE615:
 8577               	.LBB617:
 975:main.c        ****          i < EEPROM_NUMER_TELEFONU_BRAMA_0 +
 8578               		.loc 1 975 0
 8579 2db2 08E0      		ldi r16,lo8(8)
 8580 2db4 10E0      		ldi r17,0
 8581               	.LVL628:
 8582               	.L934:
 980:main.c        ****         bledny_zapis = TRUE;
 8583               		.loc 1 980 0
 8584 2db6 C801      		movw r24,r16
 8585 2db8 0E94 0000 		call eeprom_read_byte
 8586               	.LVL629:
 8587 2dbc 8F3F      		cpi r24,lo8(-1)
 8588 2dbe 01F4      		brne .L933
 979:main.c        ****       if (eeprom_read_byte((void *)i) != 0xff) {
 8589               		.loc 1 979 0
 8590 2dc0 0F5F      		subi r16,-1
 8591 2dc2 1F4F      		sbci r17,-1
 8592               	.LVL630:
 975:main.c        ****          i < EEPROM_NUMER_TELEFONU_BRAMA_0 +
 8593               		.loc 1 975 0
 8594 2dc4 083A      		cpi r16,-88
 8595 2dc6 8FE0      		ldi r24,15
 8596 2dc8 1807      		cpc r17,r24
 8597 2dca 01F4      		brne .L934
 8598               	.LBE617:
 985:main.c        ****       dodaj_komende(KOMENDA_KOLEJKI_RESET_USTAWIEN_0);
 8599               		.loc 1 985 0
 8600 2dcc FF20      		tst r15
 8601 2dce 01F0      		breq .L935
 8602               	.L933:
 8603               	.LVL631:
 986:main.c        ****       break;
 8604               		.loc 1 986 0
 8605 2dd0 83E0      		ldi r24,lo8(3)
 8606 2dd2 00C0      		rjmp .L1015
 8607               	.LVL632:
 8608               	.L935:
 989:main.c        ****     ustaw_stan_led(FALSE); // Wylacz diode po zakonczeniu resetu
 8609               		.loc 1 989 0
 8610 2dd4 0E94 0000 		call inicjalizuj_parametry_modulu
 8611               	.LVL633:
 990:main.c        ****     break;
 8612               		.loc 1 990 0
 8613 2dd8 409A      		sbi 0x8,0
 8614 2dda 00C0      		rjmp .L1014
 8615               	.LVL634:
 8616               	.L922:
 8617               	.LBE614:
 8618               	.LBB618:
 994:main.c        **** 
 8619               		.loc 1 994 0
 8620 2ddc 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8621 2de0 8111      		cpse r24,__zero_reg__
 8622 2de2 00C0      		rjmp .L936
 994:main.c        **** 
 8623               		.loc 1 994 0 is_stmt 0 discriminator 2
 8624 2de4 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8625 2de8 8111      		cpse r24,__zero_reg__
 8626 2dea 00C0      		rjmp .L936
 994:main.c        **** 
 8627               		.loc 1 994 0 discriminator 4
 8628 2dec 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 8629 2df0 8111      		cpse r24,__zero_reg__
 8630 2df2 00C0      		rjmp .L936
 994:main.c        **** 
 8631               		.loc 1 994 0 discriminator 6
 8632 2df4 F99B      		sbis 0x1f,1
 8633 2df6 00C0      		rjmp .L937
 8634               	.L936:
 994:main.c        **** 
 8635               		.loc 1 994 0 discriminator 7
 8636 2df8 84E8      		ldi r24,lo8(-124)
 8637 2dfa 00C0      		rjmp .L1015
 8638               	.L937:
 996:main.c        ****       // Poza dozwolonym czasem - ignoruj
 8639               		.loc 1 996 0 is_stmt 1
 8640 2dfc D090 0000 		lds r13,blokada_sterowania_czasowa
 8641 2e00 D110      		cpse r13,__zero_reg__
 8642 2e02 00C0      		rjmp .L1014
1004:main.c        **** 
 8643               		.loc 1 1004 0
 8644 2e04 8E01      		movw r16,r28
 8645 2e06 0B5E      		subi r16,-21
 8646 2e08 1F4F      		sbci r17,-1
 8647 2e0a 60E0      		ldi r22,lo8(numer_telefonu_ktory_dzwoni)
 8648 2e0c 70E0      		ldi r23,hi8(numer_telefonu_ktory_dzwoni)
 8649 2e0e C801      		movw r24,r16
 8650 2e10 0E94 0000 		call strcpy
 8651               	.LVL635:
1008:main.c        ****         &bufor_eeprom[0]);
 8652               		.loc 1 1008 0
 8653 2e14 F801      		movw r30,r16
 8654               		0:
 8655 2e16 0190      		ld __tmp_reg__,Z+
 8656 2e18 0020      		tst __tmp_reg__
 8657 2e1a 01F4      		brne 0b
 8658 2e1c BF01      		movw r22,r30
 8659 2e1e 6150      		subi r22,1
 8660 2e20 7109      		sbc r23,__zero_reg__
1007:main.c        ****         &numer_lokalny[0], &numer_lokalny[strlen((char *)numer_lokalny)],
 8661               		.loc 1 1007 0
 8662 2e22 40E0      		ldi r20,lo8(bufor_eeprom)
 8663 2e24 50E0      		ldi r21,hi8(bufor_eeprom)
 8664 2e26 C801      		movw r24,r16
 8665 2e28 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 8666               	.LVL636:
1013:main.c        ****       // Tylko w trybie prywatnym sprawdzamy listę
 8667               		.loc 1 1013 0
 8668 2e2c 8091 0000 		lds r24,tryb_pracy
 8669 2e30 8130      		cpi r24,lo8(1)
 8670 2e32 01F0      		breq .L941
 8671 2e34 98E0      		ldi r25,lo8(8)
 8672 2e36 E92E      		mov r14,r25
 8673 2e38 F12C      		mov r15,__zero_reg__
 8674               	.L942:
 8675               	.LBB619:
1017:main.c        ****                 &bufor_eeprom[0],
 8676               		.loc 1 1017 0
 8677 2e3a B701      		movw r22,r14
 8678 2e3c 80E0      		ldi r24,lo8(bufor_eeprom)
 8679 2e3e 90E0      		ldi r25,hi8(bufor_eeprom)
 8680 2e40 0E94 0000 		call porownaj_numer_telefonu_blok
 8681               	.LVL637:
 8682 2e44 8111      		cpse r24,__zero_reg__
 8683 2e46 00C0      		rjmp .L981
 8684               	.LVL638:
 8685 2e48 F5E0      		ldi r31,5
 8686 2e4a EF0E      		add r14,r31
 8687 2e4c F11C      		adc r15,__zero_reg__
1015:main.c        ****            nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 8688               		.loc 1 1015 0
 8689 2e4e 28EA      		ldi r18,-88
 8690 2e50 E216      		cp r14,r18
 8691 2e52 2FE0      		ldi r18,15
 8692 2e54 F206      		cpc r15,r18
 8693 2e56 01F4      		brne .L942
 8694               	.L941:
 8695               	.LVL639:
 8696               	.LBE619:
1028:main.c        ****       wyciagnij_ostatnie_cyfry(numer_lokalny, numer_skrocony, 9);
 8697               		.loc 1 1028 0
 8698 2e58 8091 0000 		lds r24,skryba_wlaczona
 8699 2e5c 8823      		tst r24
 8700 2e5e 01F0      		breq .L943
1028:main.c        ****       wyciagnij_ostatnie_cyfry(numer_lokalny, numer_skrocony, 9);
 8701               		.loc 1 1028 0 is_stmt 0 discriminator 1
 8702 2e60 DD20      		tst r13
 8703 2e62 01F4      		brne .+2
 8704 2e64 00C0      		rjmp .L944
 8705               	.L948:
 8706 2e66 DD24      		clr r13
 8707 2e68 DA94      		dec r13
 8708               	.LVL640:
 8709               	.L943:
1051:main.c        ****                          ADRES_EEPROM_DEBUG_SKRYBA_2); // DEBUG
 8710               		.loc 1 1051 0 is_stmt 1
 8711 2e6a 81E0      		ldi r24,lo8(1)
 8712 2e6c 9091 0000 		lds r25,skryba_wlaczona
 8713 2e70 9111      		cpse r25,__zero_reg__
 8714 2e72 00C0      		rjmp .L950
 8715 2e74 80E0      		ldi r24,0
 8716               	.L950:
 8717 2e76 61EF      		ldi r22,lo8(-15)
 8718 2e78 7FE0      		ldi r23,lo8(15)
 8719 2e7a 0E94 0000 		call zapisz_znak_w_eeprom
 8720               	.LVL641:
1053:main.c        ****                          ADRES_EEPROM_DEBUG_SKRYBA_3); // DEBUG
 8721               		.loc 1 1053 0
 8722 2e7e 81E0      		ldi r24,lo8(1)
 8723 2e80 D110      		cpse r13,__zero_reg__
 8724 2e82 80E0      		ldi r24,0
 8725               	.L951:
 8726 2e84 62EF      		ldi r22,lo8(-14)
 8727 2e86 7FE0      		ldi r23,lo8(15)
 8728 2e88 0E94 0000 		call zapisz_znak_w_eeprom
 8729               	.LVL642:
1056:main.c        ****       uchar len_full = strlen((char *)numer_lokalny);
 8730               		.loc 1 1056 0
 8731 2e8c 8091 0000 		lds r24,skryba_wlaczona
 8732 2e90 8823      		tst r24
 8733 2e92 01F0      		breq .L953
1056:main.c        ****       uchar len_full = strlen((char *)numer_lokalny);
 8734               		.loc 1 1056 0 is_stmt 0 discriminator 1
 8735 2e94 D110      		cpse r13,__zero_reg__
 8736 2e96 00C0      		rjmp .L953
 8737               	.LBB620:
1057:main.c        **** 
 8738               		.loc 1 1057 0 is_stmt 1
 8739 2e98 F801      		movw r30,r16
 8740               		0:
 8741 2e9a 0190      		ld __tmp_reg__,Z+
 8742 2e9c 0020      		tst __tmp_reg__
 8743 2e9e 01F4      		brne 0b
 8744 2ea0 3197      		sbiw r30,1
 8745 2ea2 CF01      		movw r24,r30
 8746 2ea4 801B      		sub r24,r16
 8747 2ea6 910B      		sbc r25,r17
 8748 2ea8 182F      		mov r17,r24
 8749               	.LVL643:
1060:main.c        **** 
 8750               		.loc 1 1060 0
 8751 2eaa 64EF      		ldi r22,lo8(-12)
 8752 2eac 7FE0      		ldi r23,lo8(15)
 8753 2eae 0E94 0000 		call zapisz_znak_w_eeprom
 8754               	.LVL644:
1062:main.c        ****         // Skopiuj skrócony numer do numer_telefonu_skryba
 8755               		.loc 1 1062 0
 8756 2eb2 1330      		cpi r17,lo8(3)
 8757 2eb4 00F0      		brlo .L953
1064:main.c        **** 
 8758               		.loc 1 1064 0
 8759 2eb6 BE01      		movw r22,r28
 8760 2eb8 6F5F      		subi r22,-1
 8761 2eba 7F4F      		sbci r23,-1
 8762 2ebc 80E0      		ldi r24,lo8(numer_telefonu_skryba)
 8763 2ebe 90E0      		ldi r25,hi8(numer_telefonu_skryba)
 8764 2ec0 0E94 0000 		call strcpy
 8765               	.LVL645:
1067:main.c        ****           zapisz_znak_w_eeprom(
 8766               		.loc 1 1067 0
 8767 2ec4 80E0      		ldi r24,lo8(numer_telefonu_skryba)
 8768 2ec6 90E0      		ldi r25,hi8(numer_telefonu_skryba)
 8769 2ec8 FC01      		movw r30,r24
 8770               		0:
 8771 2eca 0190      		ld __tmp_reg__,Z+
 8772 2ecc 0020      		tst __tmp_reg__
 8773 2ece 01F4      		brne 0b
 8774 2ed0 CF01      		movw r24,r30
 8775 2ed2 8050      		subi r24,lo8(numer_telefonu_skryba+1)
 8776 2ed4 9040      		sbci r25,hi8(numer_telefonu_skryba+1)
 8777 2ed6 0397      		sbiw r24,3
 8778 2ed8 00F0      		brlo .L953
1068:main.c        ****               1, ADRES_EEPROM_DEBUG_SKRYBA_4); // DEBUG: komenda dodana
 8779               		.loc 1 1068 0
 8780 2eda 63EF      		ldi r22,lo8(-13)
 8781 2edc 7FE0      		ldi r23,lo8(15)
 8782 2ede 81E0      		ldi r24,lo8(1)
 8783 2ee0 0E94 0000 		call zapisz_znak_w_eeprom
 8784               	.LVL646:
1072:main.c        ****         }
 8785               		.loc 1 1072 0
 8786 2ee4 86E8      		ldi r24,lo8(-122)
 8787 2ee6 0E94 0000 		call dodaj_komende
 8788               	.LVL647:
 8789               	.L953:
 8790               	.LBE620:
1078:main.c        ****       if (tryb_pracy == 1) {
 8791               		.loc 1 1078 0
 8792 2eea 8091 0000 		lds r24,tryb_clip
 8793 2eee 8823      		tst r24
 8794 2ef0 01F4      		brne .+2
 8795 2ef2 00C0      		rjmp .L1014
1079:main.c        ****         // Tryb publiczny - otwórz dla każdego
 8796               		.loc 1 1079 0
 8797 2ef4 8091 0000 		lds r24,tryb_pracy
 8798 2ef8 8130      		cpi r24,lo8(1)
 8799 2efa 01F0      		breq .+2
 8800 2efc 00C0      		rjmp .L956
 8801               	.L957:
1081:main.c        ****       } else if (znaleziono) {
 8802               		.loc 1 1081 0
 8803 2efe 0E94 0000 		call ustaw_wyjscie_clip
 8804               	.LVL648:
 8805 2f02 00C0      		rjmp .L1014
 8806               	.LVL649:
 8807               	.L981:
 8808               	.LBB621:
1020:main.c        ****           break;
 8809               		.loc 1 1020 0
 8810 2f04 DD24      		clr r13
 8811 2f06 DA94      		dec r13
 8812 2f08 00C0      		rjmp .L941
 8813               	.LVL650:
 8814               	.L944:
 8815               	.LBE621:
 8816               	.LBB622:
 8817               	.LBB623:
 767:main.c        **** 
 8818               		.loc 1 767 0
 8819 2f0a F801      		movw r30,r16
 8820               		0:
 8821 2f0c 0190      		ld __tmp_reg__,Z+
 8822 2f0e 0020      		tst __tmp_reg__
 8823 2f10 01F4      		brne 0b
 8824 2f12 3197      		sbiw r30,1
 8825 2f14 E01B      		sub r30,r16
 8826 2f16 F10B      		sbc r31,r17
 8827               	.LVL651:
 8828 2f18 CE01      		movw r24,r28
 8829 2f1a 0196      		adiw r24,1
 8830 2f1c 7C01      		movw r14,r24
 769:main.c        ****     // Take last max_digits
 8831               		.loc 1 769 0
 8832 2f1e EA30      		cpi r30,lo8(10)
 8833 2f20 00F0      		brlo .L945
 771:main.c        ****   } else {
 8834               		.loc 1 771 0
 8835 2f22 E950      		subi r30,9
 8836 2f24 FF0B      		sbc r31,r31
 8837               	.LVL652:
 8838 2f26 B801      		movw r22,r16
 8839 2f28 6E0F      		add r22,r30
 8840 2f2a 7F1F      		adc r23,r31
 8841               	.L1013:
 774:main.c        ****   }
 8842               		.loc 1 774 0
 8843 2f2c 0E94 0000 		call strcpy
 8844               	.LVL653:
 8845               	.LBE623:
 8846               	.LBE622:
1033:main.c        ****           &bufor_eeprom[0]);
 8847               		.loc 1 1033 0
 8848 2f30 F701      		movw r30,r14
 8849               		0:
 8850 2f32 0190      		ld __tmp_reg__,Z+
 8851 2f34 0020      		tst __tmp_reg__
 8852 2f36 01F4      		brne 0b
 8853 2f38 BF01      		movw r22,r30
 8854 2f3a 6150      		subi r22,1
 8855 2f3c 7109      		sbc r23,__zero_reg__
1032:main.c        ****           &numer_skrocony[0], &numer_skrocony[strlen((char *)numer_skrocony)],
 8856               		.loc 1 1032 0
 8857 2f3e 40E0      		ldi r20,lo8(bufor_eeprom)
 8858 2f40 50E0      		ldi r21,hi8(bufor_eeprom)
 8859 2f42 C701      		movw r24,r14
 8860 2f44 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 8861               	.LVL654:
1036:main.c        ****         for (uint nr_uzyt_clip = 0;
 8862               		.loc 1 1036 0
 8863 2f48 8091 0000 		lds r24,tryb_pracy
 8864 2f4c 8130      		cpi r24,lo8(1)
 8865 2f4e 01F4      		brne .+2
 8866 2f50 00C0      		rjmp .L943
 8867 2f52 88E0      		ldi r24,lo8(8)
 8868 2f54 E82E      		mov r14,r24
 8869 2f56 F12C      		mov r15,__zero_reg__
 8870               	.L947:
 8871               	.LBB625:
1040:main.c        ****                   &bufor_eeprom[0],
 8872               		.loc 1 1040 0
 8873 2f58 B701      		movw r22,r14
 8874 2f5a 80E0      		ldi r24,lo8(bufor_eeprom)
 8875 2f5c 90E0      		ldi r25,hi8(bufor_eeprom)
 8876 2f5e 0E94 0000 		call porownaj_numer_telefonu_blok
 8877               	.LVL655:
 8878 2f62 8111      		cpse r24,__zero_reg__
 8879 2f64 00C0      		rjmp .L948
 8880               	.LVL656:
 8881 2f66 F5E0      		ldi r31,5
 8882 2f68 EF0E      		add r14,r31
 8883 2f6a F11C      		adc r15,__zero_reg__
1037:main.c        ****              nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA;
 8884               		.loc 1 1037 0
 8885 2f6c 28EA      		ldi r18,-88
 8886 2f6e E216      		cp r14,r18
 8887 2f70 2FE0      		ldi r18,15
 8888 2f72 F206      		cpc r15,r18
 8889 2f74 01F4      		brne .L947
 8890 2f76 00C0      		rjmp .L943
 8891               	.LVL657:
 8892               	.L945:
 8893               	.LBE625:
 8894               	.LBB626:
 8895               	.LBB624:
 774:main.c        ****   }
 8896               		.loc 1 774 0
 8897 2f78 B801      		movw r22,r16
 8898 2f7a 00C0      		rjmp .L1013
 8899               	.LVL658:
 8900               	.L956:
 8901               	.LBE624:
 8902               	.LBE626:
1082:main.c        ****         // Tryb prywatny - otwórz tylko dla znalezionych
 8903               		.loc 1 1082 0
 8904 2f7c DD20      		tst r13
 8905 2f7e 01F4      		brne .+2
 8906 2f80 00C0      		rjmp .L1014
 8907 2f82 00C0      		rjmp .L957
 8908               	.LVL659:
 8909               	.L921:
 8910               	.LBE618:
 8911               	.LBB627:
1092:main.c        **** 
 8912               		.loc 1 1092 0
 8913 2f84 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 8914 2f88 8111      		cpse r24,__zero_reg__
 8915 2f8a 00C0      		rjmp .L958
1092:main.c        **** 
 8916               		.loc 1 1092 0 is_stmt 0 discriminator 2
 8917 2f8c 8091 0000 		lds r24,liczba_znakow_do_zapisu
 8918 2f90 8111      		cpse r24,__zero_reg__
 8919 2f92 00C0      		rjmp .L958
1092:main.c        **** 
 8920               		.loc 1 1092 0 discriminator 4
 8921 2f94 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 8922 2f98 8111      		cpse r24,__zero_reg__
 8923 2f9a 00C0      		rjmp .L958
1092:main.c        **** 
 8924               		.loc 1 1092 0 discriminator 6
 8925 2f9c F99B      		sbis 0x1f,1
 8926 2f9e 00C0      		rjmp .L959
 8927               	.L958:
1092:main.c        **** 
 8928               		.loc 1 1092 0 discriminator 7
 8929 2fa0 85E8      		ldi r24,lo8(-123)
 8930 2fa2 00C0      		rjmp .L1015
 8931               	.L959:
1095:main.c        ****       return TRUE; // Duplicate found, abort
 8932               		.loc 1 1095 0 is_stmt 1
 8933 2fa4 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 8934 2fa6 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 8935 2fa8 0E94 0000 		call czy_numer_istnieje
 8936               	.LVL660:
 8937 2fac 8111      		cpse r24,__zero_reg__
 8938 2fae 00C0      		rjmp .L1014
1104:main.c        ****             (char *)numer_telefonu_do_ktorego_dzwonic)],
 8939               		.loc 1 1104 0
 8940 2fb0 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 8941 2fb2 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 8942 2fb4 FB01      		movw r30,r22
 8943               		0:
 8944 2fb6 0190      		ld __tmp_reg__,Z+
 8945 2fb8 0020      		tst __tmp_reg__
 8946 2fba 01F4      		brne 0b
 8947 2fbc BF01      		movw r22,r30
 8948 2fbe 6150      		subi r22,1
 8949 2fc0 7109      		sbc r23,__zero_reg__
1102:main.c        ****         &numer_telefonu_do_ktorego_dzwonic[0],
 8950               		.loc 1 1102 0
 8951 2fc2 40E0      		ldi r20,lo8(bufor_eeprom)
 8952 2fc4 50E0      		ldi r21,hi8(bufor_eeprom)
 8953 2fc6 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 8954 2fc8 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 8955 2fca 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 8956               	.LVL661:
 8957 2fce 08E0      		ldi r16,lo8(8)
 8958 2fd0 10E0      		ldi r17,0
 8959               	.LVL662:
 8960               	.L964:
 8961               	.LBB628:
1111:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
 8962               		.loc 1 1111 0
 8963 2fd2 C801      		movw r24,r16
 8964 2fd4 0E94 0000 		call eeprom_read_byte
 8965               	.LVL663:
 8966 2fd8 8F3F      		cpi r24,lo8(-1)
 8967 2fda 01F4      		brne .L961
1112:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
 8968               		.loc 1 1112 0
 8969 2fdc 65E0      		ldi r22,lo8(5)
 8970 2fde C801      		movw r24,r16
 8971 2fe0 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 8972               	.LVL664:
 8973               	.LBE628:
1121:main.c        ****       // Policz aktywnych uzytkownikow
 8974               		.loc 1 1121 0
 8975 2fe4 8091 0000 		lds r24,skryba_wlaczona
 8976 2fe8 08E0      		ldi r16,lo8(8)
 8977 2fea 10E0      		ldi r17,0
 8978               	.LBB629:
1123:main.c        ****       for (uint i = 0; i < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++i) {
 8979               		.loc 1 1123 0
 8980 2fec F12C      		mov r15,__zero_reg__
 8981 2fee E12C      		mov r14,__zero_reg__
 8982               	.LBE629:
1121:main.c        ****       // Policz aktywnych uzytkownikow
 8983               		.loc 1 1121 0
 8984 2ff0 8823      		tst r24
 8985 2ff2 01F4      		brne .+2
 8986 2ff4 00C0      		rjmp .L1014
 8987               	.L962:
 8988               	.LVL665:
 8989               	.LBB631:
 8990               	.LBB630:
1125:main.c        ****           ++aktywne_numery;
 8991               		.loc 1 1125 0
 8992 2ff6 C801      		movw r24,r16
 8993 2ff8 0E94 0000 		call eeprom_read_byte
 8994               	.LVL666:
 8995 2ffc 8F3F      		cpi r24,lo8(-1)
 8996 2ffe 01F0      		breq .L965
1126:main.c        ****         }
 8997               		.loc 1 1126 0
 8998 3000 2FEF      		ldi r18,-1
 8999 3002 E21A      		sub r14,r18
 9000 3004 F20A      		sbc r15,r18
 9001               	.LVL667:
 9002               	.L965:
 9003 3006 0B5F      		subi r16,-5
 9004 3008 1F4F      		sbci r17,-1
1124:main.c        ****         if (czy_aktywny_numer_telefonu_brama(i)) {
 9005               		.loc 1 1124 0 discriminator 2
 9006 300a 083A      		cpi r16,-88
 9007 300c 8FE0      		ldi r24,15
 9008 300e 1807      		cpc r17,r24
 9009 3010 01F4      		brne .L962
 9010               	.LVL668:
 9011               	.L1019:
 9012               	.LBE630:
 9013               	.LBE631:
 9014               	.LBE627:
 9015               	.LBB633:
 9016               	.LBB634:
1187:main.c        ****         skryba_wlaczona = FALSE;
 9017               		.loc 1 1187 0
 9018 3012 8091 0000 		lds r24,skryba_limit
 9019 3016 9091 0000 		lds r25,skryba_limit+1
 9020 301a E816      		cp r14,r24
 9021 301c F906      		cpc r15,r25
 9022 301e 00F4      		brsh .+2
 9023 3020 00C0      		rjmp .L1014
1188:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_SKRYBA);
 9024               		.loc 1 1188 0
 9025 3022 1092 0000 		sts skryba_wlaczona,__zero_reg__
1189:main.c        **** 
 9026               		.loc 1 1189 0
 9027 3026 69EF      		ldi r22,lo8(-7)
 9028 3028 7FE0      		ldi r23,lo8(15)
 9029 302a 80E0      		ldi r24,0
 9030 302c 0E94 0000 		call zapisz_znak_w_eeprom
 9031               	.LVL669:
1191:main.c        ****         zapisz_znak_w_eeprom(0, ADRES_EEPROM_TRYB_PRACY);
 9032               		.loc 1 1191 0
 9033 3030 1092 0000 		sts tryb_pracy,__zero_reg__
1192:main.c        ****       }
 9034               		.loc 1 1192 0
 9035 3034 6EEF      		ldi r22,lo8(-2)
 9036 3036 7FE0      		ldi r23,lo8(15)
 9037 3038 80E0      		ldi r24,0
 9038 303a 0E94 0000 		call zapisz_znak_w_eeprom
 9039               	.LVL670:
 9040 303e 00C0      		rjmp .L1014
 9041               	.LVL671:
 9042               	.L961:
 9043 3040 0B5F      		subi r16,-5
 9044 3042 1F4F      		sbci r17,-1
 9045               	.LBE634:
 9046               	.LBE633:
 9047               	.LBB640:
 9048               	.LBB632:
1109:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 9049               		.loc 1 1109 0
 9050 3044 083A      		cpi r16,-88
 9051 3046 FFE0      		ldi r31,15
 9052 3048 1F07      		cpc r17,r31
 9053 304a 01F4      		brne .L964
 9054 304c 00C0      		rjmp .L1014
 9055               	.LVL672:
 9056               	.L923:
 9057               	.LBE632:
 9058               	.LBE640:
 9059               	.LBB641:
1142:main.c        **** 
 9060               		.loc 1 1142 0
 9061 304e 8091 0000 		lds r24,bufor_pomoc_liczba_znakow_do_zapisu
 9062 3052 8111      		cpse r24,__zero_reg__
 9063 3054 00C0      		rjmp .L966
1142:main.c        **** 
 9064               		.loc 1 1142 0 is_stmt 0 discriminator 2
 9065 3056 8091 0000 		lds r24,liczba_znakow_do_zapisu
 9066 305a 8111      		cpse r24,__zero_reg__
 9067 305c 00C0      		rjmp .L966
1142:main.c        **** 
 9068               		.loc 1 1142 0 discriminator 4
 9069 305e 8091 0000 		lds r24,czy_zajety_bufor_eeprom
 9070 3062 8111      		cpse r24,__zero_reg__
 9071 3064 00C0      		rjmp .L966
1142:main.c        **** 
 9072               		.loc 1 1142 0 discriminator 6
 9073 3066 F99B      		sbis 0x1f,1
 9074 3068 00C0      		rjmp .L967
 9075               	.L966:
1142:main.c        **** 
 9076               		.loc 1 1142 0 discriminator 7
 9077 306a 86E8      		ldi r24,lo8(-122)
 9078 306c 00C0      		rjmp .L1015
 9079               	.L967:
1150:main.c        ****         bufor_skryba);
 9080               		.loc 1 1150 0 is_stmt 1
 9081 306e 60E0      		ldi r22,lo8(numer_telefonu_skryba)
 9082 3070 70E0      		ldi r23,hi8(numer_telefonu_skryba)
 9083 3072 FB01      		movw r30,r22
 9084               		0:
 9085 3074 0190      		ld __tmp_reg__,Z+
 9086 3076 0020      		tst __tmp_reg__
 9087 3078 01F4      		brne 0b
 9088 307a BF01      		movw r22,r30
 9089 307c 6150      		subi r22,1
 9090 307e 7109      		sbc r23,__zero_reg__
1148:main.c        ****         &numer_telefonu_skryba[0],
 9091               		.loc 1 1148 0
 9092 3080 AE01      		movw r20,r28
 9093 3082 4F5F      		subi r20,-1
 9094 3084 5F4F      		sbci r21,-1
 9095 3086 80E0      		ldi r24,lo8(numer_telefonu_skryba)
 9096 3088 90E0      		ldi r25,hi8(numer_telefonu_skryba)
 9097 308a 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9098               	.LVL673:
1156:main.c        ****       return TRUE; // Duplicate found, abort
 9099               		.loc 1 1156 0
 9100 308e 80E0      		ldi r24,lo8(numer_telefonu_skryba)
 9101 3090 90E0      		ldi r25,hi8(numer_telefonu_skryba)
 9102 3092 0E94 0000 		call czy_numer_istnieje
 9103               	.LVL674:
 9104 3096 8111      		cpse r24,__zero_reg__
 9105 3098 00C0      		rjmp .L1014
1161:main.c        **** 
 9106               		.loc 1 1161 0
 9107 309a 85E0      		ldi r24,lo8(5)
 9108 309c FE01      		movw r30,r28
 9109 309e 3196      		adiw r30,1
 9110 30a0 A0E0      		ldi r26,lo8(bufor_eeprom)
 9111 30a2 B0E0      		ldi r27,hi8(bufor_eeprom)
 9112               		0:
 9113 30a4 0190      		ld r0,Z+
 9114 30a6 0D92      		st X+,r0
 9115 30a8 8A95      		dec r24
 9116 30aa 01F4      		brne 0b
 9117               	.LVL675:
 9118 30ac 08E0      		ldi r16,lo8(8)
 9119 30ae 10E0      		ldi r17,0
 9120               	.LVL676:
 9121               	.L972:
 9122               	.LBB636:
1166:main.c        ****         zapisz_znaki_w_eeprom_bez_kopiowania(
 9123               		.loc 1 1166 0
 9124 30b0 C801      		movw r24,r16
 9125 30b2 0E94 0000 		call eeprom_read_byte
 9126               	.LVL677:
 9127 30b6 8F3F      		cpi r24,lo8(-1)
 9128 30b8 01F4      		brne .L969
1167:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
 9129               		.loc 1 1167 0
 9130 30ba 65E0      		ldi r22,lo8(5)
 9131 30bc C801      		movw r24,r16
 9132 30be 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 9133               	.LVL678:
 9134               	.LBE636:
1177:main.c        ****       // Policz aktywnych uzytkownikow
 9135               		.loc 1 1177 0
 9136 30c2 8091 0000 		lds r24,skryba_wlaczona
 9137 30c6 08E0      		ldi r16,lo8(8)
 9138 30c8 10E0      		ldi r17,0
 9139               	.LBB637:
1179:main.c        ****       for (uint i = 0; i < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++i) {
 9140               		.loc 1 1179 0
 9141 30ca F12C      		mov r15,__zero_reg__
 9142 30cc E12C      		mov r14,__zero_reg__
 9143               	.LBE637:
1177:main.c        ****       // Policz aktywnych uzytkownikow
 9144               		.loc 1 1177 0
 9145 30ce 8823      		tst r24
 9146 30d0 01F4      		brne .+2
 9147 30d2 00C0      		rjmp .L1014
 9148               	.L970:
 9149               	.LVL679:
 9150               	.LBB638:
 9151               	.LBB635:
1181:main.c        ****           ++aktywne_numery;
 9152               		.loc 1 1181 0
 9153 30d4 C801      		movw r24,r16
 9154 30d6 0E94 0000 		call eeprom_read_byte
 9155               	.LVL680:
 9156 30da 8F3F      		cpi r24,lo8(-1)
 9157 30dc 01F0      		breq .L974
1182:main.c        ****         }
 9158               		.loc 1 1182 0
 9159 30de 2FEF      		ldi r18,-1
 9160 30e0 E21A      		sub r14,r18
 9161 30e2 F20A      		sbc r15,r18
 9162               	.LVL681:
 9163               	.L974:
 9164 30e4 0B5F      		subi r16,-5
 9165 30e6 1F4F      		sbci r17,-1
1180:main.c        ****         if (czy_aktywny_numer_telefonu_brama(i)) {
 9166               		.loc 1 1180 0 discriminator 2
 9167 30e8 083A      		cpi r16,-88
 9168 30ea 8FE0      		ldi r24,15
 9169 30ec 1807      		cpc r17,r24
 9170 30ee 01F4      		brne .L970
 9171 30f0 00C0      		rjmp .L1019
 9172               	.LVL682:
 9173               	.L969:
 9174 30f2 0B5F      		subi r16,-5
 9175 30f4 1F4F      		sbci r17,-1
 9176               	.LBE635:
 9177               	.LBE638:
 9178               	.LBB639:
1164:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 9179               		.loc 1 1164 0
 9180 30f6 083A      		cpi r16,-88
 9181 30f8 FFE0      		ldi r31,15
 9182 30fa 1F07      		cpc r17,r31
 9183 30fc 01F4      		brne .L972
 9184 30fe 00C0      		rjmp .L1014
 9185               	.LVL683:
 9186               	.L976:
 9187               	.LBE639:
 9188               	.LBE641:
1199:main.c        ****                                          numer_telefonu_do_ktorego_dzwonic)],
 9189               		.loc 1 1199 0
 9190 3100 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic)
 9191 3102 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic)
 9192 3104 FB01      		movw r30,r22
 9193               		0:
 9194 3106 0190      		ld __tmp_reg__,Z+
 9195 3108 0020      		tst __tmp_reg__
 9196 310a 01F4      		brne 0b
 9197 310c BF01      		movw r22,r30
 9198 310e 6150      		subi r22,1
 9199 3110 7109      		sbc r23,__zero_reg__
1198:main.c        ****                                      &numer_telefonu_do_ktorego_dzwonic[strlen(
 9200               		.loc 1 1198 0
 9201 3112 40E0      		ldi r20,lo8(bufor_eeprom)
 9202 3114 50E0      		ldi r21,hi8(bufor_eeprom)
 9203 3116 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 9204 3118 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 9205 311a 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9206               	.LVL684:
 9207 311e 08E0      		ldi r16,lo8(8)
 9208 3120 10E0      		ldi r17,0
 9209               	.LVL685:
 9210               	.L978:
 9211               	.LBB642:
1206:main.c        ****               &bufor_eeprom[0], // 1 porwnanie zajmuje ~10us, czyli 170 numerw ~
 9212               		.loc 1 1206 0
 9213 3122 B801      		movw r22,r16
 9214 3124 80E0      		ldi r24,lo8(bufor_eeprom)
 9215 3126 90E0      		ldi r25,hi8(bufor_eeprom)
 9216 3128 0E94 0000 		call porownaj_numer_telefonu_blok
 9217               	.LVL686:
 9218 312c 8823      		tst r24
 9219 312e 01F0      		breq .L977
1210:main.c        ****         konwertuj_telefon_na_blok_eeprom(&numer_telefonu_do_ktorego_dzwonic[0],
 9220               		.loc 1 1210 0
 9221 3130 1092 0000 		sts numer_telefonu_do_ktorego_dzwonic,__zero_reg__
1211:main.c        ****                                          &numer_telefonu_do_ktorego_dzwonic[1],
 9222               		.loc 1 1211 0
 9223 3134 40E0      		ldi r20,lo8(bufor_eeprom)
 9224 3136 50E0      		ldi r21,hi8(bufor_eeprom)
 9225 3138 60E0      		ldi r22,lo8(numer_telefonu_do_ktorego_dzwonic+1)
 9226 313a 70E0      		ldi r23,hi8(numer_telefonu_do_ktorego_dzwonic+1)
 9227 313c 80E0      		ldi r24,lo8(numer_telefonu_do_ktorego_dzwonic)
 9228 313e 90E0      		ldi r25,hi8(numer_telefonu_do_ktorego_dzwonic)
 9229 3140 0E94 0000 		call konwertuj_telefon_na_blok_eeprom
 9230               	.LVL687:
1214:main.c        ****             EEPROM_NUMER_TELEFONU_BRAMA(nr_uzyt_clip),
 9231               		.loc 1 1214 0
 9232 3144 65E0      		ldi r22,lo8(5)
 9233 3146 C801      		movw r24,r16
 9234 3148 0E94 0000 		call zapisz_znaki_w_eeprom_bez_kopiowania
 9235               	.LVL688:
 9236 314c 00C0      		rjmp .L1014
 9237               	.L977:
 9238 314e 0B5F      		subi r16,-5
 9239 3150 1F4F      		sbci r17,-1
1204:main.c        ****          nr_uzyt_clip < MAX_LICZBA_NUMEROW_TELEFONOW_BRAMA; ++nr_uzyt_clip) {
 9240               		.loc 1 1204 0
 9241 3152 083A      		cpi r16,-88
 9242 3154 FFE0      		ldi r31,15
 9243 3156 1F07      		cpc r17,r31
 9244 3158 01F4      		brne .L978
 9245 315a 00C0      		rjmp .L1014
 9246               	.LBE642:
 9247               		.cfi_endproc
 9248               	.LFE58:
 9250               	.global	wykonanie_komend
 9252               	wykonanie_komend:
 9253               	.LFB60:
1294:main.c        ****   if (wykonanie_komend_SIM900())
 9254               		.loc 1 1294 0
 9255               		.cfi_startproc
 9256               	/* prologue: function */
 9257               	/* frame size = 0 */
 9258               	/* stack size = 0 */
 9259               	.L__stack_usage = 0
1295:main.c        ****     ;
 9260               		.loc 1 1295 0
 9261 315c 0E94 0000 		call wykonanie_komend_SIM900
 9262               	.LVL689:
 9263 3160 8111      		cpse r24,__zero_reg__
 9264 3162 00C0      		rjmp .L1022
1297:main.c        ****     ;
 9265               		.loc 1 1297 0
 9266 3164 0E94 0000 		call wykonanie_komend_ukladow
 9267               	.LVL690:
 9268 3168 8111      		cpse r24,__zero_reg__
 9269 316a 00C0      		rjmp .L1022
1299:main.c        ****     ;
 9270               		.loc 1 1299 0
 9271 316c 0E94 0000 		call wykonanie_komend_powiadomien
 9272               	.LVL691:
 9273               	.L1022:
1303:main.c        **** }
 9274               		.loc 1 1303 0
 9275 3170 0C94 0000 		jmp usun_komende
 9276               	.LVL692:
 9277               		.cfi_endproc
 9278               	.LFE60:
 9280               		.section	.text.startup,"ax",@progbits
 9281               	.global	main
 9283               	main:
 9284               	.LFB70:
1702:main.c        **** 
1703:main.c        **** #include "test_debug.h"
1704:main.c        **** 
1705:main.c        **** int main(void) {
 9285               		.loc 1 1705 0
 9286               		.cfi_startproc
 9287               	/* prologue: function */
 9288               	/* frame size = 0 */
 9289               	/* stack size = 0 */
 9290               	.L__stack_usage = 0
 9291               	.LVL693:
 9292               	.LBB643:
 9293               	.LBB644:
 9294               		.loc 7 473 0
 9295 0000 88E1      		ldi r24,lo8(24)
 9296 0002 9BE0      		ldi r25,lo8(11)
 9297               	/* #APP */
 9298               	 ;  473 "/usr/local/avr8-gnu-toolchain/avr/include/avr/wdt.h" 1
 9299 0004 0FB6      		in __tmp_reg__,__SREG__
 9300 0006 F894      		cli
 9301 0008 A895      		wdr
 9302 000a 8093 6000 		sts 96, r24
 9303 000e 0FBE      		out __SREG__,__tmp_reg__
 9304 0010 9093 6000 		sts 96, r25
 9305               	 	
 9306               	 ;  0 "" 2
 9307               	.LVL694:
 9308               	/* #NOAPP */
 9309               	.LBE644:
 9310               	.LBE643:
1706:main.c        ****   // POMOC_DODAJ2('*', 'u');
1707:main.c        ****   { // inicjalizacja
1708:main.c        **** #ifndef DEBUG
1709:main.c        ****     wdt_enable(WDTO_120MS);
1710:main.c        ****     opoznienie_startowe();
 9311               		.loc 1 1710 0
 9312 0014 0E94 0000 		call opoznienie_startowe
 9313               	.LVL695:
1711:main.c        ****     opoznienie_startowe();
 9314               		.loc 1 1711 0
 9315 0018 0E94 0000 		call opoznienie_startowe
 9316               	.LVL696:
1712:main.c        ****     opoznienie_startowe();
 9317               		.loc 1 1712 0
 9318 001c 0E94 0000 		call opoznienie_startowe
 9319               	.LVL697:
1713:main.c        ****     opoznienie_startowe();
 9320               		.loc 1 1713 0
 9321 0020 0E94 0000 		call opoznienie_startowe
 9322               	.LVL698:
1714:main.c        **** #endif
1715:main.c        ****     inicjalizacja_portow();
 9323               		.loc 1 1715 0
 9324 0024 81E0      		ldi r24,lo8(1)
 9325 0026 87B9      		out 0x7,r24
 9326 0028 88B9      		out 0x8,r24
 9327 002a 80E2      		ldi r24,lo8(32)
 9328 002c 8AB9      		out 0xa,r24
1716:main.c        ****     inicjalizuj_parametry_modulu();
 9329               		.loc 1 1716 0
 9330 002e 0E94 0000 		call inicjalizuj_parametry_modulu
 9331               	.LVL699:
1717:main.c        ****     inicjalizacja_SIM900();
 9332               		.loc 1 1717 0
 9333 0032 0E94 0000 		call inicjalizacja_SIM900
 9334               	.LVL700:
1718:main.c        **** #ifdef DEBUG
1719:main.c        ****     debug_main();
1720:main.c        **** #endif
1721:main.c        ****     ustaw_parametry_dla_bezpieczenstwa();
 9335               		.loc 1 1721 0
 9336 0036 0E94 0000 		call ustaw_parametry_dla_bezpieczenstwa
 9337               	.LVL701:
1722:main.c        ****   }
1723:main.c        **** 
1724:main.c        ****   sei();
 9338               		.loc 1 1724 0
 9339               	/* #APP */
 9340               	 ;  1724 "main.c" 1
 9341 003a 7894      		sei
 9342               	 ;  0 "" 2
 9343               	/* #NOAPP */
 9344               	.L1029:
1725:main.c        **** 
1726:main.c        ****   for (;;) {
1727:main.c        ****     // wykonanie watkw moe trwa maksymalnie 10 ms
1728:main.c        ****     if (CZY_WYKONAC_WATKI_10MS())
 9345               		.loc 1 1728 0
 9346 003c 8091 0000 		lds r24,wykonac_watki
 9347 0040 80FD      		sbrc r24,0
1729:main.c        ****       ustaw_parametry_dla_bezpieczenstwa();
 9348               		.loc 1 1729 0
 9349 0042 0E94 0000 		call ustaw_parametry_dla_bezpieczenstwa
 9350               	.LVL702:
 9351               	.L1025:
1730:main.c        ****     if (CZY_WYKONAC_WATKI_100MS()) {
 9352               		.loc 1 1730 0
 9353 0046 8091 0000 		lds r24,wykonac_watki
 9354 004a 81FD      		sbrc r24,1
1731:main.c        ****       steruj_urzadzeniem_100MS();
 9355               		.loc 1 1731 0
 9356 004c 0E94 0000 		call steruj_urzadzeniem_100MS
 9357               	.LVL703:
 9358               	.L1026:
1732:main.c        **** #ifdef TEST_PCB
1733:main.c        ****       testPCB();
1734:main.c        **** #endif
1735:main.c        ****     }
1736:main.c        ****     if (CZY_WYKONAC_WATKI_10MS()) {
 9359               		.loc 1 1736 0
 9360 0050 8091 0000 		lds r24,wykonac_watki
 9361 0054 80FF      		sbrs r24,0
 9362 0056 00C0      		rjmp .L1027
1737:main.c        ****       steruj_urzadzeniem_10MS();
 9363               		.loc 1 1737 0
 9364 0058 0E94 0000 		call steruj_urzadzeniem_10MS
 9365               	.LVL704:
1738:main.c        ****       wykonanie_komend();
 9366               		.loc 1 1738 0
 9367 005c 0E94 0000 		call wykonanie_komend
 9368               	.LVL705:
1739:main.c        **** 
1740:main.c        ****       RESETUJ_WYKONANIE_WATKOW();
 9369               		.loc 1 1740 0
 9370 0060 1092 0000 		sts wykonac_watki,__zero_reg__
 9371               	.L1027:
1741:main.c        ****     }
1742:main.c        **** 
1743:main.c        ****     { // tryb SLEEP
1744:main.c        ****       cli();
 9372               		.loc 1 1744 0
 9373               	/* #APP */
 9374               	 ;  1744 "main.c" 1
 9375 0064 F894      		cli
 9376               	 ;  0 "" 2
1745:main.c        ****       if (!wykonaj_zdarzenie_timer) {
 9377               		.loc 1 1745 0
 9378               	/* #NOAPP */
 9379 0066 8091 0000 		lds r24,wykonaj_zdarzenie_timer
 9380 006a 8111      		cpse r24,__zero_reg__
 9381 006c 00C0      		rjmp .L1028
1746:main.c        ****         sleep_enable();
 9382               		.loc 1 1746 0
 9383 006e 83B7      		in r24,0x33
 9384 0070 8160      		ori r24,lo8(1)
 9385 0072 83BF      		out 0x33,r24
1747:main.c        ****         sei();
 9386               		.loc 1 1747 0
 9387               	/* #APP */
 9388               	 ;  1747 "main.c" 1
 9389 0074 7894      		sei
 9390               	 ;  0 "" 2
1748:main.c        ****         sleep_cpu();
 9391               		.loc 1 1748 0
 9392               	 ;  1748 "main.c" 1
 9393 0076 8895      		sleep
 9394               		
 9395               	 ;  0 "" 2
1749:main.c        ****         cli();
 9396               		.loc 1 1749 0
 9397               	 ;  1749 "main.c" 1
 9398 0078 F894      		cli
 9399               	 ;  0 "" 2
1750:main.c        ****         sleep_disable();
 9400               		.loc 1 1750 0
 9401               	/* #NOAPP */
 9402 007a 83B7      		in r24,0x33
 9403 007c 8E7F      		andi r24,lo8(-2)
 9404 007e 83BF      		out 0x33,r24
 9405               	.L1028:
1751:main.c        ****       }
1752:main.c        ****       sei();
 9406               		.loc 1 1752 0
 9407               	/* #APP */
 9408               	 ;  1752 "main.c" 1
 9409 0080 7894      		sei
 9410               	 ;  0 "" 2
1753:main.c        ****       wolne_zdarzenie_timer();
 9411               		.loc 1 1753 0
 9412               	/* #NOAPP */
 9413 0082 0E94 0000 		call wolne_zdarzenie_timer
 9414               	.LVL706:
1728:main.c        ****       ustaw_parametry_dla_bezpieczenstwa();
 9415               		.loc 1 1728 0
 9416 0086 00C0      		rjmp .L1029
 9417               		.cfi_endproc
 9418               	.LFE70:
 9420               		.local	licznik_resetow.3747
 9421               		.comm	licznik_resetow.3747,1,1
 9422               		.local	licznik_wybuc_watki_100MS.3703
 9423               		.comm	licznik_wybuc_watki_100MS.3703,1,1
 9424               		.local	licznik_dioda_led_poziom_sieci.3696
 9425               		.comm	licznik_dioda_led_poziom_sieci.3696,1,1
 9426               		.section	.progmem.data,"a",@progbits
 9429               	tab_eeprom_fabryczny.3612:
 9430 0000 FF        		.byte	-1
 9431 0001 41        		.byte	65
 9432 0002 42        		.byte	66
 9433 0003 43        		.byte	67
 9434 0004 44        		.byte	68
 9435 0005 00        		.byte	0
 9436               		.local	licznik_odebranych_znakow.3457
 9437               		.comm	licznik_odebranych_znakow.3457,2,1
 9438               		.local	licznik_poprzednia_komenda.3456
 9439               		.comm	licznik_poprzednia_komenda.3456,2,1
 9440               		.local	poprzednia_komenda.3455
 9441               		.comm	poprzednia_komenda.3455,1,1
 9442               		.local	licznik_bezpieczenstwa.3454
 9443               		.comm	licznik_bezpieczenstwa.3454,2,1
 9444               		.local	licznik_cyklu_8_sek.3450
 9445               		.comm	licznik_cyklu_8_sek.3450,1,1
 9448               	nastepna_komenda.3441:
 9449 0006 00        		.byte	0
 9450 0007 00        		.byte	0
 9451 0008 A1        		.byte	-95
 9452 0009 A2        		.byte	-94
 9453 000a A3        		.byte	-93
 9454 000b A5        		.byte	-91
 9455 000c A6        		.byte	-90
 9456 000d A7        		.byte	-89
 9457 000e A8        		.byte	-88
 9458 000f 93        		.byte	-109
 9461               	instrukcje.3440:
 9462 0010 2B63 7069 		.string	"+cpin?"
 9462      6E3F 00
 9463 0017 0000 0000 		.zero	7
 9463      0000 00
 9464 001e 2B63 6E6D 		.string	"+cnmi=2,1,2,1"
 9464      693D 322C 
 9464      312C 322C 
 9464      3100 
 9465 002c 2B6D 6F72 		.string	"+moring=1"
 9465      696E 673D 
 9465      3100 
 9466 0036 0000 0000 		.zero	4
 9467 003a 2B63 6C69 		.string	"+clip=1"
 9467      703D 3100 
 9468 0042 0000 0000 		.zero	6
 9468      0000 
 9469 0048 2B64 6465 		.string	"+ddet=1,10,1"
 9469      743D 312C 
 9469      3130 2C31 
 9469      00
 9470 0055 00        		.zero	1
 9471 0056 2B63 616C 		.string	"+calm=1"
 9471      6D3D 3100 
 9472 005e 0000 0000 		.zero	6
 9472      0000 
 9473 0064 2B63 7273 		.string	"+crsl=1"
 9473      6C3D 3100 
 9474 006c 0000 0000 		.zero	6
 9474      0000 
 9475 0072 2B63 7573 		.string	"+cusd=1"
 9475      643D 3100 
 9476 007a 0000 0000 		.zero	6
 9476      0000 
 9477 0080 2B63 7062 		.string	"+cpbw=26,\"1\""
 9477      773D 3236 
 9477      2C22 3122 
 9477      00
 9478 008d 00        		.zero	1
 9479 008e 2B63 6C74 		.string	"+clts=1"
 9479      733D 3100 
 9480 0096 0000 0000 		.zero	6
 9480      0000 
 9483               	instrukcja.3426:
 9484 009c 2B63 6D69 		.string	"+cmic=0,15"
 9484      633D 302C 
 9484      3135 00
 9487               	instrukcja_usun_wszystkie_smsy.3423:
 9488 00a7 2B63 6D67 		.string	"+cmgda=6"
 9488      6461 3D36 
 9488      00
 9489               		.local	drugi_raz.3422
 9490               		.comm	drugi_raz.3422,1,1
 9493               	instrukcja_podaj_pin.3420:
 9494 00b0 2B63 7069 		.string	"+cpin=\"1976\""
 9494      6E3D 2231 
 9494      3937 3622 
 9494      00
 9497               	instrukcja_at.3417:
 9498 00bd 2B69 6663 		.string	"+ifc=2,2"
 9498      3D32 2C32 
 9498      00
 9501               	instrukcja_ustawienie_pamieci.3414:
 9502 00c6 2B63 706D 		.string	"+cpms=\"SM\",\"SM\",\"SM\""
 9502      733D 2253 
 9502      4D22 2C22 
 9502      534D 222C 
 9502      2253 4D22 
 9505               	instrukcja_ustawienie_pamieci.3412:
 9506 00db 2B63 6473 		.string	"+cdscb"
 9506      6362 00
 9509               	instrukcja_cclk.3410:
 9510 00e2 2B63 636C 		.string	"+cclk?"
 9510      6B3F 00
 9513               	instrukcja_sprawdz_operatora.3408:
 9514 00e9 2B63 6F70 		.string	"+cops?"
 9514      733F 00
 9517               	instrukcja_odczyt_ksiazki.3406:
 9518 00f0 2B63 7062 		.string	"+cpbr=26"
 9518      723D 3236 
 9518      00
 9521               	instrukcja_creg.3404:
 9522 00f9 2B63 7265 		.string	"+creg?"
 9522      673F 00
 9525               	instrukcja_poziom_sieci.3402:
 9526 0100 2B63 7371 		.string	"+csq"
 9526      00
 9529               	instrukcja_vts.3398:
 9530 0105 2B76 7473 		.string	"+vts=1"
 9530      3D31 00
 9533               	instrukcja_odbierz_rozmowe.3396:
 9534 010c 6100      		.string	"a"
 9537               	instrukcja_odrzuc_rozmowe.3394:
 9538 010e 6800      		.string	"h"
 9541               	__c.3391:
 9542 0110 2B43 4D54 		.string	"+CMTI:"
 9542      493A 00
 9545               	instrukcja_usun_smsa.3387:
 9546 0117 2B63 6D67 		.string	"+cmgd="
 9546      643D 00
 9549               	instrukcja_odczytaj_smsa.3357:
 9550 011e 2B63 6D67 		.string	"+cmgr="
 9550      723D 00
 9553               	instrukcja_wyslij_smsa.3325:
 9554 0125 2B63 6D67 		.string	"+cmgs="
 9554      733D 00
 9557               	__c.3305:
 9558 012c 2B43 4D54 		.string	"+CMTI:"
 9558      493A 00
 9561               	__c.3298:
 9562 0133 2B44 544D 		.string	"+DTMF:"
 9562      463A 00
 9565               	__c.3293:
 9566 013a 2B43 4C49 		.string	"+CLIP:"
 9566      503A 00
 9569               	__c.3280:
 9570 0141 3E00      		.string	">"
 9573               	__c.3251:
 9574 0143 2B43 4D47 		.string	"+CMGR:"
 9574      523A 00
 9577               	polecenie_operator.3222:
 9578 014a 2B43 4F50 		.string	"+COPS:"
 9578      533A 00
 9581               	urc.3217:
 9582 0151 2B43 5245 		.string	"+CREG:"
 9582      473A 00
 9585               	urc.3214:
 9586 0158 2B43 5351 		.string	"+CSQ:"
 9586      3A00 
 9587               		.local	nr_zapytania_o_pin.3208
 9588               		.comm	nr_zapytania_o_pin.3208,1,1
 9591               	polecenie_pin_ready.3207:
 9592 015e 2B43 5049 		.string	"+CPIN: READY"
 9592      4E3A 2052 
 9592      4541 4459 
 9592      00
 9595               	polecenie_zegar.3196:
 9596 016b 2B43 434C 		.string	"+CCLK:"
 9596      4B3A 00
 9597               		.local	licznik_reset.3143
 9598               		.comm	licznik_reset.3143,1,1
 9601               	__c.3127:
 9602 0172 313D 5243 		.string	"1=RCV 2=BSY 3=CNT 4=QSM 5=QAL 6=FND 7=ADD"
 9602      5620 323D 
 9602      4253 5920 
 9602      333D 434E 
 9602      5420 343D 
 9605               	__c.3125:
 9606 019c 2055 373D 		.string	" U7="
 9606      00
 9609               	__c.3123:
 9610 01a1 2055 363D 		.string	" U6="
 9610      00
 9613               	__c.3121:
 9614 01a6 2055 353D 		.string	" U5="
 9614      00
 9617               	__c.3119:
 9618 01ab 5534 3D00 		.string	"U4="
 9621               	__c.3117:
 9622 01af 2055 333D 		.string	" U3="
 9622      00
 9625               	__c.3115:
 9626 01b4 2055 323D 		.string	" U2="
 9626      00
 9629               	__c.3113:
 9630 01b9 5531 3D00 		.string	"U1="
 9633               	__c.3111:
 9634 01bd 534B 5259 		.string	"SKRYBA:"
 9634      4241 3A00 
 9637               	__c.3108:
 9638 01c5 4445 4255 		.string	"DEBUG\n"
 9638      470A 00
 9641               	tekst_demo.3051:
 9642 01cc 7777 772E 		.string	"www.sonfy.pl"
 9642      736F 6E66 
 9642      792E 706C 
 9642      00
 9645               	__c.3049:
 9646 01d9 536B 7279 		.string	"Skryba: Wylaczony"
 9646      6261 3A20 
 9646      5779 6C61 
 9646      637A 6F6E 
 9646      7900 
 9649               	__c.3041:
 9650 01eb 4861 726D 		.string	"Harmonogram: Wylaczony"
 9650      6F6E 6F67 
 9650      7261 6D3A 
 9650      2057 796C 
 9650      6163 7A6F 
 9653               	__c.3039:
 9654 0202 2044 544D 		.string	" DTMF"
 9654      4600 
 9657               	__c.3037:
 9658 0208 2043 4C49 		.string	" CLIP"
 9658      5000 
 9661               	__c.3035:
 9662 020e 5472 7962 		.string	"Tryb: Publiczny"
 9662      3A20 5075 
 9662      626C 6963 
 9662      7A6E 7900 
 9665               	__c.3033:
 9666 021e 5472 7962 		.string	"Tryb: Prywatny"
 9666      3A20 5072 
 9666      7977 6174 
 9666      6E79 00
 9669               	__c.3031:
 9670 022d 5374 6174 		.string	"Status: Aktywny"
 9670      7573 3A20 
 9670      416B 7479 
 9670      776E 7900 
 9673               	__c.3029:
 9674 023d 5374 6174 		.string	"Status: Zablokowany"
 9674      7573 3A20 
 9674      5A61 626C 
 9674      6F6B 6F77 
 9674      616E 7900 
 9677               	tekst_gsm.3015:
 9678 0251 557A 7974 		.string	"Uzytkownicy "
 9678      6B6F 776E 
 9678      6963 7920 
 9678      00
 9681               	tekst_gsm.3004:
 9682 025e 557A 7974 		.string	"Uzytkownicy "
 9682      6B6F 776E 
 9682      6963 7920 
 9682      00
 9685               	text_sygnal.3000:
 9686 026b 5379 676E 		.string	"Sygnal GSM "
 9686      616C 2047 
 9686      534D 2000 
 9689               	__c.2998:
 9690 0277 437A 6173 		.string	"Czas: "
 9690      3A20 00
 9693               	tekst_gsm.2996:
 9694 027e 4143 3830 		.string	"AC800-TS"
 9694      302D 5453 
 9694      00
 9695               		.local	stan.2965
 9696               		.comm	stan.2965,1,1
 9697               		.local	opoznienie_1s.2964
 9698               		.comm	opoznienie_1s.2964,1,1
 9699               	.global	wysylanie_smsa_clipa
 9700               		.section .bss
 9703               	wysylanie_smsa_clipa:
 9704 0000 00        		.zero	1
 9705               		.comm	ptr_start_pdu_z_wiadomoscia,2,1
 9706               	.global	wysylanie_echa_przez_pdu
 9709               	wysylanie_echa_przez_pdu:
 9710 0001 00        		.zero	1
 9711               		.local	liczba_kolejnych_watchdogow_wysylania
 9712               		.comm	liczba_kolejnych_watchdogow_wysylania,1,1
 9713               		.local	licznik_watchdog_wysylanie_smsa_100ms
 9714               		.comm	licznik_watchdog_wysylanie_smsa_100ms,2,1
 9715               		.local	licznik_awaryjnych_resetow_kolejki
 9716               		.comm	licznik_awaryjnych_resetow_kolejki,2,1
 9717               		.local	licznik_usunietych_sms_przez_limit
 9718               		.comm	licznik_usunietych_sms_przez_limit,2,1
 9719               		.local	licznik_kolejka_stoi_100ms
 9720               		.comm	licznik_kolejka_stoi_100ms,2,1
 9721               		.local	ostatnia_pierwsza_komenda
 9722               		.comm	ostatnia_pierwsza_komenda,1,1
 9723               		.local	timer_report_user_100ms
 9724               		.comm	timer_report_user_100ms,2,1
 9725               		.local	licznik_report_user
 9726               		.comm	licznik_report_user,1,1
 9727               		.comm	numer_telefonu_skryba,20,1
 9728               		.comm	numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama,1,1
 9729               		.comm	nie_wysylaj_echa_z_powodu_nietypowego_smsa,1,1
 9730               		.comm	kod_modulu,4,1
 9731               	.global	tryb_pracy
 9732               		.data
 9735               	tryb_pracy:
 9736 0000 01        		.byte	1
 9737               	.global	blokada_systemu
 9738               		.section .bss
 9741               	blokada_systemu:
 9742 0002 00        		.zero	1
 9743               	.global	opoznienie_wysylania_clipow_100MS
 9746               	opoznienie_wysylania_clipow_100MS:
 9747 0003 0000      		.zero	2
 9748               	.global	licznik_reset_urzadzenia
 9751               	licznik_reset_urzadzenia:
 9752 0005 00        		.zero	1
 9753               	.global	licznik_reset_modulu_SIM900
 9756               	licznik_reset_modulu_SIM900:
 9757 0006 00        		.zero	1
 9758               	.global	modul_zalogowany_w_sieci
 9761               	modul_zalogowany_w_sieci:
 9762 0007 00        		.zero	1
 9763               	.global	licznik_wybudz_watki_10MS
 9766               	licznik_wybudz_watki_10MS:
 9767 0008 00        		.zero	1
 9768               	.global	wykonac_watki
 9771               	wykonac_watki:
 9772 0009 00        		.zero	1
 9773               	.global	wykonac_watki_10MS
 9776               	wykonac_watki_10MS:
 9777 000a 00        		.zero	1
 9778               	.global	wykonaj_zdarzenie_timer
 9781               	wykonaj_zdarzenie_timer:
 9782 000b 00        		.zero	1
 9783               	.global	stan_cyklu_blysku
 9786               	stan_cyklu_blysku:
 9787 000c 00        		.zero	1
 9788               	.global	liczba_blyskow_led
 9791               	liczba_blyskow_led:
 9792 000d 00        		.zero	1
 9793               		.comm	licznik_100ms_dioda_led,1,1
 9794               	.global	g_czas_systemowy_100ms
 9797               	g_czas_systemowy_100ms:
 9798 000e 0000 0000 		.zero	4
 9799               	.global	licznik_timeout_rozmowy_100ms
 9802               	licznik_timeout_rozmowy_100ms:
 9803 0012 0000      		.zero	2
 9804               	.global	tryb_clip
 9805               		.data
 9808               	tryb_clip:
 9809 0001 FF        		.byte	-1
 9810               	.global	skryba_limit
 9813               	skryba_limit:
 9814 0002 2003      		.word	800
 9815               	.global	skryba_wlaczona
 9816               		.section .bss
 9819               	skryba_wlaczona:
 9820 0014 00        		.zero	1
 9821               		.comm	stan_wyjscie,1,1
 9822               	.global	watchdog_sms_safe_mode_100ms
 9825               	watchdog_sms_safe_mode_100ms:
 9826 0015 0000      		.zero	2
 9827               	.global	watchdog_sms_trwa_reset
 9830               	watchdog_sms_trwa_reset:
 9831 0017 00        		.zero	1
 9832               	.global	watchdog_sms_licznik_100ms
 9835               	watchdog_sms_licznik_100ms:
 9836 0018 0000      		.zero	2
 9837               	.global	watchdog_sms_aktywny
 9840               	watchdog_sms_aktywny:
 9841 001a 00        		.zero	1
 9842               		.comm	opoznienie_zatrzymaj_odpytywanie_urzadzenia,1,1
 9843               	.global	blokada_clip
 9846               	blokada_clip:
 9847 001b 00        		.zero	1
 9848               	.global	max_oczekiwanie_na_odpowiedz_at
 9851               	max_oczekiwanie_na_odpowiedz_at:
 9852 001c 00        		.zero	1
 9853               		.comm	licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow,1,1
 9854               	.global	licznik_bezpieczenstwa_opoznienie_wysylania_sms
 9857               	licznik_bezpieczenstwa_opoznienie_wysylania_sms:
 9858 001d 0000      		.zero	2
 9859               	.global	licznik_ogolny_blad_zalogowania
 9862               	licznik_ogolny_blad_zalogowania:
 9863 001f 0000      		.zero	2
 9864               	.global	licznik_blad_zalogowania_u_operatora
 9867               	licznik_blad_zalogowania_u_operatora:
 9868 0021 00        		.zero	1
 9869               	.global	licznik_blad_stanu_karty_SIM
 9872               	licznik_blad_stanu_karty_SIM:
 9873 0022 00        		.zero	1
 9874               	.global	licznik_awaria_brak_zasiegu
 9877               	licznik_awaria_brak_zasiegu:
 9878 0023 0000      		.zero	2
 9879               	.global	liczba_smsow_ech_do_wyslania
 9882               	liczba_smsow_ech_do_wyslania:
 9883 0025 00        		.zero	1
 9884               	.global	ustaw_maksymalny_czas_dzwonienia
 9887               	ustaw_maksymalny_czas_dzwonienia:
 9888 0026 00        		.zero	1
 9889               	.global	maksymalny_czas_dzwonienia
 9892               	maksymalny_czas_dzwonienia:
 9893 0027 00        		.zero	1
 9894               		.comm	numer_telefonu_do_ktorego_dzwonic,33,1
 9895               		.comm	numer_telefonu_ktory_dzwoni,17,1
 9896               	.global	liczba_prob_wyslania_smsa
 9899               	liczba_prob_wyslania_smsa:
 9900 0028 00        		.zero	1
 9901               	.global	flaga_wysylanie_smsa
 9904               	flaga_wysylanie_smsa:
 9905 0029 00        		.zero	1
 9906               		.comm	numer_telefonu_wysylanego_smsa,33,1
 9907               	.global	flaga_odczytywanie_smsa
 9910               	flaga_odczytywanie_smsa:
 9911 002a 00        		.zero	1
 9912               		.comm	numer_telefonu_odebranego_smsa,17,1
 9913               	.global	dlugosc_pdu
 9916               	dlugosc_pdu:
 9917 002b 00        		.zero	1
 9918               		.comm	bufor_pdu,200,1
 9919               	.global	licznik_bezpieczenstwa_wykonywana_rozmowa
 9922               	licznik_bezpieczenstwa_wykonywana_rozmowa:
 9923 002c 0000      		.zero	2
 9924               	.global	trwa_rozmowa_przychodzaca_od_uzytkownika
 9927               	trwa_rozmowa_przychodzaca_od_uzytkownika:
 9928 002e 00        		.zero	1
 9929               	.global	max_oczekiwanie_na_odpowiedz
 9930               		.data
 9933               	max_oczekiwanie_na_odpowiedz:
 9934 0004 03        		.byte	3
 9935               		.comm	liczba_wykonanych_komend_identycznego_polecenia,1,1
 9936               	.global	nastepne_wysylane_polecenie_SIM900
 9937               		.section .bss
 9940               	nastepne_wysylane_polecenie_SIM900:
 9941 002f 00        		.zero	1
 9942               	.global	licznik_wysylane_polecenie_SIM900
 9945               	licznik_wysylane_polecenie_SIM900:
 9946 0030 0000      		.zero	2
 9947               	.global	aktualnie_wysylane_polecenie_SIM900
 9950               	aktualnie_wysylane_polecenie_SIM900:
 9951 0032 00        		.zero	1
 9952               		.comm	nazwa_operatora,11,1
 9953               	.global	oproznij_bufor_SIM900_po_bledzie
 9956               	oproznij_bufor_SIM900_po_bledzie:
 9957 0033 00        		.zero	1
 9958               	.global	opoznienie_SIM900_100MS
 9961               	opoznienie_SIM900_100MS:
 9962 0034 00        		.zero	1
 9963               		.text
 9964               	.Letext0:
 9965               		.file 8 "narzedzia.h"
 9966               		.file 9 "/usr/local/avr8-gnu-toolchain/avr/include/stdint.h"
 9967               		.file 10 "/usr/local/avr8-gnu-toolchain/lib/gcc/avr/7.3.0/include/stddef.h"
 9968               		.file 11 "/usr/local/avr8-gnu-toolchain/avr/include/stdio.h"
 9969               		.file 12 "enumkomendy.h"
 9970               		.file 13 "data_sim900.h"
 9971               		.file 14 "pamiec_ram.h"
 9972               		.file 15 "interpretacjaSMS.h"
 9973               		.file 16 "komendy.h"
 9974               		.file 17 "poleceniagsm.h"
 9975               		.file 18 "sim900.h"
 9976               		.file 19 "zapiseeprom.h"
 9977               		.file 20 "bufpomoc.h"
 9978               		.file 21 "/usr/local/avr8-gnu-toolchain/avr/include/avr/eeprom.h"
 9979               		.file 22 "konfiguracja.h"
 9980               		.file 23 "/usr/local/avr8-gnu-toolchain/avr/include/string.h"
 9981               		.file 24 "pdu.h"
 9982               		.file 25 "/usr/local/avr8-gnu-toolchain/avr/include/avr/pgmspace.h"
 9983               		.file 26 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:4      *ABS*:000000000000003f __SREG__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:5      *ABS*:000000000000003b __RAMPZ__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:6      *ABS*:0000000000000000 __tmp_reg__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:7      *ABS*:0000000000000001 __zero_reg__
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:12     .text:0000000000000000 watchdog_sms_disarm
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9840   .bss:000000000000001a watchdog_sms_aktywny
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9835   .bss:0000000000000018 watchdog_sms_licznik_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:33     .text:000000000000000e czy_numer_istnieje
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:100    .text:000000000000004e usun_zablokowany_sms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9950   .bss:0000000000000032 aktualnie_wysylane_polecenie_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:128    .text:0000000000000062 zareaguj_na_usuniety_sms_z_powodu_limitu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9716   .bss:000000000000004a licznik_usunietych_sms_przez_limit
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9791   .bss:000000000000000d liczba_blyskow_led
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9786   .bss:000000000000000c stan_cyklu_blysku
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:166    .text:000000000000008e polozenie_polecenia_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:187    .text:0000000000000098 opoznienie_startowe
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:252    .text:00000000000000d8 zapisz_debug_do_eeprom
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9724   .bss:0000000000000051 licznik_report_user
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9722   .bss:000000000000004f timer_report_user_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9904   .bss:0000000000000029 flaga_wysylanie_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:368    .text:000000000000015c test_dioda_wyjscia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9696   .bss:0000000000000044 opoznienie_1s.2964
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9598   .bss:0000000000000043 stan.2965
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:411    .text:000000000000018a test_wejscie
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:443    .text:000000000000019a __vector_16
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9766   .bss:0000000000000008 licznik_wybudz_watki_10MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9776   .bss:000000000000000a wykonac_watki_10MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9781   .bss:000000000000000b wykonaj_zdarzenie_timer
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:658    .text:000000000000029c generuj_raport_sieci
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9693   .progmem.data:000000000000027e tekst_gsm.2996
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9689   .progmem.data:0000000000000277 __c.2998
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9685   .progmem.data:000000000000026b text_sygnal.3000
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9761   .bss:0000000000000007 modul_zalogowany_w_sieci
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:840    .text:0000000000000364 generuj_raport_uzytkownikow_1
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9681   .progmem.data:000000000000025e tekst_gsm.3004
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:1026   .text:0000000000000416 generuj_raport_uzytkownikow
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9677   .progmem.data:0000000000000251 tekst_gsm.3015
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:1204   .text:00000000000004b8 generuj_raport_stanu_urzadzenia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9741   .bss:0000000000000002 blokada_systemu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9673   .progmem.data:000000000000023d __c.3029
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9669   .progmem.data:000000000000022d __c.3031
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9735   .data:0000000000000000 tryb_pracy
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9665   .progmem.data:000000000000021e __c.3033
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9661   .progmem.data:000000000000020e __c.3035
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9808   .data:0000000000000001 tryb_clip
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9657   .progmem.data:0000000000000208 __c.3037
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9653   .progmem.data:0000000000000202 __c.3039
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9649   .progmem.data:00000000000001eb __c.3041
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9819   .bss:0000000000000014 skryba_wlaczona
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9813   .data:0000000000000002 skryba_limit
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9641   .progmem.data:00000000000001cc tekst_demo.3051
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9645   .progmem.data:00000000000001d9 __c.3049
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:1536   .text:000000000000069e ustaw_wyjscie_clip
                            *COM*:0000000000000001 stan_wyjscie
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:1574   .text:00000000000006be wykonanie_polecenia_sms
                            *COM*:0000000000000011 numer_telefonu_odebranego_smsa
                            *COM*:0000000000000021 numer_telefonu_wysylanego_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9637   .progmem.data:00000000000001c5 __c.3108
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9633   .progmem.data:00000000000001bd __c.3111
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9629   .progmem.data:00000000000001b9 __c.3113
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9625   .progmem.data:00000000000001b4 __c.3115
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9621   .progmem.data:00000000000001af __c.3117
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9617   .progmem.data:00000000000001ab __c.3119
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9613   .progmem.data:00000000000001a6 __c.3121
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9609   .progmem.data:00000000000001a1 __c.3123
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9605   .progmem.data:000000000000019c __c.3125
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9601   .progmem.data:0000000000000172 __c.3127
                            *COM*:0000000000000021 numer_telefonu_do_ktorego_dzwonic
                            *COM*:0000000000000001 numer_skopiowanego_telefonu_do_raportu_uzytkownikow_brama
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:2412   .text:0000000000000b3a steruj_wejsciem_reset_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9588   .bss:0000000000000042 licznik_reset.3143
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:2483   .text:0000000000000b82 sprawdz_przychodzaca_rozmowe
                            *COM*:0000000000000011 numer_telefonu_ktory_dzwoni
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:2601   .text:0000000000000c0e zakonczono_rozmowe_telefoniczna
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9961   .bss:0000000000000034 opoznienie_SIM900_100MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9922   .bss:000000000000002c licznik_bezpieczenstwa_wykonywana_rozmowa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9887   .bss:0000000000000026 ustaw_maksymalny_czas_dzwonienia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9892   .bss:0000000000000027 maksymalny_czas_dzwonienia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9846   .bss:000000000000001b blokada_clip
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:2631   .text:0000000000000c2a zakonczono_wysylanie_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9703   .bss:0000000000000000 wysylanie_smsa_clipa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:2654   .text:0000000000000c36 problem_z_wyslaniem_powiadomienia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9945   .bss:0000000000000030 licznik_wysylane_polecenie_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:2686   .text:0000000000000c5e wyzerowanie_danych_SIM900
                            *COM*:0000000000000001 licznik_oczekiwanie_na_potwierdzenie_wyslania_znakow
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9927   .bss:000000000000002e trwa_rozmowa_przychodzaca_od_uzytkownika
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9910   .bss:000000000000002a flaga_odczytywanie_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:2725   .text:0000000000000c8c reset_modulu_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9872   .bss:0000000000000022 licznik_blad_stanu_karty_SIM
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9867   .bss:0000000000000021 licznik_blad_zalogowania_u_operatora
                            *COM*:000000000000000b nazwa_operatora
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9862   .bss:000000000000001f licznik_ogolny_blad_zalogowania
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9940   .bss:000000000000002f nastepne_wysylane_polecenie_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:2789   .text:0000000000000ce6 obsluga_wysylania_sms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9899   .bss:0000000000000028 liczba_prob_wyslania_smsa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:3001   .text:0000000000000df0 odpowiedz_na_polecenie
                            *COM*:0000000000000001 liczba_wykonanych_komend_identycznego_polecenia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9581   .progmem.data:0000000000000151 urc.3217
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9569   .progmem.data:0000000000000141 __c.3280
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9851   .bss:000000000000001c max_oczekiwanie_na_odpowiedz_at
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9595   .progmem.data:000000000000016b polecenie_zegar.3196
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9591   .progmem.data:000000000000015e polecenie_pin_ready.3207
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9490   .bss:0000000000000041 nr_zapytania_o_pin.3208
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9585   .progmem.data:0000000000000158 urc.3214
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9577   .progmem.data:000000000000014a polecenie_operator.3222
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9802   .bss:0000000000000012 licznik_timeout_rozmowy_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9573   .progmem.data:0000000000000143 __c.3251
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9916   .bss:000000000000002b dlugosc_pdu
                            *COM*:00000000000000c8 bufor_pdu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:4170   .text:000000000000147c obsluga_komendy_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9956   .bss:0000000000000033 oproznij_bufor_SIM900_po_bledzie
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9565   .progmem.data:000000000000013a __c.3293
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9561   .progmem.data:0000000000000133 __c.3298
                            *COM*:0000000000000001 licznik_100ms_dioda_led
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9557   .progmem.data:000000000000012c __c.3305
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:4646   .text:0000000000001722 wyslanie_polecenia_ROM
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:4689   .text:000000000000174a wyslij_sms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9553   .progmem.data:0000000000000125 instrukcja_wyslij_smsa.3325
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9933   .data:0000000000000004 max_oczekiwanie_na_odpowiedz
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:4865   .text:0000000000001844 wykonanie_komend_SIM900
                            *COM*:0000000000000001 opoznienie_zatrzymaj_odpytywanie_urzadzenia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9448   .progmem.data:0000000000000006 nastepna_komenda.3441
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9461   .progmem.data:0000000000000010 instrukcje.3440
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9549   .progmem.data:000000000000011e instrukcja_odczytaj_smsa.3357
                            *COM*:0000000000000001 nie_wysylaj_echa_z_powodu_nietypowego_smsa
                            *COM*:0000000000000002 ptr_start_pdu_z_wiadomoscia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9545   .progmem.data:0000000000000117 instrukcja_usun_smsa.3387
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9541   .progmem.data:0000000000000110 __c.3391
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9537   .progmem.data:000000000000010e instrukcja_odrzuc_rozmowe.3394
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9533   .progmem.data:000000000000010c instrukcja_odbierz_rozmowe.3396
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9529   .progmem.data:0000000000000105 instrukcja_vts.3398
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9525   .progmem.data:0000000000000100 instrukcja_poziom_sieci.3402
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9521   .progmem.data:00000000000000f9 instrukcja_creg.3404
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9517   .progmem.data:00000000000000f0 instrukcja_odczyt_ksiazki.3406
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9513   .progmem.data:00000000000000e9 instrukcja_sprawdz_operatora.3408
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9509   .progmem.data:00000000000000e2 instrukcja_cclk.3410
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9505   .progmem.data:00000000000000db instrukcja_ustawienie_pamieci.3412
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9501   .progmem.data:00000000000000c6 instrukcja_ustawienie_pamieci.3414
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9497   .progmem.data:00000000000000bd instrukcja_at.3417
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9493   .progmem.data:00000000000000b0 instrukcja_podaj_pin.3420
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9445   .bss:0000000000000040 drugi_raz.3422
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9487   .progmem.data:00000000000000a7 instrukcja_usun_wszystkie_smsy.3423
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9483   .progmem.data:000000000000009c instrukcja.3426
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:6257   .text:00000000000020da steruj_SIM900_100MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9746   .bss:0000000000000003 opoznienie_wysylania_clipow_100MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9443   .bss:000000000000003f licznik_cyklu_8_sek.3450
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9877   .bss:0000000000000023 licznik_awaria_brak_zasiegu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9756   .bss:0000000000000006 licznik_reset_modulu_SIM900
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:6556   .text:00000000000022b2 steruj_SIM900_10MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9441   .bss:000000000000003d licznik_bezpieczenstwa.3454
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9439   .bss:000000000000003c poprzednia_komenda.3455
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9437   .bss:000000000000003a licznik_poprzednia_komenda.3456
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9425   .bss:0000000000000038 licznik_odebranych_znakow.3457
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:6859   .text:0000000000002472 wykonanie_komend_powiadomien
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:7135   .text:00000000000025de test_sms_clip_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:7151   .text:00000000000025e0 steruj_wejscia_wyjscia_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:7173   .text:00000000000025ec zapis_w_eeprom_stanu_wyjsc
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:7269   .text:0000000000002668 steruj_urzadzeniem_100MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9720   .bss:000000000000004e ostatnia_pierwsza_komenda
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9718   .bss:000000000000004c licznik_kolejka_stoi_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9712   .bss:0000000000000046 licznik_watchdog_wysylanie_smsa_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9714   .bss:0000000000000048 licznik_awaryjnych_resetow_kolejki
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9698   .bss:0000000000000045 liczba_kolejnych_watchdogow_wysylania
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9830   .bss:0000000000000017 watchdog_sms_trwa_reset
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9825   .bss:0000000000000015 watchdog_sms_safe_mode_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9423   .bss:0000000000000037 licznik_dioda_led_poziom_sieci.3696
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:7612   .text:0000000000002894 steruj_urzadzeniem_10MS
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:7634   .text:00000000000028a0 wolne_zdarzenie_timer
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9771   .bss:0000000000000009 wykonac_watki
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9421   .bss:0000000000000036 licznik_wybuc_watki_100MS.3703
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:7818   .text:000000000000297e ustaw_parametry_dla_bezpieczenstwa
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:7856   .text:000000000000299e inicjalizuj_parametry_modulu
                            *COM*:0000000000000004 kod_modulu
                             .bss:0000000000000035 licznik_resetow.3747
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:8262   .text:0000000000002bfa wykonanie_komend_ukladow
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9429   .progmem.data:0000000000000000 tab_eeprom_fabryczny.3612
                            *COM*:0000000000000014 numer_telefonu_skryba
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9252   .text:000000000000315c wykonanie_komend
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9283   .text.startup:0000000000000000 main
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9709   .bss:0000000000000001 wysylanie_echa_przez_pdu
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9751   .bss:0000000000000005 licznik_reset_urzadzenia
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9797   .bss:000000000000000e g_czas_systemowy_100ms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9857   .bss:000000000000001d licznik_bezpieczenstwa_opoznienie_wysylania_sms
/var/folders/6z/r258d_ld7nl6hm6r8km5x35c0000gn/T//ccLBsinz.s:9882   .bss:0000000000000025 liczba_smsow_ech_do_wyslania

UNDEFINED SYMBOLS
bufor_eeprom
konwertuj_telefon_na_blok_eeprom
porownaj_numer_telefonu_blok
filtruj_i_dodaj_komende
odebrany_blok_SIM900
strstr_P
bufor_pomoc_liczba_znakow_do_zapisu
liczba_znakow_do_zapisu
czy_zajety_bufor_eeprom
komendy_kolejka
zapisz_znaki_w_eeprom
licznik_wejscie
komenda_SIM900
liczba_odebranych_znakow_SIM900
licznik_opoznienie_oczekiwania_na_bajt_SIM900
sprawdzaj_wejscie_CTS_SIM900
podlaczony_modul_gsm_SIM900
nr_wyslanego_znaku_SIM900
wysylany_blok_SIM900
memcpy_P
strcpy_P
rtc_czas
strcat
poziom_sieci_gsm
__divmodhi4
__utoa_ncheck
eeprom_read_byte
tekst_wysylanego_smsa
czas_start_h
sprintf
czas_stop_m
czas_stop_h
czas_start_m
licznik_przelacznik_wyjscia
interpretuj_wiadomosc_sms
__tablejump2__
strcpy
dodaj_komende
czy_sa_komendy_z_przedzialu
stan_logiczny_na_wejsciu
wykonywanie_rozmowy_telefonicznej
czekanie_na_odebranie_zachety
liczba_komend_w_kolejce_SIM900
flaga_odebrany_znak_zachety
licznik_100ms_procedura_inicjalizacyjna_SIM900
podlaczona_karta_SIM_SIM900
filtruj_komendy_z_przedzialu
numer_bledu_cms
numer_bledu_cme
strtol
strncmp_P
strchr
blokada_sterowania_czasowa
bledny_PIN
memcpy
konwertuj_blok_dwa_znaki_na_znak_pdu
liczba_wysylanych_znakow_SIM900
memcmp
strtoul
wyslij_polecenie_ROM_SIM900
konwertuj_blok_eeprom_na_telefon
zapisz_naglowek_pdu
ascii_to_pdu_blok
wyslij_polecenie_RAM_SIM900
pobierz_numer_telefonu_nadawcy_z_PDU
konwertuj_pdu_na_blok_wysylany
wyslij_znaki_SIM900
pobierz_date_z_PDU
pobierz_czas_z_PDU
pdu_to_ascii
bufor_ustaw_czas
procedura_inicjalizacyjna_SIM900_100MS
czy_jest_nowa_komenda_SIM900
kopiuj_blok_eeprom_na_telefon
aktualizuj_stan_wyzwolenia_wejsc_100ms
steruj_wyjscia_100ms
steruj_wejscia_10ms
zapisz_bajt_w_EEPROM
poczatek_polecenia_SIM900
zakonczenie_polecenia_SIM900
czy_jest_nowe_polecenie_SIM900
eeprom_read_block
eeprom_update_block
eeprom_update_byte
zapisz_znaki_w_eeprom_bez_kopiowania
memset
zapisz_znak_w_eeprom
usun_komende
inicjalizacja_SIM900
__do_copy_data
__do_clear_bss
